07 09 06 (Pierre, Damien, David)
================================

- Définition d'une Syntaxe abstraite de focal

Plan de travail de la refonte du compilo:

- Syntaxe concrète laissée pour plus tard. Ne faut-il pas partir d'une syntaxe
  Caml à complèter pour faire focal ?

- Typage

- Compilation avec records seulement. En effet, on n'a pas les moyens
  d'entretenir les 2 modèles de compilation.
  Attention le code de Renaud ne marche actuellement qu'avec la compilation en
  objets. On devra donc le faire marcher avec les records ...

13 09 06 (Pierre, Damien)
================================

- Le lexer est réalisé. Caractéristiques: très semblable à celui de Caml, sauf
quelques différences et surtout simplifications. Ce lexeur permettra les
infixes généraux de l'utilisateur.

- Le parser est aussi commencé (à poursuivre).

- La syntaxe abstraite est retouchée pour les phrases toplevels et les
définitions de valeurs.

12-10-06 (Pierre, David)
========================

Boolean operators: && || ~| (almost as in Caml)
Proposition operators: /\ \/ -> <-> ~ (as in Coq)

Infixes généraux:
- une suite de symboles est supposée être un identificateur infix
  ex: + ++ ** -><- :=

- la précédence de l'infixe correspondant est donnée par le ou les premiers
caractères du symbole; par exemple ++ a la même précédence (et règle
d'associativité que +), **+ a la même précédence que **.

- Tout token commençant par un caractère symbolique (i.e. non alpha-numérique)
 définit une priorité dans le parser. Exemple @ définit une priorité, de même
 que : et même , ou ;.

(0) Les identificateurs alphanumériques, noms propres et noms communs (!)

Start_L_Ident ::= [_a-z]
Start_U_Ident ::= [A-Z]

Continue_Ident ::= [_a-zA-Z0-9]

L_Ident := Start_L_Ident (Continue_Ident*)
U_Ident := Start_U_Ident (Continue_Ident*)

(1) Les identificateurs infixes, noms d'opérations binaires

Start_Infix ::= + - * ^ @ % & | , : = \ / < > #
         Pas ' ni " qui sont des délimiteurs de chaînes et caractères

Continue_Infix := Start_Infix
                | Start_Prefix
                | Continue_Ident

Infix ::= Start_Infix (Continue_Infix*)

Rq: End_Infix ::= SPACE  (::= blanc tab newline) ( ) [] {}

(2) Les identificateurs préfixes, noms d'opérations unaires

Start_Prefix ::= ! ~ ? $

Prefix := Start_Prefix (Continue_Infix*)

() [] {} sont des délimiteurs (sauf sans le cas (* *))

Exemples: 
 _!!_ est un infixe
 ~| est un prefixe

 a + x est autorisé, c'est une addition
 a+x est illégal n'est pas une addition
 (a )+( x) est une addition

2006-10-19 (Pierre, David)
==========================

2006-11-16 (Pierre, David, Damien)
==================================
Continue on the parser: more on expressions + patterns

2006-11-17 (Pierre)
==================================
Ajout des infixes à revoir avec les autres membres de compilation.

2006-11-23 (Pierre, David, Damien)
==================================
More parser + def coll + espèces.

2006-11-27 (Pierre)
==================================

More lexer spec + parser.

The first character of an ident which is not an _ gives the class of the identifier:

L_ident_starter ::= [a-z]
U_ident_starter ::= [A-Z]
I_ident_starter ::= [+ - * ^ @ % & | , : = \ / < > #]
P_ident_starter ::= [! ~ ? $]

ident_spacer ::= [_] [0-9]

Continue_ident ::=
  | ident_spacer
  | L_ident_starter
  | U_ident_starter
  | I_ident_starter
  | P_ident_starter
  | decimal_digit

Start_L_ident ::= [_]* L_ident_starter
Start_U_ident ::= [_]* U_ident_starter
Start_I_ident ::= [_]* I_ident_starter
Start_P_ident ::= [_]* P_ident_starter

L_Ident :=
         | Start_L_Ident (Continue_Ident*)
         | [_] ((ident_spacer)*) 
U_Ident := Start_U_Ident (Continue_Ident*)
P_Ident := Start_P_Ident (Continue_Ident*)
I_Ident := Start_I_Ident (Continue_Ident*)

L_Ident are Lowercase identifiers.
U_Ident are Uppercase identifiers.
I_Ident are Infix identifiers.
P_Ident are Prefix identifiers.

Remarques:
 -- \' et \" sont les délimiteurs de caractères et de chaînes: il ne figurent pas
    dans les identificateurs.
 -- () [] {} sont des délimiteurs (sauf sans le cas (* *))

Exemples:
 x, _x, x1, _1, x+, x*, _, __, sont des L_Ident
 A, _A, A1, _A+, sont des U_Ident
 +, _+_, +mat, sont des I_Ident
 !, ~!, _!!_ sont des P_Ident
 0xFF

 a + x est une addition
 a+x est un L_Ident (ce n'est donc pas une addition)
 (a )+( x) est une addition



2007-07-11 (Pierre, Renaud, François)
=====================================

--------------------------------------------------------------------------
		 QUESTIONS AVEC DÉCISIONS EN RÉPONSE
Sujet                      Proposition                                Etat
--------------------------------------------------------------------------
Noms de collections   Doivent commencer par 1 alphabétique
et d'espèces          majuscule.
--------------------------------------------------------------------------
self                  Doit être renommé en "Self" dans la syntaxe
                      afin de rester cohérent avec le fait que
                      noms de collections et d'espèces doivent        FAIT
                      commencer par 1 alphabétique majuscule.
--------------------------------------------------------------------------
! et #                Doivent devenir optionnels. Autrement dit,
                      si une application apparaît, on ira
                      implicitement rechercher si elle réfère
                      à une méthode de self ou à un ident
                      toplevel du fichier courant sans qu'il
                      soit nécessaire que l'utilisateur ait
                      explicitement "scopé" son ident.
                      Ceci nécessite une passe de scoping pour
                      désambiguer entre application de :
			- ident au toplevel d'un autre fichier
                          (file#ident)
			- ident au toplevel fichier (#ident)
			- méthode de self (sel!ident ou !ident)
			- méthode d'une autre collection
                          (ident!ident)
--------------------------------------------------------------------------
!                     Retirer ! comme appel de méthode. A la
                      place, utiliser '.' en combinaison avec la
                      casse de le lettre de départ des
                      identicateurs:
			- low.low ->> Accès à un champ cde record
			- Upp.low ->> Accès à la méthode "low" de
                                      la collection "Upp".
			- Upp1.Upp2 ->> ??? (non spécifié)
                        - low.Upp   ->> ??? (non spécifié)
--------------------------------------------------------------------------
Syntaxe des           Les collections ne feront désormais plus
collections           qu'implanter des espèces. Elles ne pourront
                      pas déclarer ni définir des champs 
                      supplémentaires à l'espèce qu'elles
                      implantent. La syntaxe actuelle du nouveau
                      parseur à la forme:
                        collection ... implements ... = end ;;        FAIT
                      Le "=" suivi de "end" semble étrange. Du
                      fait qu'une collection de définit rien de
                      supplémentaire, on supprime le "=". Et du
                      fait qu'elle n'ait donc pas de body, on
                      supprime le "end". On a donc la syntaxe:
                        collection ... implements ... ;;
--------------------------------------------------------------------------
		 QUESTIONS SANS DÉCISIONS EN RÉPONSE
Sujet                      Question
--------------------------------------------------------------------------
constr            Le type décrivant les expresssions utilisant des
                  constructeurs de types somme a la forme :
                   | E_constr of expr * expr list
                  Ceci laisse penser que le nom du constructeur n'est pas
                  explicite et qu'il est le résultat d'un calcul arbitraire.
                  Ceci donne donc à penser que les constructeurs sont des
                  valeurs de première classe.
                  A la place, ne devtrait-on pas plutôt avoir :           FAIT
                   | E_constr of constr_name * expr list
                  Il faut voir qu'en fait le parser invariablement
                  construit une expr de la forme (E_var ident) avec ident
                  contenant le nom du constructeur.
                  Toutefois, les utilisateurs avancés devant pouvoir créer
                  des AST, cet invariant n'étant pas garanti structurellement,
                  un risque persiste.
--------------------------------------------------------------------------
ident_desc        La structure des ident_desc est particulièrement étrange
                  et impose un invariant non structurel (cite le .mli) :
                   (* If vname is self, then the real *)
                   (* name should be considered as only     *)
                   (* [cname]. If [cname] is None and       *)
                   (* [vname] is self, then it's bugged !   *)
                   | I_method of Types.cname option * vname
                  Pour la même raison que ci-dessus, il serait intéressant
                  d'avoir un type garantissant structurellement cet
                  invariant.
                      REGLÉ : Par défaut on scope en I_local et les idents
		      sont scopés en I_method uniquement lorsque l'on est
		      sûr de leur état de méthode. Ceci peut nécessiter
		      d'ailleurs que la passe de scoping ait été effectuée.
		      En fait, ce problème d'invariant était uniquement
		      présent pour les constructeurs de type parce que
		      ceux-ci étaient parsés comme bool --->> self!bool.
		      Donc une fois qu'on a viré de problème de parse, il
		      n'y a plus besoin de changer la structure des idents.
                  --------------------------------------------------------
                  De plus, le parser scope par défaut les identificateurs
                  comme étant des méthodes (I_method). Y compris les
                  identificateurs présents dans les expressions de types.
                  Ainsi, dans :                                           FAIT
                   rep = bool ;
                  "bool" sera représenté par une valeurs syntaxique encodant
                  self!bool. Ceci est franchement étrange. Le parser ne
                  devrait-il pas plutôt scoper par défaut en I_local ?
--------------------------------------------------------------------------
Algèbre de types  Doit-on autoriser (v in int) et (v in Coll) ? Autrement dit,
Types ML et       les types ML doivent-ils être mutuellement récursifs avec le
types d'espèces   type des collections ?
                  Si l'on imposait de définir une collection Int implémentant
                  des entiers, alors on pourrait écrire (v in Int) et les
                  expressions de types ne pourraient plus apparaître que dans
                  la défitition des carriers.
                  On stratifierait ainsi complètement les "types ML" et les
                  "types de collections".
                                                                     FAIT
                                                        DANS L'ALGEBRE MAIS PAS
                                                            ENCORE EXPLOITE

2007-08-02 (François)
=====================

* ENVIRONNEMENTS
****************
Faire une passe de scoping séparée et avant la phase de typage.
Les informations persistentes de scoping devront être stockée dans le même
fichier (.fo) que celles de typage, afin de ne pas multiplier les fichiers
intermédiaires.
Les algos gérant les environnements de scoping et de typage sont
essentiellement les mêmes. Surtout la recherche mappant les qualifications
! et # sur les fichiers sources représentant ls modules.
Ceci impose donc que les environnements de scoping et de typage soient dans
un même fichier et que la structure des ".fo" connaisse à la fois la structure
des deux environnements.
On créera donc dans le même fichier "env.ml" les structures des environnements
de scoping et de typage. Ensuite on pourra créer 1 seule fonction partagée
permettant le mapping des "modules" sur les fichiers source FoCaL. Et finalement
on pourra implémenter les fonctions de recherche de chacun des environnements.
On pourrait envisager une structure d'environnement générique, toutefois les
environnements de scoping n'ont pas besoin d'autant de champs que ceux de
typage (par exemple, on ne scope pas les labels de records, on ne scope pas les
noms de collections ou d'entités). Donc plutôt que d'avoir à disposition des
fonctions "add" et "find" adressant des champs d'environnement toujours vides
(et donc ne devant pas être utilisés), on fera 2 structures d'environnement
distinctes, ce qui ne dupliquera toutefois pas trop de code.

* SCOPING
*********
Par défaut, le parseur scope en I_local sauf si syntaxiquement se trouve
explicitement une désambiguation ! ou #. Le boulot du scoping est donc de
transformer si nécessaire ces I_local en I_global ou I_method.
Par contre on ne change pas les ident nativement I_global ou I_method.

Dans l'AST, une fois scopé, les idents qualifiés de I_global pourront avoir
un champ fname à None uniquement s'ils sont globaux au fichier courant, sinon
ce champs doit être à Some du fichier où ils se trouvent définis.

Lorsque l'on insère un ident global dans l'environnement de scoping, on le
binde à un (SBI_file (Some l'unité de compilation courante)). Ainsi, au moment
de sauver l'environnement de scoping pour en faire un ".fo", on n'a pas besoin
de repasser sur les bindings avec None pour les expliciter à
(Some l'unité de compilation courante). De même lorsque l'on chargera un ".fo"
on n'aura pas à refaire ce traitement.

Le scoping ne doit pas affecter les idents se trouvant explicitement et
initialement sous forme I_local ou I_method. Dans leur cas, à la rigueur le
scoping permet de s'assurer que ces identificateurs sont bien liés.

* ACCÈS EXPLICITEMENT SCOPÉS AU FICHIER COURANT
***********************************************
De part la structure des environnements, si l'on tente d'accéder à
l'information liée à un ident toplevel du fichier courant qui fait explicitement
référence à ce fichier, comme le fichier courant ajoute ses bindings directement
dans l'environnement sans passer par une injection au sein d'un environnement
de module, il va falloir faire en sorte que l'accès à l'information liée à
un tel identificateur revienne à accéder à un identificateur non explicitement
scopé... Mais ATTENTION cela pose un problème:

Fichier toto.foc

 let foo () = ...
 open Fichier_avec_foo
 ... 
 toto#foo ()

Comme "toto#foo" devrait revenir à rechercher simplement "foo", le fait que le
open ait inséré dans l'environnement un ident "foo" fait qu'il va masquer celui
auquel on veut réellement accéder.

Solution: un binding d'environment est taggé soit comme "Absolute" (il provient
d'une définition se trouvant explicitement dans l'unité de compilation
actuellement analysée), soit "Opened" (il provient d'une directive "use" ou
"open".



2007-08-05 (François)
=====================

* RECORDS
*********
Il me semble qu'il faudrait scoper aussi les champs de records. Ceux-ci
devraient pouvoir être noté avec un mécanisme de #, sinon comment parler du
champ d'un type record se trouvant dans un autre module que le module actuel
(celui de l'unité de compilation actuelle) ?
Ceci impliquerait donc qu'il faille aussi scoper les noms de champs de records.
On pourrait alors remplacer la simple string représentant le nom du champ par
(fname option) * string. Pas besoin de la généralité d'un ident car il ne peut
pas être "I_method".

* COLLECTIONS ET ESPECES POUR LE SCOPING
****************************************
En fait, je pense que l'on a besoin aussi d'un environement de collections et
d'espèces poru scoper car pour se rendre compte qu'un ident scopé I_local
initialement (et par défaut) par le parser est en fait un I_method, il faut
bien avoir la liste des méthodes et l'héritage de la collection courante.

* ===>>>> CONCLUSION SUR LES ENVIRONNEMENTS
*******************************************
Il y a quelques jours, l'idée était d'avoir 2 types d'environnements : 1 pour
le scoping et 1 pour le typing plutôt que de faire des environnements
génériques sous prétexte que les environnements de scoping n'avaient pas
besoin d'autant de champs.
En fait, il semblerait que la différence entre ces 2 environnements ne soit
plus aussi pertinente à la vue du point précédent.
Il serait intéressant de tenter des environnements génériques afin de factoriser
le code, en fait !

* QUESTION ENTRE SCOPING ET TYPAGE
**********************************
J'ai dis à l'avant dernier point que pour scoper, il nous fallait des buckets
pour les collections et les espèces dans l'environnement de scoping. Une
question inquiétante est de savoir si par malheur on ne risquerait pas d'avoir
besoin de connaître les types pour scoper (ce qui casserait notre belle
stratifications scoping PUIS typing).
A priori la réponse est NON car le scoping ne sert qu'à résoudre les ambiguités
induites par le fait de rendre optionnel (tacite) le #. Or ceci n'implique que
la recherche dans les méthodes de l'arbre d'héritage de l'espèce courante Self).
Or le type de cette espèce est implicitement connu lorsque l'on l'analyse et
il n'y a pas besoin de calculs sur les types en vue de déterminer à quel type
d'espèce la méthode "bla" peut appartenir dans "#bla".
