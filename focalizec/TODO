07 09 06 (Pierre, Damien, David)
================================

- Définition d'une Syntaxe abstraite de focal

Plan de travail de la refonte du compilo:

- Syntaxe concrète laissée pour plus tard. Ne faut-il pas partir d'une syntaxe
  Caml à complèter pour faire focal ?

- Typage

- Compilation avec records seulement. En effet, on n'a pas les moyens
  d'entretenir les 2 modèles de compilation.
  Attention le code de Renaud ne marche actuellement qu'avec la compilation en
  objets. On devra donc le faire marcher avec les records ...

13 09 06 (Pierre, Damien)
================================

- Le lexer est réalisé. Caractéristiques: très semblable à celui de Caml, sauf
quelques différences et surtout simplifications. Ce lexeur permettra les
infixes généraux de l'utilisateur.

- Le parser est aussi commencé (à poursuivre).

- La syntaxe abstraite est retouchée pour les phrases toplevels et les
définitions de valeurs.

12-10-06 (Pierre, David)
========================

Boolean operators: && || ~| (almost as in Caml)
Proposition operators: /\ \/ -> <-> ~ (as in Coq)

Infixes généraux:
- une suite de symboles est supposée être un identificateur infix
  ex: + ++ ** -><- :=

- la précédence de l'infixe correspondant est donnée par le ou les premiers
caractères du symbole; par exemple ++ a la même précédence (et règle
d'associativité que +), **+ a la même précédence que **.

- Tout token commençant par un caractère symbolique (i.e. non alpha-numérique)
 définit une priorité dans le parser. Exemple @ définit une priorité, de même
 que : et même , ou ;.

(0) Les identificateurs alphanumériques, noms propres et noms communs (!)

Start_L_Ident ::= [_a-z]
Start_U_Ident ::= [A-Z]

Continue_Ident ::= [_a-zA-Z0-9]

L_Ident := Start_L_Ident (Continue_Ident*)
U_Ident := Start_U_Ident (Continue_Ident*)

(1) Les identificateurs infixes, noms d'opérations binaires

Start_Infix ::= + - * ^ @ % & | , : = \ / < > #
         Pas ' ni " qui sont des délimiteurs de chaînes et caractères

Continue_Infix := Start_Infix
                | Start_Prefix
                | Continue_Ident

Infix ::= Start_Infix (Continue_Infix*)

Rq: End_Infix ::= SPACE  (::= blanc tab newline) ( ) [] {}

(2) Les identificateurs préfixes, noms d'opérations unaires

Start_Prefix ::= ! ~ ? $

Prefix := Start_Prefix (Continue_Infix*)

() [] {} sont des délimiteurs (sauf sans le cas (* *))

Exemples: 
 _!!_ est un infixe
 ~| est un prefixe

 a + x est autorisé, c'est une addition
 a+x est illégal n'est pas une addition
 (a )+( x) est une addition

2006-10-19 (Pierre, David)
==========================

2006-11-16 (Pierre, David, Damien)
==================================
Continue on the parser: more on expressions + patterns

2006-11-17 (Pierre)
==================================
Ajout des infixes à revoir avec les autres membres de compilation.

2006-11-23 (Pierre, David, Damien)
==================================
More parser + def coll + espèces.

2006-11-27 (Pierre)
==================================

More lexer spec + parser.

The first character of an ident which is not an _ gives the class of the identifier:

L_ident_starter ::= [a-z]
U_ident_starter ::= [A-Z]
I_ident_starter ::= [+ - * ^ @ % & | , : = \ / < > #]
P_ident_starter ::= [! ~ ? $]

ident_spacer ::= [_] [0-9]

Continue_ident ::=
  | ident_spacer
  | L_ident_starter
  | U_ident_starter
  | I_ident_starter
  | P_ident_starter
  | decimal_digit

Start_L_ident ::= [_]* L_ident_starter
Start_U_ident ::= [_]* U_ident_starter
Start_I_ident ::= [_]* I_ident_starter
Start_P_ident ::= [_]* P_ident_starter

L_Ident :=
         | Start_L_Ident (Continue_Ident*)
         | [_] ((ident_spacer)*) 
U_Ident := Start_U_Ident (Continue_Ident*)
P_Ident := Start_P_Ident (Continue_Ident*)
I_Ident := Start_I_Ident (Continue_Ident*)

L_Ident are Lowercase identifiers.
U_Ident are Uppercase identifiers.
I_Ident are Infix identifiers.
P_Ident are Prefix identifiers.

Remarques:
 -- \' et \" sont les délimiteurs de caractères et de chaînes: il ne figurent pas
    dans les identificateurs.
 -- () [] {} sont des délimiteurs (sauf sans le cas (* *))

Exemples:
 x, _x, x1, _1, x+, x*, _, __, sont des L_Ident
 A, _A, A1, _A+, sont des U_Ident
 +, _+_, +mat, sont des I_Ident
 !, ~!, _!!_ sont des P_Ident
 0xFF

 a + x est une addition
 a+x est un L_Ident (ce n'est donc pas une addition)
 (a )+( x) est une addition



2006-07-11 (Pierre, Renaud, François)
=====================================

--------------------------------------------------------------------------
		 QUESTIONS AVEC DÉCISIONS EN RÉPONSE
Sujet                      Proposition                                Etat
--------------------------------------------------------------------------
Noms de collections   Doivent commencer par 1 alphabétique
et d'espèces          majuscule.
--------------------------------------------------------------------------
self                  Doit être renommé en "Self" dans la syntaxe
                      afin de rester cohérent avec le fait que
                      noms de collections et d'espèces doivent
                      commencer par 1 alphabétique majuscule.
--------------------------------------------------------------------------
! et #                Doivent devenir optionnels. Autrement dit,
                      si une application apparaît, on ira
                      implicitement rechercher si elle réfère
                      à une méthode de self ou à un ident
                      toplevel du fichier courant sans qu'il
                      soit nécessaire que l'utilisateur ait
                      explicitement "scopé" son ident.
                      Ceci nécessite une passe de scoping pour
                      désambiguer entre application de :
			- ident au toplevel d'un autre fichier
                          (file#ident)
			- ident au toplevel fichier (#ident)
			- méthode de self (sel!ident ou !ident)
			- méthode d'une autre collection
                          (ident!ident)
--------------------------------------------------------------------------
!                     Retirer ! comme appel de méthode. A la
                      place, utiliser '.' en combinaison avec la
                      casse de le lettre de départ des
                      identicateurs:
			- low.low ->> Accès à un champ cde record
			- Upp.low ->> Accès à la méthode "low" de
                                      la collection "Upp".
			- Upp1.Upp2 ->> ??? (non spécifié)
                        - low.Upp   ->> ??? (non spécifié)
--------------------------------------------------------------------------
Syntaxe des           Les collections ne feront désormais plus
collections           qu'implanter des espèces. Elles ne pourront
                      pas déclarer ni définir des champs 
                      supplémentaires à l'espèce qu'elles
                      implantent. La syntaxe actuelle du nouveau
                      parseur à la forme:
                        collection ... implements ... = end ;;
                      Le "=" suivi de "end" semble étrange. Du
                      fait qu'une collection de définit rien de
                      supplémentaire, on supprime le "=". Et du
                      fait qu'elle n'ait donc pas de body, on
                      supprime le "end". On a donc la syntaxe:
                        collection ... implements ... ;;
--------------------------------------------------------------------------
		 QUESTIONS SANS DÉCISIONS EN RÉPONSE
Sujet                      Question
--------------------------------------------------------------------------
constr            Le type décrivant les expresssions utilisant des
                  constructeurs de types somme a la forme :
                   | E_constr of expr * expr list
                  Ceci laisse penser que le nom du constructeur n'est pas
                  explicite et qu'il est le résultat d'un calcul arbitraire.
                  Ceci donne donc à penser que les constructeurs sont des
                  valeurs de première classe.
                  A la place, ne devtrait-on pas plutôt avoir :
                   | E_constr of constr_name * expr list
                  Il faut voir qu'en fait le parser invariablement
                  construit une expr de la forme (E_var ident) avec ident
                  contenant le nom du constructeur.
                  Toutefois, les utilisateurs avancés devant pouvoir créer
                  des AST, cet invariant n'étant pas garanti structurellement,
                  un risque persiste.
--------------------------------------------------------------------------
ident_desc        La structure des ident_desc est particulièrement étrange
                  et impose un invariant non structurel (cite le .mli) :
                   (* If vname is self, then the real *)
                   (* name should be considered as only     *)
                   (* [cname]. If [cname] is None and       *)
                   (* [vname] is self, then it's bugged !   *)
                   | I_method of Types.cname option * vname
                  Pour la même raison que ci-dessus, il serait intéressant
                  d'avoir un type garantissant structurellement cet
                  invariant.
                  De plus, le parser scope par défaut les identificateurs
                  comme étant des méthodes (I_method). Y compris les
                  identificateurs présents dans les expressions de types.
                  Ainsi, dans :
                   rep = bool ;
                  "bool" sera représenté par une valeurs syntaxique encodant
                  self!bool. Ceci est franchement étrange. Le parser ne
                  devrait-il pas plutôt scoper par défaut en I_local ?
--------------------------------------------------------------------------
Algèbre de types  Doit-on autoriser (v in int) et (v in Coll) ? Autrement dit,
Types ML et       les types ML doivent-ils être mutuellement récursifs avec le
types d'espèces   type des collections ?
                  Si l'on imposait de définir une collection Int implémentant
                  des entiers, alors on pourrait écrire (v in Int) et les
                  expressions de types ne pourraient plus apparaître que dans
                  la défitition des carriers.
                  On stratifierait ainsi complètement les "types ML" et les
                  "types de collections".
