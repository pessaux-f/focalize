07 09 06 (Pierre, Damien, David)
================================

- Définition d'une Syntaxe abstraite de focal

Plan de travail de la refonte du compilo:

- Syntaxe concrète laissée pour plus tard. Ne faut-il pas partir d'une syntaxe
  Caml à complèter pour faire focal ?

- Typage

- Compilation avec records seulement. En effet, on n'a pas les moyens
  d'entretenir les 2 modèles de compilation.
  Attention le code de Renaud ne marche actuellement qu'avec la compilation en
  objets. On devra donc le faire marcher avec les records ...

13 09 06 (Pierre, Damien)
================================

- Le lexer est réalisé. Caractéristiques: très semblable à celui de Caml, sauf
quelques différences et surtout simplifications. Ce lexeur permettra les
infixes généraux de l'utilisateur.

- Le parser est aussi commencé (à poursuivre).

- La syntaxe abstraite est retouchée pour les phrases toplevels et les
définitions de valeurs.

12-10-06 (Pierre, David)
========================

Boolean operators: && || ~| (almost as in Caml)
Proposition operators: /\ \/ -> <-> ~ (as in Coq)

Infixes généraux:
- une suite de symboles est supposée être un identificateur infix
  ex: + ++ ** -><- :=

- la précédence de l'infixe correspondant est donnée par le ou les premiers
caractères du symbole; par exemple ++ a la même précédence (et règle
d'associativité que +), **+ a la même précédence que **.

- Tout token commençant par un caractère symbolique (i.e. non alpha-numérique)
 définit une priorité dans le parser. Exemple @ définit une priorité, de même
 que : et même , ou ;.

(0) Les identificateurs alphanumériques, noms propres et noms communs (!)

Start_L_Ident ::= [_a-z]
Start_U_Ident ::= [A-Z]

Continue_Ident ::= [_a-zA-Z0-9]

L_Ident := Start_L_Ident (Continue_Ident*)
U_Ident := Start_U_Ident (Continue_Ident*)

(1) Les identificateurs infixes, noms d'opérations binaires

Start_Infix ::= + - * ^ @ % & | , : = \ / < > #
         Pas ' ni " qui sont des délimiteurs de chaînes et caractères

Continue_Infix := Start_Infix
                | Start_Prefix
                | Continue_Ident

Infix ::= Start_Infix (Continue_Infix*)

Rq: End_Infix ::= SPACE  (::= blanc tab newline) ( ) [] {}

(2) Les identificateurs préfixes, noms d'opérations unaires

Start_Prefix ::= ! ~ ? $

Prefix := Start_Prefix (Continue_Infix*)

() [] {} sont des délimiteurs (sauf sans le cas (* *))

Exemples: 
 _!!_ est un infixe
 ~| est un prefixe

 a + x est autorisé, c'est une addition
 a+x est illégal n'est pas une addition
 (a )+( x) est une addition

2006-10-19 (Pierre, David)
==========================

2006-11-16 (Pierre, David, Damien)
==================================
Continue on the parser: more on expressions + patterns

2006-11-17 (Pierre)
==================================
Ajout des infixes à revoir avec les autres membres de compilation.

2006-11-23 (Pierre, David, Damien)
==================================
More parser + def coll + espèces.

2006-11-27 (Pierre)
==================================

More lexer spec + parser.

The first character of an ident which is not an _ gives the class of the identifier:

L_ident_starter ::= [a-z]
U_ident_starter ::= [A-Z]
I_ident_starter ::= [+ - * ^ @ % & | , : = \ / < > #]
P_ident_starter ::= [! ~ ? $]

ident_spacer ::= [_] [0-9]

Continue_ident ::=
  | ident_spacer
  | L_ident_starter
  | U_ident_starter
  | I_ident_starter
  | P_ident_starter
  | decimal_digit

Start_L_ident ::= [_]* L_ident_starter
Start_U_ident ::= [_]* U_ident_starter
Start_I_ident ::= [_]* I_ident_starter
Start_P_ident ::= [_]* P_ident_starter

L_Ident :=
         | Start_L_Ident (Continue_Ident*)
         | [_] ((ident_spacer)*) 
U_Ident := Start_U_Ident (Continue_Ident*)
P_Ident := Start_P_Ident (Continue_Ident*)
I_Ident := Start_I_Ident (Continue_Ident*)

L_Ident are Lowercase identifiers.
U_Ident are Uppercase identifiers.
I_Ident are Infix identifiers.
P_Ident are Prefix identifiers.

Remarques:
 -- \' et \" sont les délimiteurs de caractères et de chaînes: il ne figurent pas
    dans les identificateurs.
 -- () [] {} sont des délimiteurs (sauf sans le cas (* *))

Exemples:
 x, _x, x1, _1, x+, x*, _, __, sont des L_Ident
 A, _A, A1, _A+, sont des U_Ident
 +, _+_, +mat, sont des I_Ident
 !, ~!, _!!_ sont des P_Ident
 0xFF

 a + x est une addition
 a+x est un L_Ident (ce n'est donc pas une addition)
 (a )+( x) est une addition



2007-07-11 (Pierre, Renaud, François)
=====================================

--------------------------------------------------------------------------
		 QUESTIONS AVEC DÉCISIONS EN RÉPONSE
Sujet                      Proposition                                Etat
--------------------------------------------------------------------------
Noms de collections   Doivent commencer par 1 alphabétique
et d'espèces          majuscule.
--------------------------------------------------------------------------
self                  Doit être renommé en "Self" dans la syntaxe
                      afin de rester cohérent avec le fait que
                      noms de collections et d'espèces doivent        FAIT
                      commencer par 1 alphabétique majuscule.
--------------------------------------------------------------------------
! et #                Doivent devenir optionnels. Autrement dit,
                      si une application apparaît, on ira
                      implicitement rechercher si elle réfère
                      à une méthode de self ou à un ident
                      toplevel du fichier courant sans qu'il
                      soit nécessaire que l'utilisateur ait
                      explicitement "scopé" son ident.
                      Ceci nécessite une passe de scoping pour
                      désambiguer entre application de :
			- ident au toplevel d'un autre fichier
                          (file#ident)
			- ident au toplevel fichier (#ident)
			- méthode de self (sel!ident ou !ident)
			- méthode d'une autre collection
                          (ident!ident)                               FAIT
--------------------------------------------------------------------------
!                     Retirer ! comme appel de méthode. A la
                      place, utiliser '.' en combinaison avec la
                      casse de le lettre de départ des
                      identicateurs:
			- low.low ->> Accès à un champ cde record
			- Upp.low ->> Accès à la méthode "low" de
                                      la collection "Upp".
			- Upp1.Upp2 ->> ??? (non spécifié)
                        - low.Upp   ->> ??? (non spécifié)
--------------------------------------------------------------------------
Syntaxe des           Les collections ne feront désormais plus
collections           qu'implanter des espèces. Elles ne pourront
                      pas déclarer ni définir des champs 
                      supplémentaires à l'espèce qu'elles
                      implantent. La syntaxe actuelle du nouveau
                      parseur à la forme:
                        collection ... implements ... = end ;;        FAIT
                      Le "=" suivi de "end" semble étrange. Du
                      fait qu'une collection de définit rien de
                      supplémentaire, on supprime le "=". Et du
                      fait qu'elle n'ait donc pas de body, on
                      supprime le "end". On a donc la syntaxe:
                        collection ... implements ... ;;
--------------------------------------------------------------------------
		 QUESTIONS SANS DÉCISIONS EN RÉPONSE
Sujet                      Question
--------------------------------------------------------------------------
constr            Le type décrivant les expresssions utilisant des
                  constructeurs de types somme a la forme :
                   | E_constr of expr * expr list
                  Ceci laisse penser que le nom du constructeur n'est pas
                  explicite et qu'il est le résultat d'un calcul arbitraire.
                  Ceci donne donc à penser que les constructeurs sont des
                  valeurs de première classe.
                  A la place, ne devtrait-on pas plutôt avoir :           FAIT
                   | E_constr of constr_name * expr list
                  Il faut voir qu'en fait le parser invariablement
                  construit une expr de la forme (E_var ident) avec ident
                  contenant le nom du constructeur.
                  Toutefois, les utilisateurs avancés devant pouvoir créer
                  des AST, cet invariant n'étant pas garanti structurellement,
                  un risque persiste.
--------------------------------------------------------------------------
ident_desc        La structure des ident_desc est particulièrement étrange
                  et impose un invariant non structurel (cite le .mli) :
                   (* If vname is self, then the real *)
                   (* name should be considered as only     *)
                   (* [cname]. If [cname] is None and       *)
                   (* [vname] is self, then it's bugged !   *)
                   | I_method of Types.cname option * vname
                  Pour la même raison que ci-dessus, il serait intéressant
                  d'avoir un type garantissant structurellement cet
                  invariant.
                      REGLÉ : Par défaut on scope en I_local et les idents
		      sont scopés en I_method uniquement lorsque l'on est
		      sûr de leur état de méthode. Ceci peut nécessiter
		      d'ailleurs que la passe de scoping ait été effectuée.
		      En fait, ce problème d'invariant était uniquement
		      présent pour les constructeurs de type parce que
		      ceux-ci étaient parsés comme bool --->> self!bool.
		      Donc une fois qu'on a viré de problème de parse, il
		      n'y a plus besoin de changer la structure des idents.
                  --------------------------------------------------------
                  De plus, le parser scope par défaut les identificateurs
                  comme étant des méthodes (I_method). Y compris les
                  identificateurs présents dans les expressions de types.
                  Ainsi, dans :                                           FAIT
                   rep = bool ;
                  "bool" sera représenté par une valeurs syntaxique encodant
                  self!bool. Ceci est franchement étrange. Le parser ne
                  devrait-il pas plutôt scoper par défaut en I_local ?
--------------------------------------------------------------------------
Algèbre de types  Doit-on autoriser (v in int) et (v in Coll) ? Autrement dit,
Types ML et       les types ML doivent-ils être mutuellement récursifs avec le
types d'espèces   type des collections ?
                  Si l'on imposait de définir une collection Int implémentant
                  des entiers, alors on pourrait écrire (v in Int) et les
                  expressions de types ne pourraient plus apparaître que dans
                  la définition des carriers.
                  On stratifierait ainsi complètement les "types ML" et les
                  "types de collections".
                                                                     FAIT

2007-08-02 (François)
=====================

* ENVIRONNEMENTS
****************
Faire une passe de scoping séparée et avant la phase de typage.
Les informations persistentes de scoping devront être stockée dans le même
fichier (.fo) que celles de typage, afin de ne pas multiplier les fichiers
intermédiaires.
Les algos gérant les environnements de scoping et de typage sont
essentiellement les mêmes. Surtout la recherche mappant les qualifications
! et # sur les fichiers sources représentant les modules.
Ceci impose donc que les environnements de scoping et de typage soient dans
un même fichier et que la structure des ".fo" connaisse à la fois la structure
des deux environnements.
On créera donc dans le même fichier "env.ml" 1 seule fonction partagée
permettant le mapping des "modules" sur les fichiers source FoCaL et une
structure d'environnement générique.
                                                           Status: FAIT


* SCOPING
*********
Par défaut, le parseur scope en I_local sauf si syntaxiquement se trouve
explicitement une désambiguation ! ou #. Le boulot du scoping est donc de
transformer si nécessaire ces I_local en I_global ou I_method.

Pour les ident nativement I_global on fait en sorte que leur qualification
soit toujours explicite (plus de None). Ainsi, dans une unité de compilation
"tata", un identificateur "#fct" deviendra "tada#fct".
                                                           Status: FAIT

Pour les ident nativement I_method (comme pour les I_local pour lesquels on
a déterminé qu'ils nommaient une méthode de Self), si la methode provient
de Self, alors on laisse None plutôt que de mettre explicitement Self.
Ceci fait qu'on obtiendra moralement un "!meth" au lieu d'un "Self!meth". On
peut le changer facilement si le besoin s'en fait sentir d'ailleurs.
                                                           Status: FAIT


Lorsque L'ON INSÈRE UN IDENT GLOBAL DANS L'ENVIRONNEMENT de scoping, on le
binde à un (SBI_file (Some l'unité de compilation courante)). Ainsi, au moment
de sauver l'environnement de scoping pour en faire un ".fo", on n'a pas besoin
de repasser sur les bindings avec None pour les expliciter à
(Some l'unité de compilation courante). De même lorsque l'on chargera un ".fo"
on n'aura pas à refaire ce traitement.
                                                           Status: FAIT


Le scoping permet de s'assurer que les identificateurs sont bien liés, et à
quoi. Mais, dans certains cas on a besoin de types pour ça (par exemple "c
is C ... c#meth" comme "c" est un paramètre pour savoir s'il a la méthode
"meth", il faudrait non pas aller voir dans la structure de "c" lui-même,
mais dans celle ... de son type ! C'est-à-dire de "C" !)
Ce qu'il se passe c'est que l'on possède forcément déjà un identificateur
I_method ici et qu'en voulant le "re-scoper" en fait on fait l'identité,
seulement pour y parvenir on fait une vérification de "liage". Or, comme on
vient de voir que ceci n'est pas possible dans ce cas sans les types, il
faudra prévoir un mécanisme pour ne pas échouer.
Il n'empêche que pour ce qui est des identificateur scopés par #, la question
ne se pose pas car on n'a pas de notion de "paramètre de toplevel de fichier".



* ACCÈS EXPLICITEMENT SCOPÉS AU FICHIER COURANT
***********************************************
De part la structure des environnements, si l'on tente d'accéder à
l'information liée à un ident toplevel du fichier courant qui fait explicitement
référence à ce fichier, comme le fichier courant ajoute ses bindings directement
dans l'environnement sans passer par une injection au sein d'un environnement
de module, il va falloir faire en sorte que l'accès à l'information liée à
un tel identificateur revienne à accéder à un identificateur non explicitement
scopé... Mais ATTENTION cela pose un problème:

Fichier toto.foc

 let foo () = ...
 open Fichier_avec_foo
 ... 
 toto#foo ()

Comme "toto#foo" devrait revenir à rechercher simplement "foo", le fait que le
open ait inséré dans l'environnement un ident "foo" fait qu'il va masquer celui
auquel on veut réellement accéder.

Solution: un binding d'environment est taggé soit comme "Absolute" (il provient
d'une définition se trouvant explicitement dans l'unité de compilation
actuellement analysée), soit "Opened" (il provient d'une directive "use" ou
"open").
                                                           Status: FAIT

??? PW 2007-11-1
Je ne comprends pas vraiment ce probleme, pourquoi ne pas ajouter les
liaisons du fichier courant en passant systématiquement par une injection ?

Après open Fichier_avec_foo dans toto.foc, il est logique que
foo référence Fichier_avec_foo#foo (pas toto#foo)
et toto#foo référence bien sûr toto#foo. Quel est le problème ???

2007-08-05 (François)
=====================

* RECORDS
*********
Il me semble qu'il faudrait scoper aussi les champs de records. Ceux-ci
devraient pouvoir être noté avec un mécanisme de #, sinon comment parler du
champ d'un type record se trouvant dans un autre module que le module actuel
(celui de l'unité de compilation actuelle) ?
Ceci impliquerait donc qu'il faille aussi scoper les noms de champs de records.
On pourrait alors remplacer la simple string représentant le nom du champ par
(fname option) * string. Pas besoin de la généralité d'un ident car il ne peut
pas être "I_method".

                                                           Status: FAIT



* COLLECTIONS ET ESPECES POUR LE SCOPING
****************************************
En fait, je pense que l'on a besoin aussi d'un environement de collections et
d'espèces pour scoper car pour se rendre compte qu'un ident scopé I_local
initialement (et par défaut) par le parser est en fait un I_method, il faut
bien avoir la liste des méthodes et l'héritage de la collection courante.
                                                            Status : FAIT


* QUESTION ENTRE SCOPING ET TYPAGE
**********************************
J'ai dis à l'avant dernier point que pour scoper, il nous fallait des buckets
pour les collections et les espèces dans l'environnement de scoping. Une
question inquiétante est de savoir si par malheur on ne risquerait pas d'avoir
besoin de connaître les types pour scoper (ce qui casserait notre belle
stratifications scoping PUIS typing).
A priori la réponse est NON car le scoping ne sert qu'à résoudre les ambiguités
induites par le fait de rendre optionnel (tacite) le #. Or ceci n'implique que
la recherche dans les méthodes de l'arbre d'héritage de l'espèce courante (Self).
Or le type de cette espèce est implicitement connu lorsque l'on l'analyse et
il n'y a pas besoin de calculs sur les types en vue de déterminer à quel type
d'espèce la méthode "bla" peut appartenir dans "#bla".
Ceci signifie toutefois que lors de la passe de scoping on ne peut pas être
certain qu'un ident déjà qualifié est bien effectivement lié. Ceci, par contre,
nécéssite du typage.


2007-08-06 (François)
=====================

* HOMOGÉNÉITÉ
*************
À voir pour les constructeurs de types somme, comme pour les idents en général:
si l'on a déterminé que le scope est le fichier courant, met-on None OU
Some DU FICHIER COURANT ?
La recherche dans les environnements sait gérer les 2 cas. Par contre, il
faudrait être homogène...
                                            Status : FAIT : on met Some (...).



* RUGOSITÉS DE L'AST.
*********************
Dans un certain nombre de cas, typiquement dans ceux liés aux expressions de
type, on utilise dans Parsetree des idents alors qu'ils sont trop généraux.
| RTE_ident of ident
| RTE_app of ident * ...
| TE_ident of ident
| TE_app of ident * ...
| SPT_in ident
L'ident (d'ailleurs par défaut généré comme I_local par le parseur) laisse la
possibilité aberrante d'avoir un I_method, ce qui n'a aucun sens ! Un nom de
type ne peut être une méthode ! D'où un certain nombre d''assert false au
niveau du typage, scoping, accès aux environnements...
Il faudrait quand même songer à restreindre à quelque chose de plus ...
restreint. Par exemple quelque chose comme ce qui avait été fait pour les
"expressions constructeurs de type somme". On pourrait se satisfaire d'un
truc de la forme:
   fname option * vname
avec l'option à None dans le cas où le nom du type est de la forme #myty.
Par contre, il faut réfléchir dans ce cas ce que deviennent les noms de types
"simple" comme "bool", "int" qui eux sont actuellement considérés comme des
I_local et qui donc ne rentrerait pas dans un schéma fname option * vname.

PW 2007/11/1
                                          Status: FAIT :
                                          - les idents de type ne peuvent être
                                             que I_local ou I_global
                                          À faire ([unsure]):
                                          - pour bool et int, il doivent être
                                            scopés en
                                            I_global ("internal", Vlident "int")

PW: Cela rejoint le discussion sur les types vraiment internes que nous avons eue.


* RUGOSITÉS DE LA SYNTAXE.
**************************
D'ailleurs c'est en lien direct avec la bizarerie suivante:
  type t = alias int ;;
  type u = alias (t * int) ;;
  let youppp in u = (5, 6) ;;   (* Pourquoi le # est optionnel ici ... *)
  type inv_prod ('a, 'b) = alias ('b * 'a) ;;
  let yappp in #inv_prod (int , string) = ("gee", 42) ;;  (* ... et pas là ? *)

                                      Status : FAIT. Le # est vraiment optionnel


2007-08-16 (François)
=====================

* UNIFICATION EN PLACE ET SELF
******************************
L'information dans le contexte de typage de ce à quoi Self est égal est
un type. Or lors des unifications, maintenant que tous les types ont
un binding level, le sien peut être affecté.
Et je pense que ça peut conduire à empêcher des généralisations. Il vaudrait
mieux mettre un schéma de type que l'on instancierait à la demande avec
le binding level courant.
En plus, ça éviterait sans doute le "hack" du [is_self].

PW 2007-11-1: Je ne suis pas sûr que ce soit correct. Mettre un schéma de
type dans l'environnement et l'instancier à la demande ne suffit pas pour
assurer la correction. Il faut en plus que soit cohérent!
Ça me semble rejoindre le problème général de la règle mu, non ?

2007-08-21 (François)
=====================

* Parsetree.mli
***************

and species_param_desc =
  | SP of expr
Les expressions de paramètre lors d'une application d'espèce sont soit :
 - des [expr] en cas de paramètre "in" (où même autre chose si l'on considère
   l'approche du dernier point du 2007-07-11, ce qui d'ailleurs pose un
   certain nombre de problèmes pour appliquer la règle [ENT-INST] vu que
   remplacer un nom de collection dans des expressions de valeurs n'a pas
   vraiment de sens. Il faudrait alors avoir un moyen d'exprimer une
   expression de valeur "correspondant" au repr d'une collection afin de
   faire cette substitution. Ce serait sans doute un genre de truc builtin,
   magic...).
 - des *identificateurs* de collection (c.f thèse Virgile section 3.8, page
   43) en cas de paramètre "is".                                   OK, COMPRIS
                                                             CAR LE PARSEUR NE
                             SAIT PAS SI IL EST SOUS UN in OU un is ET  COMMME
                             C'EST LA MÊME RÈGLE, expr PERMET D'ENGLOBER TOUS
                             LES CAS. IL FAUDRA SEULEMENT FAIRE ATTENTION QUE
                             POUR LES EXPRESSIONS UTILISÉES DANS LE CADRE D'UN
                             is, ON DEVRA S'ASSURER QUE CETTE EXPRESSION EST
                             BIEN UN E_constr (EH OUI, LES NOMS DE COLLECTION
                             SONT MAJUSCULÉS ET DONC CE SERA PARSÉ COMME UN
                             CONSTRUCTEUR DE TYPE SOMME) ET ALLER LE CHERCHER
                             DANS L'ENVT DES ESPÈCES ET NON DES VALUES.
Le record ci-dessus ne permet pas d'exprimer cela.


and species_param_type_desc =
  | SPT_in of ident
  | SPT_is of species_expr
En cas de paramètre "in", ce record oblige à avoir un [ident]. Donc on ne peut
pas donner d'expression de type arbitraire. A voir avec les remarques du
dernier point du 2007-07-11.


La fonction [abstract_copy] est fausse : si le type est généralisé alors elle
ne fait pas l'abstraction. Ca, c'est d'avoir voulu partager le code avec
[specialize]. A changer !                                                 FAIT



2007-11-29
==========
David, François

Creuser l'idée de ne pas lambda-lifter pour les méthodes de paramètres d'espèce
dont une méthode dépend. A la place, passer au générateur de collection 1
paramètre de type record par paramètre d'espèce. Le type record en question
serait celui représentant l'espèce paramètre. Et dans le générateur de
collection, plutôt que d'appliquer le paramètre lambda-lifter, on appliquerait
directement le paramètrePOINTsa_méthode dont on dépend.
