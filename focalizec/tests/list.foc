use "basics" ;;
open "basics" ;;

let print_bool =
   internal bool -> string
   external
   | caml -> "string_of_bool"
;;
let ext_nil =
   internal list ('a)
   external
   | caml -> "[]"
;;
let ext_cons =
   internal 'a -> list ('a) -> basics#list ('a)
   external
   | caml -> "(fun e l -> e :: l)"
;;
let ext_head =
  internal list ('a) -> 'a
  external
  | caml -> "List.hd"
;;
let ext_tail =
  internal list ('a) -> list ('a)
  external
  | caml -> "List.tl"
;;


species Equalified_object inherits Basic_object =
  let equal (x in Self, y in Self) in bool = base_eq (x, y) ;
end ;;

species List (E is Basic_object) inherits Equalified_object =
   sig nil : Self ;
   sig cons : E -> Self -> Self ;
   sig head : Self -> E ;
   sig tail : Self -> Self ;
   let rec map (f, l) =
     if equal (l, nil) then nil
     else
       let h = head (l) in
       let q = tail (l) in
       let h2 = f (h) in
       let q2 = map (f, q) in
       cons (h2, q2) ;
end ;;

species Concrete_list (E is Basic_object) inherits List (E) =
  rep = basics#list (E) ;
  let nil in Self = ext_nil ;
  let cons (e, l) in Self = ext_cons (e, l) ;
  let head (l in Self) in E = ext_head (l) ;
  let tail (l in Self) in Self = ext_tail (l) ;
end ;;

species Contrete_int inherits Basic_object =
  rep = basics#int ;
  let print = string_of_int ;
end ;;
collection Int implements Contrete_int ;;

species Contrete_bool inherits Basic_object =
  rep = basics#bool ;
  let print = print_bool ;
end ;;
collection Bool implements Contrete_bool ;;

collection Int_list implements Concrete_list (Int) ;;
collection Bool_list implements Concrete_list (Bool) ;;
