use "basics" ;;
open "basics" ;;


(* ****************************************************************** *)
(* Must pass.                                                         *)
(* The initial example given in Virgile Prevosto's Phd, section 2.2.2 *)
(* starting page 14.                                                  *)
(* ****************************************************************** *)
species Setoide inherits Basic_object =
  sig ( = ) : Self -> Self -> bool ;
  sig element : Self ;
  let different (x, y) = basics#not_b (x = y) ;

  property refl : all x in Self, x = x ;
  property symm : all x y in Self, Self!( = ) (x, y) -> y = x ;
end ;;

species Monoide inherits Setoide =
  sig ( * ) : Self -> Self -> Self ;
  sig un : Self ;
  let element = Self! un * !un ;
end ;;

species Setoide_produit (A is Setoide, B is Setoide) inherits Setoide =
  rep = (A * B) ;

  let ( = ) (x, y) =
     and_b
       (A!( = ) (basics#first (x), basics#first (y)),
	B!( = ) (scnd (x), scnd (y))) ;
  let creer (x, y) = basics#crp (x, y) ;
  let element = Self!creer (A!element, B!element) ;
  let print (x) =
     sc ("(",
	 sc (A!print (first (x)),
	     sc (",",
		 sc (B!print (scnd (x)),
		     ")")))) ;

  proof of refl = (* by definition of ( = ) *) assumed ;
  proof of symm = assumed ;

end ;;


species Monoide_produit (C is Monoide, D is Monoide)
  inherits Monoide, Setoide_produit (C, D) =

  let un = !creer (C!un, D!un) ;
  let ( * ) (x, y) =
     crp (C!( * ) (first (x), first (y)),
	  D!( * ) (scnd (x), scnd (y))) ;
end ;;


species Entiers_concrets inherits Monoide =
  rep = basics#int ;

  let un = 1 ;
  let ( * ) = basics#int_mult ;
  let ( = ) = basics#base_eq ;
  let print = basics#string_of_int ;
  let parse = basics#int_of_string ;

  proof of refl = assumed ;
  proof of symm = assumed ;
end ;;


collection Les_entiers implements Entiers_concrets ;;


collection Couple_d_entiers implements
  Monoide_produit (Les_entiers, Les_entiers)
;;

