use "basics" ;;
open "basics" ;;

5 ;;
let x = 42 ;;
let y = "Areuh world" ;;
let id (a) = a ;;
let a2 = id (5) ;;
let a1 = id (true) ;;
id (x) ;;
id (y) ;;
let tuple (x, y) = (x, y) ;;
tuple ((id (x)), id (id (y))) ;;
let rec fact (n) = fact (n) ;;
let swap (x, y) = (y, x) ;;
true ;;
let switch (x, y, z) = if x then y else z ;;
switch (true, "foo") ;;
(* [1; 4] ;; *)

type gros_produit = alias (int * (char * bool * string) * float  * bool) ;;
type t = alias int ;;
type u = alias (t * int) ;;
let bib in u = (5, 6) ;;   (* Pourquoi le # est optionnel ici ... *)
type inv_prod ('a, 'b) = alias ('b * 'a) ;;
let doudou in #inv_prod (int , string) = ("gee", 42) ;;  (* ... et pas là ? *)
type t = | A | B ;;
#A ;;
#B ;;
A ;;
B;;
type option ('a) = | None | Some ('a) ;;
#None ;;
let u = #None ;;
let uu = None ;;
let uuu = Some (42) ;;
#Some (4) ;;
#Some ("jgjg") ;;
let v = #Some ("kikoo") ;;
let v = #Some (#Some (true)) ;;
type daube ('a, 'b) = | Glop ('a) | Pasglop ('b) ;;
let tsoin = #Glop (5) ;;
let tsointsoin = #Pasglop ("foo") ;;

type record0 = { x0 = int ; y0 = float } ;;
let r0 = { x0 = 5 ; y0 = 5.5 } ;;
type record1 ('a) = { x1 = 'a } ;;
let r1 = { x1 = 5 } ;;
let r2 = { x1 = 5.0 } ;;
let r3 = { x1 = #None } ;;
let r4 = { x1 = #Some ("foo") } ;;


let not_b (x) in bool =
   match x with
   | true -> false
   | false -> true
;;


species Basic_object =
  let equal (x, y) =
     let useless = if true then x else y in
     true ;
end ;;

type sum = | Couic | Couac ;;

species TestAbstract =
  rep = sum ;
  sig element : Self ;

  let f (x) = if true then #Couic else element ;
  let g (y) = if true then element else #Couic ;
end ;;

species Toy inherits Basic_object =
  sig ( = ) : Self -> Self -> bool
  ;
  property ``equal is reflexive'' : all x y in Self,
    Self!( = ) (x, x) and
    x = x
  ;
  property equal_symmetric : all x y in Self,
    Self!equal(x, y) -> !equal(y, x)
  ;
  property equal_transitive : all x y z in Self,
    !equal(x, y) -> !equal(y, z) -> !equal(x, z)
  ;
  sig element : Self
  ;
  let different (x, y) = #not_b(!equal(x, y))
  ;

  let faux_different (x) = equal (x, x)
  ;

  theorem same_is_not_different : all x y in Self,
     !different(x, y) <-> ( !equal(x, y))
  proof:
    by definition of different ;

end
;;


species Dummy (a in Basic_object, B is Basic_object) =
  let x = a ;
  let y (z, t) = B!equal (z, t) ;
end
;;
