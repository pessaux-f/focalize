<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD><TITLE></TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.06">
</HEAD>
<BODY TEXT=black BGCOLOR=white>
<!--HEVEA command line is: hevea -fix macros.hva syntaxdef.hva refman.hva refman.tex -->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF chapter 1 -->
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<DIV ALIGN=center><FONT SIZE=7><B><BR>
<BR>
<FONT COLOR=purple>FoCaLize</FONT></B></FONT><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<FONT SIZE=7><BR>
<BR>
<B>Reference Manual</B></FONT><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<FONT SIZE=5><B><BR>
<BR>
<FONT COLOR=purple>1.0.0</FONT></B> </FONT><BR>
<BR>
<BR>
<BR>
<BR>
<FONT SIZE=5><B><BR>
<BR>
<FONT COLOR=purple>January 2009</FONT></B></FONT><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<FONT SIZE=5><BR>
<BR>
<B>Authors</B></FONT><BR>
<BR>
 <BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<FONT SIZE=4><EM>Thérèse Hardin,
François Pessaux,
Pierre Weis,
Damien Doligez
</EM></FONT>
</DIV><BR>
<DIV ALIGN=center>
<FONT SIZE=7><B>About <FONT COLOR=purple>FoCaLize</FONT></B></FONT>
</DIV><BR>
<BR>
<BR>
<FONT SIZE=4><EM><BR>
<BR>
<FONT COLOR=purple>FoCaLize</FONT> is the result of a collective work of several researchers,
listed in the following, who designed, defined, compiled, studied, extended,
used and debugged the preceding versions. They were helped by many
students who had a summer internship under their supervision. They
would like to thank all these students and more generally all the
persons who brought some contribution to <FONT COLOR=purple>FoCaLize</FONT>. </EM></FONT><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<DIV ALIGN=center>
<FONT SIZE=5><B> <FONT COLOR=purple>FoCaLize</FONT> contributors</B></FONT>
 <BR>
<BR>
<BR>
<BR>
<BR>
<BR>

</DIV><BR>
<FONT SIZE=4>Philippe Ayrault (SPI-LIP6), William Bartlett (CPR-CEDRIC), Julien
Blond (SPI-LIP6), Sylvain Boulmé (SPI-LIP6), Matthieu Carlier
(CPR-CEDRIC), Damien Doligez (GALLIUM-INRIA), David Delahaye
(CPR-CEDRIC), Catherine Dubois (CPR-CEDRIC), Jean-Frédéric Etienne
(CPR-CEDRIC), Stéphane Fechter (SPI-LIP6), Mathieu Jaume (SPI-LIP6),
Lionel Habib (SPI-LIP6), Thérèse Hardin (SPI-LIP6), Charles
Morisset (SPI-LIP6), Ivan Noyer (SPI-LIP6), François Pessaux
(SPI-LIP6), Virgile Prevosto (SPI-LIP6), Renaud Rioboo (CPR-CEDRC),
Lien Tran (SPI-LIP6), Véronique Viguié Donzeau-Gouge (CPR-CNAM),
Pierre Weis (ESTIME-INRIA)</FONT><BR>
<BR>
<BR>
<BR>
<BR>
<DIV ALIGN=center>
<FONT SIZE=4><B>and their institutions</B></FONT>
 <BR>
<BR>
<BR>
<BR>
<BR>
<BR>

</DIV><BR>
<EM>SPI (Semantics, Proofs and Implementations) is a team of LIP6,
(Laboratoire d'Informatique de Paris 6) of UPMC (Pierre and Marie Curie
University)</EM><SUP><A NAME="text1" HREF="#note1"><FONT SIZE=2>1</FONT></A></SUP><EM>.</EM><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<EM>CPR (Conception et Programmation Raisonnées) is a team of CEDRIC
(Centre d'Etudes et de Recherches du CNAM) of CNAM (Conservatoire National
des Arts et Métiers)</EM><SUP><A NAME="text2" HREF="#note2"><FONT SIZE=2>2</FONT></A></SUP><EM> and ENSIIE (Ecole Nationale d'Informatique pour
l'Industrie et l'Entreprise)</EM><SUP><A NAME="text3" HREF="#note3"><FONT SIZE=2>3</FONT></A></SUP><EM>. </EM><BR>
<BR>
<BR>
<BR>
<EM>ESTIME and GALLIUM are teams of INRIA Rocquencourt</EM><SUP><A NAME="text4" HREF="#note4"><FONT SIZE=2>4</FONT></A></SUP><EM>
</EM><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<DIV ALIGN=center>
<FONT SIZE=5><B>Thanks</B></FONT>
 <BR>
<BR>
<BR>
<BR>
<BR>
<BR>

</DIV><BR>
The <FONT COLOR=purple>Foc</FONT> project was first partially supported by LIP6 (Projet Foc, LIP6
1997) then by the Ministry of Research (Action Modulogic).
The <FONT COLOR=purple>Focal</FONT> research team was then partially supported by the French SSURF ANR project
ANR-06-SETI-016 (Safety and Security UndeR Focal). The project also
benefited of strong collaborations with EDEMOI ANR project and with
BERTIN and SAFERIVER companies.<BR>
<BR>
The <FONT COLOR=purple>FoCaLize</FONT> language and compiler development effort started around 2005.
The architecture conception and code rewritting started from scratch in 2006
to finally make the first focalizec compiler and <FONT COLOR=purple>FoCaLize</FONT> system
distribution in 2009, January.<BR>
<BR>
This manual documents the completely revised system with the new syntax and
its semantics extensions.<BR>
<BR>


<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL><DT><A NAME="note1" HREF="#text1"><FONT SIZE=5>1</FONT></A><DD>UPMC-LIP6,
104 avenue du Président Kennedy, Paris 75016, France,
<TT>Firstname.Lastname@lip6.fr</TT>
<DT><A NAME="note2" HREF="#text2"><FONT SIZE=5>2</FONT></A><DD>CNAM-CEDRIC,
292 rue Saint Martin, 75003, Paris, France,
<TT>Firstname.Lastname@cnam.fr</TT>
<DT><A NAME="note3" HREF="#text3"><FONT SIZE=5>3</FONT></A><DD>ENSIIE-CEDRIC,
1 Square de la Résistance, 91025 Evry Cedex, France,
<TT>Lastname@ensiie.fr</TT>
<DT><A NAME="note4" HREF="#text4"><FONT SIZE=5>4</FONT></A><DD>INRIA,
 Bat 8. Domaine de Voluceau, Rocquencourt, BP 105, F-78153 Le
 Chesnay, France, <TT>Firstname.Lastname@inria.fr</TT>
</DL>
<!--END NOTES-->
<!--TOC chapter Table of Contents-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#2de52d"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=6>Table of Contents</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<UL><LI>
<A HREF="#htoc1">Chapter&nbsp;1&nbsp;&nbsp;Overview</A>
<UL><LI>
<A HREF="#htoc2">1.1&nbsp;&nbsp;The Basic Brick</A>
<LI><A HREF="#htoc3">1.2&nbsp;&nbsp;Type of Species, Interfaces and Collections</A>
<LI><A HREF="#htoc4">1.3&nbsp;&nbsp;Combining Bricks by Inheritance</A>
<LI><A HREF="#htoc5">1.4&nbsp;&nbsp;Combining Bricks by Parametrisation</A>
<UL><LI>
<A HREF="#htoc6">1.4.1&nbsp;&nbsp;Parametrisation by Collection Parameters</A>
<LI><A HREF="#htoc7">1.4.2&nbsp;&nbsp;Parametrisation by Entity Parameters</A>
</UL>
<LI><A HREF="#htoc8">1.5&nbsp;&nbsp;The Final Brick</A>
<LI><A HREF="#htoc9">1.6&nbsp;&nbsp;Properties, Theorems and Proofs</A>
<LI><A HREF="#htoc10">1.7&nbsp;&nbsp;Around the Language</A>
<UL><LI>
<A HREF="#htoc11">1.7.1&nbsp;&nbsp;Consistency of the Software</A>
<LI><A HREF="#htoc12">1.7.2&nbsp;&nbsp;Code Generation</A>
<LI><A HREF="#htoc13">1.7.3&nbsp;&nbsp;Tests</A>
<LI><A HREF="#htoc14">1.7.4&nbsp;&nbsp;Documentation</A>
</UL>
</UL>
<LI><A HREF="#htoc15">Chapter&nbsp;2&nbsp;&nbsp;Installing and Compiling</A>
<UL><LI>
<A HREF="#htoc16">2.1&nbsp;&nbsp;Required software</A>
<LI><A HREF="#htoc17">2.2&nbsp;&nbsp;Optional software</A>
<LI><A HREF="#htoc18">2.3&nbsp;&nbsp;Operating systems</A>
<LI><A HREF="#htoc19">2.4&nbsp;&nbsp;Installation</A>
<LI><A HREF="#htoc20">2.5&nbsp;&nbsp;Compilation process and outputs</A>
<UL><LI>
<A HREF="#htoc21">2.5.1&nbsp;&nbsp;Outputs</A>
<LI><A HREF="#htoc22">2.5.2&nbsp;&nbsp;Compiling a source</A>
</UL>
</UL>
<LI><A HREF="#htoc23">Chapter&nbsp;3&nbsp;&nbsp;The core language</A>
<UL><LI>
<A HREF="#htoc24">3.1&nbsp;&nbsp;Lexical conventions</A>
<UL><LI>
<A HREF="#htoc25">3.1.1&nbsp;&nbsp;Blanks</A>
<LI><A HREF="#htoc26">3.1.2&nbsp;&nbsp;Comments</A>
<LI><A HREF="#htoc27">3.1.3&nbsp;&nbsp;Annotations</A>
<LI><A HREF="#htoc28">3.1.4&nbsp;&nbsp;Identifiers</A>
<UL><LI>
<A HREF="#htoc29">3.1.4.1&nbsp;&nbsp;Introduction</A>
<LI><A HREF="#htoc30">3.1.4.2&nbsp;&nbsp;Conceptual properties of names</A>
<LI><A HREF="#htoc31">3.1.4.3&nbsp;&nbsp;Fixity of identifiers</A>
<LI><A HREF="#htoc32">3.1.4.4&nbsp;&nbsp;Precedence of identifiers</A>
<LI><A HREF="#htoc33">3.1.4.5&nbsp;&nbsp;Categorization of identifiers</A>
<LI><A HREF="#htoc34">3.1.4.6&nbsp;&nbsp;Nature of identifiers</A>
<LI><A HREF="#htoc35">3.1.4.7&nbsp;&nbsp;Regular identifiers</A>
<LI><A HREF="#htoc36">3.1.4.8&nbsp;&nbsp;Infix/prefix operators</A>
<LI><A HREF="#htoc37">3.1.4.9&nbsp;&nbsp;Defining an infix operator</A>
<LI><A HREF="#htoc38">3.1.4.10&nbsp;&nbsp;Prefix form notation</A>
</UL>
<LI><A HREF="#htoc39">3.1.5&nbsp;&nbsp;Extended identifiers</A>
<LI><A HREF="#htoc40">3.1.6&nbsp;&nbsp;Species and collection names</A>
<LI><A HREF="#htoc41">3.1.7&nbsp;&nbsp;Integer literals</A>
<LI><A HREF="#htoc42">3.1.8&nbsp;&nbsp;String literals</A>
<LI><A HREF="#htoc43">3.1.9&nbsp;&nbsp;Character literals</A>
<LI><A HREF="#htoc44">3.1.10&nbsp;&nbsp;Floating-point number literals</A>
<LI><A HREF="#htoc45">3.1.11&nbsp;&nbsp;Proof step bullets</A>
<LI><A HREF="#htoc46">3.1.12&nbsp;&nbsp;Name qualification</A>
<LI><A HREF="#htoc47">3.1.13&nbsp;&nbsp;Reserved keywords</A>
</UL>
<LI><A HREF="#htoc48">3.2&nbsp;&nbsp;Language constructs and syntax</A>
<UL><LI>
<A HREF="#htoc49">3.2.1&nbsp;&nbsp;Types</A>
<UL><LI>
<A HREF="#htoc50">3.2.1.1&nbsp;&nbsp;Type constructors</A>
<LI><A HREF="#htoc51">3.2.1.2&nbsp;&nbsp;Type expressions</A>
<LI><A HREF="#htoc52">3.2.1.3&nbsp;&nbsp;Type definitions</A>
</UL>
<LI><A HREF="#htoc53">3.2.2&nbsp;&nbsp;Type-checking</A>
<LI><A HREF="#htoc54">3.2.3&nbsp;&nbsp;Representations</A>
<LI><A HREF="#htoc55">3.2.4&nbsp;&nbsp;Expressions</A>
<UL><LI>
<A HREF="#htoc56">3.2.4.1&nbsp;&nbsp;Literal expressions</A>
<LI><A HREF="#htoc57">3.2.4.2&nbsp;&nbsp;Sum type value constructor expressions</A>
<LI><A HREF="#htoc58">3.2.4.3&nbsp;&nbsp;Identifier expressions</A>
<LI><A HREF="#htoc59">3.2.4.4&nbsp;&nbsp;<TT>let-in</TT> expression</A>
<LI><A HREF="#htoc60">3.2.4.5&nbsp;&nbsp;<TT>logical let</TT></A>
<LI><A HREF="#htoc61">3.2.4.6&nbsp;&nbsp;Conditional expression</A>
<LI><A HREF="#htoc62">3.2.4.7&nbsp;&nbsp;Match expression</A>
<LI><A HREF="#htoc63">3.2.4.8&nbsp;&nbsp;Application expression</A>
<LI><A HREF="#htoc64">3.2.4.9&nbsp;&nbsp;Operator application expression</A>
<LI><A HREF="#htoc65">3.2.4.10&nbsp;&nbsp;Record expression</A>
<LI><A HREF="#htoc66">3.2.4.11&nbsp;&nbsp;Cloning a record expression</A>
<LI><A HREF="#htoc67">3.2.4.12&nbsp;&nbsp;Record field access expression</A>
<LI><A HREF="#htoc68">3.2.4.13&nbsp;&nbsp;Parenthesised expression</A>
</UL>
<LI><A HREF="#htoc69">3.2.5&nbsp;&nbsp;Core language expressions and definitions</A>
<LI><A HREF="#htoc70">3.2.6&nbsp;&nbsp;Files and uses directives</A>
<UL><LI>
<A HREF="#htoc71">3.2.6.1&nbsp;&nbsp;The <TT>use</TT> directive</A>
<LI><A HREF="#htoc72">3.2.6.2&nbsp;&nbsp;The <TT>open</TT> directive</A>
<LI><A HREF="#htoc73">3.2.6.3&nbsp;&nbsp;The <TT>coq_require</TT> directive</A>
</UL>
<LI><A HREF="#htoc74">3.2.7&nbsp;&nbsp;Properties, theorems and proofs</A>
<UL><LI>
<A HREF="#htoc75">3.2.7.1&nbsp;&nbsp;Logical expressions</A>
<LI><A HREF="#htoc76">3.2.7.2&nbsp;&nbsp;Properties</A>
<LI><A HREF="#htoc77">3.2.7.3&nbsp;&nbsp;Proofs</A>
<LI><A HREF="#htoc78">3.2.7.4&nbsp;&nbsp;Theorems</A>
</UL>
</UL>
</UL>
<LI><A HREF="#htoc79">Chapter&nbsp;4&nbsp;&nbsp;The <FONT COLOR=purple>FoCaLize</FONT> model</A>
<UL><LI>
<A HREF="#htoc80">4.1&nbsp;&nbsp;Basic concepts</A>
<UL><LI>
<A HREF="#htoc81">4.1.1&nbsp;&nbsp;Top-level Definitions</A>
<LI><A HREF="#htoc82">4.1.2&nbsp;&nbsp;Species</A>
<LI><A HREF="#htoc83">4.1.3&nbsp;&nbsp;Complete species</A>
<LI><A HREF="#htoc84">4.1.4&nbsp;&nbsp;Interfaces</A>
<LI><A HREF="#htoc85">4.1.5&nbsp;&nbsp;Collections</A>
</UL>
<LI><A HREF="#htoc86">4.2&nbsp;&nbsp;Parametrisation</A>
<UL><LI>
<A HREF="#htoc87">4.2.1&nbsp;&nbsp;Collection parameters</A>
<LI><A HREF="#htoc88">4.2.2&nbsp;&nbsp;Entity parameters</A>
</UL>
<LI><A HREF="#htoc89">4.3&nbsp;&nbsp;Inheritance and its mechanisms</A>
<UL><LI>
<A HREF="#htoc90">4.3.1&nbsp;&nbsp;Inheritance</A>
<LI><A HREF="#htoc91">4.3.2&nbsp;&nbsp;Species expressions</A>
</UL>
<LI><A HREF="#htoc92">4.4&nbsp;&nbsp;Late-binding and dependencies</A>
<UL><LI>
<A HREF="#htoc93">4.4.1&nbsp;&nbsp;Late-binding</A>
<LI><A HREF="#htoc94">4.4.2&nbsp;&nbsp;Dependencies and erasing</A>
<UL><LI>
<A HREF="#htoc95">4.4.2.1&nbsp;&nbsp;Decl-dependencies</A>
<LI><A HREF="#htoc96">4.4.2.2&nbsp;&nbsp;Def-dependencies</A>
<LI><A HREF="#htoc97">4.4.2.3&nbsp;&nbsp;Erasing during inheritance</A>
<LI><A HREF="#htoc98">4.4.2.4&nbsp;&nbsp;Dependencies on collection parameters</A>
</UL>
<LI><A HREF="#htoc99">4.4.3&nbsp;&nbsp;More about methods definition</A>
<UL><LI>
<A HREF="#htoc100">4.4.3.1&nbsp;&nbsp;Well-formation</A>
<LI><A HREF="#htoc101">4.4.3.2&nbsp;&nbsp;Def-dependencies on the representation</A>
</UL>
</UL>
</UL>
<LI><A HREF="#htoc102">Chapter&nbsp;5&nbsp;&nbsp;The <FONT COLOR=purple>FoCaLize</FONT> Proof Language</A>
<UL><LI>
<A HREF="#htoc103">5.1&nbsp;&nbsp;Proofs of theorems</A>
<UL><LI>
<A HREF="#htoc104">5.1.1&nbsp;&nbsp;Scoping rules</A>
</UL>
</UL>
<LI><A HREF="#htoc105">Chapter&nbsp;6&nbsp;&nbsp;Recursive function definitions</A>
<LI><A HREF="#htoc106">Chapter&nbsp;7&nbsp;&nbsp;Compiler options</A>
<LI><A HREF="#htoc107">Chapter&nbsp;8&nbsp;&nbsp;Documentation generation</A>
<UL>
<UL><LI>
<A HREF="#htoc108">8.0.2&nbsp;&nbsp;Special tags</A>
<UL><LI>
<A HREF="#htoc109">8.0.2.1&nbsp;&nbsp;@title</A>
<LI><A HREF="#htoc110">8.0.2.2&nbsp;&nbsp;@author</A>
<LI><A HREF="#htoc111">8.0.2.3&nbsp;&nbsp;@description</A>
<LI><A HREF="#htoc112">8.0.2.4&nbsp;&nbsp;@mathml</A>
</UL>
<LI><A HREF="#htoc113">8.0.3&nbsp;&nbsp;Transforming the generated documentation file</A>
<UL><LI>
<A HREF="#htoc114">8.0.3.1&nbsp;&nbsp;XML to HTML</A>
</UL>
<LI><A HREF="#htoc115">8.0.4&nbsp;&nbsp;XML to LaTeX</A>
</UL>
</UL>
<LI><A HREF="#htoc116">Chapter&nbsp;9&nbsp;&nbsp;Hacking deeper</A>
<UL>
<UL><LI>
<A HREF="#htoc117">9.0.5&nbsp;&nbsp;Interfacing <FONT COLOR=purple>FoCaLize</FONT> with other languages</A>
<LI><A HREF="#htoc118">9.0.6&nbsp;&nbsp;Dealing with hand-written <FONT COLOR=purple>Coq</FONT> proofs</A>
</UL>
</UL>
<LI><A HREF="#htoc119">Chapter&nbsp;10&nbsp;&nbsp;Compiler error messages</A>
</UL>

<!--TOC section Introduction-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Introduction</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<!--TOC subsection Motivations-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>Motivations</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
The <FONT COLOR=purple>Foc</FONT> project was launched in 1998 by T. Hardin and R. Rioboo
[<A HREF="#HardinRiobooTSI04"><CITE>11</CITE></A>] <SUP><A NAME="text5" HREF="#note5"><FONT SIZE=2>5</FONT></A></SUP>
with the objective of helping all stages of development of critical software
within safety and security domains. The methods used in these domains
are evolving, ad-hoc and empirical approaches being replaced by more formal
methods. For example, for high levels of safety, formal models of the
requirement/specification phase are more and more considered as they
allow mechanized proofs, test or static analysis of the required
properties. In the same way, high level assurance in system security asks for
the use of true formal methods along the process of software
development and is often required for the specification level.
Thus the project was to elaborate an Integrated
Development Environment (IDE) able to provide high-level and justified
confidence to users, but remaining easy to use by well-trained
engineers.<BR>
<BR>
To ease developing high integrity systems with numerous software
components, an Integrated Development Environment (IDE) should provide
tools to formally express specifications, to describe design and
coding and to ensure that specification requirements are met by the
corresponding code. This is not enough. First, standards of critical systems
ask for pertinent documentation which has to be maintained along all the revisions
during the system life cycle. Second, the evaluation conformance
process of software is by nature a sceptical analysis. Thus, any proof
of code correctness must be easily redone at request and traceability
must be eased. Third, design
and coding are difficult tasks. Research in software engineering has
demonstrated the help provided by some object-oriented
features as inheritance, late binding and early research works on
programming languages have pointed out the importance of abstraction
mechanism such as modularity to help invariant maintaining. There are
a lot of other points which should also be considered when designing
an IDE for safe and/or secure systems to ensure conformance with high
Evaluation Assurance or Safety Integrity Levels (EAL-5,7 or SIL 3,4)
and to ease the evaluation process according to various standards
(e.g. IEC61508, CC, ...): handling of non-functional contents of
specification, handling of dysfunctional behaviors and vulnerabilities
from the true beginning of development and fault avoidance, fault
detection by validation testing, vulnerability and safety analysis.<BR>
<BR>
<!--TOC subsection Initial application testbed-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>Initial application testbed</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
When the <FONT COLOR=purple>Foc</FONT> project was launched by Hardin and Rioboo,
only one specific domain was considered, the one of Computer
Algebra. Algorithms used in this domain can be rather intricated and
difficult to test and this is not rare that computer algebra systems
issue a bad result, due to semantical flaws, compiler anomalies,
etc. Thus the idea was to design a language allowing to specify the
mathematics underlying these algorithms and to go step by step to
different kinds of implementations according to the specifities of the
problem under consideration<SUP><A NAME="text6" HREF="#note6"><FONT SIZE=2>6</FONT></A></SUP>. The first step was to design
the semantics of such a language, trying to fit to several
requirements: easing the expression of mathematical statements, clear
distinction between the mathematical structure (semi-ring, polynomial,
..) and its different implementations, easing the development
(modularity, inheritance, parametrisation, abstraction, ..), runtime
efficiency and confidence in the whole development (mechanised proofs,
..). After an initial phase of conceptual design, the <FONT COLOR=purple>Foc</FONT>
semantics was submitted to a double test. On one hand, this semantics
was specified in <FONT COLOR=purple>Coq</FONT> and in a categorical model of type theories by
S. Boulmé (see his thesis[<A HREF="#BoulmePhD00"><CITE>3</CITE></A>]), a point which
enlightened the borders of this approach, regarding the logical
background. On the other hand, before designing the syntax, it was
needed to study the development style in such a
language. R. Rioboo&nbsp;[<A HREF="#ThRRCalculemus"><CITE>4</CITE></A><CITE>, </CITE><A HREF="#HardinRiobooTSI04"><CITE>11</CITE></A>] used the
<FONT COLOR=purple>OCaml</FONT> language to try different solutions which are recorded in
&nbsp;[<A HREF="#HardinRiobooTSI04"><CITE>11</CITE></A>].<BR>
<BR>
<!--TOC subsection Initial <FONT COLOR=purple>Focal</FONT> design-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>Initial <FONT COLOR=purple>Focal</FONT> design</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
Then the time came to design the syntax of the language and the compiler. To
overcome inconsistencies risks, an original dependency analysis was
incorporated into the compiler (V. Prevosto
thesis[<A HREF="#PrevostoPhD03"><CITE>17</CITE></A><CITE>, </CITE><A HREF="#TPHOL2002"><CITE>20</CITE></A><CITE>, </CITE><A HREF="#PrevostoJAR02"><CITE>19</CITE></A>]) and the correction of the
compiler (mostly written by V. Prevosto) against <FONT COLOR=purple>Focal</FONT>'s semantics is
proved (by hand) [<A HREF="#TLCA2005"><CITE>18</CITE></A>], a point which
brings a satisfactory confidence in the language's correctness. Then
Rioboo&nbsp;[] began the development of a huge computer algebra
library, which offers full specification
and implementation of usual algebraic structures up to multivariate
polynomial rings with complex algorithms, first as a way to
extensively test the language and (quite satisfactory)
efficiency of the produced code and then to provide a standard library
of mathematical backgrounds. And D. Doligez[<A HREF="#ZenonBDD"><CITE>2</CITE></A>] started the
development of <FONT COLOR=purple>Zenon</FONT>, an automatic prover based on tableaux method,
which takes a <FONT COLOR=purple>Focal</FONT> statement and tries to build a proof of it and,
when succeeds, issues a <FONT COLOR=purple>Coq</FONT> term. More recently, M. Carlier and
C. Dubois[<A HREF="#CarlierDuboisLNCS2008"><CITE>15</CITE></A>] began the development of a
test tool for <FONT COLOR=purple>Focal</FONT>.<BR>
<BR>
<FONT COLOR=purple>Focal</FONT> has already been used to develop huge examples such as the
standard library and the computer algebra library. The library
dedicated to the algebra of access control models, developed by
M. Jaume and C. Morisset[<A HREF="#jias06"><CITE>12</CITE></A><CITE>, </CITE><A HREF="#fcsarspa06"><CITE>13</CITE></A><CITE>, </CITE><A HREF="#MorissetPhd"><CITE>16</CITE></A>],
is another huge example, which borrows implementations of orderings,
lattices and boolean algebras from the computer algebra library.
<FONT COLOR=purple>Focal</FONT> was also very successfully used to formalize airport security
regulations, a work by D. Delahaye, J.-F. Etienne, C. Dubois,
V. Donzeau-Gouge &nbsp;[<A HREF="#EDEMOI-All"><CITE>6</CITE></A><CITE>, </CITE><A HREF="#EDEMOI-Model"><CITE>7</CITE></A><CITE>, </CITE><A HREF="#EDEMOI-Proof"><CITE>8</CITE></A>]. This
last work led to the development of a translator[<A HREF="#Focal-UML"><CITE>5</CITE></A>]
from <FONT COLOR=purple>Focal</FONT> to UML for documentation purposes.<BR>
<BR>
<!--TOC subsection The <FONT COLOR=purple>FoCaLize</FONT> system-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>The <FONT COLOR=purple>FoCaLize</FONT> system</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
The <FONT COLOR=purple>FoCaLize</FONT> development effort started in 2006: it was clearly a
continuation of the <FONT COLOR=purple>Foc</FONT> and <FONT COLOR=purple>Focal</FONT> efforts. The new system was rewritten
from scratch. A new language and syntax was designed and carefully
implemented, with in mind ease of use, expressivity, and programmer
friendyness. The addition of powerful data structure definitions together
with the corresponding pattern matching facility, lead to new expressing
power.<BR>
<BR>
The <FONT COLOR=purple>Zenon</FONT> automatic theorem prover was also integrated in the
compiler and natively interfaced within the <FONT COLOR=purple>FoCaLize</FONT> language. New
developments for recursive functions support is on the way (in particular for
termination proofs).<BR>
<BR>
A formal specification can be built by declaring names of functions
and values and introducing
properties. Then, design and implementation can incrementally be done
by adding definitions of functions and proving that the implementation
meets the specification or design requirements. Thus, developing in
<FONT COLOR=purple>FoCaLize</FONT> is a kind of refinement process from formal model to design
and code, completely done within <FONT COLOR=purple>FoCaLize</FONT>. Taking the global development
in consideration within the same environment brings some conciseness,
helps documentation and reviewing.
Thus a <FONT COLOR=purple>FoCaLize</FONT> development is organised as a hierarchy that may have
several roots. The upper levels of the hierarchy are built along the
specification stage while the lower ones correspond to
implementation and each node of the hierarchy corresponds to a progress
toward a complete implementation.<BR>
<BR>
The <FONT COLOR=purple>FoCaLize</FONT> system provides means for the developers to formally express
their specifications and to go step by step (in an incremental approach) to
design and implementation while proving that such an implementation
meets its specification or design requirements. The <FONT COLOR=purple>FoCaLize</FONT> language offers
high level mechanisms such as inheritance, late binding, redefinition,
parametrization, etc. Confidence in proofs submitted by developers or
automatically done relies on formal proof verification. <FONT COLOR=purple>FoCaLize</FONT> also
provides some automation of documentation production and management.<BR>
<BR>
We would like to mention several works about safety and/or security
concerns within <FONT COLOR=purple>FoCaLize</FONT> and specially the definition of a safety life
cycle by P. Ayrault, T. Hardin and F. Pessaux [<A HREF="#TTSS08"><CITE>1</CITE></A>] and the
study of some traps within formal methods by E. Jaeger and
T. Hardin[<A HREF="#traps"><CITE>10</CITE></A>].<BR>
<BR>
<!--TOC subsection The <FONT COLOR=purple>FoCaLize</FONT> system in short-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>The <FONT COLOR=purple>FoCaLize</FONT> system in short</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<FONT COLOR=purple>FoCaLize</FONT> can be seen as an IDE still in development, which
gives a positive solution to the three requirements identified above:
<OL type=1><LI>
pertinent documentation is maintained within the system being written,
 and its extraction is an automatic part of the compilation process,
<LI>proofs are written using a high level proof language, so that proofs
 are easier to write and their verification is automatic and reliable,
<LI>the framework provides powerful abstraction mechanisms to facilitate
 design and development; however, these mechanisms are carefully ruled:
 the compiler performs numerous validity checks to ensure that no
 further development can inadvertantly break the invariants or
 invalidate the proofs; indeed, the compiler ensures that if a theorem
 was based on assumptions that are now violated by the new development,
 then the theorem is out of reach of the programmer.
</OL>
<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL><DT><A NAME="note5" HREF="#text5"><FONT SIZE=5>5</FONT></A><DD>They were members of the SPI (Semantics, Proofs,
Implementations) team of the LIP6 (Lab. Informatique de Paris 6)
at Université Pierre et Marie Curie (UMPC), Paris
<DT><A NAME="note6" HREF="#text6"><FONT SIZE=5>6</FONT></A><DD>For example Computer Algebra
Libraries use several different representations of polynomials
according to the treatment to be done
</DL>
<!--END NOTES-->
<!--TOC chapter Overview-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#2de52d"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc1"><B><FONT SIZE=6>Chapter&nbsp;1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>Overview</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<BR>
 
<A NAME="glimpse"></A>
Before entering the precise description of <FONT COLOR=purple>FoCaLize</FONT> we give an
informal 
presentation of near all its features, to help further reading of the
reference manual. Every construction or feature of <FONT COLOR=purple>FoCaLize</FONT> will be
entirely described in the following chapters. <BR>
<BR>
<!--TOC section The Basic Brick-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc2"><B><FONT SIZE=5>1.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>The Basic Brick</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
The primitive entity of a <FONT COLOR=purple>FoCaLize</FONT> development is the
<EM>species</EM>. It can be viewed as a record grouping ``things'' related
to a same concept. Like in most modular design systems (i.e. objected 
oriented, algebraic abstract types) the idea is to group a data
structure with the operations to process it. Since in <FONT COLOR=purple>FoCaLize</FONT> we don't
only address data type and operations, among these ``things'' we also
find the declaration (specification) of these operations, the
properties (which may represent 
requirements) and their proofs. <BR>
<BR>
We now describe each of these ``things'', called <EM>methods</EM>.
<UL><LI>
 The <EM>method</EM> introduced by the keyword
 <TT>representation</TT> gives the data representation of entities
 manipulated by the <EM>species</EM>. It is a type called the
 <EM>representation</EM> (or the representation type when emphasising
 on the fact that it is a type) and defined by a type expression. 
 The <EM>representation</EM> may be not-yet-defined in a <EM>species</EM>, 
 meaning that the real structure of the data-type the <EM>species</EM>
 embeds does not need to be known at this point. In this case, it is
 simply a type variable. However, to obtain an
 implementation, the <EM>representation</EM>
 has to be defined later either by setting <TT>representation = exp</TT> where
 <TT>exp</TT> is a type expression or by inheritance (see below). 
 Type expressions in <FONT COLOR=purple>FoCaLize</FONT> are roughly ML-like types (variables,
 basic types, inductive types, record types) plus
 <EM>species representation types</EM>, denoted by keyword <TT>Self</TT>
 inside the species and by the name of their <EM>species</EM>
 outside of them.<BR>
<BR>
Each <EM>species</EM> has a unique method <EM>representation</EM>. This
 is not a restriction compared to other languages where
 programs/objects/modules can own several private variables
 representing the internal state, hence the data structure of the
 manipulated entities by the program/object/module. In such a case,
 the <EM>representation</EM> can simply be the tuple grouping all these
 variables that were disseminated all along the
 program/object/module.<BR>
<BR>
<LI>Declarations are composed of the keyword <TT>signature</TT>
 followed by a name and a type. It serves to announce a <EM>method</EM> to
 be defined later, i.e. to only specify its type, without
 implementation yet. Such <EM>methods</EM> are especially dedicated
 for specification or design purposes since declared names may be
 used to define others <EM>methods</EM> while
 delaying their definition. The type provided by
 the <EM>signature</EM> allows <FONT COLOR=purple>FoCaLize</FONT> to ensure via type-checking
 that the method is used in contexts compatibles with this
 type. The late-binding and the collection mechanisms, further
 introduced, ensure that the definition of the method will be
 effectively known when needed.<BR>
<BR>
<LI>Definitions are composed of the keyword <TT>let</TT>, followed
 by a name, a type and an expression. They serve to introduce
 constants or functions, i.e. computational operations. The core
 language used to implement them is roughly ML-like expressions
 (let-binding, pattern matching, conditional, higher order
 functions, ...) with the addition of a construction to call a
 <EM>method</EM> from a given <EM>species</EM>. Mutually recursive
 definitions are introduced by <TT>let rec</TT>.<BR>
<BR>
<LI>Statements are composed of the keyword <TT>property</TT>
 followed by a name and a first-order
 formula. A <EM>property</EM> may serve to express requirements
 (i.e. facts that the system must hold to conform to the Statement
 of Work) and then can be viewed as a
 specification purpose <EM>method</EM>, like <EM>signature</EM>s were for
 <TT>let</TT>-<EM>method</EM>s. It will lead to a proof obligation later
 in the development. A <EM>property</EM> may also be used to express
 some ``quality'' information of the system (soundness,
 correctness, ..) also submitted to a proof obligation. Formulae
 are written with usual logical connectors, universal and
 existential quantifications over a <FONT COLOR=purple>FoCaLize</FONT> type, and names of <EM>methods</EM> known within the <EM>species</EM>'s context. For instance,
 a <EM>property</EM> telling that if the speed is non-null, then doors
 can't be opened could look like:
 <DIV ALIGN=center>
 <TT>all v in Speed, v &lt;&gt; Speed!zero -&gt; ~doors_open</TT>
 </DIV>
 In the same way as <EM>signatures</EM>, even if no proof is
 yet given, the name of the <EM>property</EM> can be used to express 
 other ones and its statement can be used as an hypothesis in
 proofs. <FONT COLOR=purple>FoCaLize</FONT> late binding and collection mechanisms ensure
 that the proof of a <EM>property</EM> will be ultimately done.<BR>
<BR>
<LI>Theorems (<TT>theorem</TT>) made of a name, a statement and a
 proof are <EM>properties</EM> together with the formal proof that their
 statement holds in the context of the <EM>species</EM>. The proof
 accompanying the statement will be processed by <FONT COLOR=purple>FoCaLize</FONT> and
 ultimately checked with the theorem prover <FONT COLOR=purple>Coq</FONT>.<BR>
<BR>
Like in any formal development, one severe difficulty before
 proving is obviously to state a true interesting and meaningful
 statement. For instance, claiming that a piece of software is
 ``formally proved'' as respecting the safety requirements <TT>system_ok</TT> ``since <B>its</B> property is demonstrated'' is a
 lie if this property was, for instance, <TT>1 = 1 -&gt;
 system_ok</TT>. This is obviously a non-sense since the text of the
 property is trivial and does not link <TT>system_ok</TT> with the
 rest of the software (see [<A HREF="#traps"><CITE>10</CITE></A>] for less trivial examples).</UL>
We now make concrete these notions on an example we will incrementally
extend. We want to model some simple algebraic structures. Let's start
with the description of a ``setoid'' representing the data structure of
``things'' belonging to a set, which can be submitted to an
equality test and
exhibited (i.e. one can get a witness of existence of one of these
``things'').<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;(&nbsp;=&nbsp;)&nbsp;:&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;-&gt;&nbsp;bool&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;element&nbsp;:&nbsp;Self&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;property&nbsp;refl&nbsp;:&nbsp;all&nbsp;x&nbsp;in&nbsp;Self,&nbsp;x&nbsp;=&nbsp;x&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;property&nbsp;symm&nbsp;:&nbsp;all&nbsp;x&nbsp;y&nbsp;in&nbsp;Self,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;x&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;property&nbsp;trans:&nbsp;all&nbsp;x&nbsp;y&nbsp;z&nbsp;in&nbsp;Self,&nbsp;x=y&nbsp;and&nbsp;y=z&nbsp;-&gt;&nbsp;x=z&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;different&nbsp;(x,&nbsp;y)&nbsp;=&nbsp;basics#not_b&nbsp;(x&nbsp;=&nbsp;y)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
In this <EM>species</EM>, the <EM>representation</EM> is not explicitly
given (no keyword <TT>representation</TT>) , since we don't need to set
it to be able to express functions and properties our ``setoid''
requires. However, we can refer to it via <TT>Self</TT> and it is in fact
a type variable. In the same way, we specify a <EM>signature</EM> for the
equality (operator <TT>=</TT>). We introduce the three properties that
an equality (equivalence relation) must conform to. <BR>
<BR>
We complete the example by the definition of
the function <TT>different</TT> which use the name <TT>=</TT>
(here <TT>basics#not_b</TT> stands for the
function <TT>not_b</TT>, the boolean <TT>and</TT> coming from the <FONT COLOR=purple>FoCaLize</FONT>
source file <TT>basics.fcl</TT>). It is possible right now to prove that
<TT>different</TT> is irreflexive, under the hypothesis that <TT>=</TT> is an
equivalence relation (i.e. that each implementation of <TT>=</TT> given
further will satisfy these properties). <BR>
<BR>
<BR>
<BR>
<BR>
<BR>
It is possible to use <EM>methods</EM> only declared before they get a
real <EM>definition</EM> thanks to the <EM>late-binding</EM> feature
provided by <FONT COLOR=purple>FoCaLize</FONT>. In the same idea, redefining a <EM>method</EM> is
allowed in <FONT COLOR=purple>FoCaLize</FONT> and, it is 
always the last version which is kept as the effective <EM>definition</EM>
inside the species.<BR>
<BR>
<!--TOC section Type of Species, Interfaces and Collections-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc3"><B><FONT SIZE=5>1.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Type of Species, Interfaces and Collections</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="species-type"></A>
<A NAME="species-interface"></A>
The <EM>type</EM> of a <EM>species</EM> is obtained by removing definitions
and proofs. Thus, it is a kind of record type, made of all the method
types of the species. If the <TT>representation</TT> is still a type
variable say <FONT FACE=symbol>a</FONT>, then the <EM>species</EM> type is prefixed with an
existential binder <FONT FACE=symbol>$</FONT> <FONT FACE=symbol>a</FONT>. This binder will be eliminated as
soon as the <TT>representation</TT> will be instantiated (defined) and
must be eliminated to obtain runnable code. <BR>
<BR>
<BR>
<BR>
<BR>
<BR>
The <EM>interface</EM> of a species is obtained by abstracting the <EM>representation</EM> type in the <EM>species type</EM> and this abstraction
is permanent. <BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<B>Beware!</B> <EM>No special construction
is given to denote interfaces in the concrete syntax, they are
simply denoted by the name of the species underlying them.</EM> Do not
confuse a species and its interface. <BR>
<BR>
<BR>
<BR>
<BR>
<BR>
 The <EM>species type</EM> remain totally implicit in the concrete syntax, being
just used as a step to build <EM>species interface</EM>. It is used
during inheritance resolution. <BR>
<BR>
Interfaces can be ordered by inclusion, a point providing a very
simple notion of subtyping. This point will be further commented. <BR>
<BR>
A species is said to be <EM>complete</EM> if all declarations have
received definitions and all properties have received proofs.<BR>
<BR>
When <EM>complete</EM>, a species can be submitted to an abstraction
process of its representation to create a <EM>collection</EM>. Thus the
<EM>interface</EM> of the collection is just the <EM>interface</EM> of the
complete species underlying it. A collection can hence be seen as an
abstract data type, only usable through the methods of its interface,
but having the guarantee that all methods/theorems are defined/proved. <BR>
<BR>
<!--TOC section Combining Bricks by Inheritance-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc4"><B><FONT SIZE=5>1.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Combining Bricks by Inheritance</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
A <FONT COLOR=purple>FoCaLize</FONT> development is organised as a hierarchy which may have
several roots. Usually the upper levels of the hierarchy are built
during the specification stage while the lower ones correspond to
implementations. Each node of the hierarchy, i.e. each <EM>species</EM>,
is a progress to a complete implementation. On the previous 
example, forgetting <TT>different</TT>, we typically presented a kind of
<EM>species</EM> for ``specification'' since it expressed only
<EM>signatures</EM> of functions to be later implemented and properties
to which, later, give <EM>proofs</EM>.<BR>
<BR>
We can now create a new <EM>species</EM>, may be more complex, by
<B>inheritance</B> of a previously defined. We say here ``may be more
complex'' because it can add new operations and properties, but it can
also only bring real definitions to <EM>signatures</EM> and <EM>proofs</EM>
to <EM>properties</EM>, adding no new <EM>method</EM>.<BR>
<BR>
Hence, in <FONT COLOR=purple>FoCaLize</FONT> inheritance serves two kinds of evolutions. In the
first case the evolution aims making a <EM>species</EM> with more
operations but keeping those of its parents (or redefining some of
them). In the second case, the <EM>species</EM> only tends to be closer
to a ``run-able'' implementation, providing explicit definitions to
<EM>methods</EM> that were previously only declared.<BR>
<BR>
Continuing our example, we want to extend our model to represent
``things'' with a multiplication and a neutral element for this
operation.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;(&nbsp;*&nbsp;)&nbsp;:&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;one&nbsp;:&nbsp;Self&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;element&nbsp;=&nbsp;one&nbsp;*&nbsp;one&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
We see here that we added new <EM>methods</EM> but also gave a definition
to <TT>element</TT>, saying it is the application of the method <TT>*</TT>
to <TT>one</TT> twice, both of them being only <EM>declared</EM>. Here, we
used the inheritance in both the presented ways: making a more complex
entity by adding <EM>methods</EM> and getting closer to the
implementation by explicitly defining <TT>element</TT>.<BR>
<BR>
Multiple inheritance is available in <FONT COLOR=purple>FoCaLize</FONT>. For sake of simplicity,
the above example uses simple inheritance. In case of inheriting a
<EM>method</EM> from several parents, the order of parents in the
<TT>inherits</TT> clause serves to determine the chosen <EM>method</EM>.<BR>
<BR>
The <EM>type</EM> of a <EM>species</EM> built using inheritance is defined
like for other <EM>species</EM>, the <EM>methods</EM> types retained inside
it being those of the <EM>methods</EM> present in the <EM>species</EM> after
inheritance is resolved.<BR>
<BR>
A strong constraint in inheritance is that the type of inherited,
and/or redefined <EM>methods</EM> must not change. This is required to
ensure consistence of the <FONT COLOR=purple>FoCaLize</FONT> model, hence of the developed
software. More precisely, if the representation is given by a type
expression containing some type variables, then it can be more defined
by instanciation of these variables. In the same way, two signatures
have compatible types if they have a common unifier, thus, roughly
speaking if they are compatible Ml-like types. For example, if the
representation was not yet defined, thus being still a type variable,
it can be defined by <TT>int</TT>. And if a species <I>S</I> inherits from
<I>S</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>S</I>2 a method called <I>m</I>, there is no type clash if <I>S</I><SUB><FONT SIZE=2>1</FONT></SUB> !<I>m</I>
and <I>S</I><SUB><FONT SIZE=2>2</FONT></SUB>!<I>m</I> can be unified, then the method <I>S</I>!<I>m</I> has the most general
unifier of these two types as its own type. <BR>
<BR>
<!--TOC section Combining Bricks by Parametrisation-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc5"><B><FONT SIZE=5>1.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Combining Bricks by Parametrisation</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
Until now we are only able to enrich <EM>species</EM>. 
However, we sometimes need to use a <EM>species</EM>, not to take over
its <EM>methods</EM>, but rather to use it as an ``ingredient'' to build
a new structure. For instance, a pair of setoids is a
new structure, using the previous <EM>species</EM> as the ``ingredient''
to create the structure of the pair. Indeed, the structure of a pair is
independent of the structure of each component it is made of. A pair
can be seen as <EM>parametrised</EM> by its two components.
Following this idea, <FONT COLOR=purple>FoCaLize</FONT> allows two flavors of parametrisation.<BR>
<BR>
<!--TOC subsection Parametrisation by Collection Parameters-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc6"><B><FONT SIZE=4>1.4.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Parametrisation by Collection Parameters</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
We first introduce the <EM>collection parameters</EM>. They are
<EM>collections</EM> that the hosting species may use through their
<EM>methods</EM> to define its own ones.<BR>
<BR>
A <EM>collection parameter</EM> is given a name <I>C</I> and an interface
<I>I</I>. The name <I>C</I> serves to call the <EM>methods</EM> of <I>C</I> which figure in
<I>I</I>. <I>C</I> can be instantiated by an effective parameter <I>CE</I> of
interface <I>IE</I>. <I>CE</I> is a collection and its interface <I>IE</I> must
contain <I>I</I>. Moreover, the collection and late-binding mechanisms
ensure that all methods appearing in <I>I</I> are indeed implemented
(defined for functions, proved for properties) in <I>CE</I>. Thus, no
runtime error, due to linkage of libraries, can occur and any <EM>properties</EM> stated in <I>I</I> can be safely used as an hypothesis.<BR>
<BR>
Calling a <EM>species</EM>'s <EM>method</EM> is
done via the ``bang'' notation:
<TT>!meth</TT> or <BR>
<TT>Self!meth</TT> for a <EM>method</EM> of the current
<EM>species</EM> (and in this case, even simpler: <TT>meth</TT>, since the
<FONT COLOR=purple>FoCaLize</FONT> compiler will resolve scoping issues). To call
<EM>collection parameters</EM>'s <EM>method</EM>, the same notation is used:
<TT>A!element</TT> stands for the <EM>method</EM> <TT>element</TT> of the
<EM>collection parameter</EM> <TT>A</TT>.<BR>
<BR>
To go on with our example, a pair of setoids has two components, hence a
<EM>species</EM> for pairs of setoids will have two
<EM>collection parameters</EM>. It is itself a setoid, a fact which is
simply recorded via the inheritance mechanism:
<TT>inherits Setoid</TT> gives to <TT>Setoid_product</TT> all the methods
of <TT>Setoid</TT>.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;representation&nbsp;=&nbsp;(A&nbsp;*&nbsp;B)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;(&nbsp;=&nbsp;)&nbsp;(x,&nbsp;y)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and_b</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A!(&nbsp;=&nbsp;)&nbsp;(first&nbsp;(x),&nbsp;first&nbsp;(y)),</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B!(&nbsp;=&nbsp;)&nbsp;(scnd&nbsp;(x),&nbsp;scnd&nbsp;(y)))&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;create&nbsp;(x,&nbsp;y)&nbsp;in&nbsp;Self&nbsp;=&nbsp;basics#crp&nbsp;(x,&nbsp;y)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;element&nbsp;=&nbsp;Self!create&nbsp;(A!element,&nbsp;B!element)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;proof&nbsp;of&nbsp;refl&nbsp;=&nbsp;by&nbsp;definition&nbsp;of&nbsp;(&nbsp;=&nbsp;)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
We express the <EM>representation</EM> of the product of two setoids as the
Cartesian product of the <EM>representation</EM> of the two parameters. In
<TT>A * B</TT>, <TT>*</TT> is the <FONT COLOR=purple>FoCaLize</FONT> type  constructor of pairs, <TT>A</TT> denotes indeed 
the representation of the first <EM>collection parameter</EM>, and <TT>B</TT>
the one of of the second <EM>collection parameter</EM>.<BR>
<BR>
Next, we add a definition for <TT>=</TT> of <TT>Setoid_product</TT>,
relying on the methods <TT>=</TT> of <TT>A</TT> (<TT>A!( = )</TT>) and <TT>B</TT>
(which are not yet defined). Similarly, we introduce a definition for
<TT>element</TT> by building a pair, using
the function <TT>create</TT> (which calls the predefined function <TT>basics#crp</TT>) and the methods <TT>element</TT> of respectively <TT>A</TT>
and <TT>B</TT>. And we can prove that <TT>=</TT> of <TT>Setoid_product</TT> is
indeed reflexive, upon the hypothesis made on <TT>A!( = )</TT>
and <TT>B!( = )</TT>. The part of <FONT COLOR=purple>FoCaLize</FONT> used to write proofs will be
shortly presented later, in section <A HREF="#focal-proof-language">1.6</A>.<BR>
<BR>
This way, the <EM>species</EM> <TT>Setoid_product</TT> builds its <EM>methods</EM> relying on those of its <EM>collection parameters</EM>. Note the
two different uses of <TT>Setoid</TT> in our <EM>species</EM> <TT>Setoid_product</TT>, which inherits of <TT>Setoid</TT> and is parametrised
by <TT>Setoid</TT>.<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
Why such <EM>collection parameters</EM> and not simply <EM>species
 parameters</EM>? There are two reasons. First, effective parameters must
 provide definitions/proofs for all the methods of the required
 interface: this is the contract. Thus, effective parameters must 
 be <EM>complete</EM> species. Then, we do not want the parametrisation
 to introduce dependencies
on the parameters' <EM>representation</EM> definitions. For example, it is
 impossible to express `` if <TT>A!representation</TT> is <TT>int</TT> and <TT>B!representation</TT>
 is <TT>bool</TT> then <TT>A*B</TT> is a list of boolean values''. This would
dramatically restrict possibilities to instantiate parameters since
assumptions on the <EM>representation</EM>, possibly used in the
parametrised <EM>species</EM> to write its own <EM>methods</EM>, 
could prevent <EM>collections</EM> having the right set of <EM>methods</EM> but
a different representation to be used as
effective parameters. Such a behaviour would make parametrisation too
weak to be usable. We choose to always hide the <EM>representation</EM> of a
<EM>collection parameter</EM> to the parametrised
hosting <EM>species</EM>. Hence the introduction of the notion of
<EM>collection</EM>, obtained by abstracting the representation from a
complete species.<BR>
<BR>
<!--TOC subsection Parametrisation by Entity Parameters-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc7"><B><FONT SIZE=4>1.4.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Parametrisation by Entity Parameters</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
Let us imagine we want to make a <EM>species</EM> working on natural numbers
modulo a certain value. In the expression
5 <TT> <I>modulo</I> </TT> 2 <I>is</I> 1, both 5 and 2
are natural numbers. To be sure that the <EM>species</EM> will
consistently work with the same modulo, this last one must be embedded
in the <EM>species</EM>. However, the <EM>species</EM> itself doesn't rely
on a particular value of the modulo. Hence this value is clearly a
<B>parameter</B> of the species, but a parameter in which we are
interested by its <B>value</B>, not only by its <EM>representation</EM> and the
methods acting on it. We call
such parameters <EM>entity parameters</EM>, their introduction rests upon
the introduction of a <EM>collection parameter</EM> and they denote a
<EM>value</EM> having the type of the <EM>representation</EM> of this
<EM>collection parameter</EM>. <BR>
<BR>
Let us first have a <EM>species</EM> representing natural numbers:<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;one&nbsp;:&nbsp;Self&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;modulo&nbsp;:&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV>
Note that <TT>IntModel</TT> can be later implemented in various ways,
using Peano's integers, machine integers, arbitrary-precision
arithmetic ...<BR>
<BR>
We now build our <EM>species</EM> ``working modulo ...'', embedding
the value of this modulo:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;job1&nbsp;(x&nbsp;in&nbsp;Naturals)&nbsp;in&nbsp;...&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;Naturals!modulo&nbsp;(x,&nbsp;n)&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;job2&nbsp;(x&nbsp;in&nbsp;Naturals,&nbsp;...)&nbsp;in&nbsp;...&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;...&nbsp;Naturals!modulo&nbsp;(x,&nbsp;n)&nbsp;...&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV>
Using the <EM>entity parameter</EM> <TT>n</TT>, we ensure that the
<EM>species</EM> <TT>Modulo_work</TT> works for <EM>any</EM> value of the
modulo, but will always use the <EM>same</EM> value <TT>n</TT> of the modulo
everywhere inside the <EM>species</EM>.<BR>
<BR>
<!--TOC section The Final Brick-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc8"><B><FONT SIZE=5>1.5</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>The Final Brick</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
As briefly introduced in <A HREF="#species-interface">1.2</A>, a <EM>species</EM>
needs to be fully defined to lead to executable code for its functions
and checkable proofs for its theorems. When a <EM>species</EM> is fully
defined, it can be turned into a <EM>collection</EM>. Hence, a <EM>collection</EM>
represents the final stage of the inheritance tree of a <EM>species</EM>
and leads to an effective data representation with
executable functions processing it.<BR>
<BR>
For instance, providing that the previous
<EM>species</EM> <TT>IntModel</TT> turned into a fully-defined species
<TT>MachineNativeInt</TT> through inheritances steps, with a <EM>method</EM>
<TT>from_string</TT> allowing to create the natural representation of a
string, we could get a related collection by:<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV><BR>
Next, to get a <EM>collection</EM> implementing arithmetic modulo 8, we
could extract from the <EM>species</EM> <TT>Modulo_work</TT> the following
<EM>collection</EM>:<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;(MachineNativeIntColl,&nbsp;MachineNativeIntColl!from_string&nbsp;(``8'')&nbsp;;;</TT></FONT></DIV><BR>
As seen by this example, a species can be applied to effective
parameters by giving their values with the usual syntax of parameter
passing. <BR>
<BR>
As said before, to ensure modularity and abstraction, the
<EM>representation</EM> of a 
<EM>collection</EM> turns hidden. This means that any software component
dealing with a <EM>collection</EM> will only be able to manipulate it
through the operations (<EM>methods</EM>) its interface provides. This
point is especially important since it prevents other software
components from possibly breaking invariants required by the internals
of the <EM>collection</EM>.<BR>
<BR>
<!--TOC section Properties, Theorems and Proofs-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc9"><B><FONT SIZE=5>1.6</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Properties, Theorems and Proofs</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="focal-proof-language"></A><BR>
<FONT COLOR=purple>FoCaLize</FONT> aims not only to write programs, it intends to encompass both
the executable model (i.e. program) and properties this model must
satisfy. For this reason, ``special'' <EM>methods</EM> deal with logic
instead of purely behavioural aspects of the system: <EM>theorems</EM>,
<EM>properties</EM> and <EM>proofs</EM>.<BR>
<BR>
Stating a <EM>property</EM> expects that a <EM>proof</EM> that it
<B>holds</B> will finally be given. For <EM>theorems</EM>, the <EM>proof</EM> is
directly embedded in the <EM>theorem</EM>. Such proofs must be done by
the developer and will finally be sent to the formal proof assistant
<FONT COLOR=purple>Coq</FONT> who will automatically check that the demonstration of the
<EM>property</EM> is consistent. Writing a proof can be done in several ways.<BR>
<BR>
It can be written in <FONT COLOR=purple>FoCaLize</FONT>'s proof language, a hierarchical proof
language that allows to give hints and directions for a proof. This
language will be sent to an external theorem prover,
<FONT COLOR=purple>Zenon</FONT>&nbsp;[<A HREF="#Zenon"><CITE>Zenon</CITE></A><CITE>, </CITE><A HREF="#zenon0.4.1"><CITE>9</CITE></A>] developed by D. Doligez. This prover is
a first order theorem prover based on the tableau method incorporating
implementation novelties such as sharing. <FONT COLOR=purple>Zenon</FONT> will attempt, from
these hints to automatically generate the proof and exhibit a <FONT COLOR=purple>Coq</FONT>
term suitable for verification by <FONT COLOR=purple>Coq</FONT>. Basic hints given by the
developer to <FONT COLOR=purple>Zenon</FONT> are: ``prove by definition of a <EM>method</EM>''
(i.e. looking inside its body) and ``prove by <EM>property</EM>''
(i.e. using the logical body of a <EM>theorem</EM> or <EM>property</EM>''.
Surrounding this hints mechanism, the language allows to build the
proof by stating assumptions (that must obviously be demonstrated
next) that can be used to prove lemmas or parts for the whole
property. We show below an example of such demonstration.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;!order_inf(i,&nbsp;x)&nbsp;-&gt;&nbsp;!order_inf(i,&nbsp;y)&nbsp;-&gt;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!order_inf(i,&nbsp;!inf(x,&nbsp;y))</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;proof:</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;1&gt;1&nbsp;assume&nbsp;x&nbsp;in&nbsp;Self,&nbsp;assume&nbsp;y&nbsp;in&nbsp;Self,</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assume&nbsp;i&nbsp;in&nbsp;Self,&nbsp;assume&nbsp;H1:&nbsp;!order_inf(i,&nbsp;x),</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assume&nbsp;H2:&nbsp;!order_inf(i,&nbsp;y),</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prove&nbsp;!order_inf(i,&nbsp;!inf(x,&nbsp;y))</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;2&gt;1&nbsp;prove&nbsp;!equal(i,&nbsp;!inf(!inf(i,&nbsp;x),&nbsp;y))</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;hypothesis&nbsp;H1,&nbsp;H2</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property&nbsp;inf_left_substitution_rule,</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equal_symmetric,&nbsp;equal_transitive</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;definition&nbsp;of&nbsp;order_inf</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;2&gt;9&nbsp;qed</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;step&nbsp;&lt;2&gt;1</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property&nbsp;inf_is_associative,&nbsp;equal_transitive</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;definition&nbsp;of&nbsp;order_inf</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;1&gt;2&nbsp;conclude</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;;</TT></FONT></DIV><BR>
The important point is that <FONT COLOR=purple>Zenon</FONT> works for the
developer: <B>it searches the proof itself</B>, the developer does not
have to elaborate it formally ``from scratch''.<BR>
<BR>
Like any automatic theorem prover, <FONT COLOR=purple>Zenon</FONT> may fail finding a
demonstration. In this case, <FONT COLOR=purple>FoCaLize</FONT> allows to write verbatim
<FONT COLOR=purple>Coq</FONT> proofs. In this case, the proof is not anymore automated, but
this leaves the full power of expression of <FONT COLOR=purple>Coq</FONT> to the developer.<BR>
<BR>
Finally, the <TT>assumed</TT> keyword is the ultimate proof backdoor,
telling that the proof is not given but that the property must be
admitted. Obviously, a really safe development should not make usage of
such ``proofs'' since they bypass the formal verification of
software's model. However, such a functionality remains needed since
some of ``well-known'' properties can never be proved for a computer.
For instance, <FONT FACE=symbol>"</FONT> <I>x</I> <FONT FACE=symbol>Î</FONT> <I>I</I><I>N</I>, <I>x</I>+1 &gt;<I>n</I> does not hold in a
computer with native integers. However, in a mathematical
framework, this property holds and is needed to carry out other
proofs. Thus the developer may prove either that all manipulated values
remain in an interval where this property holds or may admit this
property or may add code to detect overflow ... 
 On another side, a development may be linked with external
code, trusted or not, but for which properties cannot be proved inside
the <FONT COLOR=purple>FoCaLize</FONT> part since it does not belong to it. Expressing properties
of the <FONT COLOR=purple>FoCaLize</FONT> part may need to express properties on the imported
code, that cannot be formally proved, then must be ``assumed''.<BR>
<BR>
<!--TOC section Around the Language-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc10"><B><FONT SIZE=5>1.7</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Around the Language</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
In the previous sections, we presented <FONT COLOR=purple>FoCaLize</FONT> through its programming
model and shortly its syntax. We especially investigated the various
entities making a <FONT COLOR=purple>FoCaLize</FONT> program. We now address what becomes a
<FONT COLOR=purple>FoCaLize</FONT> program once compiled. We recall that <FONT COLOR=purple>FoCaLize</FONT> supports the
redefinition of functions, which permits for example to specialise
code to a specific representation (for example, there
exists a generic implementation of integer addition modulo <TT>n</TT> but
it can be redefined in arithmetics modulo <TT>2</TT> if boolean values
are used to represent the two values). It is also a very convenient
tool to maintain software. <BR>
<BR>
<!--TOC subsection Consistency of the Software-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc11"><B><FONT SIZE=4>1.7.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Consistency of the Software</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
All along the development cycle of a <FONT COLOR=purple>FoCaLize</FONT> program, the compiler
keeps trace of dependencies between <EM>species</EM>, their
<EM>methods</EM>, the <EM>proofs</EM>, ...to ensure that modifications
of one of them will be detected those depending of it.<BR>
<BR>
<FONT COLOR=purple>FoCaLize</FONT> considers two types of dependencies:
<UL><LI>
The <B>decl</B>-dependency: a <EM>method</EM> <I>A</I> decl-depends on a
 <EM>method</EM> <I>B</I>, if the <B>declaration</B> of <I>B</I> is required to
 state <I>A</I>.
<LI>The <B>def</B>-dependency: a <EM>method</EM> (and more especially, a
 <EM>theorem</EM>) <I>A</I> def-depends on a <EM>method</EM> <I>B</I>, if the
 <B>definition</B> of <I>B</I> is required to state <I>A</I> (and more
 especially, to prove the property stated by the <EM>theorem</EM>
 <I>A</I>).
</UL>
The redefinition of a function may invalidate the proofs that use
properties of the body of the redefined function. All the proofs
which truly depend of the definition are then erased by the compiler
and must be done again in the context updated with the new
definition. Thus the main difficulty is to choose the best level in
the hierarchy to do a proof. In [<A HREF="#PrevostoJaume2003"><CITE>21</CITE></A>], Prevosto and
Jaume propose a <EM>coding style</EM> to minimise the number of proofs
to be redone in the case of a redefinition, by a certain kind of
modularisation of the proofs.<BR>
<BR>
<!--TOC subsection Code Generation-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc12"><B><FONT SIZE=4>1.7.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Code Generation</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<FONT COLOR=purple>FoCaLize</FONT> currently compiles programs toward two languages, <FONT COLOR=purple>OCaml</FONT> to
get an executable piece of software, and <FONT COLOR=purple>Coq</FONT> to have a formal model
of the program, with theorems and proofs.<BR>
<BR>
In <FONT COLOR=purple>OCaml</FONT> code generation, all
the logical aspects are discarded since they do not lead to executable
code.<BR>
<BR>
Conversely, in <FONT COLOR=purple>Coq</FONT>, all the <EM>methods</EM> are compiled,
i.e. ``computational'' <EM>methods</EM> and logical <EM>methods</EM> with
their proofs. This allows <FONT COLOR=purple>Coq</FONT> to check the entire consistence of
the system developed in <FONT COLOR=purple>FoCaLize</FONT>.<BR>
<BR>
<!--TOC subsection Tests-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc13"><B><FONT SIZE=4>1.7.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Tests</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<FONT COLOR=purple>FoCaLize</FONT> incorporates a tool named <EM>FocalTest</EM>
[<A HREF="#CarlierDuboisLNCS2008"><CITE>15</CITE></A>] for Integration/Validation testing. It
allows to confront automatically a property of the specification with
an implementation. It generates automatically test cases, executes
them and produces a test report as an XML document. The property under
test is used to generate the test cases, it also serves as an
oracle. When a test case fails, it means a counterexample of the
property has been found: the implantation does not match the property;
it can also indicate an error in the specification.<BR>
<BR>
The tool <EM>FocalTest</EM> automatically produces the test environment and
the drivers to conduct the tests. We benefit from the inheritance
mechanism to isolate the testing harness from the components written
by the programmer.<BR>
<BR>
The testable properties are required to be broken down into a
precondition and a conclusion, both executable.
<EM>FocalTest</EM> proposes a pure random test cases generation: it
generates test cases until the precondition is satisfied, the verdict
of the test case is given by executing the post-condition. It can be
an expensive process for some kind of preconditions. To overcome this
drawback, a constraint based generation is under development: it
allows to produce directly test cases for which the precondition is
satisfied.<BR>
<BR>
<!--TOC subsection Documentation-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc14"><B><FONT SIZE=4>1.7.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Documentation</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
The tool called <FONT COLOR=purple>FoCaLizeDoc</FONT> [<A HREF="#MaarekCalculemus03"><CITE>14</CITE></A>] automatically
generates documentation, thus the documentation of a component is
always coherent with respect to its implementation.<BR>
<BR>
This tool uses its own XML format that contains information coming not
only from structured comments (that are parsed and kept in the
program's abstract syntax tree) and <FONT COLOR=purple>FoCaLize</FONT> concrete syntax but also
from type inference and dependence analysis. From this XML
representation and thanks to some XSLT stylesheets, it is possible to
generate HTML files or L<sup>A</sup>T<sub>E</sub>X files. Although this documentation is
not the complete safety case, it can helpfully contribute to its
elaboration. In the same way, it is possible to produce UML
models&nbsp;[<A HREF="#Focal-UML"><CITE>5</CITE></A>] as means to provide a graphical documentation
for <FONT COLOR=purple>FoCaLize</FONT> specifications. The use of graphical notations appears
quite useful when interacting with end-users, as these tend to be more
intuitive and are easier to grasp than their formal (or textual)
counterparts. This transformation is based on a formal schema and
captures every aspect of the <FONT COLOR=purple>FoCaLize</FONT> language, so that it has been
possible to prove the soundness of this transformation (semantic
preservation).<BR>
<BR>
<FONT COLOR=purple>FoCaLize</FONT>'s architecture is designed to easily plug third-parties
analyses that can use the internal structures elaborated by the
compiler from the source code. This allows, for example, to make
dedicated documentation tools for custom purposes, just exploiting
information stored in the <FONT COLOR=purple>FoCaLize</FONT> program's abstract syntax tree, or
extra information possibly added by extra processes, analyses.
<BR>
<BR>
<!--TOC chapter Installing and Compiling-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#2de52d"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc15"><B><FONT SIZE=6>Chapter&nbsp;2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>Installing and Compiling</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<BR>
<!--TOC section Required software-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc16"><B><FONT SIZE=5>2.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Required software</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="required-software"></A>
To be able to develop with the <FONT COLOR=purple>FoCaLize</FONT> environment, a few third party
tools are required. All of them can be freely downloaded from their
related website.
<UL><LI>
 The Objective Caml compiler (version <FONT FACE=symbol>³</FONT> 3.10.2).<BR>
Available
 at <CODE>http://caml.inria.fr</CODE>. This will be used to compile both
 the <FONT COLOR=purple>FoCaLize</FONT> system at installation stage from the tarball and
 the <FONT COLOR=purple>FoCaLize</FONT> compiler's output generated by the compilation of
 your <FONT COLOR=purple>FoCaLize</FONT> programs.<BR>
<BR>
<LI>The Coq Proof Assistant (version <FONT FACE=symbol>³</FONT> 8.1pl4).<BR>
Available at
 <CODE>http://coq.inria.fr</CODE>. This will be used to compile both
 the <FONT COLOR=purple>FoCaLize</FONT> libraries at installation stage from the tarball and
 the <FONT COLOR=purple>FoCaLize</FONT> compiler's output generated by the compilation of
 your <FONT COLOR=purple>FoCaLize</FONT> programs.
</UL>
<!--TOC section Optional software-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc17"><B><FONT SIZE=5>2.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Optional software</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="optional-software"></A>
The <FONT COLOR=purple>FoCaLize</FONT> compiler can generate dependencies graphs from compiled
source code. It generates them in the format suitable to be processed
and displayed by the <FONT COLOR=purple>dotty</FONT> tools suit of the ``Graphwiz'' package. If
you plan to examine these graphs, you also need to install this
software from <CODE>http://www.graphviz.org/</CODE>.<BR>
<BR>
<!--TOC section Operating systems-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc18"><B><FONT SIZE=5>2.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Operating systems</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<FONT COLOR=purple>FoCaLize</FONT> was fully developed under Linux using free software. Hence,
any Unix-based operating system should support <FONT COLOR=purple>FoCaLize</FONT>. The currently
tested Unix are: Fedora, Debian, Suse, BSD.<BR>
<BR>
Windows users can run <FONT COLOR=purple>FoCaLize</FONT> via the Unix-like
environment <FONT COLOR=purple>Cygwin</FONT> providing both users and developers tools. This
software is freely distributed and available
at <CODE>http://www.cygwin.com/</CODE>.<BR>
<BR>
<BR>
<!--TOC paragraph From the official <FONT COLOR=purple>Cygwin</FONT> web site:-->

<H5>From the official <FONT COLOR=purple>Cygwin</FONT> web site:</H5><!--SEC END -->

``<EM>Cygwin is a Linux-like environment for Windows. It consists of
two parts: A DLL (cygwin1.dll) which acts as a Linux API emulation
layer providing substantial Linux API functionality. A collection of
tools which provide Linux look and feel.
<BR>
The Cygwin DLL currently works with all recent, commercially released
x86 32 bit and 64 bit versions of Windows, with the exception of
Windows CE.
<BR>
Cygwin is not a way to run native linux apps on Windows. You have to
rebuild your application from source if you want it to run on
Windows.<BR>
<BR>
Cygwin is not a way to magically make native Windows apps aware of
UNIX ® functionality, like signals, ptys, etc. Again, you need to
build your apps from source if you want to take advantage of Cygwin
functionality.</EM>''<BR>
<BR>
<BR>
Under <FONT COLOR=purple>Cygwin</FONT>, the required packages are the same as those listed
in <A HREF="#required-software">2.1</A> and <A HREF="#optional-software">2.2</A>. As stated
in <FONT COLOR=purple>Cygwin</FONT>'s citation above, you need to get the sources packages of
this software and compile them yourself, following information
provided in these packages.<BR>
<BR>
The installation of <FONT COLOR=purple>FoCaLize</FONT> itself is the same for all operating
systems and is described in the following section
(<A HREF="#installation">2.4</A>).<BR>
<BR>
<!--TOC section Installation-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc19"><B><FONT SIZE=5>2.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Installation</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="installation"></A>
<A NAME="@default0"></A>
<FONT COLOR=purple>FoCaLize</FONT> is currently distributed as a tarball containing the whole
source code of the development environment. You must first deflate the
archive (a directory will be created) by:
<DIV ALIGN=center>
<TT>tar xvzf focalize-x.x.x.tgz</TT>
</DIV>
Next, go in the sources directory:
<DIV ALIGN=center>
<TT>cd focalize-x.x.x/</TT>
</DIV>
You now must configure the build process by:
<DIV ALIGN=center>
<TT>./configure</TT>
</DIV>
The configuration script then asks for directories where to install
the <FONT COLOR=purple>FoCaLize</FONT> components. You may just press enter to keep the default
installation directories.
<PRE>
latour:~/src/focalize$ ./configure ~/pkg
Where to install FoCaLize binaries ?
Default is /usr/local/bin.
Just press enter to use default location.

Where to install FoCaLize libraries ?
Default is /usr/local/lib/focalize.
Just press enter to use default location.
</PRE>After the configuration ends, just build the system:
<DIV ALIGN=center>
<TT>make all</TT>
</DIV>
And finally, get root priviledges to install the <FONT COLOR=purple>FoCaLize</FONT> system:
<DIV ALIGN=center>
<TT>su</TT><BR>
<TT>make install</TT>
</DIV>

<BR>
<!--TOC section Compilation process and outputs-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc20"><B><FONT SIZE=5>2.5</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Compilation process and outputs</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
We call <EM>compilation unit</EM><A NAME="@default1"></A> a file
containing source code for toplevel-definitions, species,
collections. Visibility rules, described in section
<A HREF="#qualified-name">3.1.12</A>, are defined according to compilation units status.
From a compilation unit, the compiler issues several files described
on the following.<BR>
<BR>
<!--TOC subsection Outputs-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc21"><B><FONT SIZE=4>2.5.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Outputs</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

A <FONT COLOR=purple>FoCaLize</FONT> development contains both
``computational code'' (i.e. code performing operations that lead to
an effect, a result) and logical properties.<BR>
<BR>
<BR>
When compiled, two outputs are generated:
<UL><LI>
 The ``computational code'' is compiled into <FONT COLOR=purple>OCaml</FONT> source
 that can then be compiled with the <FONT COLOR=purple>OCaml</FONT> compiler to lead to an
 executable binary. In this pass, logical properties are discarded
 since they do not lead to executable code.
 <LI>Both the ``computational code'' and the logical properties are
 compiled into a <FONT COLOR=purple>Coq</FONT> model. This model can then be sent to the
 <FONT COLOR=purple>Coq</FONT> proof assistant who will verify the consistency of both the
 ``computational code'' and the logical properties (whose
 proofs<A NAME="@default2"></A> must be obviously provided) of the
 <FONT COLOR=purple>FoCaLize</FONT> development. This means that the <FONT COLOR=purple>Coq</FONT> code generated is
 not intended to be used to generate an <FONT COLOR=purple>OCaml</FONT> source code by
 automated extraction. As stated above, the executable generation
 is preferred using directly the generated <FONT COLOR=purple>OCaml</FONT> code. In this
 idea, <FONT COLOR=purple>Coq</FONT> acts as an assessor of the development instead of a
 code generator.<BR>
<BR>
More accurately, <FONT COLOR=purple>FoCaLize</FONT> first generates a pre-<FONT COLOR=purple>Coq</FONT> code, i.e. a
 file containing <FONT COLOR=purple>Coq</FONT> syntax plus ``holes'' in place of proofs
 written in the <FONT COLOR=purple>FoCaLize</FONT> Proof Language. This kind of files is
 suffixed by ``.zv'' instead of directly ``.v''. When sending this
 file to <FONT COLOR=purple>Zenon</FONT> these ``holes'' will be filled by effective
 <FONT COLOR=purple>Coq</FONT> code automatically generated by <FONT COLOR=purple>Zenon</FONT> (if it succeed in
 finding a proof), hence leading to a pure <FONT COLOR=purple>Coq</FONT> code file that can
 be compiled by <FONT COLOR=purple>Coq</FONT>.</UL>

In addition, several other outputs can be generated for documentation
or debug purposes. See the section <A HREF="#compiler-options">7</A> for
details.<BR>
<BR>
<!--TOC subsection Compiling a source-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc22"><B><FONT SIZE=4>2.5.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Compiling a source</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

Compiling a <FONT COLOR=purple>FoCaLize</FONT> program involves several steps that are
automatically handled by the <FONT COLOR=purple>focalizec</FONT> command. Using the command
line options, it is possible to tune the code generations steps as
described in <A HREF="#compiler-options">7</A>.
<OL type=1><LI>
 <B><FONT COLOR=purple>FoCaLize</FONT> source compilation</B>. This step takes the <FONT COLOR=purple>FoCaLize</FONT>
 source code and generates the <FONT COLOR=purple>OCaml</FONT> and/or ``pre-''<FONT COLOR=purple>Coq</FONT> code.
 You can disable the code generation for one of these languages
 (see page <A HREF="#compiler-options">7</A>), or both, in this case, no code is
 produced and you only get the <FONT COLOR=purple>FoCaLize</FONT> object code produced without
 anymore else output and the process ends at this point. If you
 disable one of the target languages, then you won't get any
 generated file for it, hence no need to address its related
 compilation process described below.<BR>
<BR>
Assuming you generate code for both <FONT COLOR=purple>OCaml</FONT> and <FONT COLOR=purple>Coq</FONT>&nbsp; you will get
 two generated files: <TT>source.ml</TT> (the <FONT COLOR=purple>OCaml</FONT> code) and
 <TT>source.zv</TT> (the ``pre-''<FONT COLOR=purple>Coq</FONT> code).<BR>
<BR>
<LI><B><FONT COLOR=purple>OCaml</FONT> code compilation</B>. This step takes the generated
 <FONT COLOR=purple>OCaml</FONT> code (it is an <FONT COLOR=purple>OCaml</FONT> source file) and compile it. This
 is done like any regular <FONT COLOR=purple>OCaml</FONT> compilation, the only difference
 is that the search path containing the <FONT COLOR=purple>FoCaLize</FONT> installation path
 and your own used extra <FONT COLOR=purple>FoCaLize</FONT> source files directories are
 automatically passed to the <FONT COLOR=purple>OCaml</FONT> compiler. Hence this steps
 acts like a manual invocation:
 <PRE>
ocamlc -c -I /usr/local/lib/focalize -I mylibs
   -I myotherlibs source.ml
    </PRE>This produces the <FONT COLOR=purple>OCaml</FONT> object file <TT>source.cmo</TT>. Note that
 you can also ask to use the <FONT COLOR=purple>OCaml</FONT> code in native mode, in this
 case the <TT>ocamlopt</TT> version of the <FONT COLOR=purple>OCaml</FONT> compiler is
 selected (see <FONT COLOR=purple>OCaml</FONT> reference manual for more information) and
 the object files are <TT>.cmx</TT> files instead of <TT>.cmo</TT>.
 ones.<BR>
<BR>
<LI><B>``Pre-''<FONT COLOR=purple>Coq</FONT> code compilation</B>. This step takes the
 generated <TT>.zv</TT> file and attempts to produce a real <FONT COLOR=purple>Coq</FONT>
 <TT>.v</TT> source file by replacing proofs written in <FONT COLOR=purple>FoCaLize</FONT> Proof
 Language by some effective <FONT COLOR=purple>Coq</FONT> proofs found by the <FONT COLOR=purple>Zenon</FONT>
 theorem prover. Note that if <FONT COLOR=purple>Zenon</FONT> fails in finding a proof, a
 hole will remain in the final <FONT COLOR=purple>Coq</FONT> <TT>.v</TT> file. Such a hole
 appears as the text ``<TT>TO_BE_DONE_MANUALLY.</TT>'' in place of
 the effective proof. In this case, <FONT COLOR=purple>Coq</FONT> will obviously fail
 in compiling the file, so the user must do the proof by hand or
 modify his original <FONT COLOR=purple>FoCaLize</FONT> source file to get a working proof.
 This step acts like a manual invocation:
 <DIV ALIGN=center>
 <TT>zvtov -new source.zv</TT>
 </DIV>
 For more about the <FONT COLOR=purple>Zenon</FONT> options, consult section
 <A HREF="#zenon_options">??</A>.<BR>
<BR>
<LI><B><FONT COLOR=purple>Coq</FONT> code compilation</B>. This step takes the generated
 <TT>.v</TT> code and compiles it with <FONT COLOR=purple>Coq</FONT>. This is done like any
 regular <FONT COLOR=purple>Coq</FONT> compilation. The only difference is that the search
 path containing the <FONT COLOR=purple>FoCaLize</FONT> installation path and your own used
 extra <FONT COLOR=purple>FoCaLize</FONT> source files directories are automatically passed
 to the <FONT COLOR=purple>Coq</FONT> compiler.
 <PRE>
coqc -I /usr/local/lib/focalize -I mylibs
  -I myotherlibs source.v
    </PRE>Once this step is done, you have the <FONT COLOR=purple>Coq</FONT> object files and you
 are sure that <FONT COLOR=purple>Coq</FONT> validated you program model, properties and
 proofs. The final ``assessor'' of the tool-chain accepted your
 program.
</OL>
<BR>
<A NAME="@default3"></A>
Once all separate files are compiled, to get an executable from the
<FONT COLOR=purple>OCaml</FONT> object files, you must link them together, providing the same
search path than above and the <TT>.cmo</TT> files corresponding to all
the generated <FONT COLOR=purple>OCaml</FONT> files from all your <FONT COLOR=purple>FoCaLize</FONT> <TT>.foc</TT>
files. You also need to add the <TT>.cmo</TT> files corresponding to the
modules of the standard library you use (currently, this must be done
by the user, next versions will automate this process).
 <PRE>
ocamlc -I mylibs -I myotherlibs
  install_dir/ml_builtins.cmo install_dir/basics.cmo
  install_dir/sets.cmo ...
  mylibs/src1.cmo mylibs/src2.cmo ...
  myotherlibs src3.cmo mylibs/src3.cmo ...
  source1.cmo source2.cmo ...
  -o exec_name
    </PRE>
<!--TOC chapter The core language-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#2de52d"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc23"><B><FONT SIZE=6>Chapter&nbsp;3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>The core language</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="corelangage"></A>
<BR>
<!--TOC section Lexical conventions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc24"><B><FONT SIZE=5>3.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Lexical conventions</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default4"></A><BR>
<!--TOC subsection Blanks-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc25"><B><FONT SIZE=4>3.1.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Blanks</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default5"></A>
The following characters are considered as blanks: space, newline,
horizontal tabulation, carriage return, line feed and form
feed. Blanks are ignored, but they separate adjacent identifiers,
literals and keywords that would otherwise be confused as one single
identifier, literal or keyword.<BR>
<BR>
<!--TOC subsection Comments-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc26"><B><FONT SIZE=4>3.1.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Comments</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default6"></A>
Comments (possibly spanning) on several lines are introduced by the
two characters <TT>(*</TT>, with no intervening blanks, and terminated by
the characters <TT>*)</TT>, with no intervening blanks. Comments are
treated as blanks. Comments can occur inside string or character
literals (provided the <TT>*</TT> character is escaped) and can be nested. They
are discarded during the compilation process. Example:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;S&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;m&nbsp;(x&nbsp;in&nbsp;Self)&nbsp;=&nbsp;(*&nbsp;Another&nbsp;discarded&nbsp;comment.&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>(*&nbsp;Another&nbsp;discarded&nbsp;comment&nbsp;at&nbsp;end&nbsp;of&nbsp;file.&nbsp;*)</TT></FONT></DIV><BR>
Comments spanning on a single line start by the two characters
<TT>--</TT> and end with the end-of-line character.
Example:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;S&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;m&nbsp;(x&nbsp;in&nbsp;Self)&nbsp;=&nbsp;--&nbsp;Another&nbsp;uni-line&nbsp;comment.</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
<!--TOC subsection Annotations-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc27"><B><FONT SIZE=4>3.1.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Annotations</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default7"></A>
<A NAME="@default8"></A>
<A NAME="annotation"></A>
<B>Annotations</B> are introduced by the three characters <TT>(**</TT>,
with no intervening blanks, and terminated by the two characters
<TT>*)</TT>, with no intervening blanks.
Annotations cannot occur inside string or character literals and
cannot be nested. They must precede the construct they document.
In particular, a <B>source file cannot end by an annotation</B>.<BR>
<BR>
Unlike comments, annotations are kept during the compilation process
and recorded in the compilation information (``<TT>.fo</TT>'' files). Annotations can
be processed later on by external tools that could analyze them to
produce a new <FONT COLOR=purple>FoCaLize</FONT> source code accordingly.
For instance, the <FONT COLOR=purple>FoCaLize</FONT> development environment provides the <FONT COLOR=purple>FoCaLizeDoc</FONT>
automatic production tool that uses annotations to automatically generate
documentation.
Several annotations can be put in sequence for the same construct. We call
such a sequence an <B>annotations block</B><A NAME="@default9"></A>.
Using embedded tags in annotations allows third-party tools to easily find
out annotations that are meaningful to them, and safely ignore others.
For more information, consult
<A HREF="#documentation-generation">??</A>.
Example:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;Documentation&nbsp;for&nbsp;species&nbsp;S.&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;S&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;m&nbsp;(x&nbsp;in&nbsp;Self)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;(**&nbsp;{@TEST}&nbsp;Annotation&nbsp;for&nbsp;the&nbsp;test&nbsp;generator.&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;(**&nbsp;{@MY_TAG_MAINTAIN}&nbsp;Annotation&nbsp;for&nbsp;maintainers.&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
<!--TOC subsection Identifiers-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc28"><B><FONT SIZE=4>3.1.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Identifiers</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default10"></A>
<BR>
<BR>
<BR>
<FONT COLOR=purple>FoCaLize</FONT> features a rich class of identifiers with sophisticated lexical
rules that provide fine distinction between the kind of notion a given
identifier can designate.<BR>
<BR>
<!--TOC subsubsection Introduction-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc29"><B>3.1.4.1</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Introduction</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
Sorting words to find out which kind of meaning they may have is a very common
conceptual categorization of names that we use when we write or read ordinary
English texts. We routinely distinguish between:
<DL COMPACT=compact><DT>0pt 5pt
<FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD>a word only made of lowercase characters, that is supposed to be an
 ordinary noun, such as "table", "ball", or a verb as in "is", or an
 adjective as in "green",
<DT><FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD>a word starting with an uppercase letter, that is supposed to be a name,
 maybe a family or christian name, as in "Kennedy" or "David", or a location
 name as in "London".
</DL>
We use this distinctive look of words as a useful hint to help understanding
phrases. For instance, we accept the phrase "my ball is green" as meaningful,
whereas "my Paris is green" is considered a nonsense. This is simply because
"ball" is a regular noun and "Paris" is a name. The word "ball" as the right
lexical classification in the phrase, but "Paris" has not. This is also clear
that you can replace "ball" by another ordinary noun and get something
meaningful: "my table is green"; the same nonsense arises as well if you
replace "Paris" by another name: "my Kennedy is green".<BR>
<BR>
Natural languages are far more complicated than computer languages, but
<FONT COLOR=purple>FoCaLize</FONT> uses the same kind of tricks: the ``look'' of words helps a lot to
understand what the words are designating and how they can be used.<BR>
<BR>
<!--TOC subsubsection Conceptual properties of names-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc30"><B>3.1.4.2</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Conceptual properties of names</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<FONT COLOR=purple>FoCaLize</FONT> distinguishes 4 concepts for each name:
<DL COMPACT=compact><DT>0pt 5pt
<FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD>the <EM>fixity</EM> assigns the place where an identifier must be written,
<DT><FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD>the <EM>precedence</EM> decides the order of operations when
 identifiers are combined together,
<DT><FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD>the <EM>categorisation</EM> fixes which concept the identifier designates.
<DT><FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD>the <EM>nature</EM> of a name can either be symbolic or alphanumeric.
</DL>
Those concepts are compositional, i.e. all these concepts are independent
from one another. Put is another way: for any fixity, precedence, category and nature,
there exist identifiers with this exact properties.<BR>
<BR>
We further explain those concepts below.<BR>
<BR>
<!--TOC subsubsection Fixity of identifiers-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc31"><B>3.1.4.3</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Fixity of identifiers</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default11"></A>
<A NAME="@default12"></A>
<A NAME="@default13"></A><BR>
The fixity of an identifier answers to the question ``where this identifier
must be written ?''.
<DL COMPACT=compact><DT>0pt 5pt
<FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD>a <EM>prefix</EM> is written <EM>before</EM> its argument, as <I>sin</I> in
 <I>sin</I>&nbsp; <I>x</I> or - in - <I>y</I>,
<DT><FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD>an <EM>infix</EM> is written <EM>between</EM> its arguments, as + in
 <I>x</I>&nbsp; +&nbsp; <I>y</I> or <I>mod</I> in <I>x</I>&nbsp; <I>mod</I> &nbsp;3.
<DT><FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD>a <EM>mixfix</EM> is written <EM>among</EM> its arguments, as
 <I>if</I>&nbsp; ... <I>then</I>&nbsp; ... <I>else</I>&nbsp; ... in
 <I>if</I> <I>c</I>&nbsp; <I>then</I>&nbsp; 1&nbsp; <I>else</I>&nbsp; 2 .
</DL>
In <FONT COLOR=purple>FoCaLize</FONT>, as in maths, ordinary identifiers are always prefix and binary operators are
always infix.<BR>
<BR>
<!--TOC subsubsection Precedence of identifiers-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc32"><B>3.1.4.4</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Precedence of identifiers</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default14"></A><BR>
The precedence rules out where implicit parentheses take place in a
complex combination of symbols. For instance, according to the usual mathematical
conventions:
<DL COMPACT=compact><DT>0pt 5pt
<FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD>1&nbsp; +&nbsp; 2&nbsp; *&nbsp; 3 means 1&nbsp; +&nbsp; (2&nbsp; *&nbsp; 3) hence 7,
 it does not mean (1&nbsp; +&nbsp; 2)&nbsp; *&nbsp; 3 which is 9,
<DT><FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD>2&nbsp; *&nbsp; 3&nbsp; <SUP><FONT SIZE=2>4</FONT></SUP>&nbsp; +&nbsp; 5 means
 (2&nbsp; *&nbsp; (3&nbsp; <SUP><FONT SIZE=2>4</FONT></SUP>))&nbsp; +&nbsp; 5 hence 167, it does not mean
 ((2&nbsp; *&nbsp; 3)&nbsp; <SUP><FONT SIZE=2>4</FONT></SUP>)&nbsp; +&nbsp; 5 which is 1301,
 nor 2&nbsp; *&nbsp; (3&nbsp; <SUP><FONT SIZE=2>(4&nbsp; +&nbsp; 5)</FONT></SUP>) which is 39366.
</DL>
In <FONT COLOR=purple>FoCaLize</FONT>, all the binary infix operators have the precedence they have in maths.<BR>
<BR>
<!--TOC subsubsection Categorization of identifiers-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc33"><B>3.1.4.5</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Categorization of identifiers</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<A NAME="@default15"></A>
The category of an identifier answers to the question ``is this identifier a
possible name for this kind of concept ?''.
In programming languages category are often strict, meaning that the category
exactly states which concept attaches to the identifier.<BR>
<BR>
For <FONT COLOR=purple>FoCaLize</FONT> these categories are
<DL COMPACT=compact><DT>0pt 5pt
<FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD><EM>lowercase</EM>: the identifier starts with a lowercase letter and
 designates a simple entity of the language. It may name some of
 the language expressions, a function name, a function parameter or bound
 variable name, a method name; a type name, or a record field label name.<BR>
<BR>
<DT><FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD><EM>uppercase</EM>: the identifier starts with an uppercase letter and
 designates a more complex entity in the language. It may name a sum type
 constructor name, a module name, a species or a collection name.
</DL>
We distinguish identifiers using their first ``meaningful'' character:
the first character that is not an underscore.<BR>
<BR>
<!--TOC subsubsection Nature of identifiers-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc34"><B>3.1.4.6</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Nature of identifiers</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default16"></A><BR>
In <FONT COLOR=purple>FoCaLize</FONT> identifiers are either:
<DL COMPACT=compact><DT>0pt 5pt
<FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD><EM>symbolic</EM>: the identifier contains characters that are not
 letters. <TT>+</TT>, <TT>:=</TT>, <TT>-&gt;</TT>, <TT>+float</TT> are symbolic<BR>
<BR>
<DT><FONT SIZE=4><FONT FACE=symbol>·</FONT></FONT><DD><EM>alphanumeric</EM>: the identifier contains letters, digits and
 underscores. <TT>x</TT>, <TT>_1</TT>, <TT>Some</TT>, <TT>Basic_object</TT> are
 alphanumeric.
</DL>
<!--TOC subsubsection Regular identifiers-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc35"><B>3.1.4.7</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Regular identifiers</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default17"></A><BR>
Regular lower case identifiers are used to designate the names of variables, functions,
and labels of records.<BR>
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="digit"><I><FONT COLOR=maroon>digit</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>0</FONT></TT> ... <TT><FONT COLOR=blue>9</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="lower"><I><FONT COLOR=maroon>lower</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>a</FONT></TT> ... <TT><FONT COLOR=blue>z</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="upper"><I><FONT COLOR=maroon>upper</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>A</FONT></TT> ... <TT><FONT COLOR=blue>Z</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="letter"><I><FONT COLOR=maroon>letter</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <A HREF="#lower"><I><FONT COLOR=maroon>lower</FONT></I></A> |  <A HREF="#upper"><I><FONT COLOR=maroon>upper</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="lident"><I><FONT COLOR=maroon>lident</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> ( <A HREF="#lower"><I><FONT COLOR=maroon>lower</FONT></I></A> |  <TT><FONT COLOR=blue>_</FONT></TT> )
 { <A HREF="#letter"><I><FONT COLOR=maroon>letter</FONT></I></A> |  <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> |  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP><FONT SIZE=2>*</FONT></SUP></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="uident"><I><FONT COLOR=maroon>uident</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <A HREF="#upper"><I><FONT COLOR=maroon>upper</FONT></I></A>
 &nbsp;{ <A HREF="#letter"><I><FONT COLOR=maroon>letter</FONT></I></A> |  <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> |  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP><FONT SIZE=2>*</FONT></SUP></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="ident"><I><FONT COLOR=maroon>ident</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> |  <A HREF="#uident"><I><FONT COLOR=maroon>uident</FONT></I></A></TD>
</TR></TABLE></DIV>
<BR>
<BR>
<BR>
A regular identifier is a sequence of letters, digits, and <TT>_</TT> (the
underscore character), starting with a letter or an underscore.<BR>
<BR>
The identifier is lowercase if its first letter is lowercase.<BR>
<BR>
The identifier is uppercase if its first letter is uppercase.<BR>
<BR>
Letters contain at least the 52 lowercase and uppercase
letters from the standard ASCII set. In an identifier, all characters
are meaningful.
Examples: <TT>foo</TT>, <TT>bar</TT>, <TT>_20</TT>,
<TT>___gee_42</TT>.<BR>
<BR>
<!--TOC subsubsection Infix/prefix operators-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc36"><B>3.1.4.8</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Infix/prefix operators</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default18"></A><A NAME="@default19"></A><BR>
<FONT COLOR=purple>FoCaLize</FONT> allows infix and prefix operators built from a
``starting operator character'' and followed by a sequence of
regular identifiers or operator characters. For example, all the
following are legal operators:
<TT>+</TT>, <TT>++</TT>, <TT>~+zero</TT>, <TT>=_mod_5</TT>.<BR>
<BR>
The position in which to use the operator (i.e. infix or prefix)
is determined by the position of the first operator character
according to the following table:
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=center NOWRAP>Prefix</TD>
<TD ALIGN=center NOWRAP>Infix</TD>
</TR>
<TR><TD ALIGN=center NOWRAP>` ~ ? $ ! #</TD>
<TD ALIGN=center NOWRAP>, + - * / % &amp; | : ; &lt; = &gt; @ ^ \</TD>
</TR></TABLE>
</DIV><BR>
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="prefix-char"><I><FONT COLOR=maroon>prefix-char</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>`</FONT></TT> |  <TT><FONT COLOR=blue>~</FONT></TT> |  <TT><FONT COLOR=blue>?</FONT></TT> |  <TT><FONT COLOR=blue>$</FONT></TT> | 
 <TT><FONT COLOR=blue>!</FONT></TT> |  <TT><FONT COLOR=blue>#</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="infix-char"><I><FONT COLOR=maroon>infix-char</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>,</FONT></TT> |  <TT><FONT COLOR=blue>+</FONT></TT> |  <TT><FONT COLOR=blue>-</FONT></TT> |  <TT><FONT COLOR=blue>*</FONT></TT> | 
 <TT><FONT COLOR=blue>/</FONT></TT> |  <TT><FONT COLOR=blue>%</FONT></TT> |  <TT><FONT COLOR=blue>&amp;</FONT></TT> |  <TT><FONT COLOR=blue>|</FONT></TT> | 
 <TT><FONT COLOR=blue>:</FONT></TT> |  <TT><FONT COLOR=blue>;</FONT></TT> |  <TT><FONT COLOR=blue>&lt;</FONT></TT> |  <TT><FONT COLOR=blue>=</FONT></TT> | 
 <TT><FONT COLOR=blue>&gt;</FONT></TT> |  <TT><FONT COLOR=blue>@</FONT></TT> |  <TT><FONT COLOR=blue>^</FONT></TT> | 
 <TT><FONT COLOR=blue>\</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="prefix-op"><I><FONT COLOR=maroon>prefix-op</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#prefix-char"><I><FONT COLOR=maroon>prefix-char</FONT></I></A> &nbsp;{<A HREF="#letter"><I><FONT COLOR=maroon>letter</FONT></I></A> |  <A HREF="#prefix-char"><I><FONT COLOR=maroon>prefix-char</FONT></I></A> | 
 <A HREF="#infix-char"><I><FONT COLOR=maroon>infix-char</FONT></I></A> |  <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> |  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP><FONT SIZE=2>*</FONT></SUP></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="infix-op"><I><FONT COLOR=maroon>infix-op</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#infix-char"><I><FONT COLOR=maroon>infix-char</FONT></I></A> &nbsp;{<A HREF="#letter"><I><FONT COLOR=maroon>letter</FONT></I></A> |  <A HREF="#prefix-char"><I><FONT COLOR=maroon>prefix-char</FONT></I></A> | 
 <A HREF="#infix-char"><I><FONT COLOR=maroon>infix-char</FONT></I></A> |  <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> |  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP><FONT SIZE=2>*</FONT></SUP></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="operator"><I><FONT COLOR=maroon>operator</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#infix-op"><I><FONT COLOR=maroon>infix-op</FONT></I></A> |  <A HREF="#prefix-op"><I><FONT COLOR=maroon>prefix-op</FONT></I></A></TD>
</TR></TABLE></DIV><BR>
Hence, in the above examples, <TT>+</TT>, <TT>++</TT> and <TT>=_mod_5</TT> will be
infix operators and <TT>~+zero</TT> will be a prefix one.<BR>
<BR>
<!--TOC subsubsection Defining an infix operator-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc37"><B>3.1.4.9</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Defining an infix operator</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default20"></A>
<A NAME="@default21"></A>
<A NAME="@default22"></A><BR>
The notion of infix/prefix operator does not mean that <FONT COLOR=purple>FoCaLize</FONT> defines all
these operators: it means that the programmer may freely define and use them
as ordinary prefix/infix operators instead of only writing prefix function
names and regular function application. For instance, if you do not like the
<FONT COLOR=purple>FoCaLize</FONT> predefined <CODE>^</CODE> operator to concatenate strings, you can define your
own infix synonym for <CODE>^</CODE>, say tt ++, using:<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV>
Then you can use the <TT>++</TT> operator in the usual way
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV><BR>
As shown in the example, at definition-time, the syntax requires
the operator to be embraced by parentheses. More precisely, you must
enclose the operator between <B>spaces</B> and parentheses.
You must write <TT>( + )</TT> with spaces, not simply <TT>(+)</TT> (which leads
to a syntax error anyway).<BR>
<BR>
<!--TOC subsubsection Prefix form notation-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc38"><B>3.1.4.10</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Prefix form notation</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default23"></A>
<A NAME="@default24"></A><BR>
The notation <TT>( op )</TT> is named the <EM>prefix form notation</EM> for
operator <TT>op</TT>.<BR>
<BR>
Since you can only define prefix identifiers in <FONT COLOR=purple>FoCaLize</FONT>, you must use the
prefix form notation to define an infix or prefix operator.<BR>
<BR>
When a prefix or infix operator has been defined, it is still possible
to use it as a regular identifier using its prefix form notation.
For instance, you can use the prefix form of operator <TT>++</TT>
to apply it in a prefix position as a simple regular function (with a
strange name admittedly!):<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV><BR>
<B>Attention</B>: a common error while defining an operator is to forget
the spaces around the operator. This is particularly confusing, if you
type the <TT>*</TT> operator without spaces around the operator: you
write the lexical entity <TT>(*)</TT> which is the beginning (or the end)
of a comment!<BR>
<BR>
The <FONT COLOR=purple>FoCaLize</FONT> notion of symbolic identifiers go largely beyond simple
infix operators. Symbolic identifiers let you assign sophisticated names
to your functions and operators.
For instance, instead of creating a function to check if integer <TT>x</TT>
is equal to the predecessor of integer <TT>y</TT>, as in
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>...&nbsp;if&nbsp;is_eq_to_predecessor&nbsp;(5,&nbsp;7)&nbsp;...&nbsp;;</TT></FONT></DIV>
it is possible to directly define
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>...&nbsp;if&nbsp;5&nbsp;=pred&nbsp;7&nbsp;...&nbsp;;</TT></FONT></DIV><BR>
<B>Attention</B> : since a comma can start an infix symbol, be careful
when using commas to add a space after each comma to prevent confusion.
In particular, when using commas to separate tuple components, always type
a space after each comma. For instance, if you write <TT>(1,n)</TT>
then the lexical analyser finds only two words: the integer <TT>1</TT> as
desired, then the infix operator <TT>,n</TT> which is certainly not the
intended meaning. Hence, following usual typography rules, always type a
space after a comma (unless you have define a special operator starting
by a comma).<BR>
<BR>
<B>Rule of thumb</B>: The prefix version of symbolic identifiers is obtained
by enclosing the symbol between spaces and parens.<BR>
<BR>
<!--TOC subsection Extended identifiers-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc39"><B><FONT SIZE=4>3.1.5</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Extended identifiers</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="extended-identifiers"></A>
<A NAME="@default25"></A><BR>
Moreover, <FONT COLOR=purple>FoCaLize</FONT> has special forms of identifiers to allow using
spaces inside or to extend the notion of operator identifiers.
<UL><LI>
 <B>Delimited alphanumerical identifiers</B>.
 <A NAME="@default26"></A>
 They start by two characters <TT>`</TT> (backquote) and end by two
 characters <TT>'</TT> (quote). In addition to usual alpha-numerical
 characters, the delimited identifiers can have spaces. For example:
 <TT>``equal is reflexive''</TT>, <TT>``fermat conjecture''</TT>.
 <LI><B>Delimited symbolic identifiers</B>.
 They are delimited by the same delimitor characters and contain
 symbolic characters.
</UL>
The first meaningful character at the beginning of a delimited
ident/symbol is used to find its associated token.<BR>
<BR>
<!--TOC subsection Species and collection names-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc40"><B><FONT SIZE=4>3.1.6</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Species and collection names</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default27"></A> Species, collection
names and collection parameters are uppercase identifiers.<BR>
<BR>
<!--TOC subsection Integer literals-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc41"><B><FONT SIZE=4>3.1.7</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Integer literals</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="integer literals"></A>
<A NAME="octal"></A>
<A NAME="hexadecimal"></A>
<A NAME="binary"></A><BR>
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="binary-digit"><I><FONT COLOR=maroon>binary-digit</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>0</FONT></TT> |  <TT><FONT COLOR=blue>1</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="octal-digit"><I><FONT COLOR=maroon>octal-digit</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>0</FONT></TT> ... <TT><FONT COLOR=blue>7</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="hexadecimal-digit"><I><FONT COLOR=maroon>hexadecimal-digit</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>0</FONT></TT> ... <TT><FONT COLOR=blue>9</FONT></TT>
 |  <TT><FONT COLOR=blue>A</FONT></TT> ... <TT><FONT COLOR=blue>F</FONT></TT>
 |  <TT><FONT COLOR=blue>a</FONT></TT> ... <TT><FONT COLOR=blue>f</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="sign"><I><FONT COLOR=maroon>sign</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>+</FONT></TT> |  <TT><FONT COLOR=blue>-</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-binary-literal"><I><FONT COLOR=maroon>unsigned-binary-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>0</FONT></TT> ( <TT><FONT COLOR=blue>b</FONT></TT> |  <TT><FONT COLOR=blue>B</FONT></TT> )
 <A HREF="#binary-digit"><I><FONT COLOR=maroon>binary-digit</FONT></I></A> &nbsp;{ <A HREF="#binary-digit"><I><FONT COLOR=maroon>binary-digit</FONT></I></A> |  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP><FONT SIZE=2>*</FONT></SUP></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-octal-literal"><I><FONT COLOR=maroon>unsigned-octal-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>0</FONT></TT> ( <TT><FONT COLOR=blue>o</FONT></TT> |  <TT><FONT COLOR=blue>O</FONT></TT> )
 <A HREF="#octal-digit"><I><FONT COLOR=maroon>octal-digit</FONT></I></A> &nbsp;{ <A HREF="#octal-digit"><I><FONT COLOR=maroon>octal-digit</FONT></I></A> |  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP><FONT SIZE=2>*</FONT></SUP></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-decimal-literal"><I><FONT COLOR=maroon>unsigned-decimal-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> &nbsp;{ <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> |  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP><FONT SIZE=2>*</FONT></SUP></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-hexadecimal-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>0</FONT></TT> ( <TT><FONT COLOR=blue>x</FONT></TT> |  <TT><FONT COLOR=blue>X</FONT></TT> )
 <A HREF="#hexadecimal-digit"><I><FONT COLOR=maroon>hexadecimal-digit</FONT></I></A> &nbsp;{ <A HREF="#hexadecimal-digit"><I><FONT COLOR=maroon>hexadecimal-digit</FONT></I></A> |  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP><FONT SIZE=2>*</FONT></SUP></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-integer-literal"><I><FONT COLOR=maroon>unsigned-integer-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#unsigned-binary-literal"><I><FONT COLOR=maroon>unsigned-binary-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#unsigned-octal-literal"><I><FONT COLOR=maroon>unsigned-octal-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#unsigned-decimal-literal"><I><FONT COLOR=maroon>unsigned-decimal-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#unsigned-hexadecimal-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="integer-literal"><I><FONT COLOR=maroon>integer-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 [<A HREF="#sign"><I><FONT COLOR=maroon>sign</FONT></I></A>] &nbsp;<A HREF="#unsigned-integer-literal"><I><FONT COLOR=maroon>unsigned-integer-literal</FONT></I></A></TD>
</TR></TABLE></DIV><BR>
An integer literal is a sequence of one or more digits, optionally
preceded by a minus or plus sign and/or a base prefix. By default,
i.e. without a base prefix, integers are in decimal. For instance:
<TT>0</TT>, <TT>-42</TT>, <TT>+36</TT>. <FONT COLOR=purple>FoCaLize</FONT> syntax allows to also specify
integers in other bases by preceding the digits by the following
prefixes:
<UL><LI>
 <B>Binary</B>: base 2. Prefix is <TT>0b</TT> or <TT>0B</TT>.
 Digits are [0-1].
 <LI><B>Octal</B>: base 8. Prefix is <TT>0o</TT> or <TT>00</TT>.
 Digits are [0-7].
 <LI><B>Hexadecimal</B>: base 16. Prefix is <TT>0x</TT> or <TT>0X</TT>.
 Digits are [0-9] [A-F] [a-f].
</UL>
Here are various examples of integers in various bases:
<TT>-0x1Ff</TT>, <TT>0B01001</TT>, <TT>+Oo347</TT>.<BR>
<BR>
<!--TOC subsection String literals-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc42"><B><FONT SIZE=4>3.1.8</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>String literals</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="string literal"></A><BR>
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="string-literal"><I><FONT COLOR=maroon>string-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>"</FONT></TT>
 { <A HREF="#plain-char"><I><FONT COLOR=maroon>plain-char</FONT></I></A> |  <TT><FONT COLOR=blue>\</FONT></TT> <A HREF="#char-escape"><I><FONT COLOR=maroon>char-escape</FONT></I></A> }<SUP><FONT SIZE=2>*</FONT></SUP>
 <TT><FONT COLOR=blue>"</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="plain-char"><I><FONT COLOR=maroon>plain-char</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <EM>any printable character except backslash
 (\) and double quote (<TT>"</TT>)</EM></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="char-escape"><I><FONT COLOR=maroon>char-escape</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>b</FONT></TT> |  <TT><FONT COLOR=blue>n</FONT></TT> |  <TT><FONT COLOR=blue>r</FONT></TT> |  <TT><FONT COLOR=blue>t</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP>  |  <TT><FONT COLOR=blue>"</FONT></TT> |  <TT><FONT COLOR=blue>'</FONT></TT> |  <TT><FONT COLOR=blue>*</FONT></TT>
 |  <TT><FONT COLOR=blue>\</FONT></TT> |  <TT><FONT COLOR=blue>`</FONT></TT> |  <TT><FONT COLOR=blue>-</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> |  <TT><FONT COLOR=blue>)</FONT></TT> |  <TT><FONT COLOR=blue>[</FONT></TT> |  <TT><FONT COLOR=blue>]</FONT></TT>
 |  <TT><FONT COLOR=blue>{</FONT></TT> |  <TT><FONT COLOR=blue>}</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> &nbsp;<A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> &nbsp;<A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#hexadecimal-digit"><I><FONT COLOR=maroon>hexadecimal-digit</FONT></I></A> &nbsp;<A HREF="#hexadecimal-digit"><I><FONT COLOR=maroon>hexadecimal-digit</FONT></I></A></TD>
</TR></TABLE></DIV><BR>
String literals are sequences of any characters delimited by <TT>"</TT>
(double quote) characters (<EM>ipso facto</EM> with no intervening
<TT>"</TT>).
Escape sequences (meta code to insert characters that can't appear
simply in a string) available in string literals are summarised in the
table below:<BR>
<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD VALIGN=top ALIGN=center NOWRAP>Sequence</TD>
<TD VALIGN=top ALIGN=center NOWRAP>Character</TD>
<TD VALIGN=top ALIGN=left>Comment</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\b</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP>\008</TD>
<TD VALIGN=top ALIGN=left>Backspace.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\n</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP>\010</TD>
<TD VALIGN=top ALIGN=left>Line feed.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\r</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP>\013</TD>
<TD VALIGN=top ALIGN=left>Carriage return.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\t</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP>\009</TD>
<TD VALIGN=top ALIGN=left>Tabulation.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=left>Space character.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\"</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP><TT>"</TT></TD>
<TD VALIGN=top ALIGN=left>Double quote.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\'</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP><TT>'</TT></TD>
<TD VALIGN=top ALIGN=left>Single quote.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>*</TD>
<TD VALIGN=top ALIGN=left>Since comments cannot appear inside
 strings, to insert one of the
 sequence ``(*'', ``*)'', ``{*'',
 ``*}'', ``[*'', or ``*]'',
 use this escape sequence
 combined with the six following
 ones.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\(</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP>(</TD>
<TD VALIGN=top ALIGN=left>6*See comment above for</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\)</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP>)</TD>
<TD VALIGN=top ALIGN=left>&nbsp;</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\[</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP>[</TD>
<TD VALIGN=top ALIGN=left>&nbsp;</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\]</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP>]</TD>
<TD VALIGN=top ALIGN=left>&nbsp;</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\{</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP>{</TD>
<TD VALIGN=top ALIGN=left>&nbsp;</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\}</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP>}</TD>
<TD VALIGN=top ALIGN=left>&nbsp;</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\\</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP>\</TD>
<TD VALIGN=top ALIGN=left>Backslash character.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\`</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP>`</TD>
<TD VALIGN=top ALIGN=left>Backquote character.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\-</FONT></TT></TD>
<TD VALIGN=top ALIGN=center NOWRAP><TT>-</TT></TD>
<TD VALIGN=top ALIGN=left>Minus (dash) character. As for multi-line
 comments, uni-line comments can't appear in
 strings. Hence, to insert the sequence
 ``<TT>--</TT>'' use this escape
 sequence twice.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\</FONT></TT><EM>digit digit digit</EM></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=left>The character whose ASCII code in
 <B>decimal</B> is given by the 3 digits
 following the \. This
 sequence is valid for all
 ASCII codes.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT><FONT COLOR="#ff0000">\0x</FONT></TT><EM> hex hex</EM></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=left>The character whose ASCII code in
 <B>hexadecimal</B> is given by the 2
 characters following the \. This
 sequence is valid for all
 ASCII codes.</TD>
</TR></TABLE><BR>
<!--TOC subsection Character literals-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc43"><B><FONT SIZE=4>3.1.9</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Character literals</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="character literals"></A><BR>
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="character-literal"><I><FONT COLOR=maroon>character-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>'</FONT></TT>
 ( <A HREF="#plain-char"><I><FONT COLOR=maroon>plain-char</FONT></I></A> |  <TT><FONT COLOR=blue>\</FONT></TT> <A HREF="#char-escape"><I><FONT COLOR=maroon>char-escape</FONT></I></A> )
 <TT><FONT COLOR=blue>'</FONT></TT></TD>
</TR></TABLE></DIV><BR>
Characters literals are composed of one character enclosed between two
``<TT>'</TT>'' (quote) characters. Example: <TT>'a'</TT>, <TT>'?'</TT>.
Escape sequences (meta code to insert characters that can't appear
simply in a character literal) must also be enclosed by
quotes. Available escape sequences are summarised in the table above
(see section&nbsp;<A HREF="#string literal">3.1.8</A>).<BR>
<BR>
<!--TOC subsection Floating-point number literals-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc44"><B><FONT SIZE=4>3.1.10</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Floating-point number literals</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="decimal-literal"><I><FONT COLOR=maroon>decimal-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 [<A HREF="#sign"><I><FONT COLOR=maroon>sign</FONT></I></A>] &nbsp;<A HREF="#unsigned-decimal-literal"><I><FONT COLOR=maroon>unsigned-decimal-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="hexadecimal-literal"><I><FONT COLOR=maroon>hexadecimal-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 [<A HREF="#sign"><I><FONT COLOR=maroon>sign</FONT></I></A>] &nbsp;<A HREF="#unsigned-hexadecimal-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="scientific-notation"><I><FONT COLOR=maroon>scientific-notation</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>e</FONT></TT> |  <TT><FONT COLOR=blue>E</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-decimal-float-literal"><I><FONT COLOR=maroon>unsigned-decimal-float-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#unsigned-decimal-literal"><I><FONT COLOR=maroon>unsigned-decimal-literal</FONT></I></A>
 &nbsp;[<TT><FONT COLOR=blue>.</FONT></TT> {<A HREF="#unsigned-decimal-literal"><I><FONT COLOR=maroon>unsigned-decimal-literal</FONT></I></A>}<SUP><FONT SIZE=2>*</FONT></SUP>] 
 &nbsp;[<A HREF="#scientific-notation"><I><FONT COLOR=maroon>scientific-notation</FONT></I></A> &nbsp;<A HREF="#decimal-literal"><I><FONT COLOR=maroon>decimal-literal</FONT></I></A>]</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-hexadecimal-float-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-float-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#unsigned-hexadecimal-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-literal</FONT></I></A>
 &nbsp;[<TT><FONT COLOR=blue>.</FONT></TT> {<A HREF="#unsigned-hexadecimal-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-literal</FONT></I></A>}<SUP><FONT SIZE=2>*</FONT></SUP>] 
 &nbsp;[<A HREF="#scientific-notation"><I><FONT COLOR=maroon>scientific-notation</FONT></I></A> &nbsp;<A HREF="#hexadecimal-literal"><I><FONT COLOR=maroon>hexadecimal-literal</FONT></I></A>]</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-float-literal"><I><FONT COLOR=maroon>unsigned-float-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#unsigned-decimal-float-literal"><I><FONT COLOR=maroon>unsigned-decimal-float-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#unsigned-hexadecimal-float-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-float-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="float-literal"><I><FONT COLOR=maroon>float-literal</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> [<A HREF="#sign"><I><FONT COLOR=maroon>sign</FONT></I></A>] &nbsp;<A HREF="#unsigned-float-literal"><I><FONT COLOR=maroon>unsigned-float-literal</FONT></I></A></TD>
</TR></TABLE></DIV><BR>
Floating-point numbers literals are made of an optional sign ('+' or
'-') followed by a non-empty sequence of digits followed by a dot
('.') followed by a possibly empty sequence of digits and finally an
optional scientific notation ('e' or 'E' followed an optional sign
then by a non-empty sequence of digits. <FONT COLOR=purple>FoCaLize</FONT> allows floats to be
written in decimal or in hexadecimal. In the first case, digits are
[0-9]. Example: <TT>0.</TT>, <TT>-0.1</TT>, <TT>1.e-10</TT>, <TT>+5E7</TT>.
In the second case, they are [0-9 a-f A-F] and the number must be
prefixed by ``0x'' or ``0X''. Example <TT>0xF2.E4</TT>, <TT>0X4.3A</TT>,
<TT>Ox5a.a3eef</TT>, <TT>Ox5a.a3e-ef</TT>.<BR>
<BR>
<!--TOC subsection Proof step bullets-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc45"><B><FONT SIZE=4>3.1.11</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Proof step bullets</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default28"></A>
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="proof-step-bullet"><I><FONT COLOR=maroon>proof-step-bullet</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>&lt;</FONT></TT> {<A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A>}<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>&gt;</FONT></TT>
 &nbsp;{ <A HREF="#letter"><I><FONT COLOR=maroon>letter</FONT></I></A> |  <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> }<SUP><FONT SIZE=2>+</FONT></SUP></TD>
</TR></TABLE></DIV>
<BR>
A proof step bullet is a non-negative non-signed integer literal
(i.e. a non empty sequence of [0-9] characters) delimited by the
characters <TT>&lt;</TT> and <TT>&gt;</TT>, followed by a non-empty sequence of
alphanumeric characters (i.e. [A-Z a-z 0-9]).
The first part of the bullet (i.e. the integer literal) stands for the
depth of the bullet and the second part stands for its name. Example:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prove&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&lt;2&gt;1&nbsp;prove&nbsp;...&nbsp;by&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&lt;2&gt;9&nbsp;qed&nbsp;by&nbsp;step&nbsp;&lt;2&gt;1&nbsp;property&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&lt;1&gt;2&nbsp;conclude</TT></FONT></DIV><BR>
<!--TOC subsection Name qualification-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc46"><B><FONT SIZE=4>3.1.12</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Name qualification</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="qualified-name"></A>
<A NAME="@default29"></A> <A NAME="@default30"></A>
<A NAME="@default31"></A><BR>
Name qualification is done according to the
compilation unit status.<BR>
<BR>
As precisely described in section (<A HREF="#toplevel-def">??</A>),
toplevel-definitions include species, collections, type definitions
(and their constitutive elements like constructors, record fields),
toplevel-theorems and toplevel-functions. Any toplevel-definition (thus
outside species and collections) is visible all along the compilation unit
after its apparition.
If a toplevel-definition is required by another compilation unit, you can
reference it by <B>qualifying</B> its name, i.e. making explicit the
compilation unit's name before the definition's name using the '#'
character as delimiter. Examples:
<UL><LI>
 <TT>basics#string</TT> stands for the type definition of
 <TT>string</TT> coming from the source file ``basics.fcl''.
 <LI><TT>basics#Basic_object</TT> stands for the species
 <TT>Basic_object</TT> defined in the source file ``basics.fcl''.
 <LI><TT>db#My_db_coll!create</TT> stands for the method
 <TT>create</TT> of a collection <TT>My_db_coll</TT> hosted in the
 source file ``db.fcl''.
</UL>
<A NAME="@default32"></A>
The qualification can be omitted by using the <TT>open</TT> directive
that loads the interface of the argument compilation unit and make it
directly visible in the scope of the current compilation unit. For
instance:<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV>
can be transformed with no explicit qualification into:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;S&nbsp;inherits&nbsp;Basic_object&nbsp;=&nbsp;...&nbsp;end&nbsp;;;</TT></FONT></DIV><BR>
After an <TT>open</TT> directive, the definitions of loaded (object files
of) compilation units are added in head of the current scope and mask
existing definitions wearing the same names. For example, in
the following program: <DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;Basic_object&nbsp;=&nbsp;end&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>open&nbsp;"basics";;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;S&nbsp;inherits&nbsp;Basic_object&nbsp;=&nbsp;...&nbsp;end&nbsp;;;</TT></FONT></DIV>
the species <TT>S</TT> inherits from the last <TT>Basic_object</TT> in the
scope, that is the one loaded by the <TT>open</TT> directive and not from
the one defined at the beginning of the program. It is still possible
to recover the first definition by using the ``empty'' qualification
<TT>#Basic_object</TT> in the definition of <TT>S</TT>:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;Basic_object&nbsp;=&nbsp;end&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>open&nbsp;"basics";;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;S&nbsp;inherits&nbsp;#Basic_object&nbsp;=&nbsp;...&nbsp;end&nbsp;;;</TT></FONT></DIV><BR>
The qualification starting by a '#' character without compilation
unit name before stands for ``the definition at toplevel of the
current compilation unit''.<BR>
<BR>
<!--TOC subsection Reserved keywords-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc47"><B><FONT SIZE=4>3.1.13</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Reserved keywords</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

The identifiers below are reserved keywords that cannot be employed
otherwise:
<PRE>
   alias all and as assume assumed
   begin by
   caml collection conclude coq coq_require
   definition
   else end ex external
   false function
   hypothesis
   if in inherits internal implements is
   let lexicographic local logical
   match measure
   not notation
   of on open or order
   proof prop property prove
   qed
   rec representation
   Self signature species step structural
   termination then theorem true type
   use
   with
</PRE>

<!--TOC section Language constructs and syntax-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc48"><B><FONT SIZE=5>3.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Language constructs and syntax</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<!--TOC subsection Types-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc49"><B><FONT SIZE=4>3.2.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Types</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

Before dealing with expressions and in general, constructs that allow to
compute, let us first examine data-type definitions since, to emit its
result, an algorithm must manipulate data that are more or less specific to
the algorithm. Hence we must know about type definitions to define data that
have a convenient shape and carry the necessary information to model the
problem at hand.<BR>
<BR>
Type definitions allow to build new types or more complex types by
combining previously existing types. They always appear as
toplevel-definitions, in other words, outside species and
collections. Hence a type definition is visible in the whole
compilation unit (and also in other units by using the <TT>open</TT>
directive or by qualifying the type name as described in section
<A HREF="#qualified-name">3.1.12</A>).<BR>
<BR>
<!--TOC subsubsection Type constructors-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc50"><B>3.2.1.1</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Type constructors</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

A <B>type constructor</B> is, roughly speaking, a type name.<BR>
<BR>
<FONT COLOR=purple>FoCaLize</FONT> provides the basic built-in
types (constructors):
<UL><LI>
 <TT>int</TT> for signed machine integers,
 <LI><TT>bool</TT> for boolean values (<TT>true</TT> and <TT>false</TT> that
 are hardwired in the syntax or <TT>True</TT> and <TT>False</TT> that are
 defined in ``basics.fcl''),
 <LI><TT>float</TT> for floating point numbers,
 <LI><TT>unit</TT> for the trivial type whose only value is <TT>()</TT>,
 <LI><TT>char</TT> for characters literals,
 <LI><TT>string</TT> for strings literals.
</UL>
New type constructors are introduced by
<B>type definitions</B>.
Types constructors can be parametrised by <B>type expressions</B>
separated by commas and between parentheses.<BR>
<BR>
<!--TOC subsubsection Type expressions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc51"><B>3.2.1.2</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Type expressions</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default33"></A>
<A NAME="@default34"></A>
Type definitions require <B>type expressions</B> to build more complex
data-types.
<BR>

<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#uident"><I><FONT COLOR=maroon>uident</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>Self</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>'</FONT></TT><A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#uident"><I><FONT COLOR=maroon>uident</FONT></I></A> <TT><FONT COLOR=blue>(</FONT></TT> &nbsp;{<A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>)</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A> <TT><FONT COLOR=blue>-&gt;</FONT></TT> &nbsp;<A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> {<A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>}(<TT><FONT COLOR=blue>*</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>)</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A> <TT><FONT COLOR=blue>)</FONT></TT></TD>
</TR></TABLE></DIV>
<BR>
<BR>
<BR>
A type expression can be a type constructor.<BR>
<BR>
A type expression can denote the representation of a species or a
collection by using their name, thus a capitalized name. The special
case of <TT>Self</TT> denotes the representation of the current
species. Hence, obviously <TT>Self</TT> is only bound in the scope of a
species.<BR>
<BR>
Type expressions representing function types are written using the
arrow notation (<TT>-&gt;</TT>) in which the type of the argument of the
function is the left type expression and its return type is the right
one. As usual in functional languages, a function with several (say
<I>n</I>) arguments is considered as a function with <B>1</B> argument
returning a function with <I>n</I>-1 arguments. Hence,
<TT>int -&gt; int -&gt; bool</TT> is the type of a function taking 2 integers
and returning a boolean.<BR>
<BR>
<A NAME="@default35"></A>
<FONT COLOR=purple>FoCaLize</FONT> provides native tuples (generalisation of pairs). The type of
a tuple is the type of each of its components separated by a *
character and surrounded by parentheses. Hence,
<TT>(int * bool * string) </TT> is the type of triplets whose first
component is an integer, second component is a boolean and third
component is a string.<BR>
<BR>
Finally, type expressions can be written between parentheses without
changing their semantics.<BR>
<BR>
<!--TOC subsubsection Type definitions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc52"><B>3.2.1.3</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Type definitions</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default36"></A>
<A NAME="type-definition"></A>
A type <B>definition</B> introduces a new type
 constructor (the name of the type), which becomes available to build
new type expressions. Hence, defining a type is the
way to give a name to a new type structure. <FONT COLOR=purple>FoCaLize</FONT> proposes 3 kinds
of type definitions: aliases, sum types and record types.<BR>
<BR>
<BR>
<B>Aliases</B><BR>
<BR>
<A NAME="@default37"></A><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
Aliases provide a way to create type abbreviations. It is not handy to
manipulate large <B>type expressions</B> like for instance, a tuple of
5 components: <TT>(int * int * int * int * int)</TT>. Moreover, several
kind of information can be represented by such a
tuple. For instance, x, y, z 3D-coordinates and temperature and
pressure. For another example, year, month, day, hours, minutes. In
these two cases, the manipulated type expression is the same and
the two uses cannot be easily differentiated. Type aliases allows to
give a name to a
(complex) type expression, for sake of readability or to shorten the
code. Example:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>type&nbsp;date&nbsp;=&nbsp;<B>alias</B>&nbsp;(int&nbsp;*&nbsp;int&nbsp;*&nbsp;int&nbsp;*&nbsp;int&nbsp;*&nbsp;int)&nbsp;;;</TT></FONT></DIV><BR>
<BR>

<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="alias-type-def"><I><FONT COLOR=maroon>alias-type-def</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>type</FONT></TT> <A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A> <TT><FONT COLOR=blue>=&nbsp;alias</FONT></TT> &nbsp;<A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A></TD>
</TR></TABLE></DIV>
<BR>
<BR>
<BR>
In the remaining of the development, the type names
<TT>experiment_conditions</TT> and <TT>date</TT> will be known to be
tuples of 5 integers and will be compatible with any other type being
also a tuple of 5 integers. This especially means that a <EM>type alias
does not create a really ``new'' type, it only gives a name to a type
expression and this name is type-compatible with any occurrence of the
type expression it is bound to</EM>. Obviously, it is possible to use
aliases with and in any type expression or type definition.<BR>
<BR>
<BR>
<B>Sum types</B>
<A NAME="@default38"></A>
<A NAME="@default39"></A><BR>
<BR>
Sum types provide the way to create new <B>values</B> that
 belong to the same <B>type</B>. Like <TT>1</TT> or <TT>42</TT> are
<B>values</B> of <B>type</B> <TT>int</TT>, one may want to have <TT>Red</TT>,
<TT>Blue</TT> and <TT>Green</TT> as the <B>only</B> values of a new type
called <TT>color</TT>. The <B>only</B> means that the created type <TT>color</TT>
is inhabited only by these 3 values. To define
such a type, we itemize its value names (that are always capitalized
identifiers) by preceeding them by a <TT><FONT COLOR="#ff0000">|</FONT></TT> character :<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Red</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Blue</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Green</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT></DIV>
Note that the first <TT><FONT COLOR="#ff0000">|</FONT></TT> character is required: it is not a
separator. This especially means that when writing a sum type
definition on a single line, the first <TT><FONT COLOR="#ff0000">|</FONT></TT> must be written:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV><BR>
<A NAME="@default40"></A>
<B>Values</B> of a sum type are built from the
<B>value constructors</B>, i.e. from the names enumerated in the
definition (that must not be confused with the <B>type constructor</B>
which is the name of the type. For, instance,
<TT>Red</TT> is a <B>value</B> of the type constructor <TT>color</TT>.<BR>
<BR>
Value constructors of sum
types can be <B>parametrised</B> by a type expressions, corresponding
values being obtained by applying the value constructor to values of
the parameters types. For instance, let's define the type of playing
cards as king, queen, jack and simply numbered cards:<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;King</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Queen</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Jack</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Numbered&nbsp;(int)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT></DIV> Hence, the <TT>Numbered</TT> constructor ``carries'' the integer value
written on the card. Some values of type <TT>card</TT> are: <TT>King</TT>,
<TT>(Numbered 4)</TT>, <TT>(Numbered 42)</TT>. The <TT>Numbered</TT>
constructor has <B>parameter</B>.<BR>
<BR>
<A NAME="@default41"></A>
<BR>
An important attention must be taken for constructors having
``several'' arguments. <FONT COLOR=purple>FoCaLize</FONT>provides 2 different
(``type-incompatible'') ways to make a value constructor carrying
several values.
<UL><LI>
Either the constructor has <B>1</B> argument that is a tuple,
 i.e. a type expression involving the <TT>*</TT> constructor.<BR>
<BR>
The corresponding type definition for such a type would be:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Cstr&nbsp;(bool&nbsp;*&nbsp;int&nbsp;*&nbsp;string)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT></DIV><BR>
<BR>
<LI>Or the constructor has <B>several</B> arguments, i.e. several
 type expressions separated by a comma.
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Cstr2&nbsp;(bool,&nbsp;int,&nbsp;string)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT></DIV>
means that the constructor <TT>Cstr2</TT> has <B>3 arguments</B>.
</UL>
<BR>
This especially important since when matching on such value
constructors, confusing the argument<B>s</B> of <TT>Cstr2</TT> with
one and unique tuple with 3 components will result in a type error.
Below are shown several pieces of source code with valid/invalid mixes
between these concepts.
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>type&nbsp;t&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Cstr&nbsp;(bool&nbsp;*&nbsp;int&nbsp;*&nbsp;string)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;fct_t1&nbsp;(x)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;match&nbsp;x&nbsp;with</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;Cstr&nbsp;(a,&nbsp;b,&nbsp;c)&nbsp;-&gt;&nbsp;()</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT></DIV>
leads to
<PRE>
Error: Types
(basics#bool * basics#int * basics#string),  '_a,  '_b and
(basics#bool * basics#int * basics#string) are not compatible.
</PRE>because <TT>Cstr</TT> expects 1 tuple argument and not 3
arguments.<BR>
<BR>
<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;match&nbsp;x&nbsp;with</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;Cstr&nbsp;(x)&nbsp;-&gt;&nbsp;x</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT></DIV>
is accepted since the type <TT>mytuple</TT> aliases a 3
components tuples and <TT>Cstr</TT> is really parametrised by 1 argument
that is a 3 components tuple.<BR>
<BR>
<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Cstr2&nbsp;(bool,&nbsp;int,&nbsp;string)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;fct_t3&nbsp;(x)&nbsp;in&nbsp;mytuple&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;match&nbsp;x&nbsp;with</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;Cstr2&nbsp;(y)&nbsp;-&gt;&nbsp;y............</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT></DIV>
leads to
<PRE>
Error: Types basics#bool and
basics#bool,  basics#int,  basics#string are not compatible.
</PRE>because <TT>Cstr2</TT> expects 3 arguments (types separated by comma) and
<TT>mytuple</TT> aliases a tuple.<BR>
<BR>
<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;match&nbsp;x&nbsp;with</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;Cstr2&nbsp;(a,&nbsp;b,&nbsp;c)&nbsp;-&gt;&nbsp;(a,&nbsp;b,&nbsp;c)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT></DIV>
is accepted since we rebuild explicitly a tuple from the 3
arguments of <TT>Cstr2</TT>.<BR>
<BR>
<BR>
Any type expression, even recursive, can be used as a parameter of
value contructors<A NAME="@default42"></A>.
For instance, the type of lists of boolean × integer pairs
could be defined like:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Empty</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Cons&nbsp;((bool&nbsp;*&nbsp;int)&nbsp;*&nbsp;b_i_list)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT></DIV> From this type definition, a value of type <TT>b_i_list</TT> is
either empty (constructor <TT>Empty</TT>) or has a head (the first
component of the <TT>Cons</TT> constructor) and a trailing list (the
second component of this constructor): <TT>Cons ((false, 2), (Cons
 ((true, 1), Empty)))</TT>. The length of this list is 2 and its
elements are <TT>(false, 2)</TT> followed by <TT>(true, 1)</TT>.<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>

<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="type-params"><I><FONT COLOR=maroon>type-params</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>(</FONT></TT> {<TT><FONT COLOR=blue>'</FONT></TT> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>)</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="type-args"><I><FONT COLOR=maroon>type-args</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>(</FONT></TT> {<A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>)</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="constructor"><I><FONT COLOR=maroon>constructor</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>|</FONT></TT> <A HREF="#uident"><I><FONT COLOR=maroon>uident</FONT></I></A> &nbsp;[<A HREF="#type-args"><I><FONT COLOR=maroon>type-args</FONT></I></A>]</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="sum-type-def"><I><FONT COLOR=maroon>sum-type-def</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>type</FONT></TT> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> &nbsp;[<A HREF="#type-params"><I><FONT COLOR=maroon>type-params</FONT></I></A>] <TT><FONT COLOR=blue>=</FONT></TT>
 &nbsp;{<A HREF="#constructor"><I><FONT COLOR=maroon>constructor</FONT></I></A>}<SUP><FONT SIZE=2>+</FONT></SUP></TD>
</TR></TABLE></DIV>
<BR>
<BR>
<BR>
<BR>
<B>Record types</B>
<A NAME="record-type-definition"></A>
<A NAME="@default43"></A><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
Record types provide a way to aggregate data of various types, a bit like
tuples, but naming the components of the group, instead of
differentiating them by their position like in tuples. A record is
a sequence of names and types between braces. For example:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;x&nbsp;:&nbsp;int&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;y&nbsp;:&nbsp;int&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;z&nbsp;:&nbsp;int&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;temperature&nbsp;:&nbsp;int&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;pressure&nbsp;:&nbsp;int</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>}&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>type&nbsp;identity&nbsp;=&nbsp;{</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;name&nbsp;:&nbsp;string&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;birth&nbsp;:&nbsp;int&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;living&nbsp;:&nbsp;bool</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>}&nbsp;;;</TT></FONT></DIV><BR>
<BR>

<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="field"><I><FONT COLOR=maroon>field</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> <TT><FONT COLOR=blue>=</FONT></TT> &nbsp;<A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A> <TT><FONT COLOR=blue>;</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="record-type-def"><I><FONT COLOR=maroon>record-type-def</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>type</FONT></TT> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> &nbsp;<A HREF="#type-params"><I><FONT COLOR=maroon>type-params</FONT></I></A> <TT><FONT COLOR=blue>=</FONT></TT>
 <TT><FONT COLOR=blue>{</FONT></TT> &nbsp;{<A HREF="#field"><I><FONT COLOR=maroon>field</FONT></I></A>}<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>}</FONT></TT></TD>
</TR></TABLE></DIV><BR>
<BR>
<BR>
<BR>
To create a <B>value</B> of a record type, a value of the related
type must be provided for each field of the record.
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV>
Like in tuples, records can mix types of fields.<BR>
<BR>
<BR>
<B>Parameterised type definitions</B><BR>
<BR>
It is possible, <EM>at toplevel</EM>, to <B>parametrise a type
 definition</B>, i.e. to create a type with a <B>type variable</B> that
can be instantiated by any type expression. A type variable is written
as an identifier preceded by a <TT>'</TT> (quote) character.<BR>
<BR>
For instance, the type
definition of generic (polymorphic) lists may be defined by:<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Empty</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Cons&nbsp;('a,&nbsp;&nbsp;list&nbsp;('a))</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT></DIV><BR>
The value
constructor <TT>Cons</TT> carries a value of type ``unknown'' (of type
``variable'') and the tail of the list, i.e. a value of type
<TT>list</TT> with its parameter instantiated by the same type
variable. This explicitly says that all the elements of such a list
have the same type. It is now possible to use the <TT>list</TT> type in
type <B>expressions</B> by providing a type <B>expression</B> as
argument of the <B>type constructor</B> <TT>list</TT>. For instance,
<TT>list (int)</TT> is the type of lists containing integers,
<TT>list (list (char))</TT> is the type of lists containing lists of
characters.<BR>
<BR>
Parametrised record types can also be introduced, as in the following example:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;first&nbsp;:&nbsp;'a&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;second&nbsp;:&nbsp;'b</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>}&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>type&nbsp;int_bool_pair&nbsp;=&nbsp;pair&nbsp;(int,&nbsp;bool)&nbsp;;;</TT></FONT></DIV><BR>
<!--TOC subsection Type-checking-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc53"><B><FONT SIZE=4>3.2.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Type-checking</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

The type-checking process is roughly similar to ML
type-checking. Polymorphic types are allowed at top-level. However,
methods are not allowed to be polymorphic. This means that their types
cannot contain variables. But they may contain collection parameters
as stated in section <A HREF="#collection-parameter">4.2.1</A>.<BR>
<BR>
A type <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> is an <B>instanciation</B> of a type <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> if <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> is obtained
by replacing some type variables of <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> by a ``more defined type
expression''.<BR>
<BR>
For example, '<I>a</I> <FONT FACE=symbol>®</FONT> <TT> <I>int</I> </TT> <FONT FACE=symbol>®</FONT> <TT> <I>bool</I> </TT>
is an instanciation of
'<I>a</I> <FONT FACE=symbol>®</FONT> <TT> <I>int</I> </TT> <FONT FACE=symbol>®</FONT> '<I>c</I> since we replaced
the variable '<I>c</I> by the type <TT>bool</TT>.<BR>
<BR>
<BR>
Two types <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> are said <B>compatible</B><A NAME="@default44"></A>
if they have a <B>common</B> instanciation. For the intuition, this
means that replacing variables in <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> and replacing variables in
<I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> leads to a same type.<BR>
<BR>
For example, we consider the two following types:
<UL><LI>
 <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> = '<I>a</I> <FONT FACE=symbol>®</FONT> <TT> <I>int</I> </TT> <FONT FACE=symbol>®</FONT> '<I>b</I> <FONT FACE=symbol>®</FONT> '<I>c</I>
 <LI><I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> = <TT><I>bool</I> </TT> <FONT FACE=symbol>®</FONT> '<I>d</I> <FONT FACE=symbol>®</FONT> '<I>d</I> <FONT FACE=symbol>®</FONT> '<I>e</I>
</UL>
In <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> we replace: '<I>a</I> by <TT>bool</TT>, and we leave the others
variables unchanged. We get the new type
<I>t</I>'<SUB><FONT SIZE=2>1</FONT></SUB> = <TT><I>bool</I> </TT> <FONT FACE=symbol>®</FONT> <TT> <I>int</I> </TT> <FONT FACE=symbol>®</FONT> '<I>b</I> <FONT FACE=symbol>®</FONT> '<I>c</I>.<BR>
<BR>
In <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB>, we replace '<I>d</I> by <TT>int</TT>, '<I>e</I> by '<I>c</I>. We get the new
type
<I>t</I>'<SUB><FONT SIZE=2>2</FONT></SUB> = <TT><I>bool</I> </TT> <FONT FACE=symbol>®</FONT> <TT> <I>int</I> </TT> <FONT FACE=symbol>®</FONT> '<I>b</I> <FONT FACE=symbol>®</FONT> '<I>c</I>.<BR>
<BR>
The type <I>t</I>'<SUB><FONT SIZE=2>1</FONT></SUB> is an instanciation of <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>. The type <I>t</I>'<SUB><FONT SIZE=2>2</FONT></SUB> is an
instanciation of <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB>. The two types <I>t</I>'<SUB><FONT SIZE=2>1</FONT></SUB> and <I>t</I>'<SUB><FONT SIZE=2>2</FONT></SUB> are
structurally the same. Hence <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> are <B>compatible</B>.<BR>
<BR>
As it can be seen, an instanciation does not need to change all the
type variables. Only part (or none) of them may be sufficient.<BR>
<BR>
<BR>
For the sake of intuitive view, compatibility is a generalisation of
the notion of types being ``equal''. The most trivial instanciation
appears when the two types do not have any type variables. Hence in
this case, for them to be compatible is to be structurally equal. We
find in this case, the common view of ``being a good type'' when for
instance providing an argument to a function according to the type of
the expected argument in the function's prototype.<BR>
<BR>
<!--TOC subsection Representations-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc54"><B><FONT SIZE=4>3.2.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Representations</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<A NAME="representation-type"></A>
As further explained (see section <A HREF="#rep-is-method">4.1.2</A>) the
representation is a method of a species that describes the internal
data structure that the species manages. Hence, it is a kind of <B>type definition</B>, more accurately an <B>alias type
 definition</B>. This means that a representation does not introduce a
new type, it only ``assigns'' to the representation a <B>type
 expression</B> defining the type of the manipulated entities of the
species. Moreover, like for any other methods (c.f. section
<A HREF="#no-polymorphism-for-methods">4.1.2</A>), <EM>the representation must not
 be a polymorphic type</EM>. Thus its definition cannot
contain type variables (but may contain collection parameter
names). Defining a species'representation is simply done by adding the
<TT>representation</TT> method:
 <DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;IntPair&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;representation&nbsp;=&nbsp;(int&nbsp;*&nbsp;int)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
Recall that the type introduced by the method <TT>representation</TT> is
denoted by <TT>Self</TT> within the species.<BR>
<BR>
<BR>

<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="representation"><I><FONT COLOR=maroon>representation</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>representation&nbsp;=</FONT></TT> <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A></TD>
</TR></TABLE></DIV><BR>
<BR>
<BR>
<BR>
<!--TOC subsection Expressions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc55"><B><FONT SIZE=4>3.2.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Expressions</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="expressions"></A>
<A NAME="@default45"></A> Expressions are constructs of the language that are
evaluated into a <B>value</B> of a certain <B>type</B>. Hence values and
types are not at the same level. Types serve to classify values into
categories. Although proofs may contain expressions, we describe them
in the <A HREF="#making-proofs">5</A>. Indeed proofs are not expressions, they do
not lead to <FONT COLOR=purple>FoCaLize</FONT> values thus live at another level.<BR>
<BR>
<BR>

<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="qualified-uident"><I><FONT COLOR=maroon>qualified-uident</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 [[<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>] <TT><FONT COLOR=blue>#</FONT></TT>] &nbsp;<A HREF="#uident"><I><FONT COLOR=maroon>uident</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="qualified-lident"><I><FONT COLOR=maroon>qualified-lident</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 [[<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>] <TT><FONT COLOR=blue>#</FONT></TT>] &nbsp;<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="lident-or-operator"><I><FONT COLOR=maroon>lident-or-operator</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> |  <TT><FONT COLOR=blue>(</FONT></TT> <A HREF="#operator"><I><FONT COLOR=maroon>operator</FONT></I></A> <TT><FONT COLOR=blue>)</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="method-ident"><I><FONT COLOR=maroon>method-ident</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 [<TT><FONT COLOR=blue>Self</FONT></TT>] <TT><FONT COLOR=blue>!</FONT></TT> <A HREF="#lident-or-operator"><I><FONT COLOR=maroon>lident-or-operator</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> [<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> <TT><FONT COLOR=blue>#</FONT></TT>] &nbsp;<A HREF="#uident"><I><FONT COLOR=maroon>uident</FONT></I></A> <TT><FONT COLOR=blue>!</FONT></TT> &nbsp;<A HREF="#lident-or-operator"><I><FONT COLOR=maroon>lident-or-operator</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="exp"><I><FONT COLOR=maroon>exp</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#integer-literal"><I><FONT COLOR=maroon>integer-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#string-literal"><I><FONT COLOR=maroon>string-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#character-literal"><I><FONT COLOR=maroon>character-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#float-literal"><I><FONT COLOR=maroon>float-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>true</FONT></TT> |  <TT><FONT COLOR=blue>false</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#qualified-uident"><I><FONT COLOR=maroon>qualified-uident</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#method-ident"><I><FONT COLOR=maroon>method-ident</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>let&nbsp;rec</FONT></TT> {<A HREF="#let-binding"><I><FONT COLOR=maroon>let-binding</FONT></I></A>}(<TT><FONT COLOR=blue>and</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP>
 <TT><FONT COLOR=blue>in</FONT></TT> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>if</FONT></TT> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>then</FONT></TT> &nbsp;<A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>else</FONT></TT> &nbsp;<A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>match</FONT></TT> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>with</FONT></TT> &nbsp;{<A HREF="#match-binding"><I><FONT COLOR=maroon>match-binding</FONT></I></A>}<SUP><FONT SIZE=2>+</FONT></SUP></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>(</FONT></TT> &nbsp;{<A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>)</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#prefix-op"><I><FONT COLOR=maroon>prefix-op</FONT></I></A> &nbsp;<A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> &nbsp;<A HREF="#infix-op"><I><FONT COLOR=maroon>infix-op</FONT></I></A> &nbsp;<A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>{</FONT></TT> {<A HREF="#record-field-value"><I><FONT COLOR=maroon>record-field-value</FONT></I></A>}(<TT><FONT COLOR=blue>;</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>}</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>{</FONT></TT> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>with</FONT></TT>
 &nbsp;{<A HREF="#record-field-value"><I><FONT COLOR=maroon>record-field-value</FONT></I></A>}(<TT><FONT COLOR=blue>;</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>}</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>.</FONT></TT> &nbsp;<A HREF="#qualified-lident"><I><FONT COLOR=maroon>qualified-lident</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>)</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="record-field-value"><I><FONT COLOR=maroon>record-field-value</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#qualified-lident"><I><FONT COLOR=maroon>qualified-lident</FONT></I></A> <TT><FONT COLOR=blue>=</FONT></TT> &nbsp;<A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="let-binding"><I><FONT COLOR=maroon>let-binding</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> &nbsp;[<TT><FONT COLOR=blue>in</FONT></TT> <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>] <TT><FONT COLOR=blue>=</FONT></TT> &nbsp;<A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> <TT><FONT COLOR=blue>(</FONT></TT>
 &nbsp;{<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> <TT><FONT COLOR=blue>in</FONT></TT> &nbsp;<A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP>
 <TT><FONT COLOR=blue>)</FONT></TT>
 <TT><FONT COLOR=blue>=</FONT></TT> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="match-binding"><I><FONT COLOR=maroon>match-binding</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>|</FONT></TT> <A HREF="#pattern"><I><FONT COLOR=maroon>pattern</FONT></I></A> <TT><FONT COLOR=blue>-&gt;</FONT></TT> &nbsp;<A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="pattern"><I><FONT COLOR=maroon>pattern</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#integer-literal"><I><FONT COLOR=maroon>integer-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#string-literal"><I><FONT COLOR=maroon>string-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#character-literal"><I><FONT COLOR=maroon>character-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#float-literal"><I><FONT COLOR=maroon>float-literal</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>true</FONT></TT> |  <TT><FONT COLOR=blue>false</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#qualified-uident"><I><FONT COLOR=maroon>qualified-uident</FONT></I></A>
 &nbsp;[<TT><FONT COLOR=blue>(</FONT></TT> {<A HREF="#pattern"><I><FONT COLOR=maroon>pattern</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>)</FONT></TT>]</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>_</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>{</FONT></TT> {<A HREF="#record-field-pattern"><I><FONT COLOR=maroon>record-field-pattern</FONT></I></A>}(<TT><FONT COLOR=blue>;</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>}</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> {<A HREF="#pattern"><I><FONT COLOR=maroon>pattern</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>)</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> <A HREF="#pattern"><I><FONT COLOR=maroon>pattern</FONT></I></A> <TT><FONT COLOR=blue>)</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="record-field-pattern"><I><FONT COLOR=maroon>record-field-pattern</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#qualified-lident"><I><FONT COLOR=maroon>qualified-lident</FONT></I></A> <TT><FONT COLOR=blue>=</FONT></TT> &nbsp;<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A></TD>
</TR></TABLE></DIV><BR>
<BR>
<BR>
<BR>
<!--TOC subsubsection Literal expressions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc56"><B>3.2.4.1</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Literal expressions</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default46"></A> <A NAME="@default47"></A><BR>
The literal
expressions of type integer, string, character,
float and boolean) are evaluated into the constant represented by the
literal. The expression <TT>25</TT> denotes the value 25 of type
<TT>int</TT>.<BR>
<BR>
<!--TOC subsubsection Sum type value constructor expressions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc57"><B>3.2.4.2</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Sum type value constructor expressions</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default48"></A>
We presented in section <A HREF="#type-definition">3.2.1.3</A> the way to define sum
types. We saw that <B>values</B> of such a <B>type</B> are built using
its <B>value</B> constructors.<BR>
<BR>
Hence, for <B>value</B> constructors with no argument, the constructor itself
is an expression that gets evaluated in a value wearing the same name.<BR>
<BR>
For <B>value</B> constructors with parameters, a value is created by
evaluating an expression applying the constructor to as many expressions as
the constructor's arity. Obviously, sub-expressions used as arguments of
the constructor must we well-typed according to the type of the
constructor. The resulting value is denoted by the
name of the constructor followed by the tuple of values given as
arguments. For instance, with the following type definition:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;A</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;B&nbsp;(int&nbsp;*&nbsp;bool)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT></DIV>
the expression <TT>A</TT> is evaluated into <I>A</I>, the expression
<TT>B ((2 + 3), true)</TT> is evaluated into the value <I>B</I> (5, <I>true</I>).<BR>
<BR>
<!--TOC subsubsection Identifier expressions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc58"><B>3.2.4.3</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Identifier expressions</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="identifier-expressions"></A>
<A NAME="@default49"></A>
<A NAME="@default50"></A><BR>
An identifier expression is either a basic identifier, an extended
identifier or a qualified identifier (see section
<A HREF="#qualified-name">3.1.12</A>), which denotes the value of this identifier in
the scope of the expression. The identifier is said to be <B>bound</B>
to this value.<BR>
<BR>
The value bound to an identifier can be of any type. A value having a
functional type, that is a <B>functional
 value</B><A NAME="functional-value"></A><A NAME="@default51"></A> also called a
<B>closure</B>, is created by a function definition. Such a value,
obtained by the evaluation of the body of the function, is slightly
different from other ones since it embeds both the code of the
function (i.e. a kind of evaluation of its body expression) and its
environment (i.e. bindings between identifiers occuring in the body of
the function and their value in the definition scope). This closure
will be kept untouched until it appears in a functional application
expression as described further in <A HREF="#function-application">3.2.4.8</A>.<BR>
<BR>
There are several possibilities to bind an identifier. Definitions
introduce a basic or extended identifier and <B>binds</B> it to the
value of the expression stated in the definition. There are three
ways to introduce and directly bind an identifier:
<UL><LI>
 By a <TT>let-in</TT> construct,
 <LI>By a toplevel-definition (<TT>let</TT> or <TT>theorem</TT>),
 <LI>by a method definition (<TT>let</TT>),
 </UL>
 Each of these three cases will
be described in their related section.<BR>
<BR>
There are two ways to introduce basic identifiers as parameters:
<UL><LI>
in a function definition
 <LI>by a pattern inside a <TT>match-with</TT> construct
</UL>
Then the binding of the parameter is differed until the application of
the function or the pattern-matching mechanism.
 Each of these two cases will
be described in their related section.<BR>
<BR>
Suppose that an expression <I>exp</I> contains several occurrences of an
identifier <TT>my_var</TT>. Assume that, in the scope of <I>exp</I>, <TT>my_var</TT> is bound to a <B>value</B> <I>v</I>, then each occurrence of <TT>my_var</TT> in <I>exp</I> is substituted by <I>v</I> during the evaluation of
<I>exp</I>. This is basically the principle of the so-called <B>eager</B> or
<B>call by-value</B> evaluation regime.<BR>
<BR>
<BR>
<B>Identifier resolution</B>
Remember that identifiers forms differ depending on the syntactic
class of entity they refer to, capitalized identifiers being used for
species and collections. To evaluate an identifier expression, the
<FONT COLOR=purple>FoCaLize</FONT> compiler tries to find its definition from the current scoping
context. <A NAME="@default52"></A> <A NAME="@default53"></A>
<A NAME="@default54"></A> It searches for the closest definition with this name,
starting by the parameters present in the current definition
(i.e. formal parameters in a function and in a <TT>match-with</TT>
construction and <TT>let-in</TT> bound identifiers). If no identifier
definition with this name is found, the search goes on among the
methods of the current species. If a method is found with this name,
it will be retained, otherwise the identifier is looked in the
preceding toplevel-definitions of the current compilation unit.
<A NAME="identifier-scoping-and-open"></A>
<A NAME="@default55"></A> If no suitable definition is found, then the
ones imported by the <TT>open</TT> directives are examined to find one
with the searched name. Finally if no definition is found, the
identifier is <B>reported unbound</B> by an error message.<BR>
<BR>
Note that an
<TT>open</TT> directive may arise anywhere at toplevel in the source
code. Hence, the order of search between the current file's
toplevel-definitions and the imported ones by <TT>open</TT> is not really
separated: the name resolver looks for the most recent definition
considering that the toplevel-definitions and the imported ones are
ordered according to the apparition of the effective definitions in
the file themselves and the imported ones. In other words, if a
toplevel-definition exists for an entity <TT>foo</TT>, if later an
<TT>open</TT> directive imports another <TT>foo</TT>, then this last one
will be the retained one.<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<B>Identifier qualification</B><BR>
<BR>
Identifiers can manually be disambiguated in term of compilation unit
location using the sharp (#) notation as explained in section
<A HREF="#qualified-name">3.1.12</A>.<BR>
<BR>
<BR>
<A NAME="@default56"></A> As further presented in section
<A HREF="#method-qualification">4.2.1</A>, species methods identifiers are made
explicit using the ``!'' notation. The notation <TT>Spe!meth</TT> stands
for ``the method <TT>meth</TT> of the species <TT>Spe</TT>''. By extension,
<TT>!meth</TT> stands for the method <TT>meth</TT> of the current
species. It is possible to explicit <TT>Self</TT> in the naming scheme
using <TT>Self!meth</TT>. This is useful when a more recently defined
identifier hides a method of the species at hand: <DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;m&nbsp;(x&nbsp;in&nbsp;...)&nbsp;=&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;n&nbsp;(y&nbsp;in&nbsp;...)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;m&nbsp;=&nbsp;...&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Want&nbsp;to&nbsp;call&nbsp;the&nbsp;*method*&nbsp;"m"&nbsp;with&nbsp;argument&nbsp;"m"&nbsp;!!!&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;!m&nbsp;(n)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
Hence, the name resolution mechanism allows to omit the ``!'' but
making it explicit can help for conflicts resolution. Moreover, when
invoking species parameters' methods, the name resolution never
searches among methods of collection parameters, hence the explicit ``!''
notation is required.<BR>
<BR>
As the grammar shows, name qualification by compilation unit and
hosting species can be freely mixed. We can build identifiers like
<TT>my_file#My_species!my_method</TT> to refer to the method
<TT>my_method</TT> hosted in the species <TT>My_species</TT> located in
the <FONT COLOR=purple>FoCaLize</FONT> source file ``my_file.fcl''. These disambiguation
methods are indeed orthogonal.<BR>
<BR>
<BR>
<B>Extended identifier expressions</B><BR>
<BR>
Finally, infix/postfix operators can be used as regular
identifiers. Usually, an operator is syntactically used according to
it prefix or infix nature. For instance, the binary <TT>+</TT> operator
is used between its arguments as in <TT>x + 4</TT>, the unary operator <TT>~</TT> is used before its argument as in <TT>~x</TT>. <FONT COLOR=purple>FoCaLize</FONT> allows to
refer to those operators as regular identifiers (for instance as function
parameters).
This allows to use operators as any other identifiers, and
<UL><LI>
 using them as regular function (i.e. in functional position),
 <LI>bind them as arguments of functions,
 <LI>use them as regular identifiers in expressions, for example to
 pass them as arguments of other functions.
</UL>
To get an identifier from an operator, its symbol
(c.f. <A HREF="#extended-identifiers">3.1.5</A>) must be delimited by spaces and enclosed
into matching parentheses.
For example: <TT>( + )</TT> is the regular identifier corresponding to the
infix symbol <TT>+</TT>.<BR>
<BR>
Note that spaces around the operator symbol are mandatory and part of the
syntax. If spaces are omitted, the parens get their usual meaning and the
interpretation can be completely different.
A specially puzzling error is to write <TT>(*)</TT> to mean <TT>( * )</TT>:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;(*)&nbsp;(x,&nbsp;y)&nbsp;=&nbsp;...</TT></FONT></DIV>
Now, <TT>(*</TT> is evidently parsed as the beginning of comment,
leading to a syntax error or any other cryptic error long after the faulty
<TT>(*</TT> occurrence.
Conversely <TT>*)</TT> is always considered as an end of comment by the lexical
analyzer.<BR>
<BR>
<!--TOC subsubsection <TT>let-in</TT> expression-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc59"><B>3.2.4.4</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><TT>let-in</TT> expression</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default57"></A>
<A NAME="@default58"></A>
<TT>let-in</TT> expression binds an identifier to a value to
evaluate a trailing expression (the ``<TT>in-part</TT>'' of the ``<TT>let-in</TT>''
or ``body'') where this ident may appear. During the evaluation of the
trailing expression, any occurrence of the bound identifier is ``replaced''
by the value bound to this identifier. For instance:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV>
 binds <TT>x</TT> to the evaluation of the <B>expression</B> <TT>(3+2)</TT>
(i.e. the integer <B>value</B> 5) and then, the evaluation of the
trailing expression returns the tuple <B>value</B> (5, 5). From the
syntax, it is clear that <TT>let-in</TT> constructs can be nested. For
instance, <DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;y&nbsp;=&nbsp;(x,&nbsp;x)&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;z&nbsp;=&nbsp;true&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;(y,&nbsp;z,&nbsp;y,&nbsp;z)</TT></FONT></DIV>
returns the value ((5, 5), <I>true</I>, (5, 5), <I>true</I>) of type
<TT>((int * int) * bool * (int * int) * bool)</TT>.<BR>
<BR>
<BR>
<A NAME="@default59"></A>
Note that the notion of ``binding an identifier to a value'' is
essentially different from the
notion of assignment in imperative languages. In such languages (like
C, Java, Pascal,...) a variable is first <EM>declared</EM>, then a value is
<EM>assigned</EM> to the variable. It is thus possible to assign a variable
several times to different values. For example in C:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>{</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;int&nbsp;i&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;i&nbsp;=&nbsp;10&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;while&nbsp;(i&nbsp;&gt;&nbsp;0)&nbsp;i&nbsp;=&nbsp;i--&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>}</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT></DIV>
The variable <TT>i</TT> is declared, then assigned the initial value
10, then the <TT>while</TT> loop makes it decreasing by successive
assignments.<BR>
<BR>
In a <TT>let-in</TT> binding construct, an identifier is given a value
once and for all: it is impossible to change its value, once it
has been bound.
Each new definition, binding an already bound identifier will just hide the
old definition. For instance:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;y&nbsp;=&nbsp;(x,&nbsp;x)&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;true&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;z&nbsp;=&nbsp;(x,&nbsp;x)&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;(y,&nbsp;x,&nbsp;y,&nbsp;x)</TT></FONT></DIV>
leads to the value ((5, 5), <I>true</I>, (5, 5), <I>true</I>)
of type <TT>((int * int) * bool * (int * int) * bool)</TT>. Clearly the
first value bound to <TT>x</TT> holds until <TT>x</TT>
is bound again: 5 is used to define <TT>y</TT> but not to define
<TT>z</TT>, since the value of <TT>x</TT> is then the boolean <I>true</I>.<BR>
<BR>
<BR>
<BR>
<BR>
The <TT>let-in</TT> construct serves to bind an identifier to a value of
any type. As a consequence, it can also bind an identifier to a
functional value. This lead to the natural way to define <B>functions</B>. For instance:<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>f&nbsp;(6,&nbsp;7)</TT></FONT></DIV><BR>
The <B>let</B> construct binds <TT>f</TT> to a function which has 2
parameters <TT>x</TT> and <TT>y</TT>, and the body of <TT>f</TT> is the
addition of these 2 parameters. Then the body of the <TT>let-in</TT>
construct applies <TT>f</TT> to 2 effective arguments <TT>6</TT> and <TT>7</TT> (we obviously expect the result of this <EM>application</EM> to be
13). (Function application is explained below in
<A HREF="#application-expression">??</A>).<BR>
<BR>
It is possible to provide a type constraint to precise the type of the
return value of a function, or the type of the <TT>let</TT>-bound
variable or parameters:<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>f&nbsp;(6,&nbsp;7)</TT></FONT></DIV>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>f&nbsp;(6,&nbsp;7)</TT></FONT></DIV>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>(a,&nbsp;a)</TT></FONT></DIV><BR>
<BR>
It is possible to define several identifiers at the same time separating
each definition by the keyword <TT>and</TT>.
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;f&nbsp;=&nbsp;exp_1</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>and&nbsp;g&nbsp;&nbsp;=&nbsp;exp_2</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>and&nbsp;h&nbsp;=&nbsp;exp_3&nbsp;in&nbsp;exp;</TT></FONT></DIV><BR>
All the definitions are separately evaluated ``in parallel''. As a
consequence, the identifiers introduced by a <TT>let ... and </TT>
cannot be used in the right members of this construction (in the <TT>exp_i</TT>). Do not confuse this construct with nested <TT>let-in</TT> as
the followig one, where <TT>exp_2</TT> can contain <TT>f</TT> and <TT>exp_3</TT> can contain <TT>f</TT> and <TT>g</TT>.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;g&nbsp;&nbsp;=&nbsp;exp_2&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;h&nbsp;=&nbsp;exp_3&nbsp;in&nbsp;exp</TT></FONT></DIV><BR>
Mutually recursive functions need to know each other because their
bodies call these other functions and their definition require a
non-nested evaluation of each function. In this case, the keyword
<TT>let</TT> must be followed by the keyword <TT>rec</TT>.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;rec&nbsp;even&nbsp;(x)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;if&nbsp;x&nbsp;=&nbsp;0&nbsp;then&nbsp;true&nbsp;else&nbsp;odd&nbsp;(x&nbsp;-&nbsp;1)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>and&nbsp;odd&nbsp;(y)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;if&nbsp;y&nbsp;=&nbsp;0&nbsp;then&nbsp;false&nbsp;else&nbsp;even&nbsp;(y&nbsp;-&nbsp;1)&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT></DIV><FONT SIZE=4><BR>
<B>Warning:</B></FONT> in the current version of <FONT COLOR=purple>FoCaLize</FONT> mutually
recursive functions cannot be compiled into <FONT COLOR=purple>Coq</FONT> code. Only
<FONT COLOR=purple>OCaml</FONT> code generation is available. Moreover, for <FONT COLOR=purple>Coq</FONT>, recursive
functions imply termination proofs. This last point will be covered in
the section <A HREF="#recursive-function">6</A> especially dedicated to
recursive (non-mutually) function definitions.<BR>
<BR>
<!--TOC subsubsection <TT>logical let</TT>-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc60"><B>3.2.4.5</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><TT>logical let</TT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

As seen above, the <TT>let-in</TT> construct is used to bind
computational expressions. Logical expressions described further
in <A HREF="#properties-theorems-proofs">3.2.7</A> are first order logic
formulae. We would sometimes like to have parametrised logical
expressions, i.e. a kind of functions returning a logical proposition.<BR>
<BR>
Suppose we want, for a certain value of <I>x</I> and <I>y</I>, to use the fact
``<I>x</I>&lt;<I>y</I> and <I>x</I>+<I>y</I> &lt; 10'' (which holds or not) to build more complex
logical expressions.<BR>
<BR>
A first attempt is to use the logical expression <I>x</I> &lt; <I>y</I> /\
<I>x</I>+<I>y</I>&lt;10 where <I>x</I> and <I>y</I> are considered as fresh (free)
variables. But there is no way in the language of properties to
instantiate <I>x</I> and <I>y</I> by different integer values in order to obtain
a proposition (regardless of its truth value).<BR>
<BR>
Another attempt is to introduce a property bound to the proposition
<FONT FACE=symbol>"</FONT> <I>x</I>, <I>y</I> : <TT><I>int</I></TT>, <I>x</I> &lt; <I>y</I> /\ <I>x</I>+<I>y</I>&lt;10. It does not fit
because there is no provided way to substitute <I>x</I> and <I>y</I> by integer
values: there is no syntactical construction for elimination of a
universal (nor existential) quantifier in the language of properties
(note that elimination can be done during a proof).<BR>
<BR>
To allow functional bindings in logical expressions <FONT COLOR=purple>FoCaLize</FONT> provide
the <TT>logical let</TT> construct. It serves to introduce a
parameterised logical expression, which can be applied to effective
arguments to obtain a logical proposition. Our example would be
expressed by:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>open&nbsp;"basics"&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;S&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;logical&nbsp;let&nbsp;f&nbsp;(x&nbsp;:&nbsp;in&nbsp;int,&nbsp;y&nbsp;in&nbsp;int)&nbsp;=&nbsp;x&nbsp;&lt;&nbsp;y&nbsp;/\&nbsp;x&nbsp;+&nbsp;y&nbsp;&lt;&nbsp;10&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;</TT></FONT></DIV><BR>
Since <TT>logical let</TT> binds an identifier to a logical expression, the
body of the definition <B>must</B> obviously <B>be of type</B>
<TT>bool</TT>. Once defined, <TT>f</TT> can be used as a regular function,
but only in
properties and theorems statements. For instance:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>open&nbsp;"basics"&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;S&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;m&nbsp;(x&nbsp;in&nbsp;Self)&nbsp;=&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;logical&nbsp;let&nbsp;f&nbsp;(x&nbsp;:&nbsp;in&nbsp;int,&nbsp;y&nbsp;in&nbsp;int)&nbsp;=&nbsp;x&nbsp;&lt;&nbsp;y&nbsp;/\&nbsp;x&nbsp;+&nbsp;y&nbsp;&lt;&nbsp;10&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;property&nbsp;p&nbsp;:&nbsp;all&nbsp;a&nbsp;in&nbsp;Self,&nbsp;all&nbsp;b,&nbsp;c&nbsp;in&nbsp;int,&nbsp;f&nbsp;(c,&nbsp;b)&nbsp;=&gt;&nbsp;f&nbsp;(m&nbsp;(a),&nbsp;b)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;</TT></FONT></DIV>
See other examples in the standard library where this construction is
used to define associativity, commutativity, ...<BR>
<BR>
<!--TOC subsubsection Conditional expression-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc61"><B>3.2.4.6</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Conditional expression</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="conditional-expression"></A>
<A NAME="@default60"></A>
<A NAME="@default61"></A>
A conditional expression has the form:<BR>
<BR>
<TT>if</TT> <I>exp</I><SUB><FONT SIZE=2>1</FONT></SUB> <TT>then</TT>
<I>exp</I><SUB><FONT SIZE=2>2</FONT></SUB> <TT>else</TT> <I>exp</I><SUB><FONT SIZE=2>3</FONT></SUB><BR>
<BR>
Its evaluation starts by the evaluation of the <I>exp</I><SUB><FONT SIZE=2>1</FONT></SUB> expression
which must be of type boolean. If its value is <I>true</I> then the result
value of the whole expression is the value of <I>exp</I><SUB><FONT SIZE=2>2</FONT></SUB>, otherwise
(i.e. if its value is <I>false</I>) the value of <I>exp</I><SUB><FONT SIZE=2>3</FONT></SUB>. This obviously
implies that <I>exp</I><SUB><FONT SIZE=2>2</FONT></SUB> and <I>exp</I><SUB><FONT SIZE=2>3</FONT></SUB> must have the same type. This
construct is then a binary conditional expression (i.e. with 2
branches). <DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV>
The function <TT>f</TT> will return 1 if the effective argument
provided for <TT>x</TT> is <I>true</I>, otherwise it will return 0.
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;y&nbsp;=&nbsp;...&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;y_corrected&nbsp;=&nbsp;if&nbsp;is_to_small&nbsp;(y)&nbsp;then&nbsp;0&nbsp;else&nbsp;y&nbsp;in&nbsp;...</TT></FONT></DIV>
In this example, we assume we have a function <TT>is_too_small</TT>
checking if a value is ``too small'' and an identifier <TT>y</TT> bound
to a certain value. The result of the conditional expression bound to
<TT>y_corrected</TT> will be either 0 if the condition is met or <I>y</I>
otherwise.<BR>
<BR>
<!--TOC subsubsection Match expression-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc62"><B>3.2.4.7</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Match expression</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default62"></A> <A NAME="@default63"></A> <A NAME="@default64"></A><BR>
The <TT>match-with</TT> construct is a generalised conditional construct
with pattern-matching. By ``generalised'', we mean that unlike the
<TT>if-then-else</TT> which has only 2 branches, the present expression
can have several branches. The notion of condition here is not anymore
a boolean value. Instead, the construct allows to discriminate on the
different values an expression is evaluated into. The basic structure
of a <TT>match-with</TT> consists in a discriminating expression followed
by an enumeration of cases (called <B>patterns</B>). The dicriminating
expression is evaluated and its value is matched against the patterns,
following the textual ordering of these patterns, until a match
succeeds. Then the expression associated with the matchng pattern is
evaluated to obtain the value of the whole expression <TT>match-with</TT>.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;x&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;match&nbsp;a&nbsp;+&nbsp;5&nbsp;with</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;-&gt;&nbsp;"zero"</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;5&nbsp;-&gt;&nbsp;"five"</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;1&nbsp;-&gt;&nbsp;"one"</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;10&nbsp;-&gt;&nbsp;"ten"</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;_&nbsp;-&gt;&nbsp;"other"&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT></DIV> The discriminating expression in this case is <TT>a + 5</TT> of type
<TT>int</TT>. We can then react to each (or some of the) values of this
expression. When <TT>a + 5</TT> is equal to 0 the result of the
whole <TT>match-with</TT> expression (bound to the identifier <TT>x</TT>) is
the string ``zero''. When <TT>a + 5</TT> is equal to 1, the result is the string
``one'', and so on. The final pattern <TT>_</TT> stands for ``anything
that was not in the previous cases'' (also called ``catch-all
pattern''). Hence, the order of the patterns is important. If the
case <TT>|_ -&gt;</TT> was put before the case <TT>|1 -&gt;</TT>,
then this last case would never be reached since the <TT>_</TT> pattern
would have caught the discriminated value.<BR>
<BR>
<BR>
As a consequence of the structure of this construct, type constraints
must be respected in order to have the whole expression well-typed:
<UL><LI>
 The type of the discriminating expression must be compatible with the
 type of the patterns.
 <LI>thus all the patterns must have compatible
 types.
 <LI>The types of all the result expressions in the rightmost parts
 of the cases must be compatible.
</UL>
<BR>
In the example above, the patterns were constants. A value
matches a constant pattern if and only if it is equal to this
constant. In addition to this multi-branches conditional feature, the
<TT>match-with</TT> construct provides true <B>pattern matching</B>. That
is, patterns may be built from constants, value constructors,
variables and the catch-all symbol <TT>_</TT>. Any value matches any
variable pattern and the <TT>_</TT> pattern. For general patterns built
from value constructors, variables, constants,<TT>_</TT>, roughly
speaking, a value matches a pattern if this pattern can be seen as a
prefix of this value. Then, the variables of the pattern get bound to
the parts of the discriminating expression that are ``at the same
place'' than those variables. For example:<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;x&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;match&nbsp;e&nbsp;with</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;(0,&nbsp;0,&nbsp;0)&nbsp;-&gt;&nbsp;1</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;(0,&nbsp;x,&nbsp;y)&nbsp;-&gt;&nbsp;x&nbsp;+&nbsp;y</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;(1,&nbsp;1,&nbsp;x)&nbsp;-&gt;&nbsp;x</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;(x,&nbsp;y,&nbsp;z)&nbsp;-&gt;&nbsp;x&nbsp;+&nbsp;y&nbsp;+&nbsp;z</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT></DIV>
According the the type-checking mechanism, the examined expression
<TT>e</TT> must have here type <TT>(int * int * int)</TT>. The first pattern
will be chosen if <TT>e</TT> is equal to the tuple (0, 0, 0). We
say here ``equal'' since there is no variable in the pattern, hence
the only way to fit the pattern is to simply be equal. If this pattern
is not fitted, the we examine the second pattern. It will be chosen if
<TT>e</TT> has a 0 as first component and any integer for the second
and the third ones. In this case, the result value will be the
evaluation of the expression <TT>x + y</TT> where x will be bound to the
effective second component of the value of <TT>e</TT> and <TT>y</TT> will be
bound to its third component. We can notice that no ``catch-all pattern''
is needed since the enumerated patterns cover all the possible values
of tuples with 3 components (look at the last pattern that do not put
any constraint on the tuple components, hence will match all the
remaining cases).<BR>
<BR>
The previous example used tuples as matched expression and patterns,
but patterns also contain sum type value constructors, hence allowing
to ``match'' on any sum type structure. For example: <DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;A</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;B&nbsp;(int)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;C&nbsp;(int&nbsp;*&nbsp;int)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;e&nbsp;=&nbsp;...&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;x&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;match&nbsp;e&nbsp;with</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;A&nbsp;-&gt;&nbsp;0</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;B&nbsp;(3)&nbsp;-&gt;&nbsp;4</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;B&nbsp;(_)&nbsp;-&gt;&nbsp;10</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;C&nbsp;(x,&nbsp;10)&nbsp;-&gt;&nbsp;5</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;C&nbsp;(_,&nbsp;y)&nbsp;-&gt;&nbsp;y</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT></DIV>
This example shows different cases following the structure of the type
<TT>t</TT>. Note the use of the ``catch-all'' pattern
inside patterns. In fact, the ``catch-all'' pattern acts like
a variable unused in the rightmost part of the
case. It is however preferable to use ``<TT>_</TT>'' instead of a
variable since <FONT COLOR=purple>OCaml</FONT> generates warning for unused variables and the
generated <FONT COLOR=purple>OCaml</FONT> code generated by <FONT COLOR=purple>FoCaLize</FONT> will not change unused
variables into ``<TT>_</TT>''s.<BR>
<BR>
<BR>
Patterns also allow to match record values
(c.f. <A HREF="#record-expression">3.2.4.10</A>), i.e. to match on values of the fields:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;r&nbsp;=&nbsp;...&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;x&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;match&nbsp;r&nbsp;with</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;{&nbsp;name&nbsp;=&nbsp;"Alexandre"&nbsp;}&nbsp;-&gt;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;{&nbsp;name&nbsp;=&nbsp;n&nbsp;;&nbsp;birth&nbsp;=&nbsp;2003&nbsp;}&nbsp;-&gt;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;{&nbsp;name&nbsp;=&nbsp;n&nbsp;}&nbsp;-&gt;&nbsp;...</TT></FONT></DIV>
In such a pattern, fields not specified are considered as
``catch-all'' patterns. Hence, the last case catches all the record
values not caught before since the field <TT>name</TT>'s value is bound
to a variable (so, any value can match it) and the field
<TT>birth</TT> is absent (so, considered as <TT>birth = _</TT>).<BR>
<BR>
<!--TOC subsubsection Application expression-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc63"><B>3.2.4.8</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Application expression</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="function-application"></A>
<A NAME="@default65"></A> <A NAME="@default66"></A> We previously
saw that the <TT>let-in</TT> construct allows to define functions by
binding an identifier to a functional value. Using a function by
providing it with effective arguments to get its result value is
called <B>application</B>. Hence, in an application there are 2
distinct parts: the applicative part that must be an expression
leading to a functional value and the effective arguments that are
expressions whose values will be provided to the function to make its
computation. The syntax for application is simply the juxtaposition of
the applicative expression and the comma-separated expressions used as
arguments embraced by parentheses: <DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;g&nbsp;(x,&nbsp;y)&nbsp;=&nbsp;...&nbsp;f&nbsp;(y)&nbsp;...&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>g&nbsp;(f&nbsp;(3),&nbsp;4)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT></DIV>
As described in <A HREF="#functional-value">3.2.4.3</A>, the evaluation of an
application of a function to its effective arguments start by the
evaluation of these arguments (the order of the evaluation of several
arguments is left unspecified). Then these effective values are
substituted to the corresponding parameters inside the body of the
function and the so-obtained expression (the substituted body) is
evaluated. For instance, having the
following function and application:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>g&nbsp;(true,&nbsp;1)</TT></FONT></DIV> The evaluation of this <TT>let-in</TT> expression first binds the
identifier <TT>g</TT> to a <B>functional value</B> also called <B>closure</B>. Then the application expression <TT>g (true, 1)</TT> is
evaluated. So the values of <TT>g</TT> and of the expression <TT>(true,1)</TT> are elaborated: the evaluation of <TT>g</TT> returns a
closure, <TT>true</TT> is evaluated into the boolean <B>value</B> <I>true</I>,
<TT>1</TT> into the integer <B>value</B> 1. The next step is to evaluate
the body of the <B>closure</B> of <TT>g</TT>, replacing the formal
parameter <TT>x</TT> by the effective argument <I>true</I> and <TT>y</TT> by
1. The body of <TT>g</TT> creates a tuple from its 2 arguments, putting
<TT>y</TT> in the first component and <TT>x</TT> in the second. Hence, the
result of the application is the tuple <B>value</B> (1, <I>true</I>).<BR>
<BR>
<!--TOC subsubsection Operator application expression-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc64"><B>3.2.4.9</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Operator application expression</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default67"></A>
Since operators are designed to be used in infix or prefix position,
application of operators consists simply in providing arguments
according to the operator infix/prefix nature. For infix operators,
arguments are on left and right sides. For prefix operators, the
operator is in front of the argument expression.<BR>
<BR>
<!--TOC subsubsection Record expression-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc65"><B>3.2.4.10</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Record expression</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="record-expression"></A>
<A NAME="@default68"></A>
As stated in <A HREF="#record-type-definition">3.2.1.3</A>,
record types are defined by a list of labels with their types. As
usual a record
expression follows the same structure, replacing the type expressions
of the definition by values of these types. For instance, assuming the
given record type definition, the following example shows a possible
record value:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;name&nbsp;:&nbsp;string&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;birth&nbsp;:&nbsp;int&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;living&nbsp;:&nbsp;bool</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>}&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>{&nbsp;name&nbsp;=&nbsp;"Nobody"&nbsp;;&nbsp;birth&nbsp;=&nbsp;42&nbsp;;&nbsp;living&nbsp;=&nbsp;false&nbsp;}</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT></DIV>
If the record type definition is in a different compilation unit, you
may qualify the record fields by the ``<TT>#</TT>'' notation:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV><BR>
<!--TOC subsubsection Cloning a record expression-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc66"><B>3.2.4.11</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Cloning a record expression</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="record-clone-expression"></A>
<A NAME="@default69"></A>
 It is sometimes needed to create a new
value of a record type by modifying a few fields of an existing
record, leaving the other fields unchanged. If the record type
definition contains numerous fields, manually copying the old fields
values to create the new record value appears boring and error prone:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;v1&nbsp;=&nbsp;{&nbsp;a&nbsp;=&nbsp;1&nbsp;;&nbsp;b&nbsp;=&nbsp;2&nbsp;;&nbsp;c&nbsp;=&nbsp;3&nbsp;d&nbsp;=&nbsp;4&nbsp;;&nbsp;e&nbsp;=&nbsp;5&nbsp;;&nbsp;f&nbsp;=&nbsp;6&nbsp;}&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;v2&nbsp;=&nbsp;{</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;a&nbsp;=&nbsp;v1.a&nbsp;;&nbsp;b&nbsp;=&nbsp;v1.b&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;c&nbsp;=&nbsp;5&nbsp;;&nbsp;&nbsp;(*&nbsp;Changed&nbsp;value.&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;d&nbsp;=&nbsp;v1.c&nbsp;;&nbsp;&nbsp;(*&nbsp;an&nbsp;error&nbsp;since&nbsp;the&nbsp;requested&nbsp;value&nbsp;was&nbsp;&nbsp;"v1.d".&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;e&nbsp;=&nbsp;6&nbsp;;&nbsp;&nbsp;(*&nbsp;Changed&nbsp;value.&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;f&nbsp;=&nbsp;v1.f&nbsp;}&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT></DIV>
Instead of manually copy the unchanged fields, <FONT COLOR=purple>FoCaLize</FONT> provides a way
to clone a record value, that is to create a <B>new</B>, a <B>fresh</B>
value from an existing one, only by specifying the fields whose values
differ from the old record value:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;v1&nbsp;=&nbsp;...&nbsp;(*&nbsp;Like&nbsp;above.&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;v2&nbsp;=&nbsp;{&nbsp;v1&nbsp;with&nbsp;c&nbsp;=&nbsp;5&nbsp;;&nbsp;e&nbsp;=&nbsp;6&nbsp;}&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT></DIV>
As for other record value expressions, if the record type definition
is in a different compilation unit, you may qualify the record fields
by the ``<TT>#</TT>'' notation.<BR>
<BR>
<!--TOC subsubsection Record field access expression-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc67"><B>3.2.4.12</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Record field access expression</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="record-field-access"></A>
<A NAME="@default70"></A>
Once a record value is created by aggregating values of its fields, it
is possible to recover the value of one field by a dot notation. For
instance, assuming the type definition and record values of the
previous example:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>...&nbsp;v2.c&nbsp;...</TT></FONT></DIV>
respectively get the value of the fields <TT>a</TT> of <TT>v1</TT> and
<TT>c</TT> of <TT>v2</TT>, that is, 1 and 5. If the record type
definition is in a different compilation unit, you may qualify the
record fields by the ``<TT>#</TT>'' notation: <TT>t1.my_source#a</TT>.<BR>
<BR>
<!--TOC subsubsection Parenthesised expression-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc68"><B>3.2.4.13</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Parenthesised expression</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

The parentheses can be used around any expression, to enforce the
associativity or evaluation order of expressions. Simple expressions
(i.e. atomic) can also be parenthesised without changing their
values.<BR>
<BR>
<!--TOC subsection Core language expressions and definitions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc69"><B><FONT SIZE=4>3.2.5</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Core language expressions and definitions</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

In the previous sections, we described the syntax of
expressions. Expressions rarely appear outside any
definition but it is still possible to have top-level
expressions. They will be directly evaluated and not bound to any
identifier, but this implies that these expressions use previously
written definitions.<BR>
<BR>
<BR>
As further explained in (c.f. <A HREF="#species-intro">4.1.2</A>) species are made
of methods. Some methods contain expressions (functions, properties,
theorems). Function-methods are introduced by the <TT>let</TT> keyword,
using the same syntax (hence expressions) that the <TT>let-in</TT>
construct except the fact they do not have a ``<TT>in</TT>'' expression.
The idea is that the ``<TT>in</TT>'' expression is implicitly the
remaining of the species. Properties and theorems are respectively
introduced by the keywords <TT>property</TT> and <TT>theorem</TT> and may
 contain expressions. The section
<A HREF="#properties-theorems-proofs">3.2.7</A> is dedicated to their detailed explanation.
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;My_Setoid&nbsp;inherits&nbsp;Basic_object&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;(&nbsp;=&nbsp;)&nbsp;:&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;-&gt;&nbsp;bool&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;element&nbsp;:&nbsp;Self&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;different&nbsp;(x,&nbsp;y)&nbsp;=&nbsp;basics#not_b&nbsp;(x&nbsp;=&nbsp;y)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;property&nbsp;refl&nbsp;:&nbsp;all&nbsp;x&nbsp;in&nbsp;Self,&nbsp;x&nbsp;=&nbsp;x&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;property&nbsp;symm&nbsp;:&nbsp;all&nbsp;x&nbsp;y&nbsp;in&nbsp;Self,&nbsp;Self!(&nbsp;=&nbsp;)&nbsp;(x,&nbsp;y)&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;x&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
<BR>
<BR>
<BR>
Toplevel-definitions are definitions introduced outside of any
species. General functions and general theorems, i.e. that do not
depend on a particular species can be introduced as
toplvel-definitions. Toplevel-functions are introduced by the <TT>let</TT> keyword and don't have a ``<TT>in</TT>'' expression, this part
being implicitly the remaining of the program (i.e. the current
compilation unit and those using the current). Toplevel-theorems are
introduced by the <TT>theorem</TT> keyword. These definitions must be ended by a double semi
(``<TT>;;</TT>''). <DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;match&nbsp;x&nbsp;with</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Failed&nbsp;-&gt;&nbsp;true</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Unfailed&nbsp;(_)&nbsp;-&gt;&nbsp;false</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>theorem&nbsp;int_plus_minus:&nbsp;all&nbsp;x&nbsp;y&nbsp;z&nbsp;in&nbsp;int,</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;(*&nbsp;&nbsp;&nbsp;x&nbsp;+&nbsp;y&nbsp;=&nbsp;z&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;z&nbsp;-&nbsp;x&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;#base_eq&nbsp;(#int_plus&nbsp;(x,&nbsp;y),&nbsp;z)&nbsp;-&gt;&nbsp;#base_eq&nbsp;(y,&nbsp;#int_minus&nbsp;(z,&nbsp;x))</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;proof:</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;coq&nbsp;proof&nbsp;{*</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;x&nbsp;y&nbsp;z;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unfold&nbsp;int_plus,&nbsp;int_minus,&nbsp;base_eq,&nbsp;syntactic_equal&nbsp;in&nbsp;|-&nbsp;*;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;H;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unfold&nbsp;bi__int_minus;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply&nbsp;EQ_base_eq;&nbsp;apply&nbsp;Zplus_minus_eq;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symmetry&nbsp;&nbsp;in&nbsp;|-&nbsp;*;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply&nbsp;(decidable&nbsp;_&nbsp;_&nbsp;_&nbsp;(Z_eq_dec&nbsp;(x&nbsp;+&nbsp;y)&nbsp;z)&nbsp;H).</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Qed.</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;*}</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>;;</TT></FONT></DIV><BR>
<!--TOC subsection Files and uses directives-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc70"><B><FONT SIZE=4>3.2.6</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Files and uses directives</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="file directive"></A>
<FONT COLOR=purple>FoCaLize</FONT> provides 3 directives that are not expressions. This means
that they do not lead to values or computation.<BR>
<BR>
<!--TOC subsubsection The <TT>use</TT> directive-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc71"><B>3.2.6.1</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>The <TT>use</TT> directive</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default71"></A>
This directive is followed by the name of the file to open between
double quotes without the ``.fcl'' extension.
Before being allowed to use the qualified notation for an identifier,
(i.e. the ``<TT>#</TT>''-notation), the qualifying compilation must be
declared as ``used'' thanks to this directive. In other terms,
``using'' a compilation units allows to access its entities from the
current compilation unit.<BR>
<BR>
<!--TOC subsubsection The <TT>open</TT> directive-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc72"><B>3.2.6.2</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>The <TT>open</TT> directive</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default72"></A><BR>
This directive is followed by the name of the file to open between
double quotes without the ``.fcl'' extension. As previously introduced
(c.f. <A HREF="#identifier-scoping-and-open">3.2.4.3</A> and <A HREF="#qualified-name">3.1.12</A>) the
<TT>open</TT> directive loads in the current name resolution (scoping)
environment the definitions of the compilation unit named in the <TT>open</TT> directive. This prevents the user from having to explicitly
qualify definitions of this unit by the ``<TT>#</TT>''
notation. Definitions imported by the directive hide (``mask'') those
wearing the same name already defined in the current compilation unit
from the point the directive appears. Remember that it is however
possible to recover the hidden definitions, using the ``<TT>#</TT>''
notation without compilation unit name.<BR>
<BR>
Note that the <TT>open</TT> directive implicitly implies the <TT>use</TT>
directive. This means that it is not useful to add a <TT>use</TT>
together with an <TT>open</TT> directive.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV>This directive loads the definitions of the compilation unit
``sets.fcl'' in the current name resolution (scoping) environment.<BR>
<BR>
The path of the compilation unit is never specified. The file
will be searched in the library search path specified with the
<TT>-I</TT> option (c.f. <A HREF="#compiler-options">7</A>).<BR>
<BR>
<!--TOC subsubsection The <TT>coq_require</TT> directive-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc73"><B>3.2.6.3</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>The <TT>coq_require</TT> directive</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default73"></A>
Some source files of a development may be directly written in <FONT COLOR=purple>Coq</FONT> to
provide external definitions (more detailed further in
<A HREF="#interfacing-other-languages">9.0.5</A>) to import and use in the
<FONT COLOR=purple>FoCaLize</FONT> source code. In this case, the <FONT COLOR=purple>Coq</FONT> code generated for the
<FONT COLOR=purple>FoCaLize</FONT> source code must be aware of the need to import the external
definitions from the manually written <FONT COLOR=purple>Coq</FONT> file. For this reason, the
<FONT COLOR=purple>FoCaLize</FONT> source must explicitly indicate by the <TT>coq_require</TT>
directive that it makes references to definitions hosted in this
<FONT COLOR=purple>Coq</FONT> source file. For example, the file ``wellfounded.fcl'' of the
standard library needs ``wellfounded_externals.v'' and signals this
fact in its early lines of code:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>open&nbsp;"basics";;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>open&nbsp;"sets_orders";;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>coq_require&nbsp;"wellfounded_externals";;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT></DIV><BR>
<!--TOC subsection Properties, theorems and proofs-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc74"><B><FONT SIZE=4>3.2.7</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Properties, theorems and proofs</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="properties-theorems-proofs"></A>
<A NAME="@default74"></A>
<A NAME="@default75"></A><BR>
Properties are first order logic propositions and theorems are
properties with their proofs. We will study here first the structure
of logical expressions used to express the statements, show properties
and theorems forms and shorty present the 3 available ways to write
proofs.<BR>
<BR>
<!--TOC subsubsection Logical expressions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc75"><B>3.2.7.1</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Logical expressions</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="logical-expressions"></A>
<A NAME="@default76"></A>
Logical expressions are those used to write first order logic
formulas.
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>all</FONT></TT> {<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>in</FONT></TT> <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>
 <TT><FONT COLOR=blue>,</FONT></TT> &nbsp;<A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>ex</FONT></TT> {<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP> <TT><FONT COLOR=blue>in</FONT></TT> <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>
 <TT><FONT COLOR=blue>,</FONT></TT> &nbsp;<A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A> <TT><FONT COLOR=blue>-&gt;</FONT></TT> &nbsp;<A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A> <TT><FONT COLOR=blue>&lt;-&gt;</FONT></TT> &nbsp;<A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A> <TT><FONT COLOR=blue>/\</FONT></TT> &nbsp;<A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A> <TT><FONT COLOR=blue>\/</FONT></TT> &nbsp;<A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>~</FONT></TT> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A> <TT><FONT COLOR=blue>)</FONT></TT></TD>
</TR></TABLE></DIV><BR>
 Logical expressions contain the usual logical connectors ``imply''
(<FONT FACE=symbol>Þ</FONT>), ``and'' (<FONT FACE=symbol>Ù</FONT>), ``or'' (<FONT FACE=symbol>Ú</FONT>), ``there exists''
(<FONT FACE=symbol>$</FONT>), ``for all'' (<FONT FACE=symbol>"</FONT>), ``is equivalent''
(<FONT FACE=symbol>Û</FONT>) and ``not'' (¬). Moreover, logical
expressions embed the <FONT COLOR=purple>FoCaLize</FONT> expressions used in computational
methods (i.e. identifiers, conditionals, application, ...). This
allows to have connected propositions using the previously defined
functions and species methods.
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;gt&nbsp;:&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;-&gt;&nbsp;bool&nbsp;;&nbsp;&nbsp;(*&nbsp;Greater&nbsp;than...&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;geq&nbsp;:&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;-&gt;&nbsp;bool&nbsp;;&nbsp;&nbsp;(*&nbsp;Greater&nbsp;or&nbsp;equal...&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;equal&nbsp;:&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;-&gt;&nbsp;bool&nbsp;;&nbsp;&nbsp;(*&nbsp;Equal&nbsp;to...&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;different&nbsp;:&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;-&gt;&nbsp;bool&nbsp;;&nbsp;&nbsp;(*&nbsp;Different&nbsp;of...&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;property&nbsp;gt_is_lt&nbsp;:&nbsp;all&nbsp;x&nbsp;y&nbsp;in&nbsp;Self,</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;(!gt&nbsp;(x,&nbsp;y)&nbsp;-&gt;&nbsp;(!geq&nbsp;(x,&nbsp;y)&nbsp;/\&nbsp;!different(x,&nbsp;y)))</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;/\</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;(!geq&nbsp;(x,&nbsp;y)&nbsp;-&gt;&nbsp;(!gt&nbsp;(x,&nbsp;y)&nbsp;\/&nbsp;!equal(x,&nbsp;y)))&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV>
Since propositions in logical expressions are truth values, this
obviously imply that the arbitrary expressions used between connectors
must have type <TT>bool</TT>.<BR>
<BR>
<!--TOC subsubsection Properties-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc76"><B>3.2.7.2</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Properties</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

A property is a logical expression bound to an identifier. Its
form is the name of the property, a colon character (``:'') and the
logical expression being its statement. See the example given in
<A HREF="#logical-expressions">3.2.7.1</A>.
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="property"><I><FONT COLOR=maroon>property</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>property</FONT></TT> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> <TT><FONT COLOR=blue>:</FONT></TT> &nbsp;<A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A></TD>
</TR></TABLE></DIV><BR>
<!--TOC subsubsection Proofs-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc77"><B>3.2.7.3</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Proofs</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="proof-short-intro"></A>
<FONT COLOR=purple>FoCaLize</FONT> currently provides 3 ways to write proofs. We only give here a
simple description of these 3 means without going deeply in the
technical mechanisms since this problem will be especially addressed
in section <A HREF="#making-proofs">5</A> and <A HREF="#coq-proofs">9.0.6</A>.
<UL><LI>
<B>Consider the proof as ``assumed''</B>. This way is the
 simplest but also the weakest one since it consists in saying that
 no proof is given and the system must trust the stated statement.
 <DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;representation&nbsp;=&nbsp;int;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;equal&nbsp;=&nbsp;(=Ox);</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;theorem&nbsp;symetry&nbsp;:&nbsp;all&nbsp;x&nbsp;y&nbsp;in&nbsp;Self,&nbsp;Self!equal&nbsp;(x,&nbsp;y)&nbsp;-&gt;&nbsp;equal&nbsp;(y,&nbsp;x)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;proof&nbsp;:&nbsp;assumed</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;{*The&nbsp;equality&nbsp;of&nbsp;machine&nbsp;integers&nbsp;is&nbsp;admitted&nbsp;to&nbsp;be&nbsp;symetric&nbsp;&nbsp;*}&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
Following the <TT>assumed</TT> keyword is a mandatory message used for
sake of information, justification, traceability of the proof
absence. Although such a proof can introduce inconsistencies if the
``theorem'' is not a tautology and thus decrease confidence in the
correctness of the <FONT COLOR=purple>FoCaLize</FONT> program, there are several cases where
using this keyword may help.
 <UL><LI>
 The first case is simply that the developer doesn't know
 (yet ?) how to make the proof, doesn't have time yet to write
 it, is not interested in proofs but still wants his program to
 compile to get the executable code.<BR>
<BR>
<LI>Second case deals with import of external code, i.e. code
 not written in <FONT COLOR=purple>FoCaLize</FONT> and considered as external. In this
 case, since the imported code does not fit the <FONT COLOR=purple>FoCaLize</FONT> model
 and more accurately, does not have formal properties, it is
 impossible to make any proof on <FONT COLOR=purple>FoCaLize</FONT>'s side based on the
 structure of this code and its non-existing implementation
 properties. In other terms, things coming outside <FONT COLOR=purple>FoCaLize</FONT>
 universe can not be modeled by <FONT COLOR=purple>FoCaLize</FONT>. The developer only can
 import them providing a binding is given and must trust them.<BR>
<BR>
<LI>Last case addresses ``well-known'' mathematical properties
 that do not actually hold in computers since they are finite
 machines, working on bounded arithmetics. The most obvious
 example is the fact that since an integer is coded on a
 machine word (often 2<SUP><FONT SIZE=2>32</FONT></SUP> or 2<SUP><FONT SIZE=2>64</FONT></SUP> bits nowadays), the
 mathematical property <FONT FACE=symbol>"</FONT> <I>x</I> <FONT FACE=symbol>Î</FONT> <FONT COLOR=red>N</FONT>, <I>x</I> + 1 &gt;
 <I>x</I> does not hold anymore.
<BR>
<BR>
 
 However, conceptually, except when dealing with boundaries,
 this property holds and we need to achieve further proofs. For
 this reason, assuming that the proof holds is legitimate, if the
 developer is able to guaranty that the integer computations
 never overflow. If he cannot guaranty non-overflow, then this
 is a true problem of specification or design which should be
 re-considered.
 </UL><BR>
In any case, we advice the reader to use
the test tool (or another mean) to comfort the confidence in the
statement of the theorem.<BR>
<BR>
<LI><B>Write an automated proof script</B>. <FONT COLOR=purple>FoCaLize</FONT> provides a
 syntax, the <FONT COLOR=purple>FoCaLize</FONT> Proof Language, to split proofs into steps that
 may be proved by the <FONT COLOR=purple>Zenon</FONT> theorem prover. Without entering deeply
 into the syntax further described in chapter <A HREF="#making-proofs">5</A>,
 the main features are the following. The user may state hypotheses,
 demonstrate subgoals that will serve as lemmas for a higher level
 goal and may give hints about definitions or declarations of
 methods. Then <FONT COLOR=purple>Zenon</FONT> tries to automatically guess a proof of this
 goal, then tries to prove those lemmas, hence building a proof tree
 until the top goal (i.e. the theorem) is proved. Below follows an
 example of such proof.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;(all&nbsp;x&nbsp;in&nbsp;Self,&nbsp;!equal&nbsp;(x,&nbsp;!plus&nbsp;(x,&nbsp;o)))&nbsp;-&gt;&nbsp;!equal&nbsp;(o,&nbsp;!zero)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;proof&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;1&gt;1&nbsp;assume&nbsp;o&nbsp;in&nbsp;Self,</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assume&nbsp;H1:&nbsp;all&nbsp;x&nbsp;in&nbsp;Self,&nbsp;!equal&nbsp;(x,&nbsp;!plus&nbsp;(x,&nbsp;o)),</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prove&nbsp;!equal&nbsp;(o,&nbsp;!zero)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;2&gt;1&nbsp;prove&nbsp;!equal&nbsp;(!zero,&nbsp;!plus&nbsp;(!zero,&nbsp;o))</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;hypothesis&nbsp;H1</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;2&gt;3&nbsp;prove&nbsp;!equal&nbsp;(o,&nbsp;!zero)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;step&nbsp;&lt;2&gt;1</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property&nbsp;zero_is_neutral,&nbsp;equal_transitive,&nbsp;equal_symmetric</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;2&gt;4&nbsp;conclude</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;1&gt;2&nbsp;conclude</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;;</TT></FONT></DIV><BR>
<BR>
<LI><B>Write a <FONT COLOR=purple>Coq</FONT> script</B> This way is the most difficult
 since it means to directly write <FONT COLOR=purple>Coq</FONT> code. It
 requires the understanding of both <FONT COLOR=purple>Coq</FONT> and the mapping the
 <FONT COLOR=purple>FoCaLize</FONT> compiler does to generate <FONT COLOR=purple>Coq</FONT> code from <FONT COLOR=purple>FoCaLize</FONT> source
 code. The section <A HREF="#focal-coq-mapping">9.0.6</A> describes
 how <FONT COLOR=purple>FoCaLize</FONT> definitions are mapped onto
 <FONT COLOR=purple>Coq</FONT> names.<BR>
<BR>
The <FONT COLOR=purple>Coq</FONT> script is introduced by the keywords
 <TT>coq proof</TT> and surrounded by <TT>{*</TT> and <TT>*}</TT>.
Below follows an example of such proof.
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;(*&nbsp;x&nbsp;-&nbsp;y&nbsp;=&nbsp;z&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;y&nbsp;+&nbsp;z&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;#base_eq&nbsp;(#int_minus&nbsp;(x,&nbsp;y),&nbsp;z)&nbsp;-&gt;&nbsp;#base_eq&nbsp;(x,&nbsp;#int_plus&nbsp;(y,&nbsp;z))</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;proof:</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;coq&nbsp;proof&nbsp;{*</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;x&nbsp;y&nbsp;z;&nbsp;unfold&nbsp;int_plus,&nbsp;int_minus,&nbsp;base_eq,</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syntactic_equal&nbsp;in&nbsp;|-&nbsp;*;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;H;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unfold&nbsp;bi__int_minus;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply&nbsp;EQ_base_eq;&nbsp;rewrite&nbsp;&lt;-&nbsp;(Zplus_minus&nbsp;y&nbsp;x);</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply&nbsp;Zplus_eq_compat;&nbsp;trivial;&nbsp;apply&nbsp;decidable.</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply&nbsp;Z_eq_dec.&nbsp;assumption.</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Qed.</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;*}&nbsp;;;</TT></FONT></DIV>
</UL>
<!--TOC subsubsection Theorems-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc78"><B>3.2.7.4</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Theorems</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

Now we know how to write a logical statement and
(nearly ~<SUP><FONT SIZE=2>..</FONT></SUP>) how
to write a proof, the structure of a theorem appears simple since it
contains both the statement and the proof inside the same
construct. The theorem is introduced by the keyword <TT>theorem</TT> and
the proof by the keyword <TT>proof</TT> followed by an equal character
(``='').
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="theorem"><I><FONT COLOR=maroon>theorem</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>theorem</FONT></TT> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> <TT><FONT COLOR=blue>:</FONT></TT> &nbsp;<A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A>
 <TT><FONT COLOR=blue>proof&nbsp;=</FONT></TT> &nbsp;<A HREF="#proof"><I><FONT COLOR=maroon>proof</FONT></I></A></TD>
</TR></TABLE></DIV><BR>
For instance:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;theorem&nbsp;inf_right_substitution_rule&nbsp;:&nbsp;all&nbsp;x&nbsp;y&nbsp;z&nbsp;in&nbsp;Self,</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equal(y,&nbsp;z)&nbsp;-&gt;&nbsp;equal(!inf(x,&nbsp;y),&nbsp;!inf(x,&nbsp;z))</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proof:</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;property</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inf_left_substitution_rule,</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inf_commutes,</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equal_transitive&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV>
The kind of proof used here is written in <FONT COLOR=purple>FoCaLize</FONT> Proof Language and
must not be a matter of understanding at this point since this
particular point will be addressed with more details in chapter
<A HREF="#making-proofs">5</A>.<BR>
<BR>
Notice that theorems can be hosted in a species or can be
toplevel-theorems.
Unlike theorems, properties cannot appear at
toplevel since there is no way to inherit at toplevel, hence no
way to give a proof after the property definition in a ``parent''.

<!--TOC chapter The <FONT COLOR=purple>FoCaLize</FONT> model-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#2de52d"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc79"><B><FONT SIZE=6>Chapter&nbsp;4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>The <FONT COLOR=purple>FoCaLize</FONT> model</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
As stated in section <A HREF="#glimpse">1</A>, the <FONT COLOR=purple>FoCaLize</FONT> language is designed
to build an application step by step, going from very abstract
specifications to the concrete implementation through a hierarchy of
structures. At first sight species seem quite similar to
classes in an Object-Oriented context. <EM>However, despite of
inheritance and late-binding features, <FONT COLOR=purple>FoCaLize</FONT> is definitively not an
Object-Oriented language as C++, Java, etc. are.</EM><BR>
<BR>
In the following we focus on the basic concepts underlying a
<FONT COLOR=purple>FoCaLize</FONT> development, that is:
<UL><LI>
Top-level definitions
 <LI>Species
 <LI>Collections
 <LI>Parametrisation
 <LI>Inheritance
 <LI>Late-binding
</UL>
To ensure that this part can be read independently of the section
<A HREF="#glimpse">1</A>, we duplicate some explanations.<BR>
<BR>
<!--TOC section Basic concepts-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc80"><B><FONT SIZE=5>4.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Basic concepts</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<!--TOC subsection Top-level Definitions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc81"><B><FONT SIZE=4>4.1.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Top-level Definitions</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="topleve-def"></A>
<A NAME="@default77"></A>
We call <B>toplevel-definition</B> (just one word) a definition which
appears outside species and collections. Such definitions can only be:
<UL><LI>
 Species 
 <LI>collections,
 <LI>type definitions,
 <LI>general theorems (not depending on a species) 
 <LI>general functions (not depending on a species),
 <LI>expressions to be directly evaluated (but there is no way to
 bind their value to an identifier).
</UL>
Any toplevel-definition is terminated by a double semi-character
(``;;'').<A NAME="@default78"></A><BR>
<BR>
<!--TOC subsection Species-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc82"><B><FONT SIZE=4>4.1.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Species</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="species-intro"></A>
<B>Species</B> <A NAME="@default79"></A> are the nodes of the <FONT COLOR=purple>FoCaLize</FONT>
hierarchy. A species is a sequence of <B>methods</B> <A NAME="@default80"></A> or
<B>fields</B><A NAME="@default81"></A>, each one being terminated by a semi
character (``;'')<A NAME="@default82"></A>. Hence, a basic species looks like:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;meth1&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;meth2&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;end&nbsp;;;</TT></FONT></DIV><BR>
Species names are always <B>capitalised</B>. As any
toplevel-definition, a species ends with a double semi-character
(``;;'').<A NAME="@default83"></A> There are several kinds of methods:
<BR>
<UL><LI>
 <BR>
<A NAME="rep-is-method"></A>
The <B>representation</B><A NAME="@default84"></A>. It
 defines<A NAME="@default85"></A> the type of the entities
 manipulated in the species and is a kind of alias type (see section
 <A HREF="#representation-type">3.2.3</A>). The representation can be a type
 variable and then is said to be ``not yet defined'' or ``only
 declared'' and is not explicitly introduced
 <A NAME="@default86"></A>. It can be bound to a type defined
 by a more complex type expression possibly containing type variables
 (introduced via collection parameters). Either, this type value is
 obtained by inheritance or is introduced by the keyword <TT>representation</TT><A NAME="@default87"></A> followed by <TT>=</TT> followed
 by a type expression. Ultimately to get a <EM>complete</EM> (fully
 defined) species, the representation must be a fully instantiated
 type (directly or by <A HREF="#inheritance">4.3.1</A>).<BR>
<BR>
In the context of a species, the representation is denoted by <TT>Self</TT>.<BR>
<BR>
Note that a representation is never a polymorphic type. When it is
only declared, it is a type variable, which can receive only one
instantiation. In other words, this type variable is not universally
quantified, as are the type variables of polymorphic types. <BR>
<BR>
<LI><B>Signatures</B><A NAME="@default88"></A>. They introduce names of
 constants and functions, uniquely providing their type as a type
 expression. A signature
 begins with the keyword <TT>signature</TT> followed by the introduced
 name followed by <TT>:</TT> followed by a type expression. For
 instance: 
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;signature&nbsp;push&nbsp;:&nbsp;int&nbsp;-&gt;&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;end&nbsp;;;</TT></FONT></DIV> <BR>
As we saw above, <TT>Self</TT> represents the representation (thus a
 type) of the current species. Hence an operation pushing an integer
 onto a stack takes as parameter the integer to push, the stack on
 which to push and give back a new stack, that is, an entity of type
 <TT>Self</TT>.<BR>
<BR>
<BR>
<BR>
<BR>
 <LI><B>Functions</B><A NAME="@default89"></A>. They are implementations of
 signatures, providing effective code. A function is
 introduced by the <TT>let</TT> keyword followed by the name followed
 by <TT>=</TT> followed by a definition, which is similar to ML
 definitions. Recursive functions are
 introduced by <TT>let rec</TT> to make explicit the recursivity.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;representation&nbsp;=&nbsp;int&nbsp;list&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;push&nbsp;(v&nbsp;in&nbsp;int,&nbsp;s&nbsp;in&nbsp;Self)&nbsp;=&nbsp;v&nbsp;::&nbsp;s&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
Function parameters can be entities (that is, values) of the
 species itself (which type is the representation, thus denoted by
 <TT>Self</TT>), entities of known collections, values of known types.<BR>
<BR>
Functions can use in their body other methods of the species,
 toplevel-definitions of functions, methods of collections
 (described further in <A HREF="#collection">4.1.5</A>), or methods of
 collections parameters (see <A HREF="#collection-parameter">4.2.1</A>).<BR>
<BR>
<A NAME="idea-fun-using-sig"></A>
 When we say ``other methods of the species'', this includes
 functions only introduced by their
 signatures. This means that it is possible to use something only
 declared, without yet effective implementation. We will address
 this point later in detail in section <A HREF="#late-binding">4.4.1</A>.<BR>
<BR>
<BR>
Although <FONT COLOR=purple>FoCaLize</FONT> is a functional language, function application
 must always be total. This means that any function call must be
 provided all the effective arguments of the function. As
 previously
 described in the core syntax (c.f <A HREF="#function-application">3.2.4.8</A>),
 function application is ``à la C'', that is with arguments comma
 separated and enclosed by parentheses.<BR>
<BR>
<BR>
<LI><B>Properties</B><A NAME="@default90"></A>. They are first order 
 formulae containing names already introduced. When stating a
 property, the proof that it holds is not yet provided (but will have
 to be ultimately provided). A property can be viewed as a declaration.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;property&nbsp;push_returns_non_empty&nbsp;:</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;all&nbsp;v&nbsp;in&nbsp;int,&nbsp;all&nbsp;s&nbsp;in&nbsp;Self,&nbsp;push&nbsp;(v,&nbsp;s)&nbsp;-&gt;&nbsp;~&nbsp;is_empty&nbsp;(s)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
Proofs<A NAME="@default91"></A> of properties can be <B>delayed</B>,
 that is, done afterwards
 using a <TT>proof</TT> field in a species. The way to give proofs will
 be seen further.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;proof&nbsp;of&nbsp;push_returns_non_empty&nbsp;=&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
<BR>
<LI><B>Theorems</B><A NAME="@default92"></A>. They are properties with their
 proofs. In fact, when defining a property, we only give the
 statement of a theorem, leaving its proof for later. A theorem can
 be viewed as a definition.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;theorem&nbsp;push_returns_non_empty&nbsp;:</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;all&nbsp;v&nbsp;in&nbsp;int,&nbsp;all&nbsp;s&nbsp;in&nbsp;Self,&nbsp;push&nbsp;(v,&nbsp;s)&nbsp;-&gt;&nbsp;~&nbsp;is_empty</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;(s)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;proof&nbsp;=&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV></UL>
<A NAME="no-polymorphism-for-methods"></A>
One important restriction on the type of the methods is that it cannot
be polymorphic<A NAME="@default93"></A>. However, <FONT COLOR=purple>FoCaLize</FONT> provides another
mechanism to circumvent this restriction, the
parametrisation<A NAME="@default94"></A> as explained further
(c.f. <A HREF="#parametrisation">4.2</A>).<BR>
<BR>
<!--TOC subsection Complete species-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc83"><B><FONT SIZE=4>4.1.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Complete species</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

 A species is said <EM>complete</EM><A NAME="@default95"></A> if all
its methods are <EM>defined</EM>, i.e. have an implementation. In other
words this means that there is no more methods only <EM>declared</EM>. This notion implies that:
<UL><LI>
 The representation has been associated with a type definition.
 <LI>Every declaration is associated to a definition.
 <LI>A proof is given for every property.
</UL>
<BR>
Obviously, it is possible to build a species without signatures and
properties, only providing functions and theorems directly. In this
case, if the representation is also defined, then the obtained species
is trivially complete.<BR>
<BR>
The important point for a species to be complete is that it can be
turned into effective executable <FONT COLOR=purple>OCaml</FONT> code and effective checkable
<FONT COLOR=purple>Coq</FONT> code, since all the components are known.<BR>
<BR>
<BR>
<B>Important</B>: Although we said that only a complete species can
lead to effective executable code, of course species even not complete
are compiled ! This means that you do not need to have a complete
species to compile your source code ! It is very common to have
species not complete in source files since programs are written in a
modular fashion, in several files. Moreover, a library may provide
species with methods not defined, leaving the user the freedom to
chose an effective implementation for some algorithms.<BR>
<BR>
<!--TOC subsection Interfaces-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc84"><B><FONT SIZE=4>4.1.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Interfaces</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="interface"></A>
<A NAME="@default96"></A>
The <B>interface</B> of a species is the list of the declarations of
its methods. It corresponds to the end-user point of view, who wants
to know which functions he can use, and which properties these
functions have, but doesn't care about the details of the
implementation.<BR>
<BR>
<BR>
<BR>
<BR>
The interface of a species is obtained by keeping the
signatures and properties and retaining only the signatures of the let
methods and the statement of the theorems. The representation is
hidden thus abstract (only unifiable with itself). Hence, getting the
interface of a species can roughly be seen as erasing the
representation, turning the functions into signatures and the theorems
into properties.<BR>
<BR>
<BR>
<BR>
<BR>
While this abstraction is easy within programming languages, it is not
always possible when dealing with proofs and properties. Such
problematic species are rejected by <FONT COLOR=purple>FoCaLize</FONT> and will be described
later in <A HREF="#dependencies">4.4.2</A>.<BR>
<BR>
An interface has a <B>name</B>, <EM>which is the name of the underlying
species</EM>. There should be no confusion between species names and
interface names as interface names are only used to declare formal
collection parameters (see section <A HREF="#collection-parameter">4.2.1</A>) and to
apply methods of collection parameters.<BR>
<BR>
<!--TOC subsection Collections-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc85"><B><FONT SIZE=4>4.1.5</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Collections</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="collection"></A>
<A NAME="@default97"></A><BR>
A <B>collection</B> is a kind of ``grey box'', built from a <EM>complete</EM> species by abstraction of the representation. A collection
has exactly the same sequence of methods than the complete species
underlying it, apart the representation which is hidden. 
Note that creating a collection from it is the
only way to turn methods of a complete species into executable
code. This point is emphasised by the syntax:<BR>
<BR>
<TT>collection</TT> <EM>name-collection</EM> <TT>implements</TT> <EM>name-species</EM><BR>
<BR>
The interface of a collection is the one of the
complete species it implements. The interface <I>I</I><SUB><FONT SIZE=2>1</FONT></SUB> of a collection
<I>C</I><SUB><FONT SIZE=2>1</FONT></SUB> is <EM>compatible</EM> with an interface <I>I</I><SUB><FONT SIZE=2>2</FONT></SUB> if <I>I</I><SUB><FONT SIZE=2>1</FONT></SUB> contains
 all the components of <I>I</I><SUB><FONT SIZE=2>2</FONT></SUB>.<BR>
<BR>
<BR>
<BR>
<BR>
Thus, implementing a complete species creates a collection, which is a
kind of abstract data-type. This especially
means that entities of the collection cannot be directly
created or manipulated as their type is not accessible. So they can
only be manipulated by the methods of the <EM>implemented</EM> species.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;rep&nbsp;=&nbsp;int&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;create_random&nbsp;in&nbsp;Self&nbsp;=&nbsp;random_foc#random_int&nbsp;(42)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;double&nbsp;(x&nbsp;in&nbsp;Self)&nbsp;=&nbsp;x&nbsp;+&nbsp;x&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;print&nbsp;(x&nbsp;in&nbsp;Self)&nbsp;=&nbsp;print_int&nbsp;(x)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>collection&nbsp;MyFull_Instance&nbsp;implements&nbsp;Full&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;v&nbsp;=&nbsp;Full.create_random&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>Full.print&nbsp;(v)&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>let&nbsp;dv&nbsp;=&nbsp;Full.double&nbsp;(v)&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>Full.print&nbsp;(dv)&nbsp;;;</TT></FONT></DIV><BR>
In this example, we define a complete species <TT>Full</TT>. Then 
we create the collection
<TT>MyFull_Instance</TT>. And we use methods of this collection to
create entities of this collection. We print the result of the
evaluation of the top-level definitions of <TT>v</TT> and <TT>dv</TT>. <BR>
<BR>
<BR>
<BR>
<BR>
<EM>Note that two collections created from a same species are
not type-compatible since their representation is abstracted making
impossible to ensure a type equivalence.</EM><BR>
<BR>
<BR>
As a conclusion, collections are the only way to get something that
can be executed since they are the terminal items of a
<FONT COLOR=purple>FoCaLize</FONT> development hierarchy. Since they are ``terminal'', this also
means that no method can be added to a collection. Moreover, a
collection may not be used to create a new species by inheritance (as
explained in the next section).<BR>
<BR>
<!--TOC section Parametrisation-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc86"><B><FONT SIZE=5>4.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Parametrisation</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default98"></A>
<A NAME="parametrisation"></A><BR>
This section describes a first mechanism to incrementally build new
species from existing ones: the parametrisation. 
<!--TOC subsection Collection parameters-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc87"><B><FONT SIZE=4>4.2.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Collection parameters</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default99"></A>
<A NAME="@default100"></A>
<A NAME="collection-parameter"></A>
Remember that methods cannot be polymorphic<A NAME="@default101"></A>
(c.f. <A HREF="#no-polymorphism-for-methods">4.1.2</A>). For
example, how to implement the well-known polymorphic type of 
lists ? Grouping elements in a list does not
depend of
the type of these elements. The only constraint is that all elements
have the same type. Hence, a ML-like representation of lists would be
like:
<FONT SIZE=2>
</FONT><DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Nil</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;Cons&nbsp;<B>of</B>&nbsp;('a&nbsp;*&nbsp;'a&nbsp;list)</TT></FONT></DIV><BR>
The <TT>'a</TT> is a parameter of the constructor type <TT>list</TT>, which
is indeed a polymorphic ML type. <BR>
<BR>
In <FONT COLOR=purple>FoCaLize</FONT> we would like to create a
species looking like: <DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;nil&nbsp;:&nbsp;Self&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;cons&nbsp;:&nbsp;'a&nbsp;-&gt;&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
Instead of abstracting the type parameter and leaving it free in the
context of the species, in <FONT COLOR=purple>FoCaLize</FONT> we <EM>parametrise</EM> the species
by a <B>collection parameter</B> called <TT>Elem</TT> in the example:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;nil&nbsp;:&nbsp;Self&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;cons&nbsp;:&nbsp;Elem&nbsp;-&gt;&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
Collection parameters are introduced by their name followed by the
<TT>is</TT> keyword, followed by an <B>interface name</B> (remember that
an interface has the same name as its underlying species). In the
example, <TT>Basic_object</TT> is a pre-defined species from the
standard library, containing only few methods and this name is used
here to denote the interface of this species. A
collection parameter can be instantiated by any collection which
interface is <EM>compatible</EM><A NAME="@default102"></A> with the one required by
the parametrised species (c.f <A HREF="#interface">4.1.4</A>). In the example, any
effective parameter instantiating <TT>Elem</TT> is a collection which
interface contains at least the methods listed in the interface of
<TT>Basic_object</TT>. <BR>
<BR>
<BR>
In the example, we use the parameter <TT>Elem</TT> to build the signature
of our method <TT>cons</TT>. Note that collection names can be used
in type expressions to denote the ``abstracted'' representation of the
collection. Here ``abstracted'' means that the
representation is not visible but we can refer to it
as an abstract type. In other words, <TT>Elem -&gt; Self -&gt; Self</TT>
stands for the type of a function:
<UL><LI>
taking a first argument whose type is the representation of a
 collection having a compatible interface with the interface <TT>Basic_object</TT>. (This especially means that such an argument is
 created using methods of the compatible collection),
 <LI>taking a second argument whose type is the representation of
 the current species,
 <LI>and returning a value whose type is the representation of the
 current species.
</UL>
<B>Why a collection parameter and not a species
parameter? </B><BR>
<BR>
The answer to this question is especially important to
understand the programming model in <FONT COLOR=purple>FoCaLize</FONT>. It is a <B>collection
 parameter</B> because ultimately, at the terminal nodes of the
development, this parameter will have to be instantiated by an entity
where everything is defined, so at least a complete species. Imagine
how to build an executable code if a parameter can be instantiated by
a species with some methods only declared...This is the first
reason. <BR>
<BR>
Remember that properties mentioned in the collection interface have
been proved in the underlying complete species. Indeed in the hosting
species, these theorems can be used as lemmas to do current proofs. If
the collection representation was not abstracted, then some methods of
the hosting species would have the ability to directly manipulate
entities of the collection parameter, with the risk of breaking some
invariants of the collection parameter. This is the second reason.
Thus the representation of a collection parameter is abstract for the
hosting, exactly as is the representation of a collection (c.f
<A HREF="#collection">4.1.5</A>).<BR>
<BR>
To summarize, declaring a collection parameter for a parametrised
species means providing two things: the (capitalized) name of the
parameter and the interface (denoted by a species name) that the
instantiation of this parameter must satisfy.<BR>
<BR>
<BR>
It is important at this point to note that <FONT COLOR=purple>FoCaLize</FONT> deals with
dependent types<A NAME="@default103"></A>, and therefore that <EM>the order of the parameters is important</EM>. To define the type of a
parameter, one can use the preceding parameters. For instance, 
assuming that a parametrised species <TT>List</TT> 
declares the basic operations over lists, one can specify a new
species working on couples of respectively values and lists of values
like: <DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;representation&nbsp;=&nbsp;(E&nbsp;*&nbsp;L)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
The representation of this species represents the type
<TT>('a * ('a list))</TT>. This means that the type of the values in the
first component of the couple is the same than the type of the
elements of the list in the second component of the couple.<BR>
<BR>
A parametrized species (like in
the example the species <TT>MyCouple</TT>) cannot be only partially
instantiated. An
instantiation for <B>all</B> its parameters is required. <BR>
<BR>
<BR>
<A NAME="method-qualification"></A>
<A NAME="@default104"></A>
The previous example used
a parameter to build the representation of the species. 
Collection parameters can also be used via their other methods,
i.e. signatures, functions, properties and theorems, denoted by the
parameter's name followed by the ``!''<A NAME="@default105"></A>
character followed by the method name. <BR>
<BR>
To create a species describing a notion of generic couple, it suffices
to use two collection parameters, one for each component of the
couple. To define a printing (i.e. returning a string, not making side
effect in our example) method, it suffices to require each collection
parameter to provide one. Now the printing method has only to
add parentheses and comma around and between what is printed by each
parameter's printing routine. 
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;Base_obj&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;print&nbsp;:&nbsp;Self&nbsp;-&gt;&nbsp;string&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;Couple&nbsp;(C1&nbsp;is&nbsp;Base_obj,&nbsp;c2&nbsp;is&nbsp;Base_obj)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;representation&nbsp;=&nbsp;(C1&nbsp;*&nbsp;C2)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;print&nbsp;(c&nbsp;in&nbsp;Self)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;(c)&nbsp;with</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(component1,&nbsp;component2)&nbsp;-&gt;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"("&nbsp;^&nbsp;C1!print&nbsp;(component1)&nbsp;^</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",&nbsp;"&nbsp;^</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C2!print&nbsp;(component2)&nbsp;^")"&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
Hence, <TT>C1!print (component1)</TT> means ``call the collection
<TT>C1</TT>'s method <TT>print</TT> with the argument <TT>component1</TT>''. <BR>
<BR>
The
qualification mechanism using ``!'' is general and can be used to
denote the method of any available species/collection, even those of
ourselves (i.e. <TT>Self</TT>). Hence, in a species instead of calling:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;m1&nbsp;(...)&nbsp;=&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;m2&nbsp;(...)&nbsp;=&nbsp;if&nbsp;...&nbsp;then&nbsp;...&nbsp;else&nbsp;m1&nbsp;(...)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV>
it is allowed to explicitly qualify the call to <TT>m1</TT> by ``!''
with no species name, hence implicitly telling ``from myself'':
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;m1&nbsp;(...)&nbsp;=&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;m2&nbsp;(...)&nbsp;=&nbsp;if&nbsp;...&nbsp;then&nbsp;...&nbsp;else&nbsp;!m1&nbsp;(...)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV>
<A NAME="@default106"></A>
<A NAME="@default107"></A>
In fact, without explicit ``!'', the <FONT COLOR=purple>FoCaLize</FONT> compiler performs the
name resolution itself, allowing a lighter way of writing programs
instead of always needing a ``!'' character before each method call.<BR>
<BR>
<!--TOC subsection Entity parameters-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc88"><B><FONT SIZE=4>4.2.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Entity parameters</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default108"></A>
<A NAME="entity-parameter"></A>
There is a second kind of parameter: the <B>entity-parameter</B>. Such
a parameter can be instantiated by an <B>entity of a certain
 collection</B>. <BR>
<BR>
For example, to obtain a species offering addition modulo an
integer value, we need to parametrise it by an entity of a collection
implementing the integers and to give a way to build an entity
representing the value of the modulo. Such a parameter is called an
<B>entity parameter</B> and is introduced by the keyword <TT>in</TT>.
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;representation&nbsp;=&nbsp;Number&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;add&nbsp;(x&nbsp;in&nbsp;Self,&nbsp;y&nbsp;in&nbsp;Self)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;Number!modulo&nbsp;(Number!add&nbsp;(x,&nbsp;y),&nbsp;val_mod)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species</TT></FONT></DIV><BR>
Hence, any collection created from <TT>AddModN</TT> embeds the addition
modulo the effective value instantiating <TT>val_mod</TT>. It is then
possible to create various collections with each a specific modulo
value. For instance, assuming that the species <TT>AddModN</TT> is
complete and have a method <TT>from_int</TT> able to create a value of
the representation from an integer, we can create a collection
implementing addition modulo 42. We also assume that we have a
collection <TT>ACollImplentingInts</TT> having at least <TT>InterfaceForInts</TT> as interface. <BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;(ACollImplentingInts,&nbsp;ACollImplentingInts!from_int&nbsp;(42))&nbsp;;;</TT></FONT></DIV><BR>
<BR>
<BR>
<BR>
 Currently, entity parameters must live ``<TT>in</TT>'' a
collection. It is not allowed to specify an entity parameter living in
a basic type like <TT>int</TT>, <TT>string</TT>, <TT>bool</TT>...This
especially means that these basic types must be embedded in a
collection if we want to use their values as entity parameters.<BR>
<BR>
<!--TOC section Inheritance and its mechanisms-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc89"><B><FONT SIZE=5>4.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Inheritance and its mechanisms</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

In this section, we address the second mechanism to build complex species
based on existing ones. It will cover the notion of <EM>inheritance</EM>
and its related feature the <EM>late-binding</EM>.<BR>
<BR>
<!--TOC subsection Inheritance-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc90"><B><FONT SIZE=4>4.3.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Inheritance</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="inheritance"></A>
<A NAME="@default109"></A> <FONT COLOR=purple>FoCaLize</FONT> <EM>inheritance</EM> is the ability to create
a species, not from scratch, but by integrating methods of other
species. The inheritance mechanism also allows to redefine methods
already existing as long as they keep the same type expression. For
theorems to have the same type is simply to have the same statement
(but proofs can differ).<BR>
<BR>
During inheritance, it is also possible to replace a signature by an
effective definition, to redefine a property by a theorem and in the
same idea, to add a <TT>proof of</TT> to a property in order to
conceptually redefine it as a theorem. Moreover new methods can be
added to the inheriting species.<BR>
<BR>
Since inherited methods are
owned by the species that inherits, they are called exactly like if
they were defined ``from scratch'' in the species.<BR>
<BR>
For instance, assuming we have a species <TT>IntCouple</TT> that
represent couples of integers, we want to create a species <TT>OrderedIntCouple</TT> in which we ensure that the first component of the
couple is lower or equal to the second. Instead of inventing again all
the species, we will take advantage of the existing <TT>IntCouple</TT>
and ``import'' all its methods. However, we will have to change the
creation function since it must ensure at creation-time of a couple
(so at run-time) that it is indeed ordered. <TT>OrderedIntCouple</TT>
has all the methods of <TT>IntCouple</TT>, except <TT>create</TT> which is
redefined and the property <TT>is_ordered</TT>) stating that the couple
is really ordered).<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;representation&nbsp;=&nbsp;(int&nbsp;*&nbsp;int)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;print&nbsp;(x&nbsp;in&nbsp;Self)&nbsp;=&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;create&nbsp;(x&nbsp;in&nbsp;int,&nbsp;y&nbsp;in&nbsp;int)&nbsp;=&nbsp;(x,&nbsp;y)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;first&nbsp;(c1,&nbsp;c2)&nbsp;=&nbsp;c1&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;OrderedIntCouple&nbsp;inherits&nbsp;(IntCouple)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;create&nbsp;(x&nbsp;in&nbsp;int,&nbsp;y&nbsp;in&nbsp;int)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;x&nbsp;&lt;&nbsp;y&nbsp;then&nbsp;(x,&nbsp;y)&nbsp;else&nbsp;(y,&nbsp;x)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;property&nbsp;is_ordered&nbsp;:&nbsp;all&nbsp;c&nbsp;in&nbsp;Self,&nbsp;first&nbsp;(c)&nbsp;&lt;=&nbsp;scnd&nbsp;(c)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
<BR>
<A NAME="@default110"></A>
<B>Multiple inheritance</B>, i.e. inheriting from several species is
allowed by specifying several species separated by comma in the
<TT>inherits</TT> clause. The inheriting species inherits of all the
methods of inherited species. In case of a same name appears in
several inherited species, the compiler proceeds as follows. <BR>
<BR>
If all the inherited species have only declared representations, then
the representation of the inheriting species is only declared, unless
it is defined in this inheriting species. If some representations are
declared, the other ones being defined, then the totally defined
representations of inherited species must be the same and this is also
the one of the inheriting species. In the following example, species
<TT>S3</TT> will be rejected while species <TT>S4</TT> has <TT>int</TT> as
representation.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>end;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;S1&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>representation&nbsp;=&nbsp;int&nbsp;;&nbsp;..&nbsp;end&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;S2&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>representation&nbsp;=&nbsp;bool;&nbsp;...&nbsp;end;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;S3&nbsp;inherits&nbsp;S1,&nbsp;S2&nbsp;=&nbsp;...&nbsp;end;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;S4&nbsp;inherits&nbsp;S0,&nbsp;S1&nbsp;=&nbsp;...&nbsp;end;;</TT></FONT></DIV><BR>
If some methods of inherited species have the same name, if they are
all signatures or properties, if these species have no parameters,
then signatures must be identical, properties must be identical. If
some of these methods have already received definitions, if they have
the same type, then the definition which is retained for the
inheriting species is the one coming from the rightmost defined parent
in the <TT>inherits</TT> clause. For instance below, if species <TT>A</TT>,
<TT>B</TT> 
and <TT>C</TT> provide a method <TT>m</TT> which is defined in <TT>A</TT> and
<TT>B</TT> but only declared in <TT>C</TT>, then <TT>B!m</TT> is the one which
is inherited.
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...&nbsp;m&nbsp;(...)&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
<BR>
<A NAME="@default111"></A>
<B>Inheritance and parametrisation</B>
If a species <TT>S1</TT> inherits from a parametrised species <TT>S0</TT>,
it must instantiate all the parameters of <TT>S0</TT>. Due to the
dependent types<A NAME="@default112"></A> framework, if <TT>S1</TT> is itself
parametrised, it can use its own parameters to do that. <BR>
<BR>
Assume we
have a species <TT>List</TT> parametrised by a collection parameter
representing the kind of elements of the list. We want to derive
a species <TT>ListUnique</TT> in which elements are present at most
once. We build <TT>ListUnique</TT> by inheriting from <TT>List</TT>.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;representation&nbsp;=&nbsp;Elem&nbsp;list;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;empty&nbsp;=&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;add&nbsp;(e&nbsp;in&nbsp;Elem,&nbsp;l&nbsp;in&nbsp;Self)&nbsp;=&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;concat&nbsp;(l1&nbsp;in&nbsp;Self,&nbsp;l2&nbsp;in&nbsp;Self)&nbsp;=&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;ListUnique&nbsp;(UElem&nbsp;is&nbsp;...)&nbsp;inherits&nbsp;List&nbsp;(UElem)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;add&nbsp;(e&nbsp;in&nbsp;UElem,&nbsp;l&nbsp;in&nbsp;Self)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;(*&nbsp;Ensure&nbsp;the&nbsp;element&nbsp;e&nbsp;is&nbsp;not&nbsp;already&nbsp;present.&nbsp;*)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;concat&nbsp;(l1&nbsp;in&nbsp;Self,&nbsp;l2&nbsp;in&nbsp;Self)&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;(*&nbsp;Ensure&nbsp;elements&nbsp;of&nbsp;l1&nbsp;present&nbsp;in&nbsp;l2&nbsp;are&nbsp;not&nbsp;added.&nbsp;*)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV> <TT>UElem</TT> is a formal collection parameter of <TT>ListUnique</TT>
which acts as an effective collection parameter in the expression <TT>ListUnique</TT>. The representation of <TT>ListUnique</TT> is <TT>UElem
 list</TT>. The representation of <TT>UElem</TT> is hidden: it denotes a
collection. But, the value constructors of the type <TT>list</TT> are
available, for instance, for pattern-matching. <BR>
<BR>
As a consequence, if two methods in inherited species have the same
name and if at least one of them is itself a parametrised one, then
the signatures of these methods are no longer required to be identical
but their type must have a common instance after instanciation of the
collection parameters.<BR>
<BR>
<A NAME="@default113"></A>
<B>Species inheriting species parametrised by <TT>Self</TT></B> 
A species can also inherit from a species parametrised by itself
(i.e. by <TT>Self</TT>). Although this is rather tricky programming, the
standard library of <FONT COLOR=purple>FoCaLize</FONT> shows such an example in the file <EM>weak_structures.fcl</EM> in the species <TT>Commutative_semi_ring</TT>. Indeed this species specifies the fact
that a commutative semi-ring is a semi-ring on itself (as a semi-ring
of scalars). In such a case, this implies that the current species
must finally (when inheritance is resolved) have an interface
compatible with the interface required by the collection parameter of
the inherited species. The <FONT COLOR=purple>FoCaLize</FONT> compiler collects the parts of the
interface of <TT>Self</TT> obtained either by inheritance or directly in
the species body. Then it checks that the obtained interface is indeed
compatible with the required interfaces of the parametrised inherited
species. if so, the compiler is able to build the new species. Thus
the compiler tries to build a kind of fix-point but this process is
always terminating, issuing either the new species or rejecting it in
case of interface non-compliance. <BR>
<BR>
<!--TOC subsection Species expressions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc91"><B><FONT SIZE=4>4.3.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Species expressions</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default114"></A>
We summarize the different ways of building species. The first way is
to introduce a simple collection parameter, requiring that the
effective parameter can offer all the methods listed in the associated
interface. <BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV><BR>
Then, we can iterate the process and build 
a species parametrised by a parametrised species, like in the example:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV><BR>
Going on, we can inherit
from species that are referenced only by their name, like in:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV><BR>
And finally, we mix the two possibilities, building a species by
inheritance of a parametrised species, like in: <DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV><BR>
Hence, we can now define more accurately the notion of <B>species
expression</B> used for both inheritance and parametrisation. It is either
a simple species name or the application of a parametrised species to
as many collection expressions as the parametrised species has
parameters.<BR>
<BR>
<!--TOC section Late-binding and dependencies-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc92"><B><FONT SIZE=5>4.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Late-binding and dependencies</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<!--TOC subsection Late-binding-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc93"><B><FONT SIZE=4>4.4.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Late-binding</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="late-binding"></A>
<A NAME="@default115"></A> When building by multiple inheritance
(c.f. <A HREF="#inheritance">4.3.1</A>) some signatures can be replaced by functions
and properties by theorems. It is also possible to associate a
definition of function to a signature (c.f <A HREF="#idea-fun-using-sig">4.1.2</A>)or
a proof to a property. In the same order, it is possible to redefine a
method even if it is already used by an existing method.
All these features are relevant of a mechanism known as <EM>late-binding</EM>. <BR>
<BR>
During compilation, the selected method is always the <B>most
recently defined</B> along the inheritance tree. This especially means
that as long as a method is a signature, in the children the effective
implementation of the method will remain undefined (that is not a
problem since in this case the species is not complete, hence cannot
lead to a collection, i.e. code that can really be executed
yet). Moreover, if a method <TT>m</TT> previously defined in the
inheritance tree uses a method <TT>n</TT> freshly <B>re</B>defined, then
this <B>fresh redefinition</B> of <TT>n</TT> will be used in the method
<TT>m</TT>.<BR>
<BR>
<BR>
This mechanism enables two programming features:
<UL><LI>
 The mean to use a method known by its type (i.e. its prototype
 in term of Software Engineering), but for which we do not know, or
 we don't need or we don't want yet to provide an implementation.<BR>
<BR>
<LI>To provide a new implementation of a method while keeping the
 initial implementation for the inherited species. For example, the
 inheriting species can provide some new information
 (representation, functions, ..) which allow a more efficient
 implementation of a given function.
</UL>
<!--TOC subsection Dependencies and erasing-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc94"><B><FONT SIZE=4>4.4.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Dependencies and erasing</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<A NAME="dependencies"></A>
We previously saw that methods of a species can use other methods of
this species and methods from its collection parameters. This induce
what we call <B>dependencies</B><A NAME="@default116"></A>. There are two kinds
of dependencies, depending on their nature:
<UL><LI>
 <B>Decl-dependencies</B>
 <LI><B>Def-dependencies</B>
</UL>
In order to understand the difference between, we must inspect further
the notion of representation, function, and theorem.<BR>
<BR>
<!--TOC subsubsection Decl-dependencies-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc95"><B>4.4.2.1</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Decl-dependencies</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default117"></A>
When defining a function, a property or a theorem it is possible to
use another functions or signatures. For instance:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;test&nbsp;:&nbsp;Self&nbsp;-&gt;&nbsp;bool&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;f1&nbsp;(x&nbsp;in&nbsp;string)&nbsp;=&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;f2&nbsp;(y&nbsp;in&nbsp;Self)&nbsp;=&nbsp;...&nbsp;f1&nbsp;("Eat&nbsp;at&nbsp;Joe's")&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;property&nbsp;p1&nbsp;:&nbsp;all&nbsp;x&nbsp;in&nbsp;Self,&nbsp;test&nbsp;(f2&nbsp;(x))&nbsp;&lt;-&gt;&nbsp;test&nbsp;(f1&nbsp;("So&nbsp;what"))&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;theorem&nbsp;t1&nbsp;:&nbsp;all&nbsp;x&nbsp;in&nbsp;Self,&nbsp;p1&nbsp;&lt;-&gt;&nbsp;&nbsp;test&nbsp;(f1&nbsp;("Bar"))</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;proof&nbsp;=&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
In this cases, knowing the type (or the logical statement) of the used
methods is sufficient to ensure that the using method is
well-formed. The type of a method being provided by its
<B>declaration</B>, we will call these induced dependencies
<B>decl-dependencies</B>.<BR>
<BR>
Such dependencies also arise on the representation as soon as the type
of a method makes reference to the type <TT>Self</TT>. Hence we can have
dependencies on the representation as well as on other methods.<BR>
<BR>
Hence, in our example, <TT>test</TT>, <TT>f2</TT>, <TT>f1</TT> (since it is
used in <TT>p1</TT> and <TT>t1</TT> as the argument of <TT>test</TT> which expects
an argument of type <TT>Self</TT>), <TT>p1</TT> and <TT>t1</TT> have a
decl-dependency on the representation. Moreover, <TT>f2</TT> has one on
<TT>f1</TT>. The property <TT>p1</TT> has decl-dependencies on <TT>test</TT>,
<TT>f1</TT> and <TT>f2</TT> and <TT>Self</TT>. And finally <TT>t1</TT>
decl-depends on <TT>p1</TT>, <TT>test</TT>, <TT>f1</TT> and <TT>Self</TT>.<BR>
<BR>
<!--TOC subsubsection Def-dependencies-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc96"><B>4.4.2.2</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Def-dependencies</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="def-dependency"></A>
<A NAME="@default118"></A> 
A method <I>m</I> has a 
<B>def-dependency</B> over another one <I>p</I> if the system needs to
know the <B>definition</B> of <I>p</I> to ensure that <I>m</I> is well-formed.<BR>
<BR>
A definition of function can create only decl-dependencies on
methods differing from the representation since the type system of
<FONT COLOR=purple>FoCaLize</FONT> only needs the types of the names present in the body of this
function. Note also that when <B>using</B> a signature in another
method, since signature only contain types, no def-dependencies can
arise.<BR>
<BR>
Now remember that <TT>representation</TT> is also a method and there is
no syntactical way to forbid constructions like <TT>if representation
 = int ..</TT> in function or properties. Such definitions would have a
<B>def-dependency</B> on the representation<A NAME="@default119"></A>. For consistency reasons going beyond this manual
but that will be shortly presented below in
<A HREF="#def-dep-on-representation">4.4.3.2</A>, the <B><FONT COLOR=purple>FoCaLize</FONT> system rejects
 functions and properties having def-dependencies on the
 representation</B>.<BR>
<BR>
<BR>
There remains the case of theorems. This case is the most
complex since it can lead to def-dependencies in proofs. For the same
reasons than for properties, the <B><FONT COLOR=purple>FoCaLize</FONT> system rejects theorems
 which statements have def-dependencies on the representation</B>. Other
def-dependencies are accepted. These dependencies must be introduced
by the statement of the proof (with a syntax given in section
<A HREF="#zenon-an-dependencies">??</A>). Now, what does mean for a theorem to
def-depend on a method ? This basically means that to make the proof
of the theorem statement, one must use not only the declaration of a
method, but also its definition, its body. This is a needed and powerful feature.<BR>
<BR>
<!--TOC subsubsection Erasing during inheritance-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc97"><B>4.4.2.3</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Erasing during inheritance</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="@default120"></A>
<A NAME="erasing"></A>
As a consequence of def-dependencies and late-binding, if a method is
redefined, all the proofs of theorems having def-dependencies on these
methods are erased. This means that since the body of the method
changed, may be the proof is not correct anymore and must be done
again. In practice, it can happen that the proof still holds, but the
compiler can't ensure this, hence will turn the theorem into a
property in the species where the redefinition occurred. The developer
will then have to provide a new proof of the inherited theorem thanks
to the <TT>proof of</TT> field. For example, any sorting list algorithm
must satisfy the invariant that its result is a sorted list with the
same elements as its effective argument but the
proof that indeed this requirement is satisfied depends on the
different possible implementations of sort. It is perhaps possible to
decompose this proof into different lemmas to minimize erasing by
redefinition, some lemmas needing only decl-dependencies over the
redefined method. <BR>
<BR>
<!--TOC subsubsection Dependencies on collection parameters-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc98"><B>4.4.2.4</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Dependencies on collection parameters</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

Since collection parameters always have their representation abstracted,
hidden, only <B>decl-dependencies</B> can appear in the parametrised
species using them. Hence they can never lead to erasing. These
dependencies are only used internally by the <FONT COLOR=purple>FoCaLize</FONT> compiler in order
to generate the target code. For this reason, we will not focus anymore
on them.
<BR>
<BR>
<!--TOC subsection More about methods definition-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc99"><B><FONT SIZE=4>4.4.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>More about methods definition</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

We will now examine more technical points in methods definitions.
<!--TOC subsubsection Well-formation-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc100"><B>4.4.3.1</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Well-formation</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="well-formation"></A>
<A NAME="@default121"></A><BR>
<FONT COLOR=purple>FoCaLize</FONT> providing late-binding, it is possible to <B>declare</B> a
method <TT>m0</TT> and use it in another <B>defined method</B> <TT>m1</TT>.<BR>
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;m0&nbsp;:&nbsp;Self&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;m1&nbsp;=&nbsp;m0&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
In another species <TT>S1</TT>, it is also possible to <B>declare</B> a
method <TT>m1</TT> and use it in another <B>defined method</B> <TT>m0</TT>.
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;m1&nbsp;:&nbsp;Self&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;m0&nbsp;=&nbsp;x&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
As long as these two species have no interactions no problem can arise. Now, we
consider a third species <TT>S2</TT> inheriting from both <TT>S0</TT> and
<TT>S1</TT>.
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
The inheritance mechanism will take each method <B>definition</B> from
its hosting species: from <TT>S0</TT> for <TT>m1</TT> and from <TT>S1</TT> for
<TT>m2</TT>. We have hence a configuration where <TT>m0</TT> calls <TT>m1</TT>
and <TT>m1</TT> calls <TT>m0</TT>, i.e. the two methods are now mutually
recursive although it was not the case where each of them was
<B>defined</B>.<BR>
<BR>
To avoid this situation, we will say that a species is well-formed if
and only if, once inheritance is resolved, no method initially not
recursive turns to become recursive. The <FONT COLOR=purple>FoCaLize</FONT> compiler performs this
analysis and rejects any species that is not compliant to this
criterion. In the above example, an error would be raised, explaining
how the mutual recursion (the cycle of dependencies) appears,
i.e. from <TT>m1</TT> to <TT>m0</TT> (and implicitly back to <TT>m1</TT> from
<TT>m0</TT>).<FONT SIZE=2><BR>
<BR>
<TT>Species 'S2' is not well-formed. Field
'm1' involves a non-declared recursion<BR>
for the following dependent fields: m1 -&gt; m0.
</TT>
</FONT><BR>
<BR>
<!--TOC subsubsection Def-dependencies on the representation-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc101"><B>4.4.3.2</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>Def-dependencies on the representation</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="def-dep-on-representation"></A>
<A NAME="@default122"></A>
As we previously said (c.f. <A HREF="#def-dependency">4.4.2.2</A>) def-dependencies on
the representation are not allowed in properties and theorems. The reason
comes from the need to create consistent species interfaces. Let's
consider the following species with the definitions:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;representation&nbsp;=&nbsp;int&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;inc&nbsp;(x&nbsp;in&nbsp;Self)&nbsp;=&nbsp;x&nbsp;+&nbsp;1&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;theorem&nbsp;inc_spec&nbsp;:&nbsp;all&nbsp;x&nbsp;in&nbsp;Self,&nbsp;inc&nbsp;(x)&nbsp;&gt;=&nbsp;x&nbsp;+&nbsp;1</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;proof&nbsp;=&nbsp;...&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>end&nbsp;;;</TT></FONT></DIV><BR>
The statement of <TT>inc_spec</TT> contains a def-dependency on the
representation since to type-check this statement, one need to know
that the representation is <TT>int</TT>. To create the species'
interface, we must make the representation abstract, hence hiding the
fact that it is <TT>int</TT>. Without this information it it now
impossible to type-check <TT>inc_spec</TT> body since it
makes explicit reference to <TT>+</TT>, <TT>&lt;=</TT>, <TT>1</TT> that are
operations about <TT>int</TT>.<BR>
<BR>
In practice, such an error is reported as a typechecking error telling
that <TT>representation</TT> ``is not compatible with type'' <TT>t</TT>
where <TT>t</TT> is the type expression that was assigned to the
representation (i.e. <TT>int</TT> in our example).
<BR>
<BR>
<!--TOC chapter The <FONT COLOR=purple>FoCaLize</FONT> Proof Language-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#2de52d"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc102"><B><FONT SIZE=6>Chapter&nbsp;5</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>The <FONT COLOR=purple>FoCaLize</FONT> Proof Language</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="making-proofs"></A>
<BR>
<!--TOC section Proofs of theorems-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc103"><B><FONT SIZE=5>5.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Proofs of theorems</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

As presented in <A HREF="#proof-short-intro">3.2.7.3</A>, <FONT COLOR=purple>FoCaLize</FONT> proposes 3 ways to
make proof of properties. We will only deal here with proofs written
in the <FONT COLOR=purple>FoCaLize</FONT> Proof Language. As a reminder, proofs written as
direct <FONT COLOR=purple>Coq</FONT> scripts will be addressed in <A HREF="#coq-proofs">9.0.6</A>. And the
last kind of proof, by <TT><FONT COLOR="#ff0000">assumed</FONT></TT> doesn't need anymore description
since it consists in bypassing the formal proof mechanism.<BR>
<BR>
The syntax of proofs is as follows.
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="proof"><I><FONT COLOR=maroon>proof</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 {<A HREF="#proof-step"><I><FONT COLOR=maroon>proof-step</FONT></I></A>}<SUP><FONT SIZE=2>*</FONT></SUP> &nbsp;<A HREF="#qed-step"><I><FONT COLOR=maroon>qed-step</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>by</FONT></TT> {<A HREF="#fact"><I><FONT COLOR=maroon>fact</FONT></I></A>}<SUP><FONT SIZE=2>+</FONT></SUP></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>conclude</FONT></TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>coq&nbsp;proof</FONT></TT> <I><FONT COLOR=maroon>Undefined non-terminal: 'enforced-dependencies'enforced-dependencies</FONT></I> &nbsp;<I><FONT COLOR=maroon>Undefined non-terminal: 'external-code'external-code</FONT></I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <I><FONT COLOR=maroon>Undefined non-terminal: 'enforced-dependencies'enforced-dependencies</FONT></I> <TT><FONT COLOR=blue>assumed</FONT></TT> &nbsp;<I><FONT COLOR=maroon>Undefined non-terminal: 'external-code'external-code</FONT></I></TD>
</TR></TABLE></DIV><BR>
A proof is either a leaf proof or a compound proof. A leaf proof
(introduced with the <TT><FONT COLOR="#ff0000">by</FONT></TT> or <TT><FONT COLOR="#ff0000">conclude</FONT></TT> keywords)
invokes <FONT COLOR=purple>Zenon</FONT> with the
assumptions being the given facts and the goal being the goal of the
proof itself (i.e. the statement that is proved by this leaf proof).
See below for the kinds of facts that can be given.<BR>
<BR>
The <TT><FONT COLOR="#ff0000">conclude</FONT></TT> keyword is used to invoke <FONT COLOR=purple>Zenon</FONT> without
assumptions.<BR>
<BR>
A compound proof is a sequence of steps that ends with a <TT><FONT COLOR="#ff0000">qed</FONT></TT>
step. The goal of each step is stated in the step itself, except for
the <TT><FONT COLOR="#ff0000">qed</FONT></TT> step, which has the same goal as the enclosing
proof.<BR>
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="proof-step"><I><FONT COLOR=maroon>proof-step</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#proof-step-bullet"><I><FONT COLOR=maroon>proof-step-bullet</FONT></I></A> &nbsp;<A HREF="#statement"><I><FONT COLOR=maroon>statement</FONT></I></A> &nbsp;<A HREF="#proof"><I><FONT COLOR=maroon>proof</FONT></I></A></TD>
</TR></TABLE></DIV><BR>
A proof step starts with a proof bullet, which gives its level of
nesting. The top level of a proof is 0. In a compound proof, the
steps are at level one plus the level of the proof itself.<BR>
<BR>
 <BR>
For example, consider the following proof.
<PRE>
  theorem foo : A -&gt; (B -&gt; A)
  proof =
    &lt;1&gt;1 assume h1: A,
         prove B -&gt; A
      &lt;2&gt;1 assume h2: B,
           prove A
        by hypothesis h1
      &lt;2&gt;2 qed
        by step &lt;2&gt;1
    &lt;1&gt;2 qed
      conclude
</PRE>
In this proof, the steps <CODE>&lt;1&gt;1</CODE> and <CODE>&lt;1&gt;2</CODE> are at level 1
and form a compound proof of the top-level theorem. Step <CODE>&lt;1&gt;1</CODE>
also has a compound proof, composed of steps <CODE>&lt;2&gt;1</CODE>
and <CODE>&lt;2&gt;2</CODE>. These are at level 2 (one more than the level of
their enclosing step).<BR>
<BR>
After the proof bullet comes the statement of the step. This is the
statement that is asserted and proved by this step. At the end of
this step's proof, it becomes available as a fact for the next steps
of this proof. In our example, step <CODE>&lt;2&gt;1</CODE> is available in the
proof of <CODE>&lt;2&gt;2</CODE>, and <CODE>&lt;1&gt;1</CODE> is available in the proof of
<CODE>&lt;1&gt;2</CODE>. Note that <CODE>&lt;2&gt;1</CODE> is not available in the proof of
<CODE>&lt;1&gt;2</CODE>: see section&nbsp;<A HREF="#sec:scoping">5.1.1</A> for the scoping rules.<BR>
<BR>
After the statement is the proof of the step. See below (under
Statements) for a description of what is the current goal for this
proof.<BR>
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="qed-step"><I><FONT COLOR=maroon>qed-step</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#proof-step-bullet"><I><FONT COLOR=maroon>proof-step-bullet</FONT></I></A> <TT><FONT COLOR=blue> qed</FONT></TT> &nbsp;<A HREF="#proof"><I><FONT COLOR=maroon>proof</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><A HREF="#proof-step-bullet"><I><FONT COLOR=maroon>proof-step-bullet</FONT></I></A> <TT><FONT COLOR=blue> conclude</FONT></TT></TD>
</TR></TABLE></DIV><BR>
A <TT><FONT COLOR="#ff0000">qed</FONT></TT> step is similar to a normal step, except that its
statement is the goal of the enclosing proof. It may be reduced to
the word <TT><FONT COLOR="#ff0000">conclude</FONT></TT> when its proof is reduced to
<TT><FONT COLOR="#ff0000">conclude</FONT></TT>. In our example, we could have replaced
<CODE>&lt;1&gt;2</CODE> with:
<PRE>
    &lt;1&gt;2 conclude
</PRE><BR>
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="statement"><I><FONT COLOR=maroon>statement</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 {<TT><FONT COLOR=blue>assume</FONT></TT> <A HREF="#assumption"><I><FONT COLOR=maroon>assumption</FONT></I></A> <TT><FONT COLOR=blue>,</FONT></TT>}<SUP><FONT SIZE=2>*</FONT></SUP>
 &nbsp;[<TT><FONT COLOR=blue>prove</FONT></TT> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A>]</TD>
</TR></TABLE></DIV><BR>
A statement must be non-empty: at least one <TT><FONT COLOR="#ff0000">assume</FONT></TT> or the
<TT><FONT COLOR="#ff0000">prove</FONT></TT> part must be present.<BR>
<BR>
A statement appearing in a step has two readings: internal and
external. The external reading is for the rest of the
proof: the current step proves that the assumptions imply the
conclusion (i.e. the <EM>logical-exp</EM> that appears after
<TT><FONT COLOR="#ff0000">prove</FONT></TT>). The internal reading is for the proof of the step:
the current goal is the <TT><FONT COLOR="#ff0000">prove</FONT></TT> expression, and the
assumptions are available as facts.<BR>
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="assumption"><I><FONT COLOR=maroon>assumption</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A> <TT><FONT COLOR=blue>in</FONT></TT> &nbsp;<A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A> <TT><FONT COLOR=blue> :</FONT></TT> &nbsp;<A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A></TD>
</TR></TABLE></DIV><BR>
An assumption can either introduce a new (universally quantified)
variable with its type (first form), or a new named hypothesis (second
form).<BR>
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP>
<A NAME="fact"><I><FONT COLOR=maroon>fact</FONT></I></A> </TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>
 <TT><FONT COLOR=blue>definition&nbsp;of</FONT></TT>
 {[ [<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>] <TT><FONT COLOR=blue>#</FONT></TT> ] &nbsp;<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>hypothesis</FONT></TT>
 {<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> (<TT><FONT COLOR=blue>property</FONT></TT> |  <TT><FONT COLOR=blue>theorem</FONT></TT>)
 {[[[[<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>] <TT><FONT COLOR=blue>#</FONT></TT>] &nbsp;<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>]
 <TT><FONT COLOR=blue>!</FONT></TT>] &nbsp;<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>step</FONT></TT>
 {<A HREF="#proof-step-bullet"><I><FONT COLOR=maroon>proof-step-bullet</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP><FONT SIZE=2>+</FONT></SUP></TD>
</TR></TABLE></DIV><BR>
A fact used in a leaf proof can be a definition, a hypothesis, a
property, a theorem, or a step.<BR>
<BR>
Giving a definition as a fact allows <FONT COLOR=purple>Zenon</FONT> to unfold this
definition in the goal and in the other facts.<BR>
<BR>
Giving a hypothesis/property/theorem as a fact allows <FONT COLOR=purple>Zenon</FONT> to use
this hypothesis/property/theorem to prove the goal.<BR>
<BR>
Giving a <EM>proof-step-bullet</EM> as a fact allows <FONT COLOR=purple>Zenon</FONT> to use the
(external reading of the) corresponding step as an assumption to prove
the goal. Note that even if several steps are labelled with this
proof bullet, only one of them is in scope at any point, so there is
no ambiguity (see section&nbsp;<A HREF="#sec:scoping">5.1.1</A>).<BR>
<BR>
<!--TOC subsection Scoping rules-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc104"><B><FONT SIZE=4>5.1.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Scoping rules</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<A NAME="sec:scoping"></A><BR>
The scope of a step bullet extends from the end of the proof of that
step to the end of the proof of the enclosing step (i.e. the end of
the proof of the <TT><FONT COLOR="#ff0000">qed</FONT></TT> step that has the same level as this
step). This means that proof bullets can be reused in other branches
of the proof to name different steps.<BR>
<BR>
The scope of an assumption is the proof of the step where this
assumption appears.
<BR>
<BR>
<!--TOC chapter Recursive function definitions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#2de52d"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc105"><B><FONT SIZE=6>Chapter&nbsp;6</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>Recursive function definitions</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="recursive-function"></A>
<A NAME="@default123"></A><BR>
<A NAME="@default124"></A>
In the current alpha-release, the logical counterpart of recursive functions
is not completely handled (<FONT COLOR=purple>Coq</FONT> code generation). We are still working on the
point: recursive functions are planed to be fully supported as soon as
possible, in addition with new material to help writing the required termination
proofs.
<BR>
<BR>
<!--TOC chapter Compiler options-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#2de52d"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc106"><B><FONT SIZE=6>Chapter&nbsp;7</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>Compiler options</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<BR>
<A NAME="@default125"></A>
<A NAME="compiler-options"></A>
When invoking the <FONT COLOR=purple>FoCaLize</FONT> compiler with the <FONT COLOR=purple>focalizec</FONT> command,
various command line options can be provided. The compiler can process
several files in their order of apparition in the command line.
Several types of files are handled. By default, if no option is
specified, the default behaviour is of the compiler is:
<UL><LI>
 ``.ml'' and ``.mli'' files are compiled with the <FONT COLOR=purple>OCaml</FONT>
 compiler producing bytecode. It is possible to customise the
 compiler code generation using the <TT>-ocaml-comp-mode</TT> option.
 The version of <FONT COLOR=purple>OCaml</FONT> used is automatically selected from the
 configuration options selected during <FONT COLOR=purple>FoCaLize</FONT>'s
 installation. The <FONT COLOR=purple>FoCaLize</FONT> standard library path is implicitly
 passed to <FONT COLOR=purple>OCaml</FONT>.
 <LI>``.v'' files are compiled with the <FONT COLOR=purple>Coq</FONT>compiler. The
 version of <FONT COLOR=purple>Coq</FONT> used is automatically selected from the
 configuration options selected during <FONT COLOR=purple>FoCaLize</FONT>'s installation.
 The <FONT COLOR=purple>FoCaLize</FONT> standard library path is implicitly passed to
 <FONT COLOR=purple>Coq</FONT>.
 <LI>``.zv'' files are compiled by <FONT COLOR=purple>Zenon</FONT> via <FONT COLOR=purple>zvtov</FONT>. The
 generated ``.v'' file is then compiled by <FONT COLOR=purple>Coq</FONT> as describe
 above.
 <LI>``.fcl'' files are compiled by <FONT COLOR=purple>focalizec</FONT>, generating both
 the ``.ml'' <FONT COLOR=purple>OCaml</FONT> source and the ``.zv'' pre-<FONT COLOR=purple>Coq</FONT>source. The
 ``.ml'' file is then sent to <FONT COLOR=purple>OCaml</FONT>and the ``.zv'' file is sent
 to <FONT COLOR=purple>Zenon</FONT>to finally get a ``.v'' file that is sent to <FONT COLOR=purple>Coq</FONT>.
</UL>
It is possible to control the kind of files generated by
<FONT COLOR=purple>focalizec</FONT> (no <FONT COLOR=purple>Coq</FONT>, no <FONT COLOR=purple>OCaml</FONT>, ``.zv'', ``.v'' using options
described bellow.
<UL><LI>
 * <B>-dot-non-rec-dependencies</B> <EM>directory name</EM>.
 Dumps non-let-rec dependencies of the species present in the
 compiled source file. The output format is suitable to be
 graphically displayed by <FONT COLOR=purple>dotty</FONT> (free software available via the
 <FONT COLOR=purple>graphviz</FONT> package). Each species will lead to a <FONT COLOR=purple>dotty</FONT> file into
 the argument directory. Files are names by ``deps_'' + the source
 file base name (i.e. without path and suffix) + the species name +
 the suffix ``.dot''.<BR>
<BR>
<LI>* <B>-focalize-doc</B> Generates documentation. The
 result file gets located in the same directory than the compiled
 file, replacing the suffix ``.fcl'' by ``.fcd''. This file contains
 XML in plain ASCII text and need to be processed before being read.
 Consult section <A HREF="#foc-doc">??</A> for more details.<BR>
<BR>
<LI>* <B>--experimental</B> Reserved for development purpose.
 Never use. Invoking the compiler with this option may trigger
 unpredictable results.<BR>
<BR>
<LI>* <B>-i</B>. Prints the interfaces of the species present in
 the compiled source file. Result is sent to the standard output.<BR>
<BR>
<LI>* <B>-I</B> <EM>directory name</EM>. Adds the specified
 directory to the path list where to search for 
 compilation units. Several -I options can be used. The search order is
 in the standard library directory first (unless the
 -no-stdlib-path option is used, see below), then in the
 directories specified by the -I options in their apparition
 order on the command line.<BR>
<BR>
<LI>* <B>-impose-termination-proof</B>. Make termination proofs
 mandatory for recursive functions. If a recursive function doesn't
 have its termination proof, then the field will be considered as
 not fully defined and no collection will be built on the
 species hosting the function. By default this option is not
 enabled and if a recursive function does not have any termination
 proof, a warning is printed during compilation when trying to make
 a collection from this species.<BR>
<BR>
<LI>* <B>-methods-history-to-text</B> <EM>directory
 name</EM>. Dumps the methods' inheritance history of the species
 present in the compilation unit. The result is sent as plain text files
 into the argument directory. For each method of each species a file
 is generated wearing the name made of ``history_'' + the source
 file base name (i.e. without path and suffix) + ``_'' + the
 hosting species name + the suffix ``.txt''.<BR>
<BR>
<LI>* <B>-no-ansi-escape</B>. Disables ANSI escape sequences in
 the error messages. By default, when an error is reported, bold,
 italic, underline fonts are used to make easier reading the
 message. Using this option removes all these text attributes and
 may be used if your terminal doesn't support ANSI escape sequences
 or, for example, if compiling under <FONT COLOR=purple>emacs</FONT>.<BR>
<BR>
<LI>* <B>-no-coq-code</B>. Disables the <FONT COLOR=purple>Coq</FONT> code
 generation. By default <FONT COLOR=purple>Coq</FONT> code is always generated.<BR>
<BR>
<LI>* <B>--no-ocaml-code</B>. Disables the <FONT COLOR=purple>OCaml</FONT> code
 generation. By default <FONT COLOR=purple>OCaml</FONT> code is always generated.<BR>
<BR>
<LI>* <B>-no-stdlib-path</B>. Does not include the standard
 library installation directory in the libraries search path. This
 option is rarely useful and mostly dedicated to the
 <FONT COLOR=purple>FoCaLize</FONT> compiler build process.<BR>
<BR>
<LI>* <B>-ocaml-comp-mode</B> <EM>file name</EM>. Specifies the
 <FONT COLOR=purple>OCaml</FONT> compiler code generation mode. This option is folowed by
 a string that can be "byt" for bytecode compilation, "bin" for
 native code compilation, or "both" for bytecode and native code
 compilation. This option has no effect if <B>--no-ocaml-code</B>
 is used.<BR>
<BR>
<LI>* <B>-pretty</B> <EM>file name</EM>. (Undocumented: mostly for
 debug purpose). Pretty-prints the parse tree of the <FONT COLOR=purple>FoCaLize</FONT> file
 as a <FONT COLOR=purple>FoCaLize</FONT> source into the argument file.<BR>
<BR>
<LI>* <B>-raw-ast-dump</B>. (Undocumented: mostly for debug
 purpose). Prints on stderr the raw AST structure after parsing
 stage.<BR>
<BR>
<LI>* <B>-scoped_pretty</B> <EM>file name</EM>. (Undocumented:
 mostly for debug purpose). Pretty-prints the parse tree of the
 <FONT COLOR=purple>FoCaLize</FONT> file once scoped as a <FONT COLOR=purple>FoCaLize</FONT> source into the argument
 file.<BR>
<BR>
<LI>* <B>-stop-before-coq</B> When <FONT COLOR=purple>Coq</FONT> code generation is
 activated, stops the compilation process before passing the
 generated file to <FONT COLOR=purple>Coq</FONT>. The generated pre-<FONT COLOR=purple>Coq</FONT> source is sent to
 <FONT COLOR=purple>Zenon</FONT> then the compilation process stops. The produced file is
 hence ended by the suffix ``.v''. This option has no effect if
 <B>-no-coq-code</B> or <B>-stop-before-zenon</B> is used.<BR>
<BR>
<LI>* <B>-stop-before-zenon</B>. When <FONT COLOR=purple>Coq</FONT> code generation is
 activated, stops the compilation process before passing the
 generated file to <FONT COLOR=purple>Zenon</FONT>. The produced file is then a pre-<FONT COLOR=purple>Coq</FONT>
 source file, ended by the suffix ``.zv''. This option has no
 effect if <B>-no-coq-code</B> is used.<BR>
<BR>
<LI>* <B>-verbose</B>. Sets the compiler in verbose mode. It
 will then generate the trace of the steps and operations is does
 during the compilation. This feature is mostly used for debugging
 purpose but can also explain the elaboration of the model during
 compilation for people interested in <FONT COLOR=purple>FoCaLize</FONT>'s compilation
 process.<BR>
<BR>
<LI>* <B>-v</B>. Prints the <FONT COLOR=purple>FoCaLize</FONT> version then exits.<BR>
<BR>
<LI>* <B>-version</B>. Prints the full <FONT COLOR=purple>FoCaLize</FONT> version,
 sub-version and release date, then exits.<BR>
<BR>
<LI>* <B>-where</B>. Prints the binaries and libraries
 installation directories then exits.<BR>
<BR>
<LI>* <B>-help</B> <B>--help</B>. Prints the summary of command
 line options (i.e. this documentation) on the standard output.
</UL>

<!--TOC chapter Documentation generation-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#2de52d"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc107"><B><FONT SIZE=6>Chapter&nbsp;8</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>Documentation generation</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

When invoked with the <TT>-focalize-doc</TT> option, the command
<TT>focalizec</TT> generates an extra file (with the ``.fcd'' suffix)
containing ``documentation'' information extracted from the compiled
source file.<BR>
<BR>
This information describes the different elements found in the source
file (species, collections, methods, toplevel definitions, type
definitions) with various annotations like type,
definition/inheritance locations. It also contains the special comments
previously called <B>annotations</B> (c.f <A HREF="#annotation">3.1.3</A>) and that
were kept during the compilation process. Moreover, these annotations
can contain special tags used by the documentation generator of
<FONT COLOR=purple>FoCaLize</FONT>.<BR>
<BR>
<!--TOC subsection Special tags-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc108"><B><FONT SIZE=4>8.0.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Special tags</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<FONT COLOR=purple>FoCaLize</FONT>'s documentation system currently supports 5 kinds of
tags. They impact the content of the final generated document,
either in its content or in the way information is displayed depending
on the output format. These tags start with the ``@'' character and
the content of the tag follows until the end of the line. It is then
possible in an annodation to mix regular text that will not be
interpreted and tags.<BR>
<BR>
<!--TOC subsubsection @title-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc109"><B>8.0.2.1</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>@title</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

This tag must appear (i.e. is only taken into account) in the first
annotations block of the source file. The following text is considered
to be the title of the source file and will appear in the header of
the final document.<BR>
<BR>
See example provided for the <TT>@description</TT> tag below.<BR>
<BR>
<!--TOC subsubsection @author-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc110"><B>8.0.2.2</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>@author</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

This tag must appear (i.e. is only taken into account) in the first
annotations block of the source file. The following text is considered
to be the author of the source file and will appear in the header of
the final document.<BR>
<BR>
See example provided for the <TT>@description</TT> tag below.<BR>
<BR>
<!--TOC subsubsection @description-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc111"><B>8.0.2.3</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>@description</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

This tag must appear (i.e. is only taken into account) in the first
annotations block of the source file. The following text is considered
to be the description of the content of the source file (what services
it implements) and will appear in the header of the final document.<BR>
<BR>
For example:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FoCaL&nbsp;compiler&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>(*&nbsp;&nbsp;Copyright&nbsp;2007&nbsp;LIP6&nbsp;and&nbsp;INRIA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>(*&nbsp;&nbsp;Distributed&nbsp;only&nbsp;by&nbsp;permission.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>(***********************************************************************)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>(**</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;@title&nbsp;FoC&nbsp;Project.&nbsp;Basic&nbsp;algebra.</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;@author&nbsp;The&nbsp;FoC&nbsp;project</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;@description&nbsp;Basic&nbsp;sets&nbsp;operations,&nbsp;orderings&nbsp;and&nbsp;lattices.</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>...</TT></FONT></DIV>
will lead to a document header like (displayed in HTML format):<BR>
<BR>
<BR>
<IMG SRC="refman001.gif"><BR>
<BR>
You may notice in the above source code example that the header
information is located in an annotation that is not the <B>first</B>
one. In effect, the top-most banner starting by
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT></DIV>
is in fact also an annotation since it starts by the sequence
``(**''. However all these annotation belong to the same annotations
block as requiered.<BR>
<BR>
<!--TOC subsubsection @mathml-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc112"><B>8.0.2.4</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>@mathml</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

This tag must appear in the document comment preceding a method
definition. It indicates the sequence of MathML code to use to replace
the name of the method everywhere in the current document. This tag
only affects the HTML display since it allows to show more usual
symbols rather than identifiers in a browser. This is expecially
useful for mathematical formulaes where one prefer to see the sign =
rather than an identifier ``<TT>equal</TT>''.<BR>
<BR>
For example:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;a&nbsp;congruence).&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>species&nbsp;Setoid&nbsp;inherits&nbsp;Basic_object&nbsp;=</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;(**&nbsp;@mathml&nbsp;&lt;eq/&gt;&nbsp;*)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;signature&nbsp;equal&nbsp;:&nbsp;Self&nbsp;-&gt;&nbsp;Self&nbsp;-&gt;&nbsp;bool&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;property&nbsp;equal_transitive&nbsp;:&nbsp;all&nbsp;x&nbsp;y&nbsp;z&nbsp;in&nbsp;Self,</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;equal&nbsp;(x,&nbsp;y)&nbsp;-&gt;&nbsp;equal&nbsp;(y,&nbsp;z)&nbsp;-&gt;&nbsp;equal&nbsp;(x,&nbsp;z)&nbsp;;</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT></DIV>
will replace any occurrence of the method <TT>equal</TT> by the
``<CODE>&lt;eq/&gt;</CODE>'' MathML sequence that displays a = sign when
displayed by an HTML browser.<BR>
<BR>
<BR>
<IMG SRC="refman002.gif"><BR>
<BR>
<!--TOC subsection Transforming the generated documentation file-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc113"><B><FONT SIZE=4>8.0.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Transforming the generated documentation file</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

The generated documentation file is a plain ASCII text containing some
XML compliant with <FONT COLOR=purple>FoCaLize</FONT>'s DTD
(<TT>focalize/focalizec/src/docgen/focdoc.dtd</TT>). Like for any XML
files processing is performed thank to the command <FONT COLOR=purple>xsltproc</FONT> with
XSL stylesheets (``.xsl'' files).<BR>
<BR>
You may write custom XSL stylesheets to process this XML but the
distribution already provides 2 stylesheets to format this
information.<BR>
<BR>
<!--TOC subsubsection XML to HTML-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#98ff98"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc114"><B>8.0.3.1</B></A></TD>
<TD WIDTH="100%" ALIGN=center><B>XML to HTML</B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

Transformation from ``.fcd'' to a format that can be read by a WEB
browser is performed in two passes.
<OL type=1><LI>
 Convert the ``.fcl'' file to HTML with MathML annotations.
 This is done applying the stylesheet
 <TT>focalize/focalizec/src/docgen/focdoc2html.xsl</TT> with the command
 <FONT COLOR=purple>xsltproc</FONT>.<BR>
<BR>
For example:
 <PRE><FONT SIZE=2>
  xsltproc ''directory to the stylesheet''/focdoc2html.xsl mysrc.fcd &gt; tmp
  </FONT></PRE><BR>
<BR>
<LI>Convert the HTML+MathML temporary file into HTML.
 This is done applying the stylesheet
 <TT>focalize/focalizec/src/docgen/focdoc2html.xsl</TT> with the command
 <FONT COLOR=purple>xsltproc</FONT>.<BR>
<BR>
For example:
 <PRE><FONT SIZE=2>
  xsltproc ''directory to the stylesheet''/mmlctop2_0.xsl mysrc.fcd &gt; mysrc.xml
  </FONT></PRE>
 <BR>
<B>Attention:</B>
 You may note that the final result file name must be ended by the
 suffix ``.xml'' otherwise your browser won't be able to interpret it
 correctly and won't display symbols (<FONT FACE=symbol>Þ</FONT>, <FONT FACE=symbol>Î</FONT>, <FONT FACE=symbol>$</FONT>,
 <FONT FACE=symbol>®</FONT>, ...) correctly.
</OL>
<!--TOC subsection XML to LaTeX-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc115"><B><FONT SIZE=4>8.0.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>XML to LaTeX</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
Currently not officially available.
<BR>
<BR>
<!--TOC chapter Hacking deeper-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#2de52d"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc116"><B><FONT SIZE=6>Chapter&nbsp;9</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>Hacking deeper</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<!--TOC subsection Interfacing <FONT COLOR=purple>FoCaLize</FONT> with other languages-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc117"><B><FONT SIZE=4>9.0.5</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Interfacing <FONT COLOR=purple>FoCaLize</FONT> with other languages</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="interfacing-other-languages"></A><BR>
<!--TOC subsection Dealing with hand-written <FONT COLOR=purple>Coq</FONT> proofs-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#7fff7f"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc118"><B><FONT SIZE=4>9.0.6</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Dealing with hand-written <FONT COLOR=purple>Coq</FONT> proofs</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="coq-proofs"></A>
<A NAME="focal-coq-mapping"></A>
<BR>
<!--TOC chapter Compiler error messages-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#2de52d"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc119"><B><FONT SIZE=6>Chapter&nbsp;10</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>Compiler error messages</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<A NAME="compiler-error-mesgs"></A>
<BR>
<!--TOC section Unable to find file '<I>name</I>' in the search path.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Unable to find file '<I>name</I>' in the search path.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The source file made reference to a <FONT COLOR=purple>FoCaLize</FONT>
compilation unit 
<I>name</I> (by the <TT>open</TT> or <TT>use</TT> directives, or by explicit
qualification with the ``#'' notation) but the related
<FONT COLOR=purple>FoCaLize</FONT> file was not found in the current libraries search
path.<BR>
<BR>
<EM>Hints</EM>: Locate in which directory the missing file is
and add this directory to the libraries search path with the <TT>-I</TT>
compiler option.<BR>
<BR>
<!--TOC section Invalid or corrupted compilation unit '<I>name</I>'. May be it
 was compiled with another version of the compiler.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Invalid or corrupted compilation unit '<I>name</I>'. May be it
 was compiled with another version of the compiler.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: The source file made reference to a <FONT COLOR=purple>FoCaLize</FONT>
compilation unit
<I>name</I> (by the <TT>open</TT> or <TT>use</TT> directives, or by explicit
qualification with the ``#'' notation but the related
<FONT COLOR=purple>FoCaLize</FONT>  file was found with an incorrect format.<BR>
<BR>
<EM>Hints</EM>: May be the compilation unit was compiled with another
version of <FONT COLOR=purple>FoCaLize</FONT> or was mangled and you must compile it again with
your current version.<BR>
<BR>
<!--TOC section Invalid file extension for '<I>name</I>'.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Invalid file extension for '<I>name</I>'.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: The <FONT COLOR=purple>FoCaLize</FONT> compiler expects compilation units to be
ended by the suffix ``.fcl'', ``.ml'', ``.mli'', ``.zv''or ``.v''. If
the submitted input file doesn't end by one of these suffixes, this
error message arises with the name, <I>name</I> of the involved file.<BR>
<BR>
<EM>Hints</EM>: Change the extension of the input file name or ensure the
submitted input file name is the correct one.<BR>
<BR>
<!--TOC section System error - <I>sysmsg</I>.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>System error - <I>sysmsg</I>.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: During the compilation process an error related to
the operating system occurred (I/O error, permission error, file-system
error, ...). The original message <I>sysmsg</I> of the system explaining
the problem follows the <FONT COLOR=purple>FoCaLize</FONT>'s message.<BR>
<BR>
<EM>Hints</EM>: Consult the original message of the system and get an
appropriate solution depending on this message.<BR>
<BR>
<!--TOC section Invalid OCaml compiler kind "<I>string</I>" for option -ocaml-comp-mode. Must be "byt", "bin" or "both".-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Invalid OCaml compiler kind "<I>string</I>" for option -ocaml-comp-mode. Must be "byt", "bin" or "both".</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: By default, if some <FONT COLOR=purple>OCaml</FONT> code was generated, the
<FONT COLOR=purple>FoCaLize</FONT> compiler sends the generated code to the <FONT COLOR=purple>OCaml</FONT> compiler. The
default compilation mode is bytecode production. It is possible to
select the native code production using the option <TT>-ocaml-comp-mode</TT>
followed by the string ``bin'' or to select both code production modes
by the string ``both''. The argument string ``byt'' is not required
since it is the default mode. Any other string is invalid and leads to
the present error message.<BR>
<BR>
<EM>Hints</EM>: Select ``byt'', ``bin'' or ``both'' as argument to the
<TT>-ocaml-comp-mode</TT> option.<BR>
<BR>
<!--TOC section No input file. FoCaL is cowardly and gives up...-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>No input file. FoCaL is cowardly and gives up...</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: The <FONT COLOR=purple>FoCaLize</FONT> compiler needs one input file to
compile. If none is supplied, this error message arises.<BR>
<BR>
<EM>Hints</EM>: Add the input source file to compile on the command
line.<BR>
<BR>
<!--TOC section Lexical error <I>str</I>-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Lexical error <I>str</I></FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: In the currently submitted source file, a sequence
of characters is not recognised as legal according to the
<FONT COLOR=purple>FoCaLize</FONT> programming language legal words structure. The involved
character <I>str</I> follows in the error message.<BR>
<BR>
<EM>Hints</EM>: Change the source code at the indicated location.<BR>
<BR>
<!--TOC section Syntax error-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Syntax error</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: In the currently submitted source file, a phrase of
the program doesn't follow <FONT COLOR=purple>FoCaLize</FONT>'s syntax.<BR>
<BR>
<EM>Hints</EM>: Change the source code at the indicated location. It
sometimes happens that the location gets fuzzy due to the parsing
process. If the error is not immediate to you, explore the neighbours of
 the specified location. If you still can't find out the error,
have the following emergency process: comment your code and
incrementally uncomment it to find the point where the error appears
without having to search in the whole file. Once the error appears,
have a look at the part of code you uncommented since the previous
successful compilation and try to guess the syntactic cause.<BR>
<BR>
<!--TOC section Unclear syntax error <I>msg</I>.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Unclear syntax error <I>msg</I>.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: An error occurred during the syntactic analysis but
was not reported to be due to a syntax non-compliance. This error is
not clearly identified and this message is displayed as post-mortem
report with the exception <I>msg</I> that caused the error.<BR>
<BR>
<EM>Hints</EM>: None<BR>
<BR>
<!--TOC section Compilation unit '<I>m</I>' was not declared as "use"-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Compilation unit '<I>m</I>' was not declared as "use"</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: It not possible to use a qualified notation for a
compilation unit name (i.e. using an entity from this compilation unit
by explicitly specifying the unit with the ``#''-notation) before this
compilation unit is declared ``use'' or ``open''. This error message
indicates the location where an identifier refers to a compilation
unit that was not qualified either by the <TT>use</TT> or <TT>open</TT>
directive. Note that the <TT>open</TT> directive implicitly implies
<TT>use</TT>.<BR>
<BR>
<EM>Hints</EM>: Use the <TT>use</TT> directive on the compilation detected
unit.<BR>
<BR>
<!--TOC section Parameterised species expected <I>n</I><SUB><FONT SIZE=2>1</FONT></SUB> arguments but
 was provided <I>n</I><SUB><FONT SIZE=2>2</FONT></SUB>.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Parameterised species expected <I>n</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5> arguments but
 was provided <I>n</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5>.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: A species expression (used in species parameter
expression or <TT>inherits</TT> clause) applies a species with <I>n</I><SUB><FONT SIZE=2>1</FONT></SUB>
argument(s) although its definition declared it as using <I>n</I><SUB><FONT SIZE=2>2</FONT></SUB>
argument(s).<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Non-logical let must not bind '<I>ident</I>' to a property.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Non-logical let must not bind '<I>ident</I>' to a property.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: A <TT>let</TT> construct (not a <TT>logical let</TT>)
attempts to bind the identifier <I>ident</I> to a logical expression
although it can only bind it to a computational expression.<BR>
<BR>
<EM>Hints</EM>: Source program to fix. May be the <TT>let</TT> should be
turned into a <TT>logical let</TT> if the body of the binding is really a
logical expression.<BR>
<BR>
<!--TOC section Delayed termination proof refers to an unknown method
 '<I>ident</I>' of the species.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Delayed termination proof refers to an unknown method
 '<I>ident</I>' of the species.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: A <TT>proof of</TT> clause was found in a species for
the property <I>ident</I> but this property was not found in the species.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Ambiguous logical expression. Add explicit parentheses to
 associate the <I>side</I> argument of the <TT><FONT COLOR="#ff0000">/\</FONT></TT> properly.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Ambiguous logical expression. Add explicit parentheses to
 associate the <I>side</I> argument of the <TT><FONT COLOR="#ff0000">/\</FONT></TT> properly.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: A logical expression contains a
<TT><FONT COLOR="#ff0000">/\</FONT></TT> (logical ``and'') with at least one argument being a
<TT><FONT COLOR="#ff0000">-&gt;</FONT></TT> (logical ``implication'') or a <TT><FONT COLOR="#ff0000">&lt;-&gt;</FONT></TT> (logical
``equivalence'') without parentheses around the <I>side</I> argument (``left''
or ``right''). Since this is not clear of how to associate, we ask
the user to explicitly add parentheses.<BR>
<BR>
<EM>Hints</EM>: Explicitly add the parentheses to make the association
non-ambiguous.<BR>
<BR>
<!--TOC section Ambiguous logical expression. Add explicit parentheses to
 associate the <I>side</I> argument of the <TT><FONT COLOR="#ff0000">\/</FONT></TT> properly.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Ambiguous logical expression. Add explicit parentheses to
 associate the <I>side</I> argument of the <TT><FONT COLOR="#ff0000">\/</FONT></TT> properly.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: A logical expression contains a
<TT><FONT COLOR="#ff0000">\/</FONT></TT> (logical ``or'') with at least one argument being a
<TT><FONT COLOR="#ff0000">-&gt;</FONT></TT> (logical ``implication'') or a <TT><FONT COLOR="#ff0000">&lt;-&gt;</FONT></TT> (logical
``equivalence'') without parentheses around the <I>side</I> argument (``left''
or ``right''). Since this is not clear of how to associate, we ask
the user to explicitly add parentheses.<BR>
<BR>
<EM>Hints</EM>: Explicitly add the parentheses to make the association
non-ambiguous.<BR>
<BR>
<!--TOC section Unbound sum type value constructor '<I>name</I>'.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Unbound sum type value constructor '<I>name</I>'.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: An identifier representing a sum type value constructor
was not found among the available sum type definitions.<BR>
<BR>
<EM>Hints</EM>: Source program to fix. Since in core expressions
capitalized identifiers are considered as sum type value constructors,
may be you tried to use a capitalized name for one of your
variables. In this case, as any variables, make it starting with a
lowercase letter. Otherwise, may be your type definition is missing or
not reachable in the current scope (missing explicit qualification
with the ``#'' notation or <TT>open</TT> directive if your type
definition is hosted in another source file).<BR>
<BR>
<!--TOC section Unbound record type label '<I>name</I>'.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Unbound record type label '<I>name</I>'.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: An identifier representing a record type label
was not found among the available record type definitions.<BR>
<BR>
<EM>Hints</EM>: Source program to fix. May be your type definition is
missing or not reachable in the current scope (missing explicit
qualification with the ``#'' notation or <TT>open</TT> directive if your
type definition is hosted in another source file).<BR>
<BR>
<!--TOC section Unbound identifier '<I>name</I>'.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Unbound identifier '<I>name</I>'.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: An identifier (expected to be bound by a <TT>let</TT>,
a pattern of a function parameter declaration) was not found.<BR>
<BR>
<EM>Hints</EM>: Source program to fix. May be your definition should be
toplevel and is missing or not reachable in the current scope (missing
explicit qualification with the ``#'' notation or <TT>open</TT>
directive if your definition is hosted in another source file).<BR>
<BR>
<!--TOC section Unbound type '<I>name</I>'.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Unbound type '<I>name</I>'.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: The definition of an identifier expected to be a
type constructor was not found.<BR>
<BR>
May be your type definition is missing or not reachable in the current
scope (missing explicit qualification with the ``#'' notation or
<TT>open</TT> directive if your type definition is hosted in another
source file).<BR>
<BR>
<!--TOC section Unbound compilation unit '<I>name</I>'.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Unbound compilation unit '<I>name</I>'.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
 <EM>Description</EM>: A
<TT>open</TT> or <TT>use</TT> directive or an explicit qualification by the
``#'' notation makes reference to a compilation unit that was not
found in the current libraries search path.<BR>
<BR>
<EM>Hints</EM>: Locate in which directory the missing file is
and add this directory to the libraries search path with the <TT>-I</TT>
compiler option.<BR>
<BR>
<!--TOC section Unbound species '<I>name</I>'.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Unbound species '<I>name</I>'.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: The definition of the species <I>name</I> was not found
in the current scope.<BR>
<BR>
<EM>Hints</EM>: May be your species definition is missing or not
reachable in the current scope (missing explicit qualification with
the ``#'' notation or <TT>open</TT> directive if your species definition is
hosted in another source file).<BR>
<BR>
<!--TOC section Type name '<I>name</I>' already bound in the current scope.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Type name '<I>name</I>' already bound in the current scope.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: In a source file it is not allowed to redefine a
type definition. This means that each type name definition must be
unique inside a file. However, it is possible to have several type
definitions with the same names as long as they are in different
source files (even if they are used together via <TT>open</TT> directives
of explicit qualification by the ``#'' notation).<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Species name '<I>name</I>' already bound in the current scope.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Species name '<I>name</I>' already bound in the current scope.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: In a source file it is not allowed to redefine a
species definition. This means that each species name definition must
be unique inside a file. However, it is possible to have several species
definitions with the same names as long as they are in different
source files (even if they are used together via <TT>open</TT> directives
of explicit qualification by the ``#'' notation).<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Types <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> are not compatible.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Types <I>t</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5> and <I>t</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5> are not compatible.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: The typechecking system detected a type conflict
between two expressions <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> that were expected to be
type-compatible.<BR>
<BR>
<EM>Hints</EM>: Source program to fix. This is mostly due to an attempt
to use the type of a <TT>representation</TT> although it is turned
abstracted by the collection or parametrisation mechanisms. In this
case, ensure that you are not trying to make assumptions on the type
 of a collection parameter or a collection.<BR>
<BR>
<!--TOC section Type <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> occurs in <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> and would lead to a cycle.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Type <I>t</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5> occurs in <I>t</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5> and would lead to a cycle.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: The <FONT COLOR=purple>FoCaLize</FONT> type system does not allow cyclic
types. This especially means that a type expression must not be a
sub-part of itself to prevent cycles.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Type constructor '<I>name</I>' used with conflicting arities:
 <I>n</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>n</I><SUB><FONT SIZE=2>2</FONT></SUB>.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Type constructor '<I>name</I>' used with conflicting arities:
 <I>n</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5> and <I>n</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5>.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: A type expression applies a type constructor <I>name</I>
to <I>n</I><SUB><FONT SIZE=2>1</FONT></SUB> argument(s) although its definition declared it as using <I>n</I><SUB><FONT SIZE=2>2</FONT></SUB>
argument(s) (or in the other order, depending on the way the error was
detected: in any way the definition and the usage of the type involve
2 different numbers of arguments).<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section No expected argument(s).-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>No expected argument(s).</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<EM>Description</EM>: A type expression applies a type constructor to
arguments although this constructor needs none.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section In method '<I>name</I>', type scheme <I>sch</I> contains free variables.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>In method '<I>name</I>', type scheme <I>sch</I> contains free variables.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: As presented in <A HREF="#no-polymorphism-for-methods">4.1.2</A>,
species methods cannot be polymorphic. The method <I>name</I> has a
 type scheme shown by <I>sch</I> which is polymorphic. <BR>
<BR>
<EM>Hints</EM>: You may explicitly add type
annotations (constraints) on the arguments or/and return type of your
method definition. If you need some kind of such polymorphism, use the
collection parameter mechanism. <BR>
<BR>
<!--TOC section Sum type value constructor '<I>name</I>' expected <I>n</I><SUB><FONT SIZE=2>1</FONT></SUB> arguments but
 was used with <I>n</I><SUB><FONT SIZE=2>2</FONT></SUB> arguments.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Sum type value constructor '<I>name</I>' expected <I>n</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5> arguments but
 was used with <I>n</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5> arguments.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The sum type constructor <I>name</I> is used with a bad
number of arguments. It was declared to use <I>n</I><SUB><FONT SIZE=2>1</FONT></SUB> arguments but is
used with <I>n</I><SUB><FONT SIZE=2>2</FONT></SUB>.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Unbound type variable <I>name</I>.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Unbound type variable <I>name</I>.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: In a type expression, a type variable <I>name</I> is not
bound.<BR>
<BR>
<EM>Hints</EM>: Source program to fix. May be the type expression appears
in a parametrised type definition where you forgot to specify the type
constructor's parameter in head of the definition.<BR>
<BR>
<!--TOC section Method '<I>mname</I>' multiply defined in species '<I>sname</I>'.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Method '<I>mname</I>' multiply defined in species '<I>sname</I>'.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: Like for toplevel definitions, method definitions
inside a species must not bind several times the same name. In the
species <I>sname</I>, the method <I>mname</I> is defined several times.<BR>
<BR>
<EM>Hints</EM>: Source program to fix. May be you defined several times
the same method and in this case, remove one of the definitions. Or if
the different occurrences of <I>mname</I> refer to different conceptual
functions, change the names to make them different.<BR>
<BR>
<!--TOC section Delayed proof of '<I>name</I>' was found several times in the
 species. Other occurrence is at: <I>loc</I>.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Delayed proof of '<I>name</I>' was found several times in the
 species. Other occurrence is at: <I>loc</I>.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: A delayed proof of the property <I>name</I> was found
several times in the same species (i.e. not via inheritance but
directly in the species body). Only one must be kept.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section In species '<I>sname</I>', proof of '<I>pname</I>' is not related to
 an existing property.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>In species '<I>sname</I>', proof of '<I>pname</I>' is not related to
 an existing property.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: In the species <I>sname</I> a delayed proof of the
property <I>pname</I> was found but the statement of this property doesn't
exist in the current species even via inheritance.<BR>
<BR>
<EM>Hints</EM>: May be you forgot to write the property, or you mistook
on the property name the proof is related to or you forgot to inherit
from a species having this property.<BR>
<BR>
<!--TOC section Representation is multiply defined.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Representation is multiply defined.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: In a species, the method <TT>representation</TT> is
multiply defined in the body of the species although at most one
definition must be provided.<BR>
<BR>
<EM>Hints</EM>: Source program to fix. Remove the spurious definitions.<BR>
<BR>
If the <TT>representation</TT> method is not directly present in the
body, that is because the species inherits from a parent where the
representation is already defined. In this last case, since the parent's
structure is already established, you must remove the <TT>representation</TT> method
in the species where the error was reported.<BR>
<BR>
<!--TOC section Representation is multiply defined by multiple
 inheritance and was formerly found of type <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> and newly found of
 type <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB>.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Representation is multiply defined by multiple
 inheritance and was formerly found of type <I>t</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5> and newly found of
 type <I>t</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5>.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: In the species, several parents brought by
inheritance several incompatible definitions of the representation. The error message reports <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB>, two incompatible
types found for the representation definition.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section 'Self' can't be parametrised by itself.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>'Self' can't be parametrised by itself.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: This error appears when <TT>Self</TT> appears as a
species identifier used in a species expression that is a parameter of
the current defined species.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section A "is" parameter can only be instantiated by an identifier of a collection.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>A "is" parameter can only be instantiated by an identifier of a collection.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: In a species expression, a parametrised species by
an entity parameter (<TT>is</TT>-parameter) is provided an effective
argument that is not a collection identifier.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Collection '<I>s</I><SUB><FONT SIZE=2>1</FONT></SUB>' is not compatible with '<I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>'. In method
 '<I>name</I>', types <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> are not compatible.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Collection '<I>s</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5>' is not compatible with '<I>s</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5>'. In method
 '<I>name</I>', types <I>t</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5> and <I>t</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5> are not compatible.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: During collection parameter instantiation, the
interface of the provided collection <I>s</I><SUB><FONT SIZE=2>1</FONT></SUB> is not compatible with the
interface <I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>, because it doesn't have a signature containing at
least <I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>'s methods with compatibles types. The wrong field <I>name</I>
is reported with the two types <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> expected and actually
found.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Collection '<I>s</I><SUB><FONT SIZE=2>1</FONT></SUB>' is not compatible with '<I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>'. In method
 '<I>fname</I>', type <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> occurs in <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> and would lead to a cycle.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Collection '<I>s</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5>' is not compatible with '<I>s</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5>'. In method
 '<I>fname</I>', type <I>t</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5> occurs in <I>t</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5> and would lead to a cycle.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: During collection parameter instantiation, the
interface of the 
provided collection <I>s</I><SUB><FONT SIZE=2>1</FONT></SUB> is not compatible with the interface <I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>, since type compatibility check detected a cyclic
type. This means that the type <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> is a sub-part of itself via the
type <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB>.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Collection '<I>s</I><SUB><FONT SIZE=2>1</FONT></SUB>' is not compatible with '<I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>'. In method
 '<I>fname</I>', the type constructor '<I>tname</I>' is used with the different
 arities <I>n</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>n</I><SUB><FONT SIZE=2>2</FONT></SUB>.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Collection '<I>s</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5>' is not compatible with '<I>s</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5>'. In method
 '<I>fname</I>', the type constructor '<I>tname</I>' is used with the different
 arities <I>n</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5> and <I>n</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5>.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: During collection parameter instantiation, the
interface of the 
provided collection <I>s</I><SUB><FONT SIZE=2>1</FONT></SUB> is not compatible with the interface <I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>, since the type constructor (not sum type constructor)
<I>tname</I> is used with an improper number of arguments <I>n</I><SUB><FONT SIZE=2>1</FONT></SUB> versus
<I>n</I><SUB><FONT SIZE=2>2</FONT></SUB>.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Collection '<I>s</I><SUB><FONT SIZE=2>1</FONT></SUB>' is not compatible with '<I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>'. Method '<I>name</I>'
 is not present in '<I>s</I><SUB><FONT SIZE=2>1</FONT></SUB>'.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Collection '<I>s</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5>' is not compatible with '<I>s</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5>'. Method '<I>name</I>'
 is not present in '<I>s</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5>'.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: During collection parameter instantiation, the
interface of the 
provided collection <I>s</I><SUB><FONT SIZE=2>1</FONT></SUB> is not compatible with the interface <I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>,
because it doesn't have a signature containing at
least <I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>'s methods and especially not the method <I>name</I>.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Parameterised species is applied to <I>n</I> arguments.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Parameterised species is applied to <I>n</I> arguments.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: A parameterised species is applied to a wrong
number <I>n</I> of effective arguments.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Species '<I>sname</I>' cannot be turned into a collection. Method
 '<I>fname</I>' is not defined.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Species '<I>sname</I>' cannot be turned into a collection. Method
 '<I>fname</I>' is not defined.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: A collection is built out of a completely defined species
(c.f. <A HREF="#collection">4.1.5</A>), i.e. a species where <B>all</B> the methods
are <B>defined</B> and not only declared. In the species <I>sname</I>, the
method <I>mname</I> is only declared, hence the species is not complete and
no collection can be extracted from it.<BR>
<BR>
<EM>Hints</EM>: Add an effective definition of the method, either by
writing it code or by inheritance, according to your program model.<BR>
<BR>
<!--TOC section Species '<I>sname</I>' cannot be turned into a collection. Method
 '<I>fname</I>' does not have a termination proof.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Species '<I>sname</I>' cannot be turned into a collection. Method
 '<I>fname</I>' does not have a termination proof.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: A collection is built out of a completely defined species
(c.f. <A HREF="#collection">4.1.5</A>), i.e. a species where <B>all</B> the methods
are <B>defined</B> and in particular proofs of properties are
done. This also applies to recursive functions which must have a
termination proof provided. The recursive function <I>fname</I> of the
species <I>sname</I> doesn't have its termination proof.<BR>
<BR>
This error message only arises if the <TT>-impose-termination-proof</TT>
option is used on the command line. Otherwise, it is turned into a
warning and the compiler will automatically generate an assumed
proof.<BR>
<BR>
<EM>Hints</EM>: Add an effective termination proof to the function or do
not invoke the <TT>-impose-termination-proof</TT> option when compiling
the source file.<BR>
<BR>
<!--TOC section In the delayed termination proof, parameter '<I>name</I>' does
 not refer to a parameter of the original function.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>In the delayed termination proof, parameter '<I>name</I>' does
 not refer to a parameter of the original function.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: As any proof, termination proofs can be made later
after the function definition. However it must refer to the original
function's parameters names. In the current proof, the identifier
<I>name</I> doesn't exist among the original function's parameters.<BR>
<BR>
<EM>Hints</EM>: Change the parameter name in the proof to make it
matching the function definition's ones.<BR>
<BR>
<!--TOC section Method '<I>mname</I>' was found with incompatible types during
 inheritance. In species '<I>s</I><SUB><FONT SIZE=2>1</FONT></SUB>': <FONT FACE=symbol>t</FONT><SUB><FONT SIZE=2>1</FONT></SUB>, in species '<I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>':
 <FONT FACE=symbol>t</FONT><SUB><FONT SIZE=2>2</FONT></SUB>.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Method '<I>mname</I>' was found with incompatible types during
 inheritance. In species '<I>s</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5>': <FONT FACE=symbol>t</FONT></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5>, in species '<I>s</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5>':
 <FONT FACE=symbol>t</FONT></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5>.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: During inheritance, a method <I>nmane</I> was found with
2 incompatible types. Remind that all along the inheritance tree,
methods must not change their type. The two found types and the
species hosting the definitions having these types are provided by
'<I>s</I><SUB><FONT SIZE=2>1</FONT></SUB>'and <FONT FACE=symbol>t</FONT><SUB><FONT SIZE=2>1</FONT></SUB> (resp. '<I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>'and <FONT FACE=symbol>t</FONT><SUB><FONT SIZE=2>2</FONT></SUB>).<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Logical method '<I>mname</I>' appearing in species '<I>s</I><SUB><FONT SIZE=2>1</FONT></SUB>' should
 have the same statement than in species '<I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>' at
 <I>source</I>-<I>location</I>.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Logical method '<I>mname</I>' appearing in species '<I>s</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5>' should
 have the same statement than in species '<I>s</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5>' at
 <I>source</I>-<I>location</I>.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: During inheritance, a theorem or a property <I>nmane</I>
was redefined but with a different statement. As described at the
beginning of <A HREF="#inheritance">4.3.1</A>, the inheritance mechanism also allows
to redefine methods already existing as long as they keep the same
type expression. For theorems to have the same type is simply to have
the same statement. A same property can be written in several
semantically equivalent ways. For instance, transitivity of an
operation  can be written by:
<FONT FACE=symbol>"</FONT> <I>x</I>, <I>y</I>, <I>z</I> <FONT FACE=symbol>Î</FONT> <I>S</I>, <I>x</I>  <I>y</I> <FONT FACE=symbol>Þ</FONT> <I>y</I>  <I>z</I> <FONT FACE=symbol>Þ</FONT>
<I>x</I>  <I>z</I>
or
<FONT FACE=symbol>"</FONT> <I>x</I>, <I>y</I>, <I>z</I> <FONT FACE=symbol>Î</FONT> <I>S</I>, (<I>x</I>  <I>y</I> <FONT FACE=symbol>Ù</FONT> <I>y</I>  <I>z</I>) <FONT FACE=symbol>Þ</FONT>
<I>x</I>  <I>z</I>.
<FONT COLOR=purple>FoCaLize</FONT> does not try to establish the equality of these two
expressions. It only compares syntactically the statements modulo
variables renaming (i.e. <FONT FACE=symbol>a</FONT>-conversion) and non-significant
parentheses.<BR>
<BR>
<EM>Hints</EM>: The simplest way is to rewrite the logical statement of
the inheriting species as it was written in the inherited species.<BR>
<BR>
<!--TOC section Definition '<I>name</I>' is considered as both logical and
 non-logical.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Definition '<I>name</I>' is considered as both logical and
 non-logical.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: In the inheritance tree of the current species, a
method <I>name</I> was previously found a ``logical'' and is now found no
more ``logical''.<BR>
<BR>
<EM>Hints</EM>: Ensure that you did not define 2 methods with the same
name but for different purposes (one to help in stating logical
expressions and the other for your computational behaviour).<BR>
<BR>
<!--TOC section Species 'sname' is not well-formed. Method '<I>name</I>' involves
 a non-declared recursion for the following dependent methods: ...-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Species 'sname' is not well-formed. Method '<I>name</I>' involves
 a non-declared recursion for the following dependent methods: ...</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The species <I>sname</I> doesn't respect the
well-formation rule presented in <A HREF="#well-formation">4.4.3.1</A>. The chain of
functions involved in the cycle is given in the error message as a
sequence of methods names
<I>m</I><SUB><FONT SIZE=2>1</FONT></SUB> <FONT FACE=symbol>®</FONT> <I>m</I><SUB><FONT SIZE=2>2</FONT></SUB> <FONT FACE=symbol>®</FONT> ... <FONT FACE=symbol>®</FONT> <I>m</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB> with the
implicit final path <I>m</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB> <FONT FACE=symbol>®</FONT> <I>m</I><SUB><FONT SIZE=2>1</FONT></SUB>.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section No <I>lang</I> mapping given for the external value definition
 '<I>name</I>'.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>No <I>lang</I> mapping given for the external value definition
 '<I>name</I>'.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The external value definition allowing to link
<FONT COLOR=purple>FoCaLize</FONT> code to foreign languages doesn't specify how to map the value
identifier <I>name</I> in the language <I>lang</I>.<BR>
<BR>
<EM>Hints</EM>: Supply a binding for this language in the external
definition.<BR>
<BR>
<!--TOC section No <I>lang</I> mapping given for the external type definition
 '<I>name</I>'.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>No <I>lang</I> mapping given for the external type definition
 '<I>name</I>'.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The external type definition allowing to link
<FONT COLOR=purple>FoCaLize</FONT> code to foreign languages doesn't specify how to map the type
identifier <I>name</I> in the language <I>lang</I>.<BR>
<BR>
<EM>Hints</EM>: Supply a binding for this language in the external
definition.<BR>
<BR>
<!--TOC section No <I>lang</I> mapping given for the external sum type value
 constructor '<I>name</I>'.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>No <I>lang</I> mapping given for the external sum type value
 constructor '<I>name</I>'.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The external sum type definition allowing to link
<FONT COLOR=purple>FoCaLize</FONT> code to foreign languages doesn't specify how to map the sum
type constructor <I>name</I> in the language <I>lang</I>.<BR>
<BR>
<EM>Hints</EM>: Supply a binding for this language in the external
definition.<BR>
<BR>
<!--TOC section No <I>lang</I> mapping given for the external record field
 '<I>name</I>'.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>No <I>lang</I> mapping given for the external record field
 '<I>name</I>'.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The external record type definition allowing to
link <FONT COLOR=purple>FoCaLize</FONT> code to foreign languages doesn't specify how to map the
record field <I>name</I> in the language <I>lang</I>.<BR>
<BR>
<EM>Hints</EM>: Supply a binding for this language in the external
definition.<BR>
<BR>
<!--TOC section Unable to find OCaml generation information for compiled
 file '<I>file</I>'. Compilation unit may have been compiled without OCaml code
 generation enabled.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Unable to find OCaml generation information for compiled
 file '<I>file</I>'. Compilation unit may have been compiled without OCaml code
 generation enabled.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The <FONT COLOR=purple>FoCaLize</FONT> compilation unit file <I>file</I>.fcl was compiled but
the object file doesn't contain information about <FONT COLOR=purple>OCaml</FONT> code
generation. The <FONT COLOR=purple>FoCaLize</FONT> compiler allows to disable the <FONT COLOR=purple>OCaml</FONT> code
production by the <TT>--no-ocaml-code</TT> option. May be this option was used.<BR>
<BR>
<EM>Hints</EM>: Invoke the compiler on the source file <I>file</I>.fcl without
the <TT>--no-ocaml-code</TT> option.<BR>
<BR>
<!--TOC section Record type definition contains a mutable field '<I>name</I>' that can't
 be compiled to Coq.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Record type definition contains a mutable field '<I>name</I>' that can't
 be compiled to Coq.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: <FONT COLOR="#ff0000"> Never raised in the current version
 since mutable record fields are not yet available</FONT>.<BR>
<BR>
<!--TOC section Unable to find Coq generation information for compiled file
 '<I>file</I>'. Compilation unit may have been compiled without Coq code
 generation enabled.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Unable to find Coq generation information for compiled file
 '<I>file</I>'. Compilation unit may have been compiled without Coq code
 generation enabled.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The <FONT COLOR=purple>FoCaLize</FONT> compilation unit <I>file</I>.fcl was
compiled but the object file doesn't contain information about <FONT COLOR=purple>Coq</FONT>
code generation. The <FONT COLOR=purple>FoCaLize</FONT> compiler allows to disable the <FONT COLOR=purple>Coq</FONT> code
production by the <TT>--no-coq-code</TT> option. May be this option was
used.<BR>
<BR>
<EM>Hints</EM>: Invoke the compiler on the source file <I>file</I>.fcl without
the <TT>--no-coq-code</TT> option.<BR>
<BR>
<!--TOC section Using a collection parameter's method (<I>name</I>) in a Zenon proof
 with "by definition" is not allowed.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Using a collection parameter's method (<I>name</I>) in a Zenon proof
 with "by definition" is not allowed.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The current proof tries to used the definition of a
method <I>name</I> of a species parameter. Since species parameters are
always abstracted, <B>definitions</B> (i.e. ``bodies'') of their methods
are <B>not</B> available in the parametrised species. For this reason,
it is impossible to provide this definition to <FONT COLOR=purple>Zenon</FONT>.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Using an only declared method of Self (<I>name</I>) in a Zenon
 proof with "by definition" is not allowed.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Using an only declared method of Self (<I>name</I>) in a Zenon
 proof with "by definition" is not allowed.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The current proof tries to used the definition of a
method <I>name</I> <B>only declared</B> in the current species. Since the
definition is not available, it is impossible to provide it to
<FONT COLOR=purple>Zenon</FONT>.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Using a local identifier (<I>name</I>) in a Zenon proof with "by
 definition" is not allowed.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Using a local identifier (<I>name</I>) in a Zenon proof with "by
 definition" is not allowed.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The current proof tries to used a local variable
<I>name</I>, i.e. an identifier not representing a method, hence
meaningless for <FONT COLOR=purple>Zenon</FONT>.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Using a local identifier (<I>name</I>) in a Zenon proof with "by
 property" is not allowed.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Using a local identifier (<I>name</I>) in a Zenon proof with "by
 property" is not allowed.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The current proof tries to used a local variable
<I>name</I>, i.e. an identifier not representing a method, hence
meaningless for <FONT COLOR=purple>Zenon</FONT>.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Assumed hypothesis '<I>hyp</I>' in a Zenon proof was not found.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Assumed hypothesis '<I>hyp</I>' in a Zenon proof was not found.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The current proof makes a reference to an
hypothesis <I>hyp</I> that was not found in the current proof tree.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Step '&lt;...&gt;...' in a Zenon proof was not found.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Step '&lt;...&gt;...' in a Zenon proof was not found.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The current proof makes a reference to an
proof step that was not found in the current proof tree.<BR>
<BR>
<EM>Hints</EM>: None.<BR>
<BR>
<!--TOC section Mutual recursion is not yet supported for Coq code
 generation. At least functions '<I>name</I><SUB><FONT SIZE=2>1</FONT></SUB>' and '<I>name</I><SUB><FONT SIZE=2>2</FONT></SUB>' are
 involved in a mutual recursion.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Mutual recursion is not yet supported for Coq code
 generation. At least functions '<I>name</I></FONT></B><SUB><B><FONT SIZE=4>1</FONT></B></SUB><B><FONT SIZE=5>' and '<I>name</I></FONT></B><SUB><B><FONT SIZE=4>2</FONT></B></SUB><B><FONT SIZE=5>' are
 involved in a mutual recursion.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The current version of <FONT COLOR=purple>FoCaLize</FONT> does not yet handle
<FONT COLOR=purple>Coq</FONT> code generation for mutual recursive functions. At least the two
functions <I>name</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>name</I><SUB><FONT SIZE=2>2</FONT></SUB> were found as mutually recursive but
may be the recursion involves more functions. It is then impossible to
produce <FONT COLOR=purple>Coq</FONT> source code.<BR>
<BR>
<EM>Hints</EM>: Until this feature is available in <FONT COLOR=purple>FoCaLize</FONT>&nbsp; do not try to
generate the <FONT COLOR=purple>Coq</FONT> code for the source file containing these functions
by using the <TT>--no-coq-code</TT> option.<BR>
<BR>
<!--TOC section Recursive call to '<I>name</I>' contains nested recursion.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Recursive call to '<I>name</I>' contains nested recursion.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The function contains a recursive call to <I>name</I>
inside a recursive call. The current version of <FONT COLOR=purple>FoCaLize</FONT> doesn't
support the <FONT COLOR=purple>Coq</FONT> code generation for nested recursive calls.<BR>
<BR>
<EM>Hints</EM>: Try to rewrite your function with the nested call
performed before the outer recursive call. For instance:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;f&nbsp;(f&nbsp;(bla))</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT></DIV>
should be turned into:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;tmp&nbsp;=&nbsp;f&nbsp;(bla)&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;f&nbsp;(tmp)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT></DIV><BR>
<!--TOC section Recursive call to '<I>name</I>' is incomplete.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Recursive call to '<I>name</I>' is incomplete.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: The function contains a recursive occurrence of
<I>name</I> with an incomplete number of parameters. Since application
syntactically requires all the arguments to be present, this can arise
if the recursive identifier is used in non-applicative
position. However the error message is more general since future
extensions may involve partial applications. Below follows an example
of such invalid usage of a recursive function identifier:
<DIV ALIGN=left><FONT SIZE=2><TT> </TT></FONT><FONT SIZE=2><TT>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;tmp&nbsp;=&nbsp;f&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;let&nbsp;...&nbsp;&nbsp;=&nbsp;tmp&nbsp;(...)&nbsp;...&nbsp;in</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;f&nbsp;(...)</TT></FONT><FONT SIZE=2><TT><BR>
</TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;...</TT></FONT></DIV><BR>
<EM>Hints</EM>: None<BR>
<BR>
<!--TOC section Unexpected error: "<I>msg</I>". Please report.-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#66ff66"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=5>Unexpected error: "<I>msg</I>". Please report.</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<EM>Description</EM>: An error was raised and not expected during a
normal execution of the compiler. This is a failure of the compiler
and must be fixed by the <FONT COLOR=purple>FoCaLize</FONT> development team. The error message
display the internal reason of the failure and must be reported to the
<FONT COLOR=purple>FoCaLize</FONT> development team.<BR>
<BR>
<EM>Hints</EM>: <CODE>http://focal.inria.fr/</CODE>, link ``Bug tracking''.
<BR>
<BR>

<!--TOC chapter References-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#2de52d"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=6>References</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<DL COMPACT=compact><DT><A NAME="TTSS08"><FONT COLOR=purple>[1]</FONT></A><DD>
P.&nbsp;Ayrault, T.&nbsp;Hardin, and F.&nbsp;Pessaux.
Development life cycle of critical software under FoCal.
In ENTCS-Elsevier, editor, <EM>Harnessing Theories for Tool
 Support in Software-TTSS'08</EM>, 2008.<BR>
<BR>
<DT><A NAME="ZenonBDD"><FONT COLOR=purple>[2]</FONT></A><DD>
R.&nbsp;Bonichon, D.&nbsp;Delahaye, and D.&nbsp;Doligez.
<FONT COLOR=purple>Zenon</FONT>: An Extensible Automated Theorem Prover Producing
 Checkable Proofs.
In <EM>Logic for Programming Artificial Intelligence and Reasoning
 (LPAR)</EM>, volume 4790 of <EM>LNCS/LNAI</EM>, pages 151--165, Yerevan (Armenia),
 Oct. 2007. Springer.<BR>
<BR>
<DT><A NAME="BoulmePhD00"><FONT COLOR=purple>[3]</FONT></A><DD>
S.&nbsp;Boulmé.
<EM>Spécification d'un environnement dédié à la
 programmation certifiée de bibliothèques de Calcul Formel</EM>.
Thèse de doctorat, Université Paris 6, 2000.<BR>
<BR>
<DT><A NAME="ThRRCalculemus"><FONT COLOR=purple>[4]</FONT></A><DD>
S.&nbsp;Boulmé, T.&nbsp;Hardin, and R.&nbsp;Rioboo.
Some hints for polynomials in the Foc project.
In <EM>Calculemus 2001 Proceedings</EM>, June 2001.<BR>
<BR>
<DT><A NAME="Focal-UML"><FONT COLOR=purple>[5]</FONT></A><DD>
D.&nbsp;Delahaye, J.-F. Étienne, and V.&nbsp;Viguié Donzeau-Gouge.
A Formal and Sound Transformation from <FONT COLOR=purple>FoCaLize</FONT> to UML: An
 Application to Airport Security Regulations.
In <EM>UML and Formal Methods (UML&amp;FM)</EM>, Innovations in Systems and
 Software Engineering (ISSE) NASA Journal, Kitakyushu-City (Japan), Oct. 2008.
 Springer.<BR>
<BR>
<DT><A NAME="EDEMOI-All"><FONT COLOR=purple>[6]</FONT></A><DD>
D.&nbsp;Delahaye, J.-F. Étienne, and V.&nbsp;Viguié Donzeau-Gouge.
Formal Modeling of Airport Security Regulations using the
 <FONT COLOR=purple>FoCaLize</FONT> Environment.
In <EM>Requirements Engineering and Law (RELAW)</EM>, Barcelona (Spain),
 Sept. 2008. IEEE CS Press.<BR>
<BR>
<DT><A NAME="EDEMOI-Model"><FONT COLOR=purple>[7]</FONT></A><DD>
D.&nbsp;Delahaye, J.-F. Étienne, and V.&nbsp;Viguié Donzeau-Gouge.
Certifying Airport Security Regulations using the <FONT COLOR=purple>FoCaLize</FONT>
 Environment.
In <EM>Formal Methods (FM)</EM>, volume 4085 of <EM>LNCS</EM>, pages
 48--63. Springer, Aug. 2006.<BR>
<BR>
<DT><A NAME="EDEMOI-Proof"><FONT COLOR=purple>[8]</FONT></A><DD>
D.&nbsp;Delahaye, J.-F. Étienne, and V.&nbsp;Viguié Donzeau-Gouge.
Reasoning about Airport Security Regulations using the <FONT COLOR=purple>FoCaLize</FONT>
 Environment.
In <EM>International Symposium on Leveraging Applications of Formal
 Methods, Verification and Validation (ISoLA)</EM>, pages 45--52. IEEE CS Press,
 Nov. 2006.<BR>
<BR>
<DT><A NAME="zenon0.4.1"><FONT COLOR=purple>[9]</FONT></A><DD>
D.&nbsp;Doligez.
Zenon, version 0.4.1.
http://focal.inria.fr/zenon/, 2006.<BR>
<BR>
<DT><A NAME="traps"><FONT COLOR=purple>[10]</FONT></A><DD>
E.Jaeger and T.Hardin.
A few remarks about developing secure systems in b.
In IEEE, editor, <EM>HASE 2008</EM>, 2008.
.<BR>
<BR>
<DT><A NAME="HardinRiobooTSI04"><FONT COLOR=purple>[11]</FONT></A><DD>
T.&nbsp;Hardin and R.&nbsp;Rioboo.
Les objets des mathématiques.
<EM>RSTI - L'objet</EM>, 2004.<BR>
<BR>
<DT><A NAME="jias06"><FONT COLOR=purple>[12]</FONT></A><DD>
M.&nbsp;Jaume and C.&nbsp;Morisset.
A formal approach to implement access control.
<EM>Journal of Information Assurance and Security</EM>, 2:137--148,
 2006.<BR>
<BR>
<DT><A NAME="fcsarspa06"><FONT COLOR=purple>[13]</FONT></A><DD>
M.&nbsp;Jaume and C.&nbsp;Morisset.
Towards a formal specification of access control.
In <EM>Joint Workshop on Foundations of Computer Security and
 Automated Reasoning for Security Protocol Analysis FCS-ARSPA'06 (Satellite
 Workshop to LICS'2006)</EM>, 2006.<BR>
<BR>
<DT><A NAME="MaarekCalculemus03"><FONT COLOR=purple>[14]</FONT></A><DD>
M.&nbsp;Maarek and V.&nbsp;Prevosto.
Focdoc: The documentation system of foc.
In <EM>Proceedings of the 11th Calculemus Symposium</EM>, Rome, sep
 2003.<BR>
<BR>
<DT><A NAME="CarlierDuboisLNCS2008"><FONT COLOR=purple>[15]</FONT></A><DD>
M.Carlier and C.Dubois.
Functional testing in the focal environment.
In B.Beckert and R.Hähnle, editors, <EM>Tests and Proofs, Second
 International Conference, TAP 2008, Prato, Italy, April 9-11, 2008.
 Proceedings</EM>, volume 4966 of <EM>Lecture Notes in Computer Science</EM>, pages
 84--98. Springer, 2008.<BR>
<BR>
<DT><A NAME="MorissetPhd"><FONT COLOR=purple>[16]</FONT></A><DD>
C.&nbsp;Morisset.
<EM>Sémantique des systèmes de contrôle d'accès</EM>.
PhD thesis, Université Pierre et Marie Curie - Paris 6, 2007.<BR>
<BR>
<DT><A NAME="PrevostoPhD03"><FONT COLOR=purple>[17]</FONT></A><DD>
V.&nbsp;Prevosto.
<EM>Conception et Implantation du langage FoC pour le
 développement de logiciels certifiés</EM>.
PhD thesis, Université Paris 6, sep 2003.<BR>
<BR>
<DT><A NAME="TLCA2005"><FONT COLOR=purple>[18]</FONT></A><DD>
V.&nbsp;Prevosto and S.&nbsp;Boulmé.
Proof contexts with late binding.
In <EM>Typed Lambda Calculi and Applications</EM>, volume 3461 of <EM>LNCS</EM>, pages 324--338. Springer, 2005.<BR>
<BR>
<DT><A NAME="PrevostoJAR02"><FONT COLOR=purple>[19]</FONT></A><DD>
V.&nbsp;Prevosto and D.&nbsp;Doligez.
Algorithms and proof inheritance in the Foc language.
<EM>Journal of Automated Reasoning</EM>, 29(3-4):337--363, dec 2002.<BR>
<BR>
<DT><A NAME="TPHOL2002"><FONT COLOR=purple>[20]</FONT></A><DD>
V.&nbsp;Prevosto, D.&nbsp;Doligez, and T.&nbsp;Hardin.
Algebraic structure and dependent records.
In <EM>TPHOLs'2002</EM>, volume 2410 of <EM>LNCS</EM>. Springer-Verlag,
 2002.<BR>
<BR>
<DT><A NAME="PrevostoJaume2003"><FONT COLOR=purple>[21]</FONT></A><DD>
V.&nbsp;Prevosto and M.&nbsp;Jaume.
Making proofs in a hierarchy of mathematical structures.
In <EM>Proceedings of the 11th Calculemus Symposium</EM>, Rome, sep
 2003.</DL>


<!--TOC chapter Index-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#2de52d"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=6>Index</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->


<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD VALIGN=top ALIGN=left><UL><LI>
;;, <A HREF="#@default78">4.1.1</A>, <A HREF="#@default82">4.1.2</A>, <A HREF="#@default83">4.1.2</A>
<BR>
<BR>
<LI>annotation, <A HREF="#@default7">3.1.3</A>

<UL><LI>
block, <A HREF="#@default9">3.1.3</A>
</UL>
<BR>
<BR>
<LI>bang character, <A HREF="#@default105">4.2.1</A>
<LI>blank, <A HREF="#@default5">3.1.1</A>
<BR>
<BR>
<LI>category of identifiers, <A HREF="#@default15">3.1.4.5</A>
<LI>collection, <A HREF="#@default97">4.1.5</A>

<UL><LI>
parameter, <A HREF="#@default100">4.2.1</A>
</UL>
<LI>comment, <A HREF="#@default6">3.1.2</A>
<LI>compilation unit, <A HREF="#@default1">2.5</A>
<LI>compiler option, <A HREF="#@default125">7</A>
<BR>
<BR>
<LI>defining a prefix operator, <A HREF="#@default22">3.1.4.9</A>
<LI>defining an infix operator, <A HREF="#@default21">3.1.4.9</A>
<LI>defining operators, <A HREF="#@default20">3.1.4.9</A>
<LI>dependency, <A HREF="#@default116">4.4.2</A>

<UL><LI>
decl, <A HREF="#@default117">4.4.2.1</A>
<LI>def, <A HREF="#@default118">4.4.2.2</A>

<UL><LI>
on
 representation, <A HREF="#@default119">4.4.2.2</A>
<LI>on representation, <A HREF="#@default122">4.4.3.2</A>
</UL>
</UL>
<LI>directive
<UL><LI>
coq_require, <A HREF="#@default73">3.2.6.3</A>
<LI>open, <A HREF="#@default32">3.1.12</A>, <A HREF="#@default55">3.2.4.3</A>, <A HREF="#@default72">3.2.6.2</A>
<LI>use, <A HREF="#@default71">3.2.6.1</A>
</UL>
<LI>documentation, <A HREF="#@default8">3.1.3</A>
<BR>
<BR>
<LI>erasing, <A HREF="#@default120">4.4.2.3</A>
<LI>expression, <A HREF="#@default45">3.2.4</A>

<UL><LI>
application, <A HREF="#@default66">3.2.4.8</A>
<LI>constant, <A HREF="#@default47">3.2.4.1</A>
<LI>identifier, <A HREF="#@default50">3.2.4.3</A>
<LI>if, <A HREF="#@default60">3.2.4.6</A>
<LI>let-in, <A HREF="#@default58">3.2.4.4</A>
<LI>literal, <A HREF="#@default46">3.2.4.1</A>
<LI>logical, <A HREF="#@default76">3.2.7.1</A>
<LI>match, <A HREF="#@default63">3.2.4.7</A>
<LI>operator, <A HREF="#@default67">3.2.4.9</A>
<LI>record, <A HREF="#@default68">3.2.4.10</A>

<UL><LI>
clone, <A HREF="#@default69">3.2.4.11</A>
<LI>field, <A HREF="#@default70">3.2.4.12</A>
</UL>
<LI>sum type constructor, <A HREF="#@default48">3.2.4.2</A>
<LI>type, <A HREF="#@default34">3.2.1.2</A>
</UL>
<BR>
<BR>
<LI>field, <A HREF="#@default81">4.1.2</A>
<LI>fixity of identifiers, <A HREF="#@default11">3.1.4.3</A>
<LI>function, <A HREF="#@default89">4.1.2</A>

<UL><LI>
recursive, <A HREF="#@default123">6</A>
</UL>
<LI>functional value, <A HREF="#@default51">3.2.4.3</A>, <A HREF="#@default65">3.2.4.8</A>
<BR>
<BR>
<LI>identifier, <A HREF="#@default10">3.1.4</A>, <A HREF="#@default49">3.2.4.3</A>

<UL><LI>
delimited, <A HREF="#@default26">3.1.5</A>
<LI>extended, <A HREF="#@default25">3.1.5</A>
<LI>operator, <A HREF="#@default18">3.1.4.8</A>
</UL>
<LI>identifier binding, <A HREF="#@default59">3.2.4.4</A>
<LI>if, <A HREF="#@default61">3.2.4.6</A>
<LI>infix identifier, <A HREF="#@default12">3.1.4.3</A>
<LI>infix in prefix position, <A HREF="#@default24">3.1.4.10</A>
<LI>inheritance, <A HREF="#@default109">4.3.1</A>

<UL><LI>
multiple, <A HREF="#@default110">4.3.1</A>
<LI>parametrised by <TT>Self</TT>, <A HREF="#@default113">4.3.1</A>
<LI>parametrised species, <A HREF="#@default111">4.3.1</A>
</UL>
<LI>installation, <A HREF="#@default0">2.4</A>
<LI>interface, <A HREF="#@default96">4.1.4</A>

<UL><LI>
compatibility, <A HREF="#@default102">4.2.1</A>
</UL>
</UL></TD>
<TD VALIGN=top ALIGN=left><UL><LI>late-binding, <A HREF="#@default115">4.4.1</A>
<LI>let-in, <A HREF="#@default57">3.2.4.4</A>
<LI>lexical conventions, <A HREF="#@default4">3.1</A>
<LI>linking files, <A HREF="#@default3">2.5.2</A>
<BR>
<BR>
<LI>match, <A HREF="#@default62">3.2.4.7</A>
<LI>method, <A HREF="#@default80">4.1.2</A>

<UL><LI>
qualification, <A HREF="#@default56">3.2.4.3</A>, <A HREF="#@default104">4.2.1</A>
</UL>
<BR>
<BR>
<LI>name
<UL><LI>
qualification, <A HREF="#@default31">3.1.12</A>, <A HREF="#@default53">3.2.4.3</A>
<LI>resolution, <A HREF="#@default30">3.1.12</A>, <A HREF="#@default52">3.2.4.3</A>, <A HREF="#@default106">4.2.1</A>
</UL>
<LI>nature of identifiers, <A HREF="#@default16">3.1.4.6</A>
<BR>
<BR>
<LI>operator, <A HREF="#@default19">3.1.4.8</A>
<BR>
<BR>
<LI>parameter
<UL><LI>
collection, <A HREF="#@default99">4.2.1</A>
<LI>entity, <A HREF="#@default108">4.2.2</A>
</UL>
<LI>parametrisation, <A HREF="#@default94">4.1.2</A>, <A HREF="#@default98">4.2</A>
<LI>pattern matching, <A HREF="#@default64">3.2.4.7</A>
<LI>polymorphism, <A HREF="#@default93">4.1.2</A>, <A HREF="#@default101">4.2.1</A>
<LI>precedence of identifiers, <A HREF="#@default14">3.1.4.4</A>
<LI>prefix form notation, <A HREF="#@default23">3.1.4.10</A>
<LI>prefix identifier, <A HREF="#@default13">3.1.4.3</A>
<LI>proof, <A HREF="#@default2">2.5.1</A>

<UL><LI>
delayed, <A HREF="#@default91">4.1.2</A>
<LI>step bullet, <A HREF="#@default28">3.1.11</A>
</UL>
<LI>property, <A HREF="#@default75">3.2.7</A>, <A HREF="#@default90">4.1.2</A>
<BR>
<BR>
<LI>qualified name, <A HREF="#@default29">3.1.12</A>
<BR>
<BR>
<LI>recursion, <A HREF="#@default124">6</A>
<LI>regular identifiers, <A HREF="#@default17">3.1.4.7</A>
<LI>representation, <A HREF="#@default84">4.1.2</A>, <A HREF="#@default87">4.1.2</A>

<UL><LI>
declared, <A HREF="#@default86">4.1.2</A>
<LI>defined, <A HREF="#@default85">4.1.2</A>
</UL>
<BR>
<BR>
<LI>scoping, <A HREF="#@default54">3.2.4.3</A>, <A HREF="#@default107">4.2.1</A>
<LI>signature, <A HREF="#@default88">4.1.2</A>
<LI>species, <A HREF="#@default79">4.1.2</A>

<UL><LI>
complete, <A HREF="#@default95">4.1.3</A>
<LI>expression, <A HREF="#@default114">4.3.2</A>
<LI>name, <A HREF="#@default27">3.1.6</A>
</UL>
<LI>sum type, <A HREF="#@default39">3.2.1.3</A>
<BR>
<BR>
<LI>theorem, <A HREF="#@default74">3.2.7</A>, <A HREF="#@default92">4.1.2</A>
<LI>toplevel, <A HREF="#@default77">4.1.1</A>
<LI>tuple, <A HREF="#@default35">3.2.1.2</A>

<UL><LI>
as sum type value constructor arg, <A HREF="#@default41">3.2.1.3</A>
</UL>
<LI>type
<UL><LI>
compatible, <A HREF="#@default44">3.2.2</A>
<LI>definition, <A HREF="#@default36">3.2.1.3</A>

<UL><LI>
alias, <A HREF="#@default37">3.2.1.3</A>
<LI>record, <A HREF="#@default43">3.2.1.3</A>
<LI>sum, <A HREF="#@default38">3.2.1.3</A>
</UL>
<LI>dependent, <A HREF="#@default103">4.2.1</A>, <A HREF="#@default112">4.3.1</A>
<LI>expression, <A HREF="#@default33">3.2.1.2</A>
<LI>recursive, <A HREF="#@default42">3.2.1.3</A>
</UL>
<BR>
<BR>
<LI>value constructor, <A HREF="#@default40">3.2.1.3</A>
<BR>
<BR>
<LI>well-formation, <A HREF="#@default121">4.4.3.1</A>
</UL></TD>
</TR></TABLE>
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2>
<BLOCKQUOTE><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html"><EM>H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</EM></A><EM>.
</EM></BLOCKQUOTE>
</BODY>
</HTML>
