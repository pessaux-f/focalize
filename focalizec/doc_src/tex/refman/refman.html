<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>The FoCaLize system, release 1.0.0
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
BODY{background:white;}
.title{padding:1ex;background:#00B200;}
.titlemain{padding:1ex;background:#00B200;}
.titlerest{padding:1ex;background:#00B200;}
.part{padding:1ex;background:#00CC00;}
.section{padding:.5ex;background:#66FF66;}
.subsection{padding:0.3ex;background:#7FFF7F;}
.subsubsection{padding:0.5ex;background:#98FF98;}
.chapter{padding:0.5ex;background:#2DE52D;}
.fmarginpar{border:solid thin #7FFF7F; width:20%; text-align:left;}
.ffootnoterule{border:none;margin:1em auto 1em 0px;width:50%;background:#00CC00;}
.ftoc1{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #00CC00;}
.ftoc2{list-style:none;margin:1ex 1ex;padding:0ex 1ex;border-left:1ex solid #2DE52D;}
.ftoc3{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #66FF66;}
.ftoc4{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #7FFF7F;}
.ftoc5{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #98FF98;}
.ftoc6{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #CCFFCC;}
</STYLE>
</HEAD>
<BODY TEXT=black BGCOLOR=white>
<!--HEVEA command line is: hevea -fix macros.hva syntaxdef.hva refman.hva refman.tex -->
<!--CUT DEF chapter 1 --><P><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</P><DIV CLASS="center"><P><FONT SIZE=7><B><FONT COLOR=purple>FoCaLize</FONT></B></FONT></P><P><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</P><P><FONT SIZE=7><B>Reference Manual</B></FONT></P><P><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</P><P><FONT SIZE=5><B><FONT COLOR=purple>1.0.0</FONT></B></FONT><FONT SIZE=5> </FONT></P><P><BR>
<BR>
<BR>
</P><P><FONT SIZE=5><B><FONT COLOR=purple>January 2009</FONT></B></FONT></P><P><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</P><P><FONT SIZE=5><B>Authors</B></FONT></P><P> <BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</P><P><FONT SIZE=4><EM>Thérèse Hardin,
François Pessaux,
Pierre Weis,
Damien Doligez
</EM></FONT>
</P></DIV><DIV CLASS="center">
<FONT SIZE=7><B>About </B></FONT><FONT SIZE=7><B><FONT COLOR=purple>FoCaLize</FONT></B></FONT>
</DIV><P><BR>
<BR>
</P><P><FONT SIZE=4><EM><FONT COLOR=purple>FoCaLize</FONT></EM></FONT><FONT SIZE=4><EM> is the result of a collective work of several researchers,
listed in the following, who designed, defined, compiled, studied, extended,
used and debugged the preceding versions. They were helped by many
students who had a summer internship under their supervision. They
would like to thank all these students and more generally all the
persons who brought some contribution to </EM></FONT><FONT SIZE=4><EM><FONT COLOR=purple>FoCaLize</FONT></EM></FONT><FONT SIZE=4><EM>. </EM></FONT></P><P><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</P><DIV CLASS="center">
<FONT SIZE=5><B> </B></FONT><FONT SIZE=5><B><FONT COLOR=purple>FoCaLize</FONT></B></FONT><FONT SIZE=5><B> contributors</B></FONT>
 <BR>
<BR>
<BR>
<BR>
<BR>
<BR>

</DIV><P><FONT SIZE=4>Philippe Ayrault (SPI-LIP6), William Bartlett (CPR-CEDRIC), Julien
Blond (SPI-LIP6), Sylvain Boulmé (SPI-LIP6), Matthieu Carlier
(CPR-CEDRIC), Damien Doligez (GALLIUM-INRIA), David Delahaye
(CPR-CEDRIC), Catherine Dubois (CPR-CEDRIC), Jean-Frédéric Etienne
(CPR-CEDRIC), Stéphane Fechter (SPI-LIP6), Eric Jaeger (SPI-LIP6), Mathieu Jaume (SPI-LIP6), Lionel Habib (SPI-LIP6), Thérèse Hardin (SPI-LIP6), Charles
Morisset (SPI-LIP6), Ivan Noyer (SPI-LIP6), François Pessaux
(SPI-LIP6), Virgile Prevosto (SPI-LIP6), Renaud Rioboo (CPR-CEDRC),
Lien Tran (SPI-LIP6), Véronique Viguié Donzeau-Gouge (CPR-CNAM),
Pierre Weis (ESTIME-INRIA)</FONT></P><P><BR>
<BR>
</P><DIV CLASS="center">
<FONT SIZE=4><B>and their institutions</B></FONT>
 <BR>
<BR>
<BR>
<BR>
<BR>
<BR>

</DIV><P><EM>SPI (Semantics, Proofs and Implementations) is a team of LIP6,
(Laboratoire d&#X2019;Informatique de Paris 6) of UPMC (Pierre and Marie Curie
University)</EM><SUP><A NAME="text1" HREF="#note1"><EM>1</EM></A></SUP><EM>.</EM></P><P><BR>
<BR>
</P><P><EM>CPR (Conception et Programmation Raisonnées) is a team of CEDRIC
(Centre d&#X2019;Etudes et de Recherches du CNAM) of CNAM (Conservatoire National
des Arts et Métiers)</EM><SUP><A NAME="text2" HREF="#note2"><EM>2</EM></A></SUP><EM> and ENSIIE (Ecole Nationale d&#X2019;Informatique pour
l&#X2019;Industrie et l&#X2019;Entreprise)</EM><SUP><A NAME="text3" HREF="#note3"><EM>3</EM></A></SUP><EM>. </EM></P><P><BR>
<BR>
<EM>ESTIME and GALLIUM are teams of INRIA Rocquencourt</EM><SUP><A NAME="text4" HREF="#note4"><EM>4</EM></A></SUP><EM>
</EM></P><P><BR>
<BR>
</P><P><BR>
<BR>
</P><DIV CLASS="center">
<FONT SIZE=5><B>Thanks</B></FONT>
 <BR>
<BR>
<BR>
<BR>
<BR>
<BR>

</DIV><P>The <FONT COLOR=purple>Foc</FONT> project was first partially supported by LIP6 (Projet Foc, LIP6
1997) then by the Ministry of Research (Action Modulogic).
The <FONT COLOR=purple>Focal</FONT> research team was then partially supported by the French SSURF ANR project
ANR-06-SETI-016 (Safety and Security UndeR Focal). The project also
benefited of strong collaborations with EDEMOI ANR project and with
BERTIN and SAFERIVER companies.</P><P>The <FONT COLOR=purple>FoCaLize</FONT> language and compiler development effort started around 2005.
The architecture conception and code rewritting started from scratch in 2006
to finally make the first focalizec compiler and <FONT COLOR=purple>FoCaLize</FONT> system
distribution in 2009, January.</P><P>This manual documents the completely revised system with the new syntax and
its semantics extensions.</P><!--BEGIN NOTES chapter-->
<HR CLASS="ffootnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes">UPMC-LIP6,
104 avenue du Président Kennedy, Paris 75016, France,
<TT>Firstname.Lastname@lip6.fr</TT>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note2" HREF="#text2">2</A></DT><DD CLASS="dd-thefootnotes">CNAM-CEDRIC,
292 rue Saint Martin, 75003, Paris, France,
<TT>Firstname.Lastname@cnam.fr</TT>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note3" HREF="#text3">3</A></DT><DD CLASS="dd-thefootnotes">ENSIIE-CEDRIC,
1 Square de la Résistance, 91025 Evry Cedex, France,
<TT>Lastname@ensiie.fr</TT>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note4" HREF="#text4">4</A></DT><DD CLASS="dd-thefootnotes">INRIA,
Bat 8. Domaine de Voluceau, Rocquencourt, BP 105, F-78153 Le
Chesnay, France, <TT>Firstname.Lastname@inria.fr</TT>
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Contents-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Contents</H1><!--SEC END --><UL CLASS="ftoc1"><LI CLASS="li-toc">
<A HREF="#htoc1">Chapter 1  Overview</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc2">1.1  The Basic Brick</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc3">1.2  Type of Species, Interfaces and Collections</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">1.3  Combining Bricks by Inheritance</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">1.4  Combining Bricks by Parameterisation</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc6">1.4.1  Parameterisation by Collection</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc7">1.4.2  Parameterisation by Entity (Value)</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">1.5  The Final Brick</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc9">1.6  Properties, Theorems and Proofs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">1.7  Around the Language</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc11">1.7.1  Consistency of the Software</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">1.7.2  Code Generation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc13">1.7.3  Tests</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">1.7.4  Documentation</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc15">Chapter 2  Installing and Compiling</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc16">2.1  Required software</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc17">2.2  Optional software</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">2.3  Operating systems</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">2.4  Installation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc20">2.5  Compilation process and outputs</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc21">2.5.1  Outputs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">2.5.2  Compiling a source</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc23">Chapter 3  The core language</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc24">3.1  Lexical conventions</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc25">3.1.1  Blanks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">3.1.2  Comments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc27">3.1.3  Annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">3.1.4  Identifiers</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc29">3.1.4.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc30">3.1.4.2  Conceptual properties of names</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc31">3.1.4.3  Fixity of identifiers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc32">3.1.4.4  Precedence of identifiers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">3.1.4.5  Categorization of identifiers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc34">3.1.4.6  Nature of identifiers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc35">3.1.4.7  Regular identifiers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">3.1.4.8  Infix/prefix operators</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc37">3.1.4.9  Defining an infix operator</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc38">3.1.4.10  Prefix form notation</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc39">3.1.5  Extended identifiers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">3.1.6  Species and collection names</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">3.1.7  Integer literals</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc42">3.1.8  String literals</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc43">3.1.9  Character literals</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc44">3.1.10  Floating-point number literals</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">3.1.11  Proof step bullets</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc46">3.1.12  Name qualification</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc47">3.1.13  Reserved keywords</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc48">3.2  Language constructs and syntax</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc49">3.2.1  Types</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc50">3.2.1.1  Type constructors</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc51">3.2.1.2  Type expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc52">3.2.1.3  Type definitions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">3.2.2  Type-checking</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc54">3.2.3  Representations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc55">3.2.4  Expressions</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc56">3.2.4.1  Literal expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">3.2.4.2  Sum type value constructor expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc58">3.2.4.3  Identifier expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc59">3.2.4.4  <TT>let-in</TT> expression</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc60">3.2.4.5  <TT>logical let</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc61">3.2.4.6  Conditional expression</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">3.2.4.7  Match expression</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">3.2.4.8  Application expression</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc64">3.2.4.9  Operator application expression</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc65">3.2.4.10  Record expression</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc66">3.2.4.11  Cloning a record expression</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc67">3.2.4.12  Record field access expression</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc68">3.2.4.13  Parenthesised expression</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc69">3.2.5  Core language expressions and definitions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc70">3.2.6  Files and uses directives</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc71">3.2.6.1  The <TT>use</TT> directive</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc72">3.2.6.2  The <TT>open</TT> directive</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc73">3.2.6.3  The <TT>coq_require</TT> directive</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc74">3.2.7  Properties, theorems and proofs</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc75">3.2.7.1  Logical expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc76">3.2.7.2  Properties</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc77">3.2.7.3  Proofs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc78">3.2.7.4  Theorems</A>
</LI></UL>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc79">Chapter 4  The <FONT COLOR=purple>FoCaLize</FONT> model</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc80">4.1  Basic concepts</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc81">4.1.1  Top-level Definitions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc82">4.1.2  Species</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc83">4.1.3  Complete species</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc84">4.1.4  Interfaces</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc85">4.1.5  Collections</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc86">4.2  Parametrisation</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc87">4.2.1  Collection parameters</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc88">4.2.2  Entity parameters</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc89">4.3  Inheritance and its mechanisms</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc90">4.3.1  Inheritance</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc91">4.3.2  Species expressions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc92">4.4  Late-binding and dependencies</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc93">4.4.1  Late-binding</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc94">4.4.2  Dependencies and erasing</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc95">4.4.2.1  Decl-dependencies</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc96">4.4.2.2  Def-dependencies</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc97">4.4.2.3  Erasing during inheritance</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc98">4.4.2.4  Dependencies on collection parameters</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc99">4.4.3  More about methods definition</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc100">4.4.3.1  Well-formation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc101">4.4.3.2  Def-dependencies on the representation</A>
</LI></UL>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc102">Chapter 5  The <FONT COLOR=purple>FoCaLize</FONT> Proof Language</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc103">5.1  Proofs of theorems</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc104">5.1.1  Scoping rules</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc105">Chapter 6  Recursive function definitions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc106">Chapter 7  Compiler options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc107">Chapter 8  Documentation generation</A>
<UL CLASS="ftoc2">
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc108">8.0.2  Special tags</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc109">8.0.2.1  @title</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc110">8.0.2.2  @author</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc111">8.0.2.3  @description</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc112">8.0.2.4  @mathml</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc113">8.0.3  Transforming the generated documentation file</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc114">8.0.3.1  XML to HTML</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc115">8.0.4  XML to LaTeX</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc116">Chapter 9  Hacking deeper</A>
<UL CLASS="ftoc2">
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc117">9.0.5  Interfacing <FONT COLOR=purple>FoCaLize</FONT> with other languages</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc118">9.0.6  Dealing with hand-written <FONT COLOR=purple>Coq</FONT> proofs</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc119">Chapter 10  Compiler error messages</A>
</LI></UL><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR -->Introduction</H2><!--SEC END --><!--TOC subsection Motivations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Motivations</H3><!--SEC END --><P>The <FONT COLOR=purple>Foc</FONT> project was launched in 1998 by T. Hardin and R. Rioboo
[<A HREF="#HardinRiobooTSI04">10</A>] <SUP><A NAME="text5" HREF="#note5">5</A></SUP>
with the objective of helping all stages of development of critical software
within safety and security domains. The methods used in these domains
are evolving, ad-hoc and empirical approaches being replaced by more formal
methods. For example, for high levels of safety, formal models of the
requirement/specification phase are more and more considered as they
allow mechanized proofs, test or static analysis of the required
properties. In the same way, high level assurance in system security asks for
the use of true formal methods along the process of software
development and is often required for the specification level.
Thus the project was to elaborate an Integrated
Development Environment (IDE) able to provide high-level and justified
confidence to users, but remaining easy to use by well-trained
engineers.</P><P>To ease developing high integrity systems with numerous software
components, an IDE should provide
tools to formally express specifications, to describe design and
coding and to ensure that specification requirements are met by the
corresponding code. But this is not enough. First, standards of critical systems
ask for pertinent documentation which has to be maintained along all the revisions
during the system life cycle. Second, the evaluation conformance
process of software is by nature a skeptical analysis. Thus, any proof
of code correctness must be easily redone at request and traceability
must be eased. Third, design
and coding are difficult tasks. Research in software engineering has
demonstrated the help provided by some object-oriented
features as inheritance, late binding and early research works on
programming languages have pointed out the importance of abstraction
mechanisms such as modularity to help invariant preservation. There are
a lot of other points which should also be considered when designing
an IDE for safe and/or secure systems to ensure conformance with high
Evaluation Assurance or Safety Integrity Levels (EAL-5 to 7 or SIL 3 and 4)
and to ease the evaluation process according to various standards
(e.g. IEC61508, CC, ...): handling of non-functional contents of
specification, handling of dysfunctional behaviors and vulnerabilities
from the true beginning of development as well as fault avoidance and fault
detection by validation testing, vulnerability and safety analysis.</P><!--TOC subsection Initial application testbed-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Initial application testbed</H3><!--SEC END --><P>When the <FONT COLOR=purple>Foc</FONT> project was launched by T. Hardin and R. Rioboo,
only the specific domain of Computer Algebra was initially considered.
Algorithms used in this domain can be rather intricated and
difficult to test and this is not rare that computer algebra systems
issue a bad result, due to semantical flaws, compiler anomalies,
etc. Thus the idea was to design a language allowing to specify the
mathematics underlying these algorithms and to go step by step to
different kinds of implementations according to the specifities of the
problem under consideration<SUP><A NAME="text6" HREF="#note6">6</A></SUP>. The first step was to design
the semantics of such a language, trying to fit to several
requirements: easing the expression of mathematical statements, clear
distinction between the mathematical structure (semi-ring, polynomial,
..) and its different implementations, easing the development
(modularity, inheritance, parametrisation, abstraction, ..), runtime
efficiency and confidence in the whole development (mechanised proofs,
..). After an initial phase of conceptual design, the <FONT COLOR=purple>Foc</FONT>
semantics was submitted to a double test. On one hand, this semantics
was specified in <FONT COLOR=purple>Coq</FONT> and in a categorical model of type theories by
S. Boulmé (see his thesis [<A HREF="#BoulmePhD00">3</A>]), a point which
enlightened the borders of this approach, regarding the logical background. On the other hand, as a preliminary step before designing the syntax,
a strudy of the typical development style was conducted.
R. Rioboo [<A HREF="#ThRRCalculemus">4</A>, <A HREF="#HardinRiobooTSI04">10</A>] used the
<FONT COLOR=purple>OCaml</FONT> language to try different solutions, recorded in
 [<A HREF="#HardinRiobooTSI04">10</A>].</P><!--TOC subsection Initial <FONT COLOR=purple>Focal</FONT> design-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Initial <FONT COLOR=purple>Focal</FONT> design</H3><!--SEC END --><P>Then the time came to design the syntax of the language and the compiler. To
overcome inconsistencies risks, an original dependency analysis was
incorporated into the compiler (V. Prevosto
thesis [<A HREF="#PrevostoPhD03">17</A>, <A HREF="#TPHOL2002">20</A>, <A HREF="#PrevostoJAR02">19</A>]) and the correction of the
compiler (mostly written by V. Prevosto) against <FONT COLOR=purple>Focal</FONT>&#X2019;s semantics is
proved (by hand) [<A HREF="#TLCA2005">18</A>], a point which
brings a satisfactory confidence in the language&#X2019;s correctness. Then
R. Rioboo [] began the development of a huge Computer Algebra library, offering full specification
and implementation of usual algebraic structures up to multivariate
polynomial rings with complex algorithms, to
extensively test the language and the
efficiency of the produced code, aswell as to provide a standard library
of mathematical backgrounds. D. Doligez [<A HREF="#ZenonBDD">2</A>] started the
development of <FONT COLOR=purple>Zenon</FONT>, an automatic prover based on tableaux method,
which takes a <FONT COLOR=purple>Focal</FONT> statement and tries to build a proof of it and,
when succeeds, issues a <FONT COLOR=purple>Coq</FONT> term. More recently, M. Carlier and
C. Dubois[<A HREF="#CarlierDuboisLNCS2008">15</A>] began the development of a
test tool for <FONT COLOR=purple>Focal</FONT>.</P><P><FONT COLOR=purple>Focal</FONT> has already been used to develop huge examples such as the
standard library and the computer algebra library. The library
dedicated to the algebra of access control models, developed by
M. Jaume and C. Morisset [<A HREF="#jias06">12</A>, <A HREF="#fcsarspa06">13</A>, <A HREF="#MorissetPhd">16</A>],
is another huge example, which borrows implementations of orderings,
lattices and boolean algebras from the computer algebra library.
<FONT COLOR=purple>Focal</FONT> was also very successfully used to formalize airport security
regulations, a work by D. Delahaye, J.-F. Etienne, C. Dubois,
V. Donzeau-Gouge  [<A HREF="#EDEMOI-All">6</A>, <A HREF="#EDEMOI-Model">7</A>, <A HREF="#EDEMOI-Proof">8</A>]. This
last work led to the development of a translator [<A HREF="#Focal-UML">5</A>]
from <FONT COLOR=purple>Focal</FONT> to UML for documentation purposes.</P><!--TOC subsection The <FONT COLOR=purple>FoCaLize</FONT> system-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->The <FONT COLOR=purple>FoCaLize</FONT> system</H3><!--SEC END --><P>The <FONT COLOR=purple>FoCaLize</FONT> development started in 2006, as a
continuation of the <FONT COLOR=purple>Foc</FONT> and <FONT COLOR=purple>Focal</FONT> efforts. The new system was rewritten
from scratch. A new language and syntax was designed and carefully
implemented, with in mind ease of use, expressivity, and programmer
friendlyness. The addition of powerful data structure definitions &#X2013; together
with the corresponding pattern matching facilities &#X2013; leads to new expressive
power.</P><P>The <FONT COLOR=purple>Zenon</FONT> automatic theorem prover was also integrated in the
compiler and natively interfaced within the <FONT COLOR=purple>FoCaLize</FONT> language. New
developments for a better support of recursive functions is on the way (in particular for
termination proofs).</P><!--TOC subsection The <FONT COLOR=purple>FoCaLize</FONT> system in short-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->The <FONT COLOR=purple>FoCaLize</FONT> system in short</H3><!--SEC END --><P>The <FONT COLOR=purple>FoCaLize</FONT> system provides means for the developers to formally express
their specifications and to go step by step (in an incremental approach) to
design and implementation while proving that such an implementation
meets its specification or design requirements. The <FONT COLOR=purple>FoCaLize</FONT> language offers
high level mechanisms such as multiple inheritance, late binding, redefinition,
parametrization, etc. Confidence in proofs submitted by developers or
automatically done relies on formal proof verification. <FONT COLOR=purple>FoCaLize</FONT> also
provides some automation of documentation production and management.</P><P>A formal specification can be built by declaring names of functions
and values and introducing
properties. Then, design and implementation can incrementally be done
by adding definitions of functions and proving that the implementation
meets the specification or design requirements. Thus, developing in
<FONT COLOR=purple>FoCaLize</FONT> is a kind of refinement process from formal model to design
and code, completely done within <FONT COLOR=purple>FoCaLize</FONT>. Taking the global development
in consideration within the same environment brings some conciseness,
helps documentation and reviewing.</P><P>A <FONT COLOR=purple>FoCaLize</FONT> development is organised as a hierarchy that may have
several roots. The upper levels of the hierarchy are built along the
specification stage while the lower ones correspond to
implementation and each node of the hierarchy corresponds to a progress
toward a complete implementation.</P><P>We would like to mention several works about safety and/or security
concerns within <FONT COLOR=purple>FoCaLize</FONT> and specially the definition of a safety life
cycle by P. Ayrault, T. Hardin and F. Pessaux [<A HREF="#TTSS08">1</A>] and the
study of some traps within formal methods by E. Jaeger and
T. Hardin[<A HREF="#traps">11</A>].</P><P><FONT COLOR=purple>FoCaLize</FONT> can be seen as an IDE still in development, which
gives a positive solution to the three requirements identified above:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
pertinent documentation is maintained within the system being written,
and its extraction is an automatic part of the compilation process,
</LI><LI CLASS="li-enumerate">proofs are produced using an automated proved which can be guided using a high level proof language, so that proofs
are easier to write and their verification is automatic and reliable,
</LI><LI CLASS="li-enumerate">the framework provides powerful abstraction mechanisms to facilitate
design and development; however, these mechanisms are carefully ruled:
the compiler performs numerous validity checks to ensure that no
further development can inadvertantly break the invariants or
invalidate the proofs; indeed, the compiler ensures that if a theorem
was based on assumptions that are now violated by the new development,
then the theorem is out of reach of the programmer and the properties have to be proven again.
</LI></OL><!--BEGIN NOTES chapter-->
<HR CLASS="ffootnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note5" HREF="#text5">5</A></DT><DD CLASS="dd-thefootnotes">They were members of the SPI (Semantics, Proofs,
Implementations) team of the LIP6 (Lab. Informatique de Paris 6)
at Université Pierre et Marie Curie (UMPC), Paris
</DD><DT CLASS="dt-thefootnotes"><A NAME="note6" HREF="#text6">6</A></DT><DD CLASS="dd-thefootnotes">For example Computer Algebra
Libraries use different representations of polynomials
according to the treatment to be done
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Overview-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc1">Chapter 1</A>  Overview</H1><!--SEC END --><P> <A NAME="glimpse"></A>
Before entering the precise description of <FONT COLOR=purple>FoCaLize</FONT> we give an
informal 
presentation of its main features, to help further reading of the
reference manual. Every construction or feature of <FONT COLOR=purple>FoCaLize</FONT> is
entirely and precisely described in the following chapters.</P><!--TOC section The Basic Brick-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">1.1</A>  The Basic Brick</H2><!--SEC END --><P>The primitive entity of a <FONT COLOR=purple>FoCaLize</FONT> development is the
<EM>species</EM>. It can be viewed as a record grouping &#X201C;things&#X201D; related
to a same concept. Like in most modular design systems (i.e. objected 
oriented, algebraic abstract types) the idea is to group a data
structure with the operations to process it. Since in <FONT COLOR=purple>FoCaLize</FONT> we don&#X2019;t
only address data type and operations, among these &#X201C;things&#X201D; we also
find the declaration (specification) of these operations, the
properties (which may represent 
requirements) and their proofs. </P><P>We now describe each of these &#X201C;things&#X201D;, called <EM>methods</EM>.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The
<TT>representation</TT> gives the data representation of entities
manipulated by the <EM>species</EM>. It is a type
defined by a type expression. 
The <EM>representation</EM> definition may be deferred,
meaning that the real structure of the data-type the <EM>species</EM>
embeds does not need to be known at this point. In this case, it is
simply a type variable. However, to obtain an
implementation, the <EM>representation</EM>
has to be defined later either by setting <TT>representation = exp</TT> where
<TT>exp</TT> is a type expression or by inheritance (see below).
Type expressions in <FONT COLOR=purple>FoCaLize</FONT> are roughly ML-like types (variables,
basic types, inductive types, record types).
<P>Each <EM>species</EM> has a unique <EM>representation</EM>. This
is not a restriction compared to other languages where
programs/objects/modules can own several private variables
representing the internal state, hence the data structure of the
manipulated entities by the program/object/module. In such a case,
the <EM>representation</EM> is simply the tuple grouping all these
variables that were disseminated all along the
program/object/module.</P></LI><LI CLASS="li-itemize">Declarations are composed of the keyword <TT>signature</TT>
followed by a name and a type. They announce a <EM>method</EM> to
be defined later (the type is given but not yet the
implementation).
Declaration can however be used in definition of other methods: the type provided by
the <EM>signature</EM> allows <FONT COLOR=purple>FoCaLize</FONT> to ensure
that the method is used in contexts compatible with this
type. The late-binding and the collection mechanisms, further
introduced, ensure that the definition of the method will be
effectively known when needed.</LI><LI CLASS="li-itemize">Definitions are composed of the keyword <TT>let</TT>, followed
by a name, a type (optional) and an expression. They serve to introduce
constants or functions, i.e. computational operations. The core
language used to implement them is roughly ML-like expressions
(let-binding, pattern matching, conditional, higher order
functions, &#X2026;) with the addition of a construction to call a
<EM>method</EM> from a given <EM>species</EM>. Mutually recursive
definitions are introduced by <TT>let rec</TT>.</LI><LI CLASS="li-itemize">Statements are composed of the keyword <TT>property</TT>
followed by a name and a first-order
formula. A <EM>property</EM> may serve to express requirements
(i.e. facts that the system must hold to conform to the Statement
of Work) and then can be viewed as a
specification purpose <EM>method</EM>, like <EM>signature</EM>s were for
<TT>let</TT>-<EM>method</EM>s. They induce a proof obligation to be discharged at some point
in the development. A <EM>property</EM> may also be used to express
some &#X201C;quality&#X201D; information of the system (soundness,
correctness, ..) also submitted to a proof obligation. Formulae are written with usual logical connectors, universal and
existential quantifications over a <FONT COLOR=purple>FoCaLize</FONT> type, and name of <EM>methods</EM> known within the <EM>species</EM>&#X2019; context. For instance,
a <EM>property</EM> telling that for any vehicle, if the speed is non-null, then doors
can&#X2019;t be opened could look like:
<DIV CLASS="center">
<TT>all m in Self, !speed(m) &lt;&gt; Speed!zero -&gt; </TT><TT>~</TT><TT>doors_open(m)</TT>
</DIV>
In the same way as <EM>signatures</EM>, a yet to be proved <EM>property</EM>
can be used
as an hypothesis in
proof of other properties or theorems. <FONT COLOR=purple>FoCaLize</FONT> late binding and collection mechanisms ensure
that the proof of a <EM>property</EM> will be ultimately done.</LI><LI CLASS="li-itemize">Theorems (<TT>theorem</TT>) made of a name, a statement and a
proof are <EM>properties</EM> together with the formal proof that their
statement holds in the context of the <EM>species</EM>. The proof
accompanying the statement will be processed by <FONT COLOR=purple>FoCaLize</FONT>  <FONT COLOR=purple>Zenon</FONT> and
ultimately checked with the theorem prover <FONT COLOR=purple>Coq</FONT>.</LI></UL><P>Regarding properties and theorems, note that
like in any formal development, the difficulty may be more to
express a true, interesting and meaningful
statement, than to prove it. For instance, claiming that a piece of software is
&#X201C;formally proved&#X201D; because it respects a safety requirement
is meaningless
if the statement of this requirement is trivially true (see [<A HREF="#traps">11</A>] for examples).
</P><P>Let&#X2019;s illustrate these notions on an example that we incrementally
extend. We want to model some simple algebraic structures. Let&#X2019;s start
with the description of a &#X201C;setoid&#X201D; representing the data structure of
&#X201C;things&#X201D; belonging to a set, which can be submitted to an
equality test and
exhibited (i.e. one can get a witness of existence of one of these
&#X201C;things&#X201D;).</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Setoid</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> ( = ) : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>element</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>refl</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>symm</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>trans</FONT><FONT SIZE=2>: </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>=</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>and</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>=</FONT><FONT SIZE=2>z</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>=</FONT><FONT SIZE=2>z</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>different</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>basics</FONT><FONT SIZE=2>#</FONT><FONT SIZE=2>not_b</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>theorem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>different_irrefl</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, ~</FONT><FONT SIZE=2>different</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>by</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>definition</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>of</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>different</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>              </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>refl</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>In this <EM>species</EM>, the <EM>representation</EM> is not explicitly
given (the keyword <TT>representation</TT> is not used) , since we don&#X2019;t need to set
it to be able to express functions and properties our &#X201C;setoid&#X201D;
requires. However, we can refer to it via <TT>Self</TT>
(in this case a type variable). In the same way, we specify a <EM>signature</EM> for the
equality (operator <TT>=</TT>). We introduce the three properties that
an equality (an equivalence relation) must conform to.</P><P>We complete the example by the definition of
the function <TT>different</TT> which use the name <TT>=</TT>
(<TT>basics#not_b</TT> stands for the
the boolean negation function defined in the <FONT COLOR=purple>FoCaLize</FONT>
source file <TT>basics.fcl</TT>). It is possible right now to prove that
<TT>different</TT> is irreflexive, under the hypothesis that <TT>=</TT> is an
equivalence relation (i.e. that any implementation of <TT>=</TT> used by
<TT>different</TT> will satisfy these properties). </P><P><BR>
<BR>
</P><P>It is possible to use <EM>methods</EM> only declared before they get a
real <EM>definition</EM> thanks to the <EM>late-binding</EM> feature
provided by <FONT COLOR=purple>FoCaLize</FONT>. In the same idea, redefining a <EM>method</EM> is
allowed in <FONT COLOR=purple>FoCaLize</FONT> 
the last version being always kept as the effective <EM>definition</EM>
inside the species.</P><!--TOC section Type of Species, Interfaces and Collections-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc3">1.2</A>  Type of Species, Interfaces and Collections</H2><!--SEC END --><P>
<A NAME="species-type"></A>
<A NAME="species-interface"></A>
The <EM>type</EM> of a <EM>species</EM> is obtained by removing definitions
and proofs. Thus, it is a kind of record type, made of all the method
types of the species. If the <TT>representation</TT> is still a type
variable say &#X3B1;, then the <EM>species</EM> type is prefixed with an
existential binder &#X2203; &#X3B1;. This binder will be eliminated as
soon as the <TT>representation</TT> will be instantiated (defined) and
must be eliminated to obtain runnable code.</P><P><BR>
<BR>
</P><P>The <EM>interface</EM> of a species is obtained by abstracting the <EM>representation</EM> type in the <EM>species type</EM>; this abstraction
is permanent.</P><P><BR>
<BR>
</P><P><B>Warning</B> <EM>No special construction
is given to denote the interface of a species in the concrete syntax,
it is simply denoted by the name of the species.</EM> Do not
confuse a species and its interface.</P><P><BR>
<BR>
</P><P>The <EM>species type</EM> remain totally implicit in the concrete syntax, being
just used as a step to build <EM>species interface</EM>. It is used
during inheritance resolution. </P><P>Interfaces can be ordered by inclusion, a point providing a very
simple notion of subtyping. This point will be further commented. </P><P>A species is said to be <EM>complete</EM> when the representation and all declarations have
received a definition and all properties have received a proof.</P><P>When <EM>complete</EM>, a species can be submitted to an abstraction
process of its representation to create a <EM>collection</EM>. Thus the
<EM>interface</EM> of the collection is just the <EM>interface</EM> of the
complete species underlying it. A collection can hence be seen as an
abstract data type, only usable through the methods of its interface,
but having the guarantee that all declarations are defined and all statements are proved.</P><!--TOC section Combining Bricks by Inheritance-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc4">1.3</A>  Combining Bricks by Inheritance</H2><!--SEC END --><P>A <FONT COLOR=purple>FoCaLize</FONT> development is organised as a hierarchy which may have
several roots. Usually the upper levels of the hierarchy are built
during the specification stage while the lower ones correspond to
implementations. Each node of the hierarchy, i.e. each <EM>species</EM>,
is a progress towards a complete implementation. On the previous 
example, putting aside <TT>different</TT>, we typically presented a kind of
<EM>species</EM> for &#X201C;specification&#X201D; since it expresses only
<EM>signatures</EM> of functions to be later implemented and properties
to be later proved.</P><P>We can now create a new <EM>species</EM> by
<B>inheriting</B> of a previously defined one. We can make this new species more
&#X201C;complex&#X201D; by adding new operations and properties, or we can make it more concrete
by providing definitions to <EM>signatures</EM> and proofs
to <EM>properties</EM>, without adding new features.</P><P>Hence, in <FONT COLOR=purple>FoCaLize</FONT> inheritance serves two kinds of evolutions. In the
first case the evolution aims making a <EM>species</EM> with more
operations while keeping those of its parents (possibly redefining some of
them if required). In the second case, the <EM>species</EM> only tends to be closer
to a &#X201C;runnable&#X201D; implementation, providing explicit definitions to
<EM>methods</EM> that were previously only declared.</P><P>Continuing our example, we want to extend our model to represent
&#X201C;things&#X201D; with a multiplication and a neutral element for this
operation.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Monoid</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Setoid</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> ( * ) : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>one</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>element</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>one</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>one</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P><EM>Monoid</EM> are &#X201C;things&#X201D; that are <EM>Setoids</EM> but also have an operation <TT>*</TT> and a specific value called <EM>one</EM>; besides the new <EM>methods</EM> we also gave a definition
to <TT>element</TT>, saying it is the application of the method <TT>*</TT>
to <TT>one</TT> twice, both of them being only <EM>declared</EM>. Here, we
used the inheritance in both the presented ways: making a more complex
entity by adding <EM>methods</EM> and getting closer to the
implementation by explicitly defining <TT>element</TT>.</P><P>Multiple inheritance is available in <FONT COLOR=purple>FoCaLize</FONT>. For sake of simplicity,
the above example uses simple inheritance. In case of inheriting a
<EM>method</EM> from several parents, the order of parents in the
<TT>inherit</TT> clause serves to determine the chosen <EM>method</EM> (only
the latest definition of any method appearing several times in the
list of inherited species is retained).</P><P>The <EM>type</EM> of a <EM>species</EM> built using inheritance is defined
like for other <EM>species</EM>, the <EM>method</EM> types retained inside
it being those of the <EM>methods</EM> present in the <EM>species</EM> after
inheritance resolution.</P><P>A strong constraint in inheritance is that the type of inherited,
and/or redefined <EM>methods</EM> must not change. This is required to
ensure consistency of the <FONT COLOR=purple>FoCaLize</FONT> model, hence of the developed
software. More precisely, if the representation is given by a type
expression containing some type variables, then it can be more defined
by instanciation of these variables. In the same way, two signatures
have compatible types if they have a common unifier, thus, roughly
speaking if they are compatible ML-like types. For example, if the
representation was not yet defined, thus being still a type variable,
it can be defined by <TT>int</TT>. And if a species <I>S</I> inherits from
<I>S</I><SUB>1</SUB> and <I>S</I>2 a method called <I>m</I>, there is no type clash if <I>S</I><SUB>1</SUB> !<I>m</I>
and <I>S</I><SUB>2</SUB>!<I>m</I> can be unified, then the method <I>S</I>!<I>m</I> has the most general
unifier of these two types as its own type. </P><P>In a nutshell, if a species <EM>B</EM> inherits from a species <EM>A</EM>, the intuition is that any instance of <EM>B</EM> is also an instance of <EM>A</EM>.</P><!--TOC section Combining Bricks by Parameterisation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc5">1.4</A>  Combining Bricks by Parameterisation</H2><!--SEC END --><P>As indicated, inheritance is used to enrich or to implement <EM>species</EM>.
However, we sometimes need to use a <EM>species</EM>, not to take over
its <EM>methods</EM>, but rather to use it as an &#X201C;ingredient&#X201D; to build
a new structure. For instance, a product of setoids is a
new structure, using the previous <EM>species</EM> as the &#X201C;ingredient&#X201D;.
Indeed, the structure of a product is not similar to any of its component,
but is build using the structures of its components. A product
can be seen as <EM>parameterised</EM> by its two components.
Following this idea, <FONT COLOR=purple>FoCaLize</FONT> allows two flavors of parameterisation.</P><!--TOC subsection Parameterisation by Collection-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc6">1.4.1</A>  Parameterisation by Collection</H3><!--SEC END --><P>We first introduce the <EM>collection parameters</EM>. They are
<EM>collections</EM> that the hosting species may use through their
<EM>methods</EM> to define its own ones.</P><P>A <EM>collection parameter</EM> is given a name <I>C</I> and a (species) interface
<I>I</I>. The name <I>C</I> serves to call the <EM>methods</EM> declared in
<I>I</I>. Intuitively, <I>C</I> will at some stage be implemented by a collection <I>CE</I> whose
interface contains the methods of the interface <I>I</I>.
Moreover, the collection and late-binding mechanisms
ensure that all methods appearing in <I>I</I> are indeed implemented
(defined for functions, proved for properties) in <I>CE</I>. Thus, no
runtime error, due to linkage of libraries, can occur and any <EM>property</EM> or <EM>theorem</EM> stated in <I>I</I> can be safely used as an hypothesis.</P><P>Calling a <EM>species</EM>&#X2019;s <EM>method</EM> is
done via the &#X201C;bang&#X201D; notation:
<TT>!meth</TT> or<BR>
<TT>Self!meth</TT> for a <EM>method</EM> of the current
<EM>species</EM> (and in this case, even simpler: <TT>meth</TT>, since the
<FONT COLOR=purple>FoCaLize</FONT> compiler will resolve scoping issues). To call
<EM>collection parameters</EM>&#X2019;s <EM>method</EM>, the same notation is used:
<TT>A!element</TT> stands for the <EM>method</EM> <TT>element</TT> of the
<EM>collection parameter</EM> <TT>A</TT>.</P><P>To go on with our example, a product of setoids has two components, hence a
<EM>species</EM> for products of setoids has two
<EM>collection parameters</EM>. It is itself a setoid (that is, a &#X201C;thing&#X201D; with an equality), a fact which is
simply recorded via the inheritance mechanism:
<TT>inherit Setoid</TT> gives to <TT>Setoid_product</TT> all the methods
of <TT>Setoid</TT>.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Setoid_product</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>A</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Setoid</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>B</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Setoid</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Setoid</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>fst</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>A</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>snd</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>B</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>pair</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>A</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>B</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>element</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>!</FONT><FONT SIZE=2>pair</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>A</FONT><FONT SIZE=2>!</FONT><FONT SIZE=2>element</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>B</FONT><FONT SIZE=2>!</FONT><FONT SIZE=2>element</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> ( = ) (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>basics</FONT><FONT SIZE=2>#</FONT><FONT SIZE=2>and_b</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>A</FONT><FONT SIZE=2>!( = )(</FONT><FONT SIZE=2>fst</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>), </FONT><FONT SIZE=2>fst</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>)),</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>                                   </FONT><FONT SIZE=2>B</FONT><FONT SIZE=2>!( = )(</FONT><FONT SIZE=2>snd</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>), </FONT><FONT SIZE=2>snd</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>))) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>of</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>refl</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>by</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>definition</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>of</FONT><FONT SIZE=2> ( = )</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>                     </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>A</FONT><FONT SIZE=2>!</FONT><FONT SIZE=2>refl</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>B</FONT><FONT SIZE=2>!</FONT><FONT SIZE=2>refl</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>We first declare methods <TT>fst</TT>, <TT>snd</TT> and <TT>pair</TT> to represent the
two projections and the construction of pairs.
Next, we introduce a definition for <TT>element</TT> by building a pair, using
the function <TT>pair</TT> applied to the method <TT>element</TT> of respectively <TT>A</TT>
and <TT>B</TT>. We also add a definition for <TT>=</TT> of <TT>Setoid_product</TT>,
relying on the methods <TT>=</TT> of <TT>A</TT> and <TT>B</TT>
(which are not yet defined), and we prove that <TT>=</TT> of <TT>Setoid_product</TT> is
indeed reflexive, upon the hypothesis made on <TT>A!( = )</TT>
and <TT>B!( = )</TT>. The part of <FONT COLOR=purple>FoCaLize</FONT> used to write proofs will be
shortly presented later, in section <A HREF="#focal-proof-language">1.6</A>.</P><P>Such a species can be refined with <TT>representation = A * B</TT>, indicating that 
the representation of the product is the
Cartesian Product of the representation of the two parameters. In
<TT>A * B</TT>, <TT>*</TT> is the <FONT COLOR=purple>FoCaLize</FONT> type  constructor of pairs, <TT>A</TT> denotes indeed 
the representation of the first <EM>collection parameter</EM>, and <TT>B</TT>
the one of of the second <EM>collection parameter</EM>.</P><P>This way, the <EM>species</EM> <TT>Setoid_product</TT> builds its <EM>methods</EM> relying on those of its <EM>collection parameters</EM>. Note the
two different uses of <TT>Setoid</TT> in our <EM>species</EM> <TT>Setoid_product</TT>, which both inherits of and is parameterised by it.</P><P><BR>
<BR>
</P><P>Why <EM>collection parameters</EM> and not simply <EM>species
parameters</EM>? There are two reasons. First, effective parameters must
provide definitions/proofs for all the methods of the required
interface: this is the contract. Thus, effective parameters must 
be <EM>complete</EM> species. Then, we do not want the parameterisation
to introduce dependencies
on the parameters&#X2019; <EM>representation</EM> definitions. For example, it is
impossible to express &#X201C; if <TT>A!representation</TT> is <TT>int</TT> and <TT>B!representation</TT>
is <TT>bool</TT> then <TT>A*B</TT> is a list of boolean values&#X201D;. This would
dramatically restrict possibilities to instantiate parameters since
assumptions on the <EM>representation</EM>, possibly used in the
parameterised <EM>species</EM> to write its own <EM>methods</EM>, 
could prevent <EM>collections</EM> having the right set of <EM>methods</EM> but
a different representation to be used as
effective parameters. Such a behaviour would make parameterisation too
weak to be usable. We choose to always hide the <EM>representation</EM> of a
<EM>collection parameter</EM> to the parameterised
hosting <EM>species</EM>. Hence the introduction of the notion of
<EM>collection</EM>, obtained by abstracting the representation from a
complete species.</P><!--TOC subsection Parameterisation by Entity (Value)-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc7">1.4.2</A>  Parameterisation by Entity (Value)</H3><!--SEC END --><P>Let us imagine we want to make a <EM>species</EM> working on natural numbers
modulo a certain value. In the expression
5 <TT> <I>modulo</I> </TT> 2 <I>is</I> 1, both 5 and 2
are natural numbers. To be sure that the <EM>species</EM> will
consistently work with the same modulo, this last one must be embedded
in the <EM>species</EM>. However, the <EM>species</EM> itself doesn&#X2019;t rely
on a particular value of the modulo. Hence this value is clearly a
<B>parameter</B> of the species, but a parameter in which we are
interested by its <B>value</B>, not only by its <EM>representation</EM> and the
methods acting on it. We call
those <EM>entity parameters</EM>, their introduction rests upon
the introduction of a <EM>collection parameter</EM> and they denote a
<EM>value</EM> having the type of the <EM>representation</EM> of this
<EM>collection parameter</EM>. </P><P>Let us first have a <EM>species</EM> representing natural numbers:</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>IntModel</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>one</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>inc</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>modulo</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>
Note that <TT>IntModel</TT> can be later implemented in various ways,
using Peano&#X2019;s integers, machine integers, arbitrary-precision
arithmetic (as well as things that are not really integers, our specification being too simplistic)&#X2026;</P><P>We now build our <EM>species</EM> &#X201C;working modulo &#X2026;&#X201D;, embedding
the value of this modulo:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Modulo_work</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>Naturals</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>IntModel</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>n</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Naturals</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>job1</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Naturals</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> ... =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    ... </FONT><FONT SIZE=2>Naturals</FONT><FONT SIZE=2>!</FONT><FONT SIZE=2>modulo</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>n</FONT><FONT SIZE=2>) ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>job2</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Naturals</FONT><FONT SIZE=2>, ...) </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> ... =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    ... ... </FONT><FONT SIZE=2>Naturals</FONT><FONT SIZE=2>!</FONT><FONT SIZE=2>modulo</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>n</FONT><FONT SIZE=2>) ... ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>
Using the <EM>entity parameter</EM> <TT>n</TT>, we ensure that the
<EM>species</EM> <TT>Modulo_work</TT> works for <EM>any</EM> value of the
modulo, but will always use the <EM>same</EM> value <TT>n</TT> of the modulo
everywhere inside the <EM>species</EM>.</P><!--TOC section The Final Brick-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc8">1.5</A>  The Final Brick</H2><!--SEC END --><P>As briefly introduced in <A HREF="#species-interface">1.2</A>, a <EM>species</EM>
needs to be complete to lead to executable code for its functions
and checkable proofs for its theorems. When a <EM>species</EM> is
complete, it can be turned into a <EM>collection</EM>. Hence, a <EM>collection</EM>
represents the final stage of the inheritance tree of a <EM>species</EM>
and leads to an effective data representation with
executable functions processing it.</P><P>For instance, providing that the previous
<EM>species</EM> <TT>IntModel</TT> has been refined into a fully-defined species
<TT>MachineNativeInt</TT> through inheritances steps, with a <EM>method</EM>
<TT>from_string</TT> allowing to create the natural representation of a
string, we could get a related collection by:</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>collection</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>MachineNativeIntColl</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>implement</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>MachineNativeInt</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>Next, to get a <EM>collection</EM> implementing arithmetic modulo 8, we
could extract from the <EM>species</EM> <TT>Modulo_work</TT> the following
<EM>collection</EM>:</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>collection</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Modulo_8_work</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>implement</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Modulo_work</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   (</FONT><FONT SIZE=2>MachineNativeIntColl</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>MachineNativeIntColl</FONT><FONT SIZE=2>!</FONT><FONT SIZE=2>from_string</FONT><FONT SIZE=2> (``8'')</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><P>As seen by this example, a species can be applied to effective
parameters by giving their values with the usual syntax of parameter
passing. </P><P>As said before, to ensure modularity and abstraction, the
<EM>representation</EM> of a 
<EM>collection</EM> is hidden (as well as the definitions). This means that any software component
dealing with a <EM>collection</EM> will only be able to manipulate it
through the operations (<EM>methods</EM>) its interface provides. This
point is especially important since it prevents other software
components from possibly breaking invariants required by the internals
of the <EM>collection</EM>.</P><!--TOC section Properties, Theorems and Proofs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc9">1.6</A>  Properties, Theorems and Proofs</H2><!--SEC END --><P>
<A NAME="focal-proof-language"></A></P><P><FONT COLOR=purple>FoCaLize</FONT> aims not only to write programs, it intends to encompass both
the executable model (i.e. program) and properties this model must
satisfy. For this reason, &#X201C;special&#X201D; <EM>methods</EM> deal with logic
instead of purely behavioural aspects of the system: <EM>theorems</EM>,
<EM>properties</EM> and <EM>proofs</EM>.</P><P>Stating a <EM>property</EM> indicates that a <EM>proof</EM> that it
<B>holds</B> will be given at some stage of the development. For <EM>theorems</EM>, the <EM>proof</EM> is
directly provided with the statement. Such proofs must be done by
the developer and will finally be sent to the formal proof assistant
<FONT COLOR=purple>Coq</FONT> who will automatically check that the demonstration of the
<EM>property</EM> is consistent. Writing a proof can be done in several ways.</P><P>It can be written in <FONT COLOR=purple>FoCaLize</FONT>&#X2019;s proof language, a hierarchical proof
language that allows to give hints and directions for a proof. This
language will be sent to an external theorem prover,
<FONT COLOR=purple>Zenon</FONT>[<A HREF="#ZenonBDD">2</A>, <A HREF="#zenon0.4.1">9</A>] developed by D. Doligez. This prover is
a first order theorem prover based on the tableau method incorporating
implementation novelties such as sharing. <FONT COLOR=purple>Zenon</FONT> will attempt, from
these hints, to automatically generate the proof and exhibit a <FONT COLOR=purple>Coq</FONT>
term suitable for verification by <FONT COLOR=purple>Coq</FONT>. Basic hints given by the
developer to <FONT COLOR=purple>Zenon</FONT> are: &#X201C;prove by definition of a <EM>method</EM>&#X201D;
(i.e. looking inside its body) and &#X201C;prove by <EM>property</EM>&#X201D;
(i.e. using the logical statement of a <EM>theorem</EM> or <EM>property</EM>).
Surrounding this hints mechanism, the language allows to build the
proof by stating assumptions (that must obviously be demonstrated
next) that can be used to prove lemmas or parts for the whole
property. We show below an example of such demonstration.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>  </FONT><FONT SIZE=2>theorem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>order_inf_is_infimum</FONT><FONT SIZE=2>: </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>i</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>,</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    !</FONT><FONT SIZE=2>order_inf</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>i</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) -&gt; !</FONT><FONT SIZE=2>order_inf</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>i</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) -&gt;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      !</FONT><FONT SIZE=2>order_inf</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>i</FONT><FONT SIZE=2>, !</FONT><FONT SIZE=2>inf</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>))</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      &lt;1&gt;1 </FONT><FONT SIZE=2>assume</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>assume</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>,</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>           </FONT><FONT SIZE=2>assume</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>i</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>assume</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>H1</FONT><FONT SIZE=2>: !</FONT><FONT SIZE=2>order_inf</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>i</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>),</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>           </FONT><FONT SIZE=2>assume</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>H2</FONT><FONT SIZE=2>: !</FONT><FONT SIZE=2>order_inf</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>i</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>),</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>           </FONT><FONT SIZE=2>prove</FONT><FONT SIZE=2> !</FONT><FONT SIZE=2>order_inf</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>i</FONT><FONT SIZE=2>, !</FONT><FONT SIZE=2>inf</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>))</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>        &lt;2&gt;1 </FONT><FONT SIZE=2>prove</FONT><FONT SIZE=2> !</FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>i</FONT><FONT SIZE=2>, !</FONT><FONT SIZE=2>inf</FONT><FONT SIZE=2>(!</FONT><FONT SIZE=2>inf</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>i</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>), </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>))</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>          </FONT><FONT SIZE=2>by</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>hypothesis</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>H1</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>H2</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>             </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>inf_left_substitution_rule</FONT><FONT SIZE=2>,</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>               </FONT><FONT SIZE=2>equal_symmetric</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>equal_transitive</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>             </FONT><FONT SIZE=2>definition</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>of</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>order_inf</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>        &lt;2&gt;</FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>qed</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>          </FONT><FONT SIZE=2>by</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>step</FONT><FONT SIZE=2> &lt;2&gt;1</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>             </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>inf_is_associative</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>equal_transitive</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>             </FONT><FONT SIZE=2>definition</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>of</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>order_inf</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      &lt;1&gt;</FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>conclude</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    ;</FONT></TD></TR>
</TABLE><P>The important point is that <FONT COLOR=purple>Zenon</FONT> works for the
developer: <B>it searches the proof itself</B>, the developer does not
have to elaborate it formally &#X201C;from scratch&#X201D;.</P><P>Like any automatic theorem prover, <FONT COLOR=purple>Zenon</FONT> may fail finding a
demonstration. In this case, <FONT COLOR=purple>FoCaLize</FONT> allows to write verbatim
<FONT COLOR=purple>Coq</FONT> proofs. In this case, the proof is not anymore automated, but
this leaves the full power of expression of <FONT COLOR=purple>Coq</FONT> to the developer.</P><P>Finally, the <TT>assumed</TT> keyword is the ultimate proof backdoor,
telling that the proof is not given but that the property must be
admitted. Obviously, a really safe development should not make usage of
this feature since it bypasses the formal verification of
software&#X2019;s model. However, such a functionality remains needed for various
reasons. For example, a development may be linked with external code; 
properties of the <FONT COLOR=purple>FoCaLize</FONT> code may depends on properties of the external
code that have to be stated (for example using the documentation of this
code) but also assumed.
</P><!--TOC section Around the Language-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc10">1.7</A>  Around the Language</H2><!--SEC END --><P>In the previous sections, we presented <FONT COLOR=purple>FoCaLize</FONT> through its programming
model and shortly its syntax. We especially investigated the various
entities making a <FONT COLOR=purple>FoCaLize</FONT> program. We now address what becomes a
<FONT COLOR=purple>FoCaLize</FONT> program once compiled. We recall that <FONT COLOR=purple>FoCaLize</FONT> supports the
redefinition of functions, which permits for example to specialise
code to a specific representation (for example, there
exists a generic implementation of integer addition modulo <TT>n</TT> but
it can be redefined in arithmetics modulo <TT>2</TT> if boolean values
are used to represent the two values). It is also a very convenient
tool to maintain software. </P><!--TOC subsection Consistency of the Software-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc11">1.7.1</A>  Consistency of the Software</H3><!--SEC END --><P>All along the <FONT COLOR=purple>FoCaLize</FONT> development cycle, the compiler
keeps trace of dependencies between <EM>species</EM>,
<EM>methods</EM>, and <EM>proofs</EM> &#X2026;to ensure that the consequences of any modification
will be managed consistently and propagated to those depending of it.</P><P><FONT COLOR=purple>FoCaLize</FONT> deals with two types of dependencies:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The <B>decl</B>-dependency: a <EM>method</EM> <I>A</I> decl-depends on a
<EM>method</EM> <I>B</I>, if the <B>declaration</B> of <I>B</I> is required to
state <I>A</I>.
</LI><LI CLASS="li-itemize">The <B>def</B>-dependency: a <EM>method</EM> (and more especially, a
<EM>theorem</EM>) <I>A</I> def-depends on a <EM>method</EM> <I>B</I>, if the
<B>definition</B> of <I>B</I> is required to state <I>A</I> (and more
especially, to prove the property stated by the <EM>theorem</EM>
<I>A</I>).
</LI></UL><P>The redefinition of a function may invalidate the proofs that use
properties of the body of the redefined function. All the proofs
which truly depend of the definition are then invalidated by the compiler
and must be done again in the context updated with the new
definition. Thus the main difficulty is to choose the best level in
the hierarchy to do a proof. In [<A HREF="#PrevostoJaume2003">21</A>], Prevosto and
Jaume propose a <EM>coding style</EM> to minimise the number of proofs
to be redone in the case of a redefinition, by a certain kind of
modularisation of the proofs.</P><!--TOC subsection Code Generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc12">1.7.2</A>  Code Generation</H3><!--SEC END --><P><FONT COLOR=purple>FoCaLize</FONT> currently compiles programs toward two languages, <FONT COLOR=purple>OCaml</FONT> to
get an executable piece of software, and <FONT COLOR=purple>Coq</FONT> to have a formal model
of the program, with theorems and proofs.</P><P>In <FONT COLOR=purple>OCaml</FONT> code generation, all
the logical aspects are discarded since they do not lead to executable
code.</P><P>Conversely, in <FONT COLOR=purple>Coq</FONT>, all the <EM>methods</EM> are compiled,
i.e. &#X201C;computational&#X201D; <EM>methods</EM> and logical <EM>methods</EM> with
their proofs. This allows <FONT COLOR=purple>Coq</FONT> to check the entire consistence of
the system developed in <FONT COLOR=purple>FoCaLize</FONT>.</P><!--TOC subsection Tests-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">1.7.3</A>  Tests</H3><!--SEC END --><P>
<FONT COLOR=purple>FoCaLize</FONT> incorporates a tool named <EM>FocalTest</EM>
[<A HREF="#CarlierDuboisLNCS2008">15</A>] for Integration/Validation testing. It
allows to confront automatically a property of the specification with
an implementation. It generates automatically test cases, executes
them and produces a test report as an XML document. The property under
test is used to generate the test case but also as an
oracle. When a test case fails, it means that a counterexample of the
property has been found: the implementation does not match the property.
Note that this indentifies a problem in the code or in the specification.</P><P>The tool <EM>FocalTest</EM> automatically produces the test environment and
the drivers to conduct the tests. It benefits from the inheritance
mechanism to isolate the testing harness from the components written
by the programmer.</P><P>The testable properties are required to be broken down into a
precondition and a conclusion, both executable. The current version of
<EM>FocalTest</EM> proposes a pure random test cases generation: a test case
is generated, if it satisfies the pre-condition then the verdict of the test case
is obtained by executing the post-condition, else the test case is rejected.
It can be
an expensive process for some kind of preconditions. To overcome this
drawback, a constraint based generation is under development: it
allows to produce directly test cases for which the precondition is
satisfied.</P><!--TOC subsection Documentation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc14">1.7.4</A>  Documentation</H3><!--SEC END --><P>The tool called <FONT COLOR=purple>FoCaLizeDoc</FONT> [<A HREF="#MaarekCalculemus03">14</A>] automatically
generates documentation, thus the documentation of a component is
always coherent with respect to its implementation.</P><P>This tool uses its own XML format that contains information coming not
only from structured comments (that are parsed and kept in the
program&#X2019;s abstract syntax tree) and <FONT COLOR=purple>FoCaLize</FONT> concrete syntax but also
from type inference and dependency analysis. From this XML
representation and thanks to some XSLT stylesheets, it is possible to
generate HTML files or L<sup>A</sup>T<sub>E</sub>X files. Although this documentation is
not the complete safety case, it can helpfully contribute to its
elaboration. In the same way, it is possible to produce UML
models [<A HREF="#Focal-UML">5</A>] as means to provide a graphical documentation
for <FONT COLOR=purple>FoCaLize</FONT> specifications. The use of graphical notations appears
quite useful when interacting with end-users, as these tend to be more
intuitive and are easier to grasp than their formal (or textual)
counterparts. This transformation is based on a formal schema and
captures every aspect of the <FONT COLOR=purple>FoCaLize</FONT> language, so that it has been
possible to prove the soundness of this transformation (semantic
preservation).</P><P><FONT COLOR=purple>FoCaLize</FONT>&#X2019;s architecture is designed to easily plug third-parties
analyses that can use the internal structures elaborated by the
compiler from the source code. This allows, for example, to make
dedicated documentation tools for custom purposes, just exploiting
information stored in the <FONT COLOR=purple>FoCaLize</FONT> program&#X2019;s abstract syntax tree, or
extra information possibly added by extra processes, analyses.
</P><!--TOC chapter Installing and Compiling-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc15">Chapter 2</A>  Installing and Compiling</H1><!--SEC END --><!--TOC section Required software-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc16">2.1</A>  Required software</H2><!--SEC END --><P>
<A NAME="required-software"></A>
To be able to develop with the <FONT COLOR=purple>FoCaLize</FONT> environment, a few third party
tools are required. All of them can be freely downloaded from their
related website.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The Objective Caml compiler (version &#X2265; 3.10.2).<BR>
 Available
at <CODE>http://caml.inria.fr</CODE>. This will be used to compile both
the <FONT COLOR=purple>FoCaLize</FONT> system at installation stage from the tarball and
the <FONT COLOR=purple>FoCaLize</FONT> compiler&#X2019;s output generated by the compilation of
your <FONT COLOR=purple>FoCaLize</FONT> programs.</LI><LI CLASS="li-itemize">The Coq Proof Assistant (version &#X2265; 8.1pl4).<BR>
 Available at
<CODE>http://coq.inria.fr</CODE>. This will be used to compile both
the <FONT COLOR=purple>FoCaLize</FONT> libraries at installation stage from the tarball and
the <FONT COLOR=purple>FoCaLize</FONT> compiler&#X2019;s output generated by the compilation of
your <FONT COLOR=purple>FoCaLize</FONT> programs.
</LI></UL><P>Note that some distributions of <FONT COLOR=purple>FoCaLize</FONT> includes these tools and are
automatically installed during the <FONT COLOR=purple>FoCaLize</FONT>installation process.</P><!--TOC section Optional software-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc17">2.2</A>  Optional software</H2><!--SEC END --><P>
<A NAME="optional-software"></A>
The <FONT COLOR=purple>FoCaLize</FONT> compiler can generate dependencies graphs from compiled
source code. It generates them in the format suitable to be processed
and displayed by the <FONT COLOR=purple>dotty</FONT> tools suite of the &#X201C;Graphwiz&#X201D; package. If
you plan to examine these graphs, you also need to install this
software from <CODE>http://www.graphviz.org/</CODE>.</P><!--TOC section Operating systems-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc18">2.3</A>  Operating systems</H2><!--SEC END --><P>
<FONT COLOR=purple>FoCaLize</FONT> was fully developed under Linux using free software. Hence,
any Unix-based operating system should support <FONT COLOR=purple>FoCaLize</FONT>. The currently
tested Unix are: Fedora, Debian, Suse, BSD.</P><P>Windows users can run <FONT COLOR=purple>FoCaLize</FONT> via the Unix-like
environment <FONT COLOR=purple>Cygwin</FONT> providing both users and developers tools. This
software is freely distributed and available
at <CODE>http://www.cygwin.com/</CODE>.</P><P><BR>
</P><!--TOC paragraph From the official <FONT COLOR=purple>Cygwin</FONT> web site:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->From the official <FONT COLOR=purple>Cygwin</FONT> web site:</H5><!--SEC END --><P>
&#X201C;<EM>Cygwin is a Linux-like environment for Windows. It consists of
two parts: A DLL (cygwin1.dll) which acts as a Linux API emulation
layer providing substantial Linux API functionality. A collection of
tools which provide Linux look and feel.
<BR>
The Cygwin DLL currently works with all recent, commercially released
x86 32 bit and 64 bit versions of Windows, with the exception of
Windows CE.
<BR>
Cygwin is not a way to run native linux apps on Windows. You have to
rebuild your application from source if you want it to run on
Windows.</EM></P><P><EM>Cygwin is not a way to magically make native Windows apps aware of
UNIX ® functionality, like signals, ptys, etc. Again, you need to
build your apps from source if you want to take advantage of Cygwin
functionality.</EM>&#X201D;</P><P><BR>
Under <FONT COLOR=purple>Cygwin</FONT>, the required packages are the same as those listed
in <A HREF="#required-software">2.1</A> and <A HREF="#optional-software">2.2</A>. As stated
in <FONT COLOR=purple>Cygwin</FONT>&#X2019;s citation above, you need to get the sources packages of
this software and compile them yourself, following information
provided in these packages.</P><P>The installation of <FONT COLOR=purple>FoCaLize</FONT> itself is the same for all operating
systems and is described in the following section
(<A HREF="#installation">2.4</A>).</P><!--TOC section Installation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc19">2.4</A>  Installation</H2><!--SEC END --><P>
<A NAME="installation"></A>
<A NAME="@default0"></A>
<FONT COLOR=purple>FoCaLize</FONT> is currently distributed as a tarball containing the whole
source code of the development environment. You must first deflate the
archive (a directory will be created) by:
</P><DIV CLASS="center">
<TT>tar xvzf focalize-x.y.z.tgz</TT>
</DIV><P>
Where <I>x</I>.<I>y</I>.<I>z</I> is the version number. Next, go in the sources directory:
</P><DIV CLASS="center">
<TT>cd focalize-x.x.x/</TT>
</DIV><P>
You now must configure the build process by:
</P><DIV CLASS="center">
<TT>./configure</TT>
</DIV><P>
The configuration script then asks for directories where to install
the <FONT COLOR=purple>FoCaLize</FONT> components. You may just press enter to keep the default
installation directories.
</P><PRE CLASS="verbatim">latour:~/src/focalize$ ./configure ~/pkg
Where to install FoCaLize binaries ?
Default is /usr/local/bin.
Just press enter to use default location.

Where to install FoCaLize libraries ?
Default is /usr/local/lib/focalize.
Just press enter to use default location.
</PRE><P>After the configuration ends, just build the system:
</P><DIV CLASS="center">
<TT>make all</TT>
</DIV><P>
And finally, get root priviledges to install the <FONT COLOR=purple>FoCaLize</FONT> system:
</P><DIV CLASS="center">
<TT>su</TT><BR>
<TT>make install</TT>
</DIV><!--TOC section Compilation process and outputs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc20">2.5</A>  Compilation process and outputs</H2><!--SEC END --><P>We call <EM>compilation unit</EM><A NAME="@default1"></A> a file
containing source code for toplevel-definitions, species,
collections. Visibility rules, described in section
<A HREF="#qualified-name">3.1.12</A>, are defined according to compilation units status.
From a compilation unit, the compiler issues several files described
thereafter.</P><!--TOC subsection Outputs-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc21">2.5.1</A>  Outputs</H3><!--SEC END --><P>
A <FONT COLOR=purple>FoCaLize</FONT> development contains both
computational code (i.e. code performing operations leading to
an effect, a result) and logical properties.</P><P><BR>
When compiled, two outputs are generated:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The &#X201C;computational code&#X201D; is compiled into <FONT COLOR=purple>OCaml</FONT> source
that can then be compiled with the <FONT COLOR=purple>OCaml</FONT> compiler to lead to an
executable binary. In this pass, logical properties are discarded
since they do not lead to executable code.
</LI><LI CLASS="li-itemize">Both the &#X201C;computational code&#X201D; and the logical properties are
compiled into a <FONT COLOR=purple>Coq</FONT> model. This model can then be sent to the
<FONT COLOR=purple>Coq</FONT> proof assistant who will verify the consistency of both the
&#X201C;computational code&#X201D; and the logical properties (whose
proofs<A NAME="@default2"></A> must be obviously provided) of the
<FONT COLOR=purple>FoCaLize</FONT> development. This means that the <FONT COLOR=purple>Coq</FONT> code generated is
not intended to be used to generate an <FONT COLOR=purple>OCaml</FONT> source code by
automated extraction. As stated above, the executable generation
is preferred using directly the generated <FONT COLOR=purple>OCaml</FONT> code. In this
idea, <FONT COLOR=purple>Coq</FONT> acts as an assessor of the development instead of a
code generator.<P>More accurately, <FONT COLOR=purple>FoCaLize</FONT> first generates a pre-<FONT COLOR=purple>Coq</FONT> code, i.e. a
file containing <FONT COLOR=purple>Coq</FONT> syntax plus &#X201C;holes&#X201D; in place of proofs
written in the <FONT COLOR=purple>FoCaLize</FONT> Proof Language. This kind of files is
suffixed by &#X201C;.zv&#X201D; instead of directly &#X201C;.v&#X201D;. When sending this
file to <FONT COLOR=purple>Zenon</FONT> these &#X201C;holes&#X201D; will be filled by effective
<FONT COLOR=purple>Coq</FONT> code automatically generated by <FONT COLOR=purple>Zenon</FONT> (if it succeed in
finding a proof), hence leading to a pure <FONT COLOR=purple>Coq</FONT> code file that can
be compiled by <FONT COLOR=purple>Coq</FONT>.</P></LI></UL><P>
In addition, several other outputs can be generated for documentation
or debug purposes. See the section <A HREF="#compiler-options">7</A> for
details.</P><!--TOC subsection Compiling a source-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc22">2.5.2</A>  Compiling a source</H3><!--SEC END --><P>
Compiling a <FONT COLOR=purple>FoCaLize</FONT> program involves several steps (numbered here 1, 2, 3 and 4) that are
automatically handled by the <FONT COLOR=purple>focalizec</FONT> command. Using the command
line options, it is possible to tune the code generations steps as
described in <A HREF="#compiler-options">7</A>.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<B><FONT COLOR=purple>FoCaLize</FONT></B><B> source compilation</B>. This step takes the <FONT COLOR=purple>FoCaLize</FONT>
source code and generates the <FONT COLOR=purple>OCaml</FONT> and/or &#X201C;pre-&#X201D;<FONT COLOR=purple>Coq</FONT> code.
You can disable the code generation for one of these languages
(see page <A HREF="#compiler-options">7</A>), or both, in this case, no code is
produced and you only get the <FONT COLOR=purple>FoCaLize</FONT> object code produced without
anymore else output and the process ends at this point. If you
disable one of the target languages, then you won&#X2019;t get any
generated file for it, hence no need to address its related
compilation process described below.<P>Assuming you generate code for both <FONT COLOR=purple>OCaml</FONT> and <FONT COLOR=purple>Coq</FONT>  you will get
two generated files: <TT>source.ml</TT> (the <FONT COLOR=purple>OCaml</FONT> code) and
<TT>source.zv</TT> (the &#X201C;pre-&#X201D;<FONT COLOR=purple>Coq</FONT> code).</P></LI><LI CLASS="li-enumerate"><B><FONT COLOR=purple>OCaml</FONT></B><B> code compilation</B>. This step takes the generated
<FONT COLOR=purple>OCaml</FONT> code (it is an <FONT COLOR=purple>OCaml</FONT> source file) and compile it. This
is done like any regular <FONT COLOR=purple>OCaml</FONT> compilation, the only difference
is that the search path containing the <FONT COLOR=purple>FoCaLize</FONT> installation path
and your own used extra <FONT COLOR=purple>FoCaLize</FONT> source files directories are
automatically passed to the <FONT COLOR=purple>OCaml</FONT> compiler. Hence this steps
acts like a manual invocation:
<PRE CLASS="verbatim">ocamlc -c -I /usr/local/lib/focalize -I mylibs
   -I myotherlibs source.ml
    </PRE>This produces the <FONT COLOR=purple>OCaml</FONT> object file <TT>source.cmo</TT>. Note that
you can also ask to use the <FONT COLOR=purple>OCaml</FONT> code in native mode, in this
case the <TT>ocamlopt</TT> version of the <FONT COLOR=purple>OCaml</FONT> compiler is
selected (see <FONT COLOR=purple>OCaml</FONT> reference manual for more information) and
the object files are <TT>.cmx</TT> files instead of <TT>.cmo</TT>.
ones.</LI><LI CLASS="li-enumerate"><B>&#X201C;Pre-&#X201D;</B><B><FONT COLOR=purple>Coq</FONT></B><B> code compilation</B>. This step takes the
generated <TT>.zv</TT> file and attempts to produce a real <FONT COLOR=purple>Coq</FONT>
<TT>.v</TT> source file by replacing proofs written in <FONT COLOR=purple>FoCaLize</FONT> Proof
Language by some effective <FONT COLOR=purple>Coq</FONT> proofs found by the <FONT COLOR=purple>Zenon</FONT>
theorem prover. Note that if <FONT COLOR=purple>Zenon</FONT> fails in finding a proof, a
hole will remain in the final <FONT COLOR=purple>Coq</FONT> <TT>.v</TT> file. Such a hole
appears as the text &#X201C;<TT>TO_BE_DONE_MANUALLY.</TT>&#X201D; in place of
the effective proof. In this case, <FONT COLOR=purple>Coq</FONT> will obviously fail
in compiling the file, so the user must do the proof by hand or
modify his original <FONT COLOR=purple>FoCaLize</FONT> source file to get a working proof.
This step acts like a manual invocation:
<DIV CLASS="center">
<TT>zvtov -new source.zv</TT>
</DIV>
For more about the <FONT COLOR=purple>Zenon</FONT> options, consult section
<A HREF="#zenon_options">??</A>. </LI><LI CLASS="li-enumerate"><B><FONT COLOR=purple>Coq</FONT></B><B> code compilation</B>. This step takes the generated
<TT>.v</TT> code and compiles it with <FONT COLOR=purple>Coq</FONT>. This is done like any
regular <FONT COLOR=purple>Coq</FONT> compilation. The only difference is that the search
path containing the <FONT COLOR=purple>FoCaLize</FONT> installation path and your own used
extra <FONT COLOR=purple>FoCaLize</FONT> source files directories are automatically passed
to the <FONT COLOR=purple>Coq</FONT> compiler.
<PRE CLASS="verbatim">coqc -I /usr/local/lib/focalize -I mylibs
  -I myotherlibs source.v
    </PRE>Once this step is done, you have the <FONT COLOR=purple>Coq</FONT> object files and you
are sure that <FONT COLOR=purple>Coq</FONT> validated you program model, properties and
proofs. The final &#X201C;assessor&#X201D; of the tool-chain accepted your
program.
</LI></OL><P><BR>
<A NAME="@default3"></A>
Once all separate files are compiled, to get an executable from the
<FONT COLOR=purple>OCaml</FONT> object files, you must link them together, providing the same
search path than above and the <TT>.cmo</TT> files corresponding to all
the generated <FONT COLOR=purple>OCaml</FONT> files from all your <FONT COLOR=purple>FoCaLize</FONT> <TT>.foc</TT>
files. You also need to add the <TT>.cmo</TT> files corresponding to the
modules of the standard library you use (currently, this must be done
by the user, next versions will automate this process).
</P><PRE CLASS="verbatim">ocamlc -I mylibs -I myotherlibs
  install_dir/ml_builtins.cmo install_dir/basics.cmo
  install_dir/sets.cmo ...
  mylibs/src1.cmo mylibs/src2.cmo ...
  myotherlibs src3.cmo mylibs/src3.cmo ...
  source1.cmo source2.cmo ...
  -o exec_name
    </PRE><!--TOC chapter The core language-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc23">Chapter 3</A>  The core language</H1><!--SEC END --><P>
<A NAME="corelangage"></A>
</P><!--TOC section Lexical conventions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc24">3.1</A>  Lexical conventions</H2><!--SEC END --><P>
<A NAME="@default4"></A></P><!--TOC subsection Blanks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc25">3.1.1</A>  Blanks</H3><!--SEC END --><P>
<A NAME="@default5"></A>
The following characters are considered as blanks: space, newline,
horizontal tabulation, carriage return, line feed and form
feed. Blanks are ignored, but they separate adjacent identifiers,
literals and keywords that would otherwise be confused as one single
identifier, literal or keyword.</P><!--TOC subsection Comments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc26">3.1.2</A>  Comments</H3><!--SEC END --><P>
<A NAME="@default6"></A>
Comments (possibly spanning) on several lines are introduced by the
two characters <TT>(*</TT>, with no intervening blanks, and terminated by
the characters <TT>*)</TT>, with no intervening blanks. Comments are
treated as blanks. Comments can occur inside string or character
literals (provided the <TT>*</TT> character is escaped) and can be nested. They
are discarded during the compilation process. Example:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><EM><FONT SIZE=2>(* Discarded comment *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* Another discarded comment *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2><EM><FONT SIZE=2>(* Another discarded comment at end of file *)</FONT></EM></FONT></TD></TR>
</TABLE><P>Comments spanning on a single line start by the two characters
<TT>--</TT> and end with the end-of-line character.
Example:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>-- </FONT><FONT SIZE=2>Discarded</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>uni</FONT><FONT SIZE=2>-</FONT><FONT SIZE=2>line</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>comment</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) = -- </FONT><FONT SIZE=2>Another</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>uni</FONT><FONT SIZE=2>-</FONT><FONT SIZE=2>line</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>comment</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>Note that double quotes (symbol ") should not appear in comments, and that
a spanning comment should not start with uniline comment mark. A uniline
comment should also always be terminated by a carriage return (an unclosed
uniline comment cannot end a file).</P><!--TOC subsection Annotations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc27">3.1.3</A>  Annotations</H3><!--SEC END --><P>
<A NAME="@default7"></A>
<A NAME="@default8"></A>
<A NAME="annotation"></A>
<B>Annotations</B> are introduced by the three characters <TT>(**</TT>,
with no intervening blanks, and terminated by the two characters
<TT>*)</TT>, with no intervening blanks.
Annotations cannot occur inside string or character literals and
cannot be nested. They must precede the construct they document.
In particular, a <B>source file cannot end by an annotation</B>.</P><P>Unlike comments, annotations are kept during the compilation process
and recorded in the compilation information (&#X201C;<TT>.fo</TT>&#X201D; files). Annotations can
be processed later on by external tools that could analyze them to
produce a new <FONT COLOR=purple>FoCaLize</FONT> source code accordingly.
For instance, the <FONT COLOR=purple>FoCaLize</FONT> development environment provides the <FONT COLOR=purple>FoCaLizeDoc</FONT>
automatic production tool that uses annotations to automatically generate
documentation.
Several annotations can be put in sequence for the same construct. We call
such a sequence an <B>annotation block</B><A NAME="@default9"></A>.
Using embedded tags in annotations allows third-party tools to easily find
out annotations that are meaningful to them, and safely ignore others.
For more information, consult
<A HREF="#documentation-generation">8</A>.
Example:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><EM><FONT SIZE=2>(** Annotation for the automatic documentation processor.</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    Documentation for species S. *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2><EM><FONT SIZE=2>(** {@TEST} Annotation for the test generator. *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2><EM><FONT SIZE=2>(** {@MY_TAG_MAINTAIN} Annotation for maintainers. *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><!--TOC subsection Identifiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc28">3.1.4</A>  Identifiers</H3><!--SEC END --><P>
<A NAME="@default10"></A>
<BR>
</P><P><FONT COLOR=purple>FoCaLize</FONT> features a rich class of identifiers with sophisticated lexical
rules that provide fine distinction between the kind of notion a given
identifier can designate.</P><!--TOC subsubsection Introduction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc29">3.1.4.1</A>  Introduction</H4><!--SEC END --><P>Sorting words to find out which kind of meaning they may have is a very common
conceptual categorization of names that we use when we write or read ordinary
English texts. We routinely distinguish between:
</P><DL CLASS="list"><DT CLASS="dt-list">
0pt 5pt
&#X2022;</DT><DD CLASS="dd-list">a word only made of lowercase characters, that is supposed to be an
ordinary noun, such as &#X201C;table&#X201D;, &#X201C;ball&#X201D;, or a verb as in &#X201C;is&#X201D;, or an
adjective as in &#X201C;green&#X201D;,
</DD><DT CLASS="dt-list">&#X2022;</DT><DD CLASS="dd-list">a word starting with an uppercase letter, that is supposed to be a name,
maybe a family or christian name, as in &#X201C;Kennedy&#X201D; or &#X201C;David&#X201D;, or a location
name as in &#X201C;London&#X201D;.
</DD></DL><P>We use this distinctive look of words as a useful hint to help understanding
phrases. For instance, we accept the phrase "my ball is green" as meaningful,
whereas "my Paris is green" is considered a nonsense. This is simply because
"ball" is a regular noun and "Paris" is a name. The word "ball" as the right
lexical classification in the phrase, but "Paris" has not. This is also clear
that you can replace "ball" by another ordinary noun and get something
meaningful: "my table is green"; the same nonsense arises as well if you
replace "Paris" by another name: "my Kennedy is green".</P><P>Natural languages are far more complicated than computer languages, but
<FONT COLOR=purple>FoCaLize</FONT> uses the same kind of tricks: the &#X201C;look&#X201D; of words helps a lot to
understand what the words are designating and how they can be used.</P><!--TOC subsubsection Conceptual properties of names-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc30">3.1.4.2</A>  Conceptual properties of names</H4><!--SEC END --><P><FONT COLOR=purple>FoCaLize</FONT> distinguishes 4 concepts for each name:</P><DL CLASS="list"><DT CLASS="dt-list">
0pt 5pt
&#X2022;</DT><DD CLASS="dd-list">the <EM>fixity</EM> assigns the place where an identifier must be written,
</DD><DT CLASS="dt-list">&#X2022;</DT><DD CLASS="dd-list">the <EM>precedence</EM> decides the order of operations when
identifiers are combined together,
</DD><DT CLASS="dt-list">&#X2022;</DT><DD CLASS="dd-list">the <EM>categorisation</EM> fixes which concept the identifier designates.
</DD><DT CLASS="dt-list">&#X2022;</DT><DD CLASS="dd-list">the <EM>nature</EM> of a name can either be symbolic or alphanumeric.
</DD></DL><P>Those concepts are compositional, i.e. all these concepts are independent
from one another. Put is another way: for any fixity, precedence, category and nature,
there exist identifiers with this exact properties.</P><P>We further explain those concepts below.</P><!--TOC subsubsection Fixity of identifiers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc31">3.1.4.3</A>  Fixity of identifiers</H4><!--SEC END --><P>
<A NAME="@default11"></A>
<A NAME="@default12"></A>
<A NAME="@default13"></A></P><P>The fixity of an identifier answers to the question &#X201C;where this identifier
must be written ?&#X201D;.</P><DL CLASS="list"><DT CLASS="dt-list">
0pt 5pt
&#X2022;</DT><DD CLASS="dd-list">a <EM>prefix</EM> is written <EM>before</EM> its argument, as <I>sin</I> in
<I>sin</I>  <I>x</I> or &#X2212; in &#X2212; <I>y</I>,
</DD><DT CLASS="dt-list">&#X2022;</DT><DD CLASS="dd-list">an <EM>infix</EM> is written <EM>between</EM> its arguments, as + in
<I>x</I>  +  <I>y</I> or <I>mod</I> in <I>x</I>  <I>mod</I>  3.
</DD><DT CLASS="dt-list">&#X2022;</DT><DD CLASS="dd-list">a <EM>mixfix</EM> is written <EM>among</EM> its arguments, as
<I>if</I>  &#X2026; <I>then</I>  &#X2026; <I>else</I>  &#X2026; in
<I>if</I> <I>c</I>  <I>then</I>  1  <I>else</I>  2 .
</DD></DL><P>In <FONT COLOR=purple>FoCaLize</FONT>, as in maths, ordinary identifiers are always prefix and binary operators are
always infix.</P><!--TOC subsubsection Precedence of identifiers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc32">3.1.4.4</A>  Precedence of identifiers</H4><!--SEC END --><P>
<A NAME="@default14"></A></P><P>The precedence rules out where implicit parentheses take place in a
complex combination of symbols. For instance, according to the usual mathematical
conventions:
</P><DL CLASS="list"><DT CLASS="dt-list">
0pt 5pt
&#X2022;</DT><DD CLASS="dd-list">1  +  2  *  3 means 1  +  (2  *  3) hence 7,
it does not mean (1  +  2)  *  3 which is 9,
</DD><DT CLASS="dt-list">&#X2022;</DT><DD CLASS="dd-list">2  *  3  <SUP>4</SUP>  +  5 means
(2  *  (3  <SUP>4</SUP>))  +  5 hence 167, it does not mean
((2  *  3)  <SUP>4</SUP>)  +  5 which is 1301,
nor 2  *  (3  <SUP>(4  +  5)</SUP>) which is 39366.
</DD></DL><P>In <FONT COLOR=purple>FoCaLize</FONT>, all the binary infix operators have the precedence they have in maths.</P><!--TOC subsubsection Categorization of identifiers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc33">3.1.4.5</A>  Categorization of identifiers</H4><!--SEC END --><P><A NAME="@default15"></A>
The category of an identifier answers to the question &#X201C;is this identifier a
possible name for this kind of concept ?&#X201D;.
In programming languages categories are often strict, meaning that the category
exactly states which concept attaches to the identifier.</P><P>For <FONT COLOR=purple>FoCaLize</FONT> these categories are
</P><DL CLASS="list"><DT CLASS="dt-list">
0pt 5pt
&#X2022;</DT><DD CLASS="dd-list"><EM>lowercase</EM>: the identifier starts with a lowercase letter and
designates a simple entity of the language. It may name some of
the language expressions, a function name, a function parameter or bound
variable name, a method name, a type name, or a record field label name.</DD><DT CLASS="dt-list">&#X2022;</DT><DD CLASS="dd-list"><EM>uppercase</EM>: the identifier starts with an uppercase letter and
designates a more complex entity in the language. It may name a sum type
constructor name, a module name, a species or a collection name.
</DD></DL><P>We distinguish identifiers using their first &#X201C;meaningful&#X201D; character:
the first character that is not an underscore.</P><!--TOC subsubsection Nature of identifiers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc34">3.1.4.6</A>  Nature of identifiers</H4><!--SEC END --><P>
<A NAME="@default16"></A></P><P>In <FONT COLOR=purple>FoCaLize</FONT> identifiers are either:</P><DL CLASS="list"><DT CLASS="dt-list">
0pt 5pt
&#X2022;</DT><DD CLASS="dd-list"><EM>symbolic</EM>: the identifier contains characters that are not
letters. <TT>+</TT>, <TT>:=</TT>, <TT>-&gt;</TT>, <TT>+float</TT> are symbolic</DD><DT CLASS="dt-list">&#X2022;</DT><DD CLASS="dd-list"><EM>alphanumeric</EM>: the identifier only contains letters, digits and
underscores. <TT>x</TT>, <TT>_1</TT>, <TT>Some</TT>, <TT>Basic_object</TT> are
alphanumeric.
</DD></DL><!--TOC subsubsection Regular identifiers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc35">3.1.4.7</A>  Regular identifiers</H4><!--SEC END --><P>
<A NAME="@default17"></A></P><P>Regular lower case identifiers are used to designate the names of variables, functions,
and labels of records.</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="digit"><I><FONT COLOR=maroon>digit</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>0</FONT></TT> &#X2026; <TT><FONT COLOR=blue>9</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="lower"><I><FONT COLOR=maroon>lower</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>a</FONT></TT> &#X2026; <TT><FONT COLOR=blue>z</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="upper"><I><FONT COLOR=maroon>upper</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>A</FONT></TT> &#X2026; <TT><FONT COLOR=blue>Z</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="letter"><I><FONT COLOR=maroon>letter</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <A HREF="#lower"><I><FONT COLOR=maroon>lower</FONT></I></A> &#X2223;  <A HREF="#upper"><I><FONT COLOR=maroon>upper</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="lident"><I><FONT COLOR=maroon>lident</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> { <TT><FONT COLOR=blue>_</FONT></TT>}<SUP>*</SUP> <A HREF="#lower"><I><FONT COLOR=maroon>lower</FONT></I></A>
 { <A HREF="#letter"><I><FONT COLOR=maroon>letter</FONT></I></A> &#X2223;  <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> &#X2223;  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP>*</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="uident"><I><FONT COLOR=maroon>uident</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> { <TT><FONT COLOR=blue>_</FONT></TT>}<SUP>*</SUP> <A HREF="#upper"><I><FONT COLOR=maroon>upper</FONT></I></A>
 { <A HREF="#letter"><I><FONT COLOR=maroon>letter</FONT></I></A> &#X2223;  <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> &#X2223;  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP>*</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="ident"><I><FONT COLOR=maroon>ident</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> &#X2223;  <A HREF="#uident"><I><FONT COLOR=maroon>uident</FONT></I></A></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
<BR>
</P><P>A regular identifier is a sequence of letters, digits, and <TT>_</TT> (the
underscore character), starting with a letter or an underscore.</P><P>The identifier is lowercase if its first &#X201C;meaningful&#X201D; letter is lowercase.</P><P>The identifier is uppercase if its first &#X201C;meaningful&#X201D; letter is uppercase.</P><P>Letters contain at least the 52 lowercase and uppercase
letters from the standard ASCII set. In an identifier, all characters
are meaningful.
Examples: <TT>foo</TT>, <TT>bar</TT>, <TT>_20</TT>,
<TT>___gee_42</TT>.</P><!--TOC subsubsection Infix/prefix operators-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc36">3.1.4.8</A>  Infix/prefix operators</H4><!--SEC END --><P>
<A NAME="@default18"></A><A NAME="@default19"></A></P><P><FONT COLOR=purple>FoCaLize</FONT> allows infix and prefix operators built from a
&#X201C;starting operator character&#X201D; and followed by a sequence of
regular identifiers or operator characters. For example, all the
following are legal operators:
<TT>+</TT>, <TT>++</TT>, <TT>~</TT><TT>+zero</TT>, <TT>=_mod_5</TT>.</P><P>The position in which to use the operator (i.e. infix or prefix)
is determined by the position of the first operator character
according to the following table:
</P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>Prefix</TD><TD ALIGN=center NOWRAP>Infix</TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X2018; ~ ? $ ! #</TD><TD ALIGN=center NOWRAP>, + - * / % &amp; | : ; &lt; = &gt; @ ^ \</TD></TR>
</TABLE>
</DIV><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="prefix-char"><I><FONT COLOR=maroon>prefix-char</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>&#X2018;</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>~</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>?</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>$</FONT></TT> &#X2223; 
<TT><FONT COLOR=blue>!</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>#</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="infix-char"><I><FONT COLOR=maroon>infix-char</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>,</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>+</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>-</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>*</FONT></TT> &#X2223; 
<TT><FONT COLOR=blue>/</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>%</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>&amp;</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>|</FONT></TT> &#X2223; 
<TT><FONT COLOR=blue>:</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>;</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>&lt;</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>=</FONT></TT> &#X2223; 
<TT><FONT COLOR=blue>&gt;</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>@</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>^</FONT></TT> &#X2223; 
<TT><FONT COLOR=blue>\</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="prefix-op"><I><FONT COLOR=maroon>prefix-op</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#prefix-char"><I><FONT COLOR=maroon>prefix-char</FONT></I></A>  {<A HREF="#letter"><I><FONT COLOR=maroon>letter</FONT></I></A> &#X2223;  <A HREF="#prefix-char"><I><FONT COLOR=maroon>prefix-char</FONT></I></A> &#X2223; 
<A HREF="#infix-char"><I><FONT COLOR=maroon>infix-char</FONT></I></A> &#X2223;  <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> &#X2223;  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP>*</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="infix-op"><I><FONT COLOR=maroon>infix-op</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#infix-char"><I><FONT COLOR=maroon>infix-char</FONT></I></A>  {<A HREF="#letter"><I><FONT COLOR=maroon>letter</FONT></I></A> &#X2223;  <A HREF="#prefix-char"><I><FONT COLOR=maroon>prefix-char</FONT></I></A> &#X2223; 
<A HREF="#infix-char"><I><FONT COLOR=maroon>infix-char</FONT></I></A> &#X2223;  <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> &#X2223;  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP>*</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="operator"><I><FONT COLOR=maroon>operator</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#infix-op"><I><FONT COLOR=maroon>infix-op</FONT></I></A> &#X2223;  <A HREF="#prefix-op"><I><FONT COLOR=maroon>prefix-op</FONT></I></A></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Hence, in the above examples, <TT>+</TT>, <TT>++</TT> and <TT>=_mod_5</TT> will be
infix operators and <TT>~</TT><TT>+zero</TT> will be a prefix one.</P><P>Note that some of these symbols, such as <TT>:</TT>, are considered as uppercase
identifiers, and others, such as <TT>+</TT>, as lowercase identifiers. The consequence
is that for example a notation starting with a <TT>:</TT> can be used as a constructor
name for a union type, but not as a method name.</P><!--TOC subsubsection Defining an infix operator-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc37">3.1.4.9</A>  Defining an infix operator</H4><!--SEC END --><P>
<A NAME="@default20"></A>
<A NAME="@default21"></A>
<A NAME="@default22"></A></P><P>The notion of infix/prefix operator does not mean that <FONT COLOR=purple>FoCaLize</FONT> defines all
these operators: it means that the programmer may freely define and use them
as ordinary prefix/infix operators instead of only writing prefix function
names and regular function application. For instance, if you do not like the
<FONT COLOR=purple>FoCaLize</FONT> predefined <CODE>^</CODE> operator to concatenate strings, you can define your
own infix synonym for <CODE>^</CODE>, say <TT>++</TT>, using:</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> ( ++ ) (</FONT><FONT SIZE=2>s1</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>s2</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>s1</FONT><FONT SIZE=2> ^ </FONT><FONT SIZE=2>s2</FONT><FONT SIZE=2> ;</FONT></TD></TR>
</TABLE><P>
Then you can use the <TT>++</TT> operator in the usual way
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>hw</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2><FONT SIZE=2>"Hello"</FONT></FONT><FONT SIZE=2> ++ </FONT><FONT SIZE=2><FONT SIZE=2>" world!"</FONT></FONT><FONT SIZE=2> ;</FONT></TD></TR>
</TABLE><P>As shown in the example, at definition-time, the syntax requires
the operator to be embraced by parentheses. More precisely, you must
enclose the operator between <B>spaces</B> and parentheses.
You must write <TT>( + )</TT> with spaces, not simply <TT>(+)</TT> (which leads
to a syntax error anyway).</P><!--TOC subsubsection Prefix form notation-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc38">3.1.4.10</A>  Prefix form notation</H4><!--SEC END --><P>
<A NAME="@default23"></A>
<A NAME="@default24"></A></P><P>The notation <TT>( op )</TT> is named the <EM>prefix form notation</EM> for
operator <TT>op</TT>.</P><P>Since you can only define prefix identifiers in <FONT COLOR=purple>FoCaLize</FONT>, you must use the
prefix form notation to define an infix or prefix operator.</P><P>When a prefix or infix operator has been defined, it is still possible
to use it as a regular identifier using its prefix form notation.
For instance, you can use the prefix form of operator <TT>++</TT>
to apply it in a prefix position as a simple regular function: </P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>... ( ++ ) (</FONT><FONT SIZE=2><FONT SIZE=2>"Hello"</FONT></FONT><FONT SIZE=2>, </FONT><FONT SIZE=2><FONT SIZE=2>" world!"</FONT></FONT><FONT SIZE=2>) ;</FONT></TD></TR>
</TABLE><P><B>Warning!</B> A common error while defining an operator is to forget
the blanks around the operator. This is particularly confusing, if you
type the <TT>*</TT> operator without blanks around the operator: you
write the lexical entity <TT>(*)</TT> which is the beginning (or the end)
of a comment!</P><P>The <FONT COLOR=purple>FoCaLize</FONT> notion of symbolic identifiers go largely beyond simple
infix operators. Symbolic identifiers let you assign sophisticated names
to your functions and operators.
For instance, instead of creating a function to check if integer <TT>x</TT>
is equal to the predecessor of integer <TT>y</TT>, as in
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is_eq_to_predecessor</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>... </FONT><FONT SIZE=2>if</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is_eq_to_predecessor</FONT><FONT SIZE=2> (5, 7) ... ;</FONT></TD></TR>
</TABLE><P>
it is possible to directly define
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> ( =</FONT><FONT SIZE=2>pred</FONT><FONT SIZE=2> ) (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>... </FONT><FONT SIZE=2>if</FONT><FONT SIZE=2> 5 =</FONT><FONT SIZE=2>pred</FONT><FONT SIZE=2> 7 ... ;</FONT></TD></TR>
</TABLE><P><B>Attention</B> : since a comma can start an infix symbol, be careful
when using commas to add a space after each comma to prevent confusion.
In particular, when using commas to separate tuple components, always type
a space after each comma. For instance, if you write <TT>(1,n)</TT>
then the lexical analyser finds only two words: the integer <TT>1</TT> as
desired, then the infix operator <TT>,n</TT> which is certainly not the
intended meaning. Hence, following usual typography rules, always type a
space after a comma (unless you have define a special operator starting
by a comma).</P><P><B>Rule of thumb</B>: The prefix version of symbolic identifiers is obtained
by enclosing the symbol between spaces and parens.</P><!--TOC subsection Extended identifiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc39">3.1.5</A>  Extended identifiers</H3><!--SEC END --><P>
<A NAME="extended-identifiers"></A>
<A NAME="@default25"></A></P><P>Moreover, <FONT COLOR=purple>FoCaLize</FONT> has special forms of identifiers to allow using
spaces inside or to extend the notion of operator identifiers.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Delimited alphanumerical identifiers</B>.
<A NAME="@default26"></A>
They start by two characters <TT>&#X2018;</TT> (backquote) and end by two
characters <TT>&#X2019;</TT> (quote). In addition to usual alpha-numerical
characters, the delimited identifiers can have spaces. For example:
<TT>&#X2018;&#X2018;equal is reflexive&#X2019;&#X2019;</TT>, <TT>&#X2018;&#X2018;fermat conjecture&#X2019;&#X2019;</TT>.
</LI><LI CLASS="li-itemize"><B>Delimited symbolic identifiers</B>.
They are delimited by the same delimitor characters and contain
symbolic characters.
</LI></UL><P>The first meaningful character at the beginning of a delimited
ident is usd to determine if it is considered as upper or lower
ident. In the same way, first meaningful character at the beginning of a
delimited symbol is used to find its associated /token.</P><!--TOC subsection Species and collection names-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc40">3.1.6</A>  Species and collection names</H3><!--SEC END --><P>
<A NAME="@default27"></A> Species, collection
names and collection parameters are uppercase identifiers.</P><!--TOC subsection Integer literals-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc41">3.1.7</A>  Integer literals</H3><!--SEC END --><P>
<A NAME="integer literals"></A>
<A NAME="octal"></A>
<A NAME="hexadecimal"></A>
<A NAME="binary"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="binary-digit"><I><FONT COLOR=maroon>binary-digit</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>0</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>1</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="octal-digit"><I><FONT COLOR=maroon>octal-digit</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>0</FONT></TT> &#X2026; <TT><FONT COLOR=blue>7</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="hexadecimal-digit"><I><FONT COLOR=maroon>hexadecimal-digit</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>0</FONT></TT> &#X2026; <TT><FONT COLOR=blue>9</FONT></TT>
&#X2223;  <TT><FONT COLOR=blue>A</FONT></TT> &#X2026; <TT><FONT COLOR=blue>F</FONT></TT>
&#X2223;  <TT><FONT COLOR=blue>a</FONT></TT> &#X2026; <TT><FONT COLOR=blue>f</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="sign"><I><FONT COLOR=maroon>sign</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>+</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>-</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-binary-literal"><I><FONT COLOR=maroon>unsigned-binary-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>0</FONT></TT> ( <TT><FONT COLOR=blue>b</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>B</FONT></TT> )
<A HREF="#binary-digit"><I><FONT COLOR=maroon>binary-digit</FONT></I></A>  { <A HREF="#binary-digit"><I><FONT COLOR=maroon>binary-digit</FONT></I></A> &#X2223;  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP>*</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-octal-literal"><I><FONT COLOR=maroon>unsigned-octal-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>0</FONT></TT> ( <TT><FONT COLOR=blue>o</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>O</FONT></TT> )
<A HREF="#octal-digit"><I><FONT COLOR=maroon>octal-digit</FONT></I></A>  { <A HREF="#octal-digit"><I><FONT COLOR=maroon>octal-digit</FONT></I></A> &#X2223;  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP>*</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-decimal-literal"><I><FONT COLOR=maroon>unsigned-decimal-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A>  { <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> &#X2223;  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP>*</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-hexadecimal-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>0</FONT></TT> ( <TT><FONT COLOR=blue>x</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>X</FONT></TT> )
<A HREF="#hexadecimal-digit"><I><FONT COLOR=maroon>hexadecimal-digit</FONT></I></A>  { <A HREF="#hexadecimal-digit"><I><FONT COLOR=maroon>hexadecimal-digit</FONT></I></A> &#X2223;  <TT><FONT COLOR=blue>_</FONT></TT> }<SUP>*</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-integer-literal"><I><FONT COLOR=maroon>unsigned-integer-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#unsigned-binary-literal"><I><FONT COLOR=maroon>unsigned-binary-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#unsigned-octal-literal"><I><FONT COLOR=maroon>unsigned-octal-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#unsigned-decimal-literal"><I><FONT COLOR=maroon>unsigned-decimal-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#unsigned-hexadecimal-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="integer-literal"><I><FONT COLOR=maroon>integer-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<A HREF="#sign"><I><FONT COLOR=maroon>sign</FONT></I></A>]  <A HREF="#unsigned-integer-literal"><I><FONT COLOR=maroon>unsigned-integer-literal</FONT></I></A></TD></TR>
</TABLE></TD></TR>
</TABLE><P>An integer literal is a sequence of one or more digits, optionally
preceded by a minus or plus sign and/or a base prefix. By default,
i.e. without a base prefix, integers are in decimal. For instance:
<TT>0</TT>, <TT>-42</TT>, <TT>+36</TT>. <FONT COLOR=purple>FoCaLize</FONT> syntax allows to also specify
integers in other bases by preceding the digits by the following
prefixes:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Binary</B>: base 2. Prefix is <TT>0b</TT> or <TT>0B</TT>.
Digits are [0-1].
</LI><LI CLASS="li-itemize"><B>Octal</B>: base 8. Prefix is <TT>0o</TT> or <TT>00</TT>.
Digits are [0-7].
</LI><LI CLASS="li-itemize"><B>Hexadecimal</B>: base 16. Prefix is <TT>0x</TT> or <TT>0X</TT>.
Digits are [0-9] [A-F] [a-f].
</LI></UL><P>
Here are various examples of integers in various bases:
<TT>-0x1Ff</TT>, <TT>0B01001</TT>, <TT>+Oo347</TT>, <TT>-OxFF_FF</TT>.</P><!--TOC subsection String literals-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc42">3.1.8</A>  String literals</H3><!--SEC END --><P>
<A NAME="string literal"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="string-literal"><I><FONT COLOR=maroon>string-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>"</FONT></TT>
{ <A HREF="#plain-char"><I><FONT COLOR=maroon>plain-char</FONT></I></A> &#X2223;  <TT><FONT COLOR=blue>\</FONT></TT> <A HREF="#char-escape"><I><FONT COLOR=maroon>char-escape</FONT></I></A> }<SUP>*</SUP>
<TT><FONT COLOR=blue>"</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="plain-char"><I><FONT COLOR=maroon>plain-char</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <EM>any printable character except backslash
(</EM><EM>\</EM><EM>) and double quote (</EM><EM><TT>"</TT></EM><EM>)</EM>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="char-escape"><I><FONT COLOR=maroon>char-escape</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>b</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>n</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>r</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>t</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>&#X2423;</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>"</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>&#X2019;</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>*</FONT></TT>
&#X2223;  <TT><FONT COLOR=blue>\</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>&#X2018;</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>-</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>)</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>[</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>]</FONT></TT>
&#X2223;  <TT><FONT COLOR=blue>{</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>}</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A>  <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A>  <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#hexadecimal-digit"><I><FONT COLOR=maroon>hexadecimal-digit</FONT></I></A>  <A HREF="#hexadecimal-digit"><I><FONT COLOR=maroon>hexadecimal-digit</FONT></I></A></TD></TR>
</TABLE></TD></TR>
</TABLE><P>String literals are sequences of any characters delimited by <TT>"</TT>
(double quote) characters (<EM>ipso facto</EM> with no intervening
<TT>"</TT>).
Escape sequences (meta code to insert characters that can&#X2019;t appear
simply in a string) available in string literals are summarised in the
table below:</P><P><BR>
</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP> Sequence</TD><TD VALIGN=top ALIGN=center NOWRAP>Character</TD><TD VALIGN=top ALIGN=left>Comment</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">b</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP>\008</TD><TD VALIGN=top ALIGN=left>Backspace.</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">n</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP>\010</TD><TD VALIGN=top ALIGN=left>Line feed.</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">r</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP>\013</TD><TD VALIGN=top ALIGN=left>Carriage return.</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">t</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP>\009</TD><TD VALIGN=top ALIGN=left>Tabulation.</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">&#X2423;</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#X2423;</TD><TD VALIGN=top ALIGN=left>Space character.</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">"</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>"</TT></TD><TD VALIGN=top ALIGN=left>Double quote.</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">&#X2019;</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>&#X2019;</TT></TD><TD VALIGN=top ALIGN=left>Single quote.</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> </TD><TD VALIGN=top ALIGN=center NOWRAP>*</TD><TD VALIGN=top ALIGN=left>Allows e.g. for insertion of &#X201C;(*&#X201D; in a string</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">(</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP>(</TD><TD VALIGN=top ALIGN=left>6*See comment above for</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">)</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP>)</TD><TD VALIGN=top ALIGN=left>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">[</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP>[</TD><TD VALIGN=top ALIGN=left>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">]</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP>]</TD><TD VALIGN=top ALIGN=left>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">{</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP>{</TD><TD VALIGN=top ALIGN=left>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">}</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP>}</TD><TD VALIGN=top ALIGN=left>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">\</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP>\</TD><TD VALIGN=top ALIGN=left>Backslash character.</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">&#X2018;</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#X2018;</TD><TD VALIGN=top ALIGN=left>Backquote character.</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">-</FONT></TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>-</TT></TD><TD VALIGN=top ALIGN=left>Minus (dash) character. As for multi-line
comments, uni-line comments can&#X2019;t appear in
strings. Hence, to insert the sequence
&#X201C;<TT>--</TT>&#X201D; use this escape
sequence twice.</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><EM>digit digit digit</EM></TD><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left>The character whose ASCII code in
<B>decimal</B> is given by the 3 digits
following the \. This
sequence is valid for all
ASCII codes.</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP> <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">0x</FONT></TT><EM> hex hex</EM></TD><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left>The character whose ASCII code in
<B>hexadecimal</B> is given by the 2
characters following the \. This
sequence is valid for all
ASCII codes.</TD></TR>
</TABLE><!--TOC subsection Character literals-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc43">3.1.9</A>  Character literals</H3><!--SEC END --><P>
<A NAME="character literals"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="character-literal"><I><FONT COLOR=maroon>character-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>&#X2019;</FONT></TT>
( <A HREF="#plain-char"><I><FONT COLOR=maroon>plain-char</FONT></I></A> &#X2223;  <TT><FONT COLOR=blue>\</FONT></TT> <A HREF="#char-escape"><I><FONT COLOR=maroon>char-escape</FONT></I></A> )
<TT><FONT COLOR=blue>&#X2019;</FONT></TT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Characters literals are composed of one character enclosed between two
&#X201C;<TT>&#X2019;</TT>&#X201D; (quote) characters. Example: <TT>&#X2019;a&#X2019;</TT>, <TT>&#X2019;?&#X2019;</TT>.
Escape sequences (meta code to insert characters that can&#X2019;t appear
simply in a character literal) must also be enclosed by
quotes. Available escape sequences are summarised in the table above
(see section <A HREF="#string literal">3.1.8</A>).</P><!--TOC subsection Floating-point number literals-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc44">3.1.10</A>  Floating-point number literals</H3><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="decimal-literal"><I><FONT COLOR=maroon>decimal-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<A HREF="#sign"><I><FONT COLOR=maroon>sign</FONT></I></A>]  <A HREF="#unsigned-decimal-literal"><I><FONT COLOR=maroon>unsigned-decimal-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="hexadecimal-literal"><I><FONT COLOR=maroon>hexadecimal-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<A HREF="#sign"><I><FONT COLOR=maroon>sign</FONT></I></A>]  <A HREF="#unsigned-hexadecimal-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="scientific-notation"><I><FONT COLOR=maroon>scientific-notation</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>e</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>E</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-decimal-float-literal"><I><FONT COLOR=maroon>unsigned-decimal-float-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#unsigned-decimal-literal"><I><FONT COLOR=maroon>unsigned-decimal-literal</FONT></I></A>
 [<TT><FONT COLOR=blue>.</FONT></TT> {<A HREF="#unsigned-decimal-literal"><I><FONT COLOR=maroon>unsigned-decimal-literal</FONT></I></A>}<SUP>*</SUP>] 
 [<A HREF="#scientific-notation"><I><FONT COLOR=maroon>scientific-notation</FONT></I></A>  <A HREF="#decimal-literal"><I><FONT COLOR=maroon>decimal-literal</FONT></I></A>]
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-hexadecimal-float-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-float-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#unsigned-hexadecimal-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-literal</FONT></I></A>
 [<TT><FONT COLOR=blue>.</FONT></TT> {<A HREF="#unsigned-hexadecimal-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-literal</FONT></I></A>}<SUP>*</SUP>] 
 [<A HREF="#scientific-notation"><I><FONT COLOR=maroon>scientific-notation</FONT></I></A>  <A HREF="#hexadecimal-literal"><I><FONT COLOR=maroon>hexadecimal-literal</FONT></I></A>]
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="unsigned-float-literal"><I><FONT COLOR=maroon>unsigned-float-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#unsigned-decimal-float-literal"><I><FONT COLOR=maroon>unsigned-decimal-float-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#unsigned-hexadecimal-float-literal"><I><FONT COLOR=maroon>unsigned-hexadecimal-float-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="float-literal"><I><FONT COLOR=maroon>float-literal</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> [<A HREF="#sign"><I><FONT COLOR=maroon>sign</FONT></I></A>]  <A HREF="#unsigned-float-literal"><I><FONT COLOR=maroon>unsigned-float-literal</FONT></I></A></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Floating-point numbers literals are made of an optional sign (&#X2019;+&#X2019; or
&#X2019;-&#X2019;) followed by a non-empty sequence of digits followed by a dot
(&#X2019;.&#X2019;) followed by a possibly empty sequence of digits and finally an
optional scientific notation (&#X2019;e&#X2019; or &#X2019;E&#X2019; followed an optional sign
then by a non-empty sequence of digits. <FONT COLOR=purple>FoCaLize</FONT> allows floats to be
written in decimal or in hexadecimal. In the first case, digits are
[0-9]. Example: <TT>0.</TT>, <TT>-0.1</TT>, <TT>1.e-10</TT>, <TT>+5E7</TT>.
In the second case, they are [0-9 a-f A-F] and the number must be
prefixed by &#X201C;0x&#X201D; or &#X201C;0X&#X201D;. Example <TT>0xF2.E4</TT>, <TT>0X4.3A</TT>,
<TT>Ox5a.a3eef</TT>, <TT>Ox5a.a3e-ef</TT>.</P><!--TOC subsection Proof step bullets-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc45">3.1.11</A>  Proof step bullets</H3><!--SEC END --><P>
<A NAME="@default28"></A>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="proof-step-bullet"><I><FONT COLOR=maroon>proof-step-bullet</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>&lt;</FONT></TT> {<A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A>}<SUP>+</SUP> <TT><FONT COLOR=blue>&gt;</FONT></TT>
 { <A HREF="#letter"><I><FONT COLOR=maroon>letter</FONT></I></A> &#X2223;  <A HREF="#digit"><I><FONT COLOR=maroon>digit</FONT></I></A> }<SUP>+</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>A proof step bullet is a non-negative non-signed integer literal
(i.e. a non empty sequence of [0-9] characters) delimited by the
characters <TT>&lt;</TT> and <TT>&gt;</TT>, followed by a non-empty sequence of
alphanumeric characters (i.e. [A-Z a-z 0-9]).
The first part of the bullet (i.e. the integer literal) stands for the
depth of the bullet and the second part stands for its name. Example:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2> &lt;1&gt;1 </FONT><FONT SIZE=2>assume</FONT><FONT SIZE=2> ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>prove</FONT><FONT SIZE=2> ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   &lt;2&gt;1 </FONT><FONT SIZE=2>prove</FONT><FONT SIZE=2> ... </FONT><FONT SIZE=2>by</FONT><FONT SIZE=2> ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   &lt;2&gt;</FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>qed</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>by</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>step</FONT><FONT SIZE=2> &lt;2&gt;1 </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2> &lt;1&gt;2 </FONT><FONT SIZE=2>conclude</FONT></TD></TR>
</TABLE><!--TOC subsection Name qualification-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc46">3.1.12</A>  Name qualification</H3><!--SEC END --><P>
<A NAME="qualified-name"></A>
<A NAME="@default29"></A> <A NAME="@default30"></A>
<A NAME="@default31"></A></P><P>Name qualification is done according to the
compilation unit status.</P><P>As precisely described in section (<A HREF="#toplevel-def">4.1.1</A>),
toplevel-definitions include species, collections, type definitions
(and their constitutive elements like constructors, record fields),
toplevel-theorems and toplevel-functions. Any toplevel-definition (thus
outside species and collections) is visible all along the compilation unit
after its apparition.
If a toplevel-definition is required by another compilation unit, you can
reference it by referencing the external compilation unit
(with a <TT>use</TT> or a <TT>open</TT> command) and then
<B>qualifying</B> its name, i.e. making explicit the
compilation unit&#X2019;s name before the definition&#X2019;s name using the &#X2019;#&#X2019;
character as delimiter. Examples:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>basics#string</TT> stands for the type definition of
<TT>string</TT> coming from the source file &#X201C;basics.fcl&#X201D;.
</LI><LI CLASS="li-itemize"><TT>basics#Basic_object</TT> stands for the species
<TT>Basic_object</TT> defined in the source file &#X201C;basics.fcl&#X201D;.
</LI><LI CLASS="li-itemize"><TT>db#My_db_coll!create</TT> stands for the method
<TT>create</TT> of a collection <TT>My_db_coll</TT> hosted in the
source file &#X201C;db.fcl&#X201D;.
</LI></UL><P><A NAME="@default32"></A>
The qualification can be omitted by using the <TT>open</TT> directive
that loads the interface of the argument compilation unit and make it
directly visible in the scope of the current compilation unit. For
instance:</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>use</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"basics"</FONT></FONT><FONT SIZE=2>;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>basics</FONT><FONT SIZE=2>#</FONT><FONT SIZE=2>Basic_object</FONT><FONT SIZE=2>; ... </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>
can be transformed with no explicit qualification into:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>open</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"basics"</FONT></FONT><FONT SIZE=2>;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Basic_object</FONT><FONT SIZE=2>; ... </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>After an <TT>open</TT> directive, the definitions of loaded (object files
of) compilation units are added in head of the current scope and mask
existing definitions wearing the same names. For example, in
the following program: <FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><EM><FONT SIZE=2>(* Redefine my basic object, containing nothing. *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Basic_object</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>open</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"basics"</FONT></FONT><FONT SIZE=2>;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Basic_object</FONT><FONT SIZE=2>; ... </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>
the species <TT>S</TT> inherits from the last <TT>Basic_object</TT> in the
scope, that is the one loaded by the <TT>open</TT> directive and not from
the one defined at the beginning of the program. It is still possible
to recover the first definition by using the &#X201C;empty&#X201D; qualification
<TT>#Basic_object</TT> in the definition of <TT>S</TT>:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><EM><FONT SIZE=2>(* Redefine my basic object, containing nothing. *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Basic_object</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>open</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"basics"</FONT></FONT><FONT SIZE=2>;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> #</FONT><FONT SIZE=2>Basic_object</FONT><FONT SIZE=2>; ... </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>The qualification starting by a &#X2019;#&#X2019; character without compilation
unit name before stands for &#X201C;the definition at toplevel of the
current compilation unit&#X201D;.</P><!--TOC subsection Reserved keywords-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc47">3.1.13</A>  Reserved keywords</H3><!--SEC END --><P>
The identifiers below are reserved keywords that cannot be employed
otherwise:
</P><PRE CLASS="verbatim">   alias all and as assume assumed
   begin by
   caml collection conclude coq coq_require
   definition
   else end ex external
   false function
   hypothesis
   if in inherit internal implement is
   let lexicographic local logical
   match measure
   not notation
   of on open or order
   proof prop property prove
   qed
   rec representation
   Self signature species step structural
   termination then theorem true type
   use
   with
</PRE><P>Keywords of <FONT COLOR=purple>Coq</FONT>or <FONT COLOR=purple>OCaml</FONT>are also reserved (For example <TT>Set</TT>),
and may cause problems at later stages of the <FONT COLOR=purple>FoCaLize</FONT>compilation.</P><P>Some symbols (such as <TT>:</TT>) are also reserved, and cannot be used to name methods.
It is still possible to use such symbols as first character of a symbolic identifier.

</P><!--TOC section Language constructs and syntax-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc48">3.2</A>  Language constructs and syntax</H2><!--SEC END --><!--TOC subsection Types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc49">3.2.1</A>  Types</H3><!--SEC END --><P>
Before dealing with expressions and in general, constructs that allow to
compute, let us first examine data-type definitions since, to emit its
result, an algorithm must manipulate data that are more or less specific to
the algorithm. Hence we must know about type definitions to define data that
have a convenient shape and carry the necessary information to model the
problem at hand.</P><P>Type definitions allow to build new types or more complex types by
combining previously existing types. They always appear as
toplevel-definitions, in other words, outside species and
collections. Hence a type definition is visible in the whole
compilation unit (and also in other units by using the <TT>open</TT>
directive or by qualifying the type name as described in section
<A HREF="#qualified-name">3.1.12</A>).</P><!--TOC subsubsection Type constructors-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc50">3.2.1.1</A>  Type constructors</H4><!--SEC END --><P>
A <B>type constructor</B> is, roughly speaking, a type name.</P><P><FONT COLOR=purple>FoCaLize</FONT> provides the basic built-in
types (constructors):
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>int</TT> for signed machine integers,
</LI><LI CLASS="li-itemize"><TT>bool</TT> for boolean values (<TT>true</TT> and <TT>false</TT> that
are hardwired in the syntax or <TT>True</TT> and <TT>False</TT> that are
defined in &#X201C;basics.fcl&#X201D;),
</LI><LI CLASS="li-itemize"><TT>float</TT> for floating point numbers,
</LI><LI CLASS="li-itemize"><TT>unit</TT> for the trivial type whose only value is <TT>()</TT>,
</LI><LI CLASS="li-itemize"><TT>char</TT> for characters literals,
</LI><LI CLASS="li-itemize"><TT>string</TT> for strings literals.
</LI></UL><P>
Note that these types are translated to <FONT COLOR=purple>OCaml</FONT>types; for example
<TT>int</TT> on 32-bits architecture encode values between &#X2212;2<SUP>30</SUP>
and +2<SUP>30</SUP>&#X2212;1.</P><P>New type constructors are introduced by
<B>type definitions</B>.
Types constructors can be parameterised by <B>type expressions</B>
separated by commas and between parentheses.</P><!--TOC subsubsection Type expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc51">3.2.1.2</A>  Type expressions</H4><!--SEC END --><P>
<A NAME="@default33"></A>
<A NAME="@default34"></A>
Type definitions require <B>type expressions</B> to build more complex
data-types.
<BR>

</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#uident"><I><FONT COLOR=maroon>uident</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>Self</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>&#X2019;</FONT></TT><A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> <TT><FONT COLOR=blue>(</FONT></TT>  {<A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP>+</SUP> <TT><FONT COLOR=blue>)</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A> <TT><FONT COLOR=blue>-&gt;</FONT></TT>  <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> {<A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>}(<TT><FONT COLOR=blue>*</FONT></TT>)<SUP>+</SUP> <TT><FONT COLOR=blue>)</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A> <TT><FONT COLOR=blue>)</FONT></TT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
<BR>
</P><P>A type expression can be a type constructor.</P><P>A type expression can denote the representation of a species or a
collection by using their name, thus a capitalized name. The special
case of <TT>Self</TT> denotes the representation of the current
species. Hence, obviously <TT>Self</TT> is only bound in the scope of a
species.</P><P>Type expressions representing function types are written using the
arrow notation (<TT>-&gt;</TT>) in which the type of the argument of the
function is the left type expression and its return type is the right
one. As usual in functional languages, a function with several (say
<I>n</I>) arguments is considered as a function with <B>1</B> argument
returning a function with <I>n</I>&#X2212;1 arguments. Hence,
<TT>int -&gt; int -&gt; bool</TT> is the type of a function taking 2 integers
and returning a boolean.</P><P><A NAME="@default35"></A>
<FONT COLOR=purple>FoCaLize</FONT> provides native tuples (generalisation of pairs). The type of
a tuple is the type of each of its components separated by a *
character and surrounded by parentheses. Hence,
<TT>(int * bool * string) </TT> is the type of triplets whose first
component is an integer, second component is a boolean and third
component is a string, e.g. <TT>(-3, true, "test")</TT>.</P><P>Finally, type expressions can be written between parentheses without
changing their semantics.</P><!--TOC subsubsection Type definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc52">3.2.1.3</A>  Type definitions</H4><!--SEC END --><P>
<A NAME="@default36"></A>
<A NAME="type-definition"></A>
A type <B>definition</B> introduces a new type
constructor (the name of the type), which becomes available to build
new type expressions. Hence, defining a type is the
way to give a name to a new type structure. <FONT COLOR=purple>FoCaLize</FONT> proposes 3 kinds
of type definitions: aliases, sum types and record types.</P><P><BR>
<B>Aliases</B></P><P><A NAME="@default37"></A></P><P><BR>
<BR>
</P><P>Aliases provide a way to create type abbreviations. It is not handy to
manipulate large <B>type expressions</B> like for instance, a tuple of
5 components: <TT>(int * int * int * int * int)</TT>. Moreover, several
kind of information can be represented by such a
tuple. For instance, a tuple with x, y, z (3D-coordinates), temperature and
pressure has the same type as a tuple with year, month, day, hours, minutes. In
these two cases, the manipulated type expression is the same and
the two uses cannot be easily differentiated. Type aliases allows to
give a name to a
(complex) type expression, for sake of readability or to shorten the
code. Example:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>experiment_conditions</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2><B>alias</B></FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>) ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>date</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2><B>alias</B></FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>) ;;</FONT></TD></TR>
</TABLE><P><BR>

</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="alias-type-def"><I><FONT COLOR=maroon>alias-type-def</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>type</FONT></TT> <A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A> <TT><FONT COLOR=blue>= alias</FONT></TT>  <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
<BR>
</P><P>In the remaining of the development, the type names
<TT>experiment_conditions</TT> and <TT>date</TT> will be known to be
tuples of 5 integers and will be compatible with any other type being
also a tuple of 5 integers. This especially means that a <EM>type alias
does not create a really &#X201C;new&#X201D; type, it only gives a name to a type
expression and this name is type-compatible with any occurrence of the
type expression it is bound to</EM>. Obviously, it is possible to use
aliases with and in any type expression or type definition.</P><P><BR>
<B>Sum types</B>
<A NAME="@default38"></A>
<A NAME="@default39"></A></P><P>Sum types provide the way to create new <B>values</B> that
belong to the same <B>type</B>. Like <TT>1</TT> or <TT>42</TT> are
<B>values</B> of <B>type</B> <TT>int</TT>, one may want to have <TT>Red</TT>,
<TT>Blue</TT> and <TT>Green</TT> as the <B>only</B> values of a new type
called <TT>color</TT>. The <B>only</B> means that the created type <TT>color</TT>
is inhabited only by these 3 values. To define
such a type, we itemize its value names (that are always capitalized
identifiers) by preceeding them by a <TT><FONT COLOR="red">|</FONT></TT> character :</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>color</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Red</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Blue</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Green</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><P>
Note that the first <TT><FONT COLOR="red">|</FONT></TT> character is required: it is not a
separator. This especially means that when writing a sum type
definition on a single line, the first <TT><FONT COLOR="red">|</FONT></TT> must be written:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>color</FONT><FONT SIZE=2> = | </FONT><FONT SIZE=2>Red</FONT><FONT SIZE=2> | </FONT><FONT SIZE=2>Blue</FONT><FONT SIZE=2> | </FONT><FONT SIZE=2>Green</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P><A NAME="@default40"></A>
<B>Values</B> of a sum type are built from the
<B>value constructors</B>, i.e. from the names enumerated in the
definition (that must not be confused with the <B>type constructor</B>
which is the name of the type. For, instance,
<TT>Red</TT> is a <B>value</B> of the type constructor <TT>color</TT>.</P><P>Value constructors of sum
types can be <B>parameterised</B> by a type expressions, corresponding
values being obtained by applying the value constructor to values of
the parameters types. For instance, let&#X2019;s define the type of playing
cards as king, queen, jack and simply numbered cards:</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>card</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>King</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Queen</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Jack</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Numbered</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><P> Hence, the <TT>Numbered</TT> constructor &#X201C;carries&#X201D; the integer value
written on the card. Some values of type <TT>card</TT> are: <TT>King</TT>,
<TT>(Numbered 4)</TT>, <TT>(Numbered 42)</TT>. The <TT>Numbered</TT>
constructor has <B>parameter</B>.</P><P><A NAME="@default41"></A>
<BR>
An important attention must be taken for constructors having
&#X201C;several&#X201D; arguments. <FONT COLOR=purple>FoCaLize</FONT> provides 2 different
(&#X201C;type-incompatible&#X201D;) ways to make a value constructor carrying
several values.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Either the constructor has <B>1</B> argument that is a tuple,
i.e. a type expression involving the <TT>*</TT> constructor.<P>The corresponding type definition for such a type would be:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>t</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Cstr</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>string</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE></LI><LI CLASS="li-itemize">Or the constructor has <B>several</B> arguments, i.e. several
type expressions separated by a comma.
<FONT SIZE=2>
</FONT><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>t2</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Cstr2</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>string</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE>
means that the constructor <TT>Cstr2</TT> has <B>3 arguments</B>.
</LI></UL><P><BR>
This especially important since when matching on such value
constructors, confusing the argument<B>s</B> of <TT>Cstr2</TT> with
one and unique tuple with 3 components will result in a type error.
Below are shown several pieces of source code with valid/invalid mixes
between these concepts.
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>mytuple</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2><B>alias</B></FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>string</FONT><FONT SIZE=2>) ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>t</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Cstr</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>string</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>fct_t1</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>match</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>with</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | </FONT><FONT SIZE=2>Cstr</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>b</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>c</FONT><FONT SIZE=2>) -&gt; ()</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><P>
leads to
</P><PRE CLASS="verbatim">Error: Types
(basics#bool * basics#int * basics#string),  '_a,  '_b and
(basics#bool * basics#int * basics#string) are not compatible.
</PRE><P>because <TT>Cstr</TT> expects 1 tuple argument and not 3
arguments.</P><P><BR>
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>fct_t1</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>match</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>with</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | </FONT><FONT SIZE=2>Cstr</FONT><FONT SIZE=2> ((</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>b</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>c</FONT><FONT SIZE=2>)) -&gt; ()</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><P>
is accepted since it makes explicit that the pattern matches
the unique argument of <TT>Cstr</TT> that is a tuple and by the way
de-structurates this tuple.</P><P><BR>
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>fct_t2</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>mytuple</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>match</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>with</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | </FONT><FONT SIZE=2>Cstr</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) -&gt; </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><P>
is accepted since the type <TT>mytuple</TT> aliases a 3
components tuples and <TT>Cstr</TT> is really parametrised by 1 argument
that is a 3 components tuple.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>fct_t2</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>match</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>with</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | </FONT><FONT SIZE=2>Cstr2</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>b</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>c</FONT><FONT SIZE=2>) -&gt; ()</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><P>NOTA: TO BE COMPLETED.</P><P>Any type expression, even recursive, can be used as a parameter of
value contructors<A NAME="@default42"></A>.
For instance, the type of lists of boolean × integer pairs
could be defined like:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>b_i_list</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Empty</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Cons</FONT><FONT SIZE=2> ((</FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>) * </FONT><FONT SIZE=2>b_i_list</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><P> From this type definition, a value of type <TT>b_i_list</TT> is
either empty (constructor <TT>Empty</TT>) or has a head (the first
component of the <TT>Cons</TT> constructor) and a tail list (the
second component of this constructor): <TT>Cons ((false, 2), (Cons
((true, 1), Empty)))</TT>. The length of this list is 2 and its
elements are <TT>(false, 2)</TT> followed by <TT>(true, 1)</TT>.</P><P><BR>
<BR>
</P><P><BR>

</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="type-params"><I><FONT COLOR=maroon>type-params</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>(</FONT></TT> {<TT><FONT COLOR=blue>&#X2019;</FONT></TT> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP>+</SUP> <TT><FONT COLOR=blue>)</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="type-args"><I><FONT COLOR=maroon>type-args</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>(</FONT></TT> {<A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP>+</SUP> <TT><FONT COLOR=blue>)</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="constructor"><I><FONT COLOR=maroon>constructor</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>|</FONT></TT> <A HREF="#uident"><I><FONT COLOR=maroon>uident</FONT></I></A>  [<A HREF="#type-args"><I><FONT COLOR=maroon>type-args</FONT></I></A>]
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="sum-type-def"><I><FONT COLOR=maroon>sum-type-def</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>type</FONT></TT> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A>  [<A HREF="#type-params"><I><FONT COLOR=maroon>type-params</FONT></I></A>] <TT><FONT COLOR=blue>=</FONT></TT>
 {<A HREF="#constructor"><I><FONT COLOR=maroon>constructor</FONT></I></A>}<SUP>+</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
<BR>
</P><P><BR>
<B>Record types</B>
<A NAME="record-type-definition"></A>
<A NAME="@default43"></A></P><P><BR>
<BR>
</P><P>Record types provide a way to aggregate data of various types, a bit like
tuples, but naming the components of the group, instead of
differentiating them by their position like in tuples. A record is
a sequence of names and types between braces. For example:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>experiment_conditions</FONT><FONT SIZE=2> = {</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>temperature</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>pressure</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>} ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>identity</FONT><FONT SIZE=2> = {</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>name</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>string</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>birth</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>living</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>} ;;</FONT></TD></TR>
</TABLE><P><BR>

</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="field"><I><FONT COLOR=maroon>field</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> <TT><FONT COLOR=blue>=</FONT></TT>  <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A> <TT><FONT COLOR=blue>;</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="record-type-def"><I><FONT COLOR=maroon>record-type-def</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>type</FONT></TT> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A>  <A HREF="#type-params"><I><FONT COLOR=maroon>type-params</FONT></I></A> <TT><FONT COLOR=blue>=</FONT></TT>
<TT><FONT COLOR=blue>{</FONT></TT>  {<A HREF="#field"><I><FONT COLOR=maroon>field</FONT></I></A>}<SUP>+</SUP> <TT><FONT COLOR=blue>}</FONT></TT></TD></TR>
</TABLE></TD></TR>
</TABLE><P><BR>
</P><P>To create a <B>value</B> of a record type, a value
must be provided for each field of the record.
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>{ </FONT><FONT SIZE=2>name</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2><FONT SIZE=2>"Benjamin"</FONT></FONT><FONT SIZE=2> ; </FONT><FONT SIZE=2>birth</FONT><FONT SIZE=2> = 2003 ; </FONT><FONT SIZE=2>living</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>true</FONT><FONT SIZE=2> }</FONT></TD></TR>
</TABLE><P>
Like in tuples, records can mix types of fields.</P><P><BR>
<B>Parameterised type definitions</B></P><P>It is possible, <EM>at toplevel</EM>, to <B>parameterise a type
definition</B> with a <B>type variable</B> that
can be instantiated by any type expression. A type variable is written
as an identifier preceded by a <TT>&#X2019;</TT> (quote) character.</P><P>For instance, the type
definition of generic (polymorphic) lists may be defined by:</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>list</FONT><FONT SIZE=2> ('</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Empty</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Cons</FONT><FONT SIZE=2> ('</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2>,  </FONT><FONT SIZE=2>list</FONT><FONT SIZE=2> ('</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2>))</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><P>The value
constructor <TT>Cons</TT> carries a value of type &#X201C;variable&#X201D;
and a tail of type
<TT>list</TT> with its parameter instantiated by the same type
variable. This explicitly says that all the elements of such a list
have the same type. It is now possible to use the <TT>list</TT> type in
type <B>expressions</B> by providing a type <B>expression</B> as
argument of the <B>type constructor</B> <TT>list</TT>. For instance,
<TT>list (int)</TT> is the type of lists containing integers,
<TT>list (list (char))</TT> is the type of lists containing lists of
characters.</P><P>Parameterised record types can also be introduced, as in the following example:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>pair</FONT><FONT SIZE=2> ('</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2>, '</FONT><FONT SIZE=2>b</FONT><FONT SIZE=2>) = {</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>first</FONT><FONT SIZE=2> : '</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>second</FONT><FONT SIZE=2> : '</FONT><FONT SIZE=2>b</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>} ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int_bool_pair</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>pair</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2>) ;;</FONT></TD></TR>
</TABLE><!--TOC subsection Type-checking-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc53">3.2.2</A>  Type-checking</H3><!--SEC END --><P>
The type-checking process is roughly similar to ML
type-checking. Polymorphic types are allowed at top-level. However,
methods are not allowed to be polymorphic. This means that their types
cannot contain variables. But they may contain collection parameters
as stated in section <A HREF="#collection-parameter">4.2.1</A>.</P><P>A type <I>t</I><SUB>1</SUB> is an <B>instanciation</B> of a type <I>t</I><SUB>2</SUB> if <I>t</I><SUB>1</SUB> is obtained
by replacing some type variables of <I>t</I><SUB>2</SUB> by a &#X201C;more defined type
expression&#X201D;.</P><P>For example, &#X2032;<I>a</I> &#X2192; <TT> <I>int</I> </TT> &#X2192; <TT> <I>bool</I> </TT>
is an instanciation of
&#X2032;<I>a</I> &#X2192; <TT> <I>int</I> </TT> &#X2192; &#X2032;<I>c</I> since we replaced
the variable &#X2032;<I>c</I> by the type <TT>bool</TT>.</P><P><BR>
Two types <I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB> are said <B>compatible</B><A NAME="@default44"></A>
if they have a <B>common</B> instanciation. For the intuition, this
means that there is an instanciation of the variables in <I>t</I><SUB>1</SUB> and
an instanciation of the variables in <I>t</I><SUB>2</SUB> such that these instanciations
make <I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB> the same type. Note that type variables appearing in
different type expressions are different variables, that is
&#X2032;<I>a</I> &#X2192; <TT><I>int</I></TT> and <TT><I>bool</I></TT> &#X2192; &#X2032;<I>a</I> are compatible.</P><P>For example, we consider the two following types:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>t</I><SUB>1</SUB> = &#X2032;<I>a</I> &#X2192; <TT> <I>int</I> </TT> &#X2192; &#X2032;<I>b</I> &#X2192; &#X2032;<I>c</I>
</LI><LI CLASS="li-itemize"><I>t</I><SUB>2</SUB> = <TT><I>bool</I> </TT> &#X2192; &#X2032;<I>d</I> &#X2192; &#X2032;<I>d</I> &#X2192; &#X2032;<I>e</I>
</LI></UL><P>In <I>t</I><SUB>1</SUB> we replace: &#X2032;<I>a</I> by <TT>bool</TT>, and we leave the others
variables unchanged. We get the new type
<I>t</I>&#X2032;<SUB>1</SUB> = <TT><I>bool</I> </TT> &#X2192; <TT> <I>int</I> </TT> &#X2192; &#X2032;<I>b</I> &#X2192; &#X2032;<I>c</I>.</P><P>In <I>t</I><SUB>2</SUB>, we replace &#X2032;<I>d</I> by <TT>int</TT>, &#X2032;<I>e</I> by &#X2032;<I>c</I>. We get the new
type
<I>t</I>&#X2032;<SUB>2</SUB> = <TT><I>bool</I> </TT> &#X2192; <TT> <I>int</I> </TT> &#X2192; <TT> <I>int</I> </TT> &#X2192; &#X2032;<I>c</I>.</P><P>The type <I>t</I>&#X2032;<SUB>1</SUB> is an instanciation of <I>t</I><SUB>1</SUB>. The type <I>t</I>&#X2032;<SUB>2</SUB> is an
instanciation of <I>t</I><SUB>2</SUB>. The two types <I>t</I>&#X2032;<SUB>1</SUB> and <I>t</I>&#X2032;<SUB>2</SUB> are
structurally the same. Hence <I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB> are <B>compatible</B>.</P><P>As it can be seen, an instanciation does not need to give a value to all the
type variables.</P><P><BR>
For the sake of intuition, compatibility is a generalisation of
the notion of types being &#X201C;equal&#X201D;. The most trivial instanciation
appears when the two types do not have any type variables; in
this case they are compatible iff they are structurally equal. This
illustrates the common view of &#X201C;being a good type&#X201D; when for
instance providing an argument to a function according to the type of
the expected argument in the function&#X2019;s prototype.</P><!--TOC subsection Representations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc54">3.2.3</A>  Representations</H3><!--SEC END --><P><A NAME="representation-type"></A>
As further explained (see section <A HREF="#rep-is-method">4.1.2</A>) the
representation is a method of a species that describes the internal
data structure that the species manages. Hence, it is a kind of <B>type definition</B>, more accurately an <B>alias type
definition</B>. This means that a representation does not introduce a
new type, it only &#X201C;assigns&#X201D; to the representation a <B>type
expression</B> defining the type of the manipulated entities of the
species. Moreover, like for any other methods (c.f. section
<A HREF="#no-polymorphism-for-methods">4.1.2</A>), <EM>the representation must not
be a polymorphic type</EM>. Thus its definition cannot
contain type variables (but may contain collection parameter
names). Defining a species&#X2019; representation is simply done by adding the
<TT>representation</TT> method:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>open</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"basics"</FONT></FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>IntPair</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>representation</FONT><FONT SIZE=2> = (</FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>Recall that the type introduced by the method <TT>representation</TT> is
denoted by <TT>Self</TT> within the species.</P><P><BR>

</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="representation"><I><FONT COLOR=maroon>representation</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>representation =</FONT></TT> <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A></TD></TR>
</TABLE></TD></TR>
</TABLE><P><BR>
</P><!--TOC subsection Expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc55">3.2.4</A>  Expressions</H3><!--SEC END --><P>
<A NAME="expressions"></A>
<A NAME="@default45"></A> Expressions are constructs of the language that are
evaluated into a <B>value</B> of a certain <B>type</B>. Hence values and
types are not at the same level. Types serve to classify values into
categories. Although proofs may contain expressions, we describe them
in Sec. <A HREF="#making-proofs">5</A>. Indeed proofs are not expressions, they do
not lead to <FONT COLOR=purple>FoCaLize</FONT> values thus live at another level.</P><P><BR>

</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="qualified-uident"><I><FONT COLOR=maroon>qualified-uident</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[[<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>] <TT><FONT COLOR=blue>#</FONT></TT>]  <A HREF="#uident"><I><FONT COLOR=maroon>uident</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="qualified-lident"><I><FONT COLOR=maroon>qualified-lident</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[[<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>] <TT><FONT COLOR=blue>#</FONT></TT>]  <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="lident-or-operator"><I><FONT COLOR=maroon>lident-or-operator</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> &#X2223;  <TT><FONT COLOR=blue>(</FONT></TT> <A HREF="#operator"><I><FONT COLOR=maroon>operator</FONT></I></A> <TT><FONT COLOR=blue>)</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="method-ident"><I><FONT COLOR=maroon>method-ident</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<TT><FONT COLOR=blue>Self</FONT></TT>] <TT><FONT COLOR=blue>!</FONT></TT> <A HREF="#lident-or-operator"><I><FONT COLOR=maroon>lident-or-operator</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> [<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> <TT><FONT COLOR=blue>#</FONT></TT>]  <A HREF="#uident"><I><FONT COLOR=maroon>uident</FONT></I></A> <TT><FONT COLOR=blue>!</FONT></TT>  <A HREF="#lident-or-operator"><I><FONT COLOR=maroon>lident-or-operator</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="exp"><I><FONT COLOR=maroon>exp</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#integer-literal"><I><FONT COLOR=maroon>integer-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#string-literal"><I><FONT COLOR=maroon>string-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#character-literal"><I><FONT COLOR=maroon>character-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#float-literal"><I><FONT COLOR=maroon>float-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>true</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>false</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#qualified-uident"><I><FONT COLOR=maroon>qualified-uident</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#method-ident"><I><FONT COLOR=maroon>method-ident</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>let rec</FONT></TT> {<A HREF="#let-binding"><I><FONT COLOR=maroon>let-binding</FONT></I></A>}(<TT><FONT COLOR=blue>and</FONT></TT>)<SUP>+</SUP>
<TT><FONT COLOR=blue>in</FONT></TT> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>if</FONT></TT> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>then</FONT></TT>  <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>else</FONT></TT>  <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>match</FONT></TT> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>with</FONT></TT>  {<A HREF="#match-binding"><I><FONT COLOR=maroon>match-binding</FONT></I></A>}<SUP>+</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>(</FONT></TT>  {<A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP>+</SUP> <TT><FONT COLOR=blue>)</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#prefix-op"><I><FONT COLOR=maroon>prefix-op</FONT></I></A>  <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A>  <A HREF="#infix-op"><I><FONT COLOR=maroon>infix-op</FONT></I></A>  <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>{</FONT></TT> {<A HREF="#record-field-value"><I><FONT COLOR=maroon>record-field-value</FONT></I></A>}(<TT><FONT COLOR=blue>;</FONT></TT>)<SUP>+</SUP> <TT><FONT COLOR=blue>}</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>{</FONT></TT> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>with</FONT></TT>
 {<A HREF="#record-field-value"><I><FONT COLOR=maroon>record-field-value</FONT></I></A>}(<TT><FONT COLOR=blue>;</FONT></TT>)<SUP>+</SUP> <TT><FONT COLOR=blue>}</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>.</FONT></TT>  <A HREF="#qualified-lident"><I><FONT COLOR=maroon>qualified-lident</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A> <TT><FONT COLOR=blue>)</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="record-field-value"><I><FONT COLOR=maroon>record-field-value</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#qualified-lident"><I><FONT COLOR=maroon>qualified-lident</FONT></I></A> <TT><FONT COLOR=blue>=</FONT></TT>  <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="let-binding"><I><FONT COLOR=maroon>let-binding</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A>  [<TT><FONT COLOR=blue>in</FONT></TT> <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>] <TT><FONT COLOR=blue>=</FONT></TT>  <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> <TT><FONT COLOR=blue>(</FONT></TT>
 {<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> <TT><FONT COLOR=blue>in</FONT></TT>  <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP>+</SUP>
<TT><FONT COLOR=blue>)</FONT></TT>
<TT><FONT COLOR=blue>=</FONT></TT> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="match-binding"><I><FONT COLOR=maroon>match-binding</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>|</FONT></TT> <A HREF="#pattern"><I><FONT COLOR=maroon>pattern</FONT></I></A> <TT><FONT COLOR=blue>-&gt;</FONT></TT>  <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="pattern"><I><FONT COLOR=maroon>pattern</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#integer-literal"><I><FONT COLOR=maroon>integer-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#string-literal"><I><FONT COLOR=maroon>string-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#character-literal"><I><FONT COLOR=maroon>character-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#float-literal"><I><FONT COLOR=maroon>float-literal</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>true</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>false</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#qualified-uident"><I><FONT COLOR=maroon>qualified-uident</FONT></I></A>
 [<TT><FONT COLOR=blue>(</FONT></TT> {<A HREF="#pattern"><I><FONT COLOR=maroon>pattern</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP>+</SUP> <TT><FONT COLOR=blue>)</FONT></TT>]
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>_</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>{</FONT></TT> {<A HREF="#record-field-pattern"><I><FONT COLOR=maroon>record-field-pattern</FONT></I></A>}(<TT><FONT COLOR=blue>;</FONT></TT>)<SUP>+</SUP> <TT><FONT COLOR=blue>}</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> {<A HREF="#pattern"><I><FONT COLOR=maroon>pattern</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP>+</SUP> <TT><FONT COLOR=blue>)</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> <A HREF="#pattern"><I><FONT COLOR=maroon>pattern</FONT></I></A> <TT><FONT COLOR=blue>)</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<A NAME="record-field-pattern"><I><FONT COLOR=maroon>record-field-pattern</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#qualified-lident"><I><FONT COLOR=maroon>qualified-lident</FONT></I></A> <TT><FONT COLOR=blue>=</FONT></TT>  <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A></TD></TR>
</TABLE></TD></TR>
</TABLE><P><BR>
</P><!--TOC subsubsection Literal expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc56">3.2.4.1</A>  Literal expressions</H4><!--SEC END --><P>
<A NAME="@default46"></A> <A NAME="@default47"></A></P><P>The literal
expressions of type integer, string, character,
float and boolean are evaluated into the constant represented by the
literal. The expression <TT>25</TT> denotes the value 25 of type
<TT>int</TT>.</P><!--TOC subsubsection Sum type value constructor expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc57">3.2.4.2</A>  Sum type value constructor expressions</H4><!--SEC END --><P>
<A NAME="@default48"></A>
We presented in section <A HREF="#type-definition">3.2.1.3</A> the way to define sum
types. We saw that <B>values</B> of such a <B>type</B> are built using
its <B>value</B> constructors.</P><P>Hence, for <B>value</B> constructors with no argument, the constructor itself
is an expression that gets evaluated in a value wearing the same name.</P><P>For <B>value</B> constructors with parameters, a value is created by
evaluating an expression applying the constructor to as many expressions as
the constructor&#X2019;s arity. Obviously, sub-expressions used as arguments of
the constructor must be well-typed (compatible) according to the type of the constructor. The resulting value is denoted by the
name of the constructor followed by the tuple of values given as
arguments. For instance, with the following type definition:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>t</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>A</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>B</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><P>
the expression <TT>A</TT> is evaluated into <I>A</I>, the expression
<TT>B ((2 + 3), true)</TT> is evaluated into the value <I>B</I> (5, <I>true</I>).</P><!--TOC subsubsection Identifier expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc58">3.2.4.3</A>  Identifier expressions</H4><!--SEC END --><P>
<A NAME="identifier-expressions"></A>
<A NAME="@default49"></A>
<A NAME="@default50"></A></P><P>An identifier expression is either a basic identifier, an extended
identifier or a qualified identifier (see section
<A HREF="#qualified-name">3.1.12</A>), which denotes the value of this identifier in
the scope of the expression. The identifier is said to be <B>bound</B>
to this value.</P><P>The value bound to an identifier can be of any type. A value having a
functional type, that is a <B>functional
value</B><A NAME="functional-value"></A><A NAME="@default51"></A> (also called a
<B>closure</B>), is created by a function definition. Such a value,
obtained by the evaluation of the body of the function, is slightly
different from other ones since it embeds both the code of the
function (i.e. a kind of evaluation of its body expression) and its
environment (i.e. bindings between identifiers occuring in the body of
the function and their value in the definition scope). This closure
will be kept untouched until it appears in a functional application
expression as described further in <A HREF="#function-application">3.2.4.8</A>.</P><P>There are several possibilities to bind an identifier. Definitions
introduce a basic or extended identifier and <B>binds</B> it to the
value of the expression stated in the definition. There are three
ways to introduce and directly bind an identifier:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
by a <TT>let-in</TT> construct,
</LI><LI CLASS="li-itemize">by a toplevel-<TT>let</TT>-definition,
</LI><LI CLASS="li-itemize">by a method definition (<TT>let</TT>).
</LI></UL><P>
Each of these cases will
be described in their related section.</P><P>There are two ways to introduce basic identifiers as parameters:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
in a function definition
</LI><LI CLASS="li-itemize">by a pattern inside a <TT>match-with</TT> construct
</LI></UL><P>
Then the binding of the parameter is deferred until the application of
the function or the pattern-matching mechanism.
Each of these cases will
be described in their related section.</P><P>Suppose that an expression <I>exp</I> contains several occurrences of an
identifier <TT>my_var</TT>. Assume that, in the scope of <I>exp</I>, <TT>my_var</TT> is bound to a <B>value</B> <I>v</I>, then each occurrence of <TT>my_var</TT> in <I>exp</I> is substituted by <I>v</I> during the evaluation of
<I>exp</I>. This is basically the principle of the so-called <B>eager</B> or
<B>call by-value</B> evaluation regime.</P><P><BR>
<B>Identifier resolution</B>
Remember that identifiers forms differ depending on the syntactic
class of entity they refer to, capitalized identifiers being used for
species and collections. To evaluate an identifier expression, the
<FONT COLOR=purple>FoCaLize</FONT> compiler tries to find its definition from the current scoping
context. <A NAME="@default52"></A> <A NAME="@default53"></A>
<A NAME="@default54"></A> It searches for the closest (latest) definition with this name,
starting by the parameters present in the current definition
(i.e. formal parameters in a function and in a <TT>match-with</TT>
construction and <TT>let-in</TT> bound identifiers). If no identifier
definition with this name is found, the search goes on among the
methods of the current species. If a method is found with this name,
it will be retained, otherwise the identifier is looked in the
preceding toplevel-definitions of the current compilation unit.
<A NAME="identifier-scoping-and-open"></A>
<A NAME="@default55"></A> If no suitable definition is found, then the
ones imported by the <TT>open</TT> directives are examined to find one
with the searched name. Finally if no definition is found, the
identifier is <B>reported unbound</B> by an error message.</P><P>Note that an
<TT>open</TT> directive may arise anywhere at toplevel in the source
code. Hence, the order of search between the current file&#X2019;s
toplevel-definitions and the imported ones by <TT>open</TT> is not really
separated: the name resolver looks for the most recent definition
considering that the toplevel-definitions and the imported ones are
ordered according to the apparition of the effective definitions in
the file themselves and the imported ones. In other words, if a
toplevel-definition exists for an entity <TT>foo</TT>, if later an
<TT>open</TT>directive imports another <TT>foo</TT>, then this last one
will be the retained one.</P><P><BR>
</P><P><BR>
<B>Identifier qualification</B></P><P>Identifiers can manually be disambiguated in term of compilation unit
location using the sharp (#) notation as explained in section
<A HREF="#qualified-name">3.1.12</A>.</P><P><BR>
<A NAME="@default56"></A> As further presented in section
<A HREF="#method-qualification">4.2.1</A>, species methods identifiers are made
explicit using the &#X201C;!&#X201D; notation. The notation <TT>Spe!meth</TT> stands
for &#X201C;the method <TT>meth</TT> of the species <TT>Spe</TT>&#X201D;. By extension,
<TT>!meth</TT> stands for the method <TT>meth</TT> of the current
species. It is possible to explicit <TT>Self</TT> in the naming scheme
using <TT>Self!meth</TT>. This is useful when a more recently defined
identifier hides a method of the species at hand: <FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> ...) = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>n</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> ...) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m</FONT><FONT SIZE=2> = ... </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* Want to call the *method* "m" with argument the local "m" !!! *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    !</FONT><FONT SIZE=2>m</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>m</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>Hence, the name resolution mechanism allows to omit the &#X201C;!&#X201D; but
making it explicit can help for conflicts resolution. Moreover, when
invoking species parameters&#X2019; methods, the name resolution never
searches among methods of collection parameters, hence the explicit &#X201C;!&#X201D;
notation is required.</P><P>As the grammar shows, name qualification by compilation unit and
hosting species can be freely mixed. We can build identifiers like
<TT>my_file#My_species!my_method</TT> to refer to the method
<TT>my_method</TT> hosted in the species <TT>My_species</TT> located in
the <FONT COLOR=purple>FoCaLize</FONT> source file &#X201C;my_file.fcl&#X201D;. These disambiguation
methods are indeed orthogonal.</P><P><BR>
<B>Extended identifier expressions</B></P><P>Finally, infix/postfix operators can be used as regular
identifiers. Usually, an operator is syntactically used according to
it prefix or infix nature. For instance, the binary <TT>+</TT> operator
is used between its arguments as in <TT>x + 4</TT>, the unary operator <TT>~</TT> is used before its argument as in <TT>~</TT><TT>x</TT>. <FONT COLOR=purple>FoCaLize</FONT> allows to
refer to those operators as regular identifiers (for instance as function
parameters).
This allows to use operators as any other identifiers, and
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
using them as regular function (i.e. in functional position),
</LI><LI CLASS="li-itemize">bind them as arguments of functions,
</LI><LI CLASS="li-itemize">use them as regular identifiers in expressions, for example to
pass them as arguments of other functions.
</LI></UL><P>
The following example illustrate the second point:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">let twice(( + ), x, y, z) = (x + y) + z ;;</TD></TR>
</TABLE><P>To get an identifier from an operator, its symbol
(c.f. <A HREF="#extended-identifiers">3.1.5</A>) must be delimited by spaces and enclosed
into matching parentheses.
For example: <TT>( + )</TT> is the regular identifier corresponding to the
infix symbol <TT>+</TT>.</P><P>Note that spaces around the operator symbol are mandatory and part of the
syntax. If spaces are omitted, the parens get their usual meaning and the
interpretation can be completely different.
A specially puzzling error is to write <TT>(*)</TT> to mean <TT>( * )</TT>:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><EM><FONT SIZE=2>(*) (x, y) = ...</FONT></EM></FONT></TD></TR>
</TABLE><P>
Now, <TT>(*</TT> is evidently parsed as the beginning of comment,
leading to a syntax error or any other cryptic error long after the faulty
<TT>(*</TT> occurrence.
Conversely <TT>*)</TT> is always considered as an end of comment by the lexical
analyzer.</P><!--TOC subsubsection <TT>let-in</TT> expression-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc59">3.2.4.4</A>  <TT>let-in</TT> expression</H4><!--SEC END --><P>
<A NAME="@default57"></A>
<A NAME="@default58"></A>
<TT>let-in</TT> expression binds an identifier to a value to
evaluate a trailing expression (the &#X201C;<TT>in-part</TT>&#X201D; of the &#X201C;<TT>let-in</TT>&#X201D;
or &#X201C;body&#X201D;) where this ident may appear. During the evaluation of the
trailing expression, any occurrence of the bound identifier is &#X201C;replaced&#X201D;
by the value bound to this identifier. For instance:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> = 3 + 2 </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>)</FONT></TD></TR>
</TABLE><P>
binds <TT>x</TT> to the evaluation of the <B>expression</B> <TT>(3+2)</TT>
(i.e. the integer <B>value</B> 5) and then, the evaluation of the
trailing expression returns the tuple <B>value</B> (5, 5). From the
syntax, it is clear that <TT>let-in</TT> constructs can be nested. For
instance, <FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> = 3+2 </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> = (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>true</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>)</FONT></TD></TR>
</TABLE><P>
returns the value ((5, 5), <I>true</I>, (5, 5), <I>true</I>) of type
<TT>((int * int) * bool * (int * int) * bool)</TT>.</P><P><BR>
<A NAME="@default59"></A>
Note that the notion of &#X201C;binding an identifier to a value&#X201D; is
essentially different from the
notion of assignment in imperative languages. In such languages (like
C, Java, Pascal,&#X2026;) a variable is first <EM>declared</EM>, then a value is
<EM>assigned</EM> to the variable. It is thus possible to assign a variable
several times to different values. For example in C:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>{</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>i</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>i</FONT><FONT SIZE=2> = 10 ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>while</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>i</FONT><FONT SIZE=2> &gt; 0) </FONT><FONT SIZE=2>i</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>i</FONT><FONT SIZE=2>-- ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>}</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT></TD></TR>
</TABLE><P>
The variable <TT>i</TT> is declared, then assigned the initial value
10, then the <TT>while</TT> loop makes it decreasing by successive
assignments.</P><P>In a <TT>let-in</TT> binding construct, an identifier is given a value
once and for all: it is impossible to change its value, once it
has been bound.
Each new definition, binding an already bound identifier will just hide the
old definition. For instance:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> = 5 </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> = (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>true</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2> = (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>)</FONT></TD></TR>
</TABLE><P>
leads to the value ((5, 5), <I>true</I>, (5, 5), <I>true</I>)
of type <TT>((int * int) * bool * (int * int) * bool)</TT>. Clearly the
first value bound to <TT>x</TT> holds until <TT>x</TT>
is bound again: 5 is used to define <TT>y</TT> but not to define
<TT>z</TT>, since the value of <TT>x</TT> is then the boolean <I>true</I>.</P><P><BR>
</P><P>The <TT>let-in</TT> construct serves to bind an identifier to a value of
any type. As a consequence, it can also bind an identifier to a
functional value. This lead to the natural way to define <B>functions</B>. For instance:</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> + </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (6, 7)</FONT></TD></TR>
</TABLE><P>The <B>let</B> construct binds <TT>f</TT> to a function which has 2
parameters <TT>x</TT> and <TT>y</TT>, and the body of <TT>f</TT> is the
addition of these 2 parameters. Then the body of the <TT>let-in</TT>
construct applies <TT>f</TT> to 2 effective arguments <TT>6</TT> and <TT>7</TT> (we obviously expect the result of this <EM>application</EM> to be
13). (Function application is explained below in
<A HREF="#function-application">3.2.4.8</A>).</P><P>It is possible to provide a type constraint to precise the type of the
return value of a function, or the type of the <TT>let</TT>-bound
variable or parameters:</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> + </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (6, 7)</FONT></TD></TR>
</TABLE><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> + </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (6, 7)</FONT></TD></TR>
</TABLE><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> = 3 </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>a</FONT><FONT SIZE=2>)</FONT></TD></TR>
</TABLE><P><BR>
It is possible to define several identifiers at the same time separating
each definition by the keyword <TT>and</TT>.
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>exp_1</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>and</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>g</FONT><FONT SIZE=2>  = </FONT><FONT SIZE=2>exp_2</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>and</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>h</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>exp_3</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>exp</FONT><FONT SIZE=2>;</FONT></TD></TR>
</TABLE><P>All the definitions are separately evaluated &#X201C;in parallel&#X201D;. As a
consequence, the identifiers introduced by a <TT>let ... and </TT>
cannot be used in the right members of this construction (in the <TT>exp_i</TT>). Do not confuse this construct with nested <TT>let-in</TT> as
the followig one, where <TT>exp_2</TT> can contain <TT>f</TT> and <TT>exp_3</TT> can contain <TT>f</TT> and <TT>g</TT>.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>exp_1</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>g</FONT><FONT SIZE=2>  = </FONT><FONT SIZE=2>exp_2</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>h</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>exp_3</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>exp</FONT></TD></TR>
</TABLE><P>Mutually recursive functions need to know each other because their
bodies call these other functions and their definition require a
non-nested evaluation of each function. In this case, the keyword
<TT>let</TT> must be followed by the keyword <TT>rec</TT>.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>rec</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>even</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   </FONT><FONT SIZE=2>if</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> = 0 </FONT><FONT SIZE=2>then</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>true</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>else</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>odd</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> - 1)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>and</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>odd</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   </FONT><FONT SIZE=2>if</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> = 0 </FONT><FONT SIZE=2>then</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>false</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>else</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>even</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> - 1) </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT></TD></TR>
</TABLE><P><FONT SIZE=4><B>Warning:</B></FONT> in the current version of <FONT COLOR=purple>FoCaLize</FONT> mutually
recursive functions cannot be compiled into <FONT COLOR=purple>Coq</FONT> code. Only
<FONT COLOR=purple>OCaml</FONT> code generation is available. Moreover, for <FONT COLOR=purple>Coq</FONT>, recursive
functions imply termination proofs. This last point will be covered in
the section <A HREF="#recursive-function">6</A> especially dedicated to
(non-mutually) recursive function definitions.</P><!--TOC subsubsection <TT>logical let</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc60">3.2.4.5</A>  <TT>logical let</TT></H4><!--SEC END --><P>
As seen above, the <TT>let-in</TT> construct is used to bind
computational expressions. We would sometimes also like to have parameterised logical
expressions, i.e. a kind of functions returning a logical proposition.
For example we may want, for a certain value of <I>x</I> and <I>y</I>, to use the statement
&#X201C;<I>x</I>&lt;<I>y</I> and <I>x</I>+<I>y</I> &lt; 10&#X201D; (which holds or not) to build more complex
logical expressions.</P><P>To allow functional bindings in logical expressions <FONT COLOR=purple>FoCaLize</FONT> provide
the <TT>logical let</TT> construct. It serves to introduce a
parameterised logical expression, which can be applied to effective
arguments to obtain a logical proposition. Our example would be
expressed by:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>use</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"basics"</FONT></FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>open</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"basics"</FONT></FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>logical</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> &lt; </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> /\ </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> + </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> &lt; 10 ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;</FONT></TD></TR>
</TABLE><P>Since <TT>logical let</TT> binds an identifier to a logical expression, the
body of the definition <B>must</B> obviously <B>be of type</B>
<TT>bool</TT>. Once defined, <TT>f</TT> can be used as a regular function,
but only in
properties and theorems statements. For instance:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>use</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"basics"</FONT></FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>open</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"basics"</FONT></FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>logical</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> &lt; </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> /\ </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> + </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> &lt; 10 ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>p</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>b</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>c</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>c</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>b</FONT><FONT SIZE=2>) =&gt; </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>m</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2>), </FONT><FONT SIZE=2>b</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;</FONT></TD></TR>
</TABLE><P>
See other examples in the standard library where this construction is
used to define associativity, commutativity, &#X2026;</P><!--TOC subsubsection Conditional expression-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc61">3.2.4.6</A>  Conditional expression</H4><!--SEC END --><P>
<A NAME="conditional-expression"></A>
<A NAME="@default60"></A>
<A NAME="@default61"></A>
A conditional expression has the form:
<TT>if</TT> <I>exp</I><SUB>1</SUB> <TT>then</TT>
<I>exp</I><SUB>2</SUB> <TT>else</TT> <I>exp</I><SUB>3</SUB></P><P>Its evaluation starts by the evaluation of the <I>exp</I><SUB>1</SUB> expression
which must be of type boolean. If its value is <I>true</I> then the result
value of the whole expression is the value of <I>exp</I><SUB>2</SUB>, otherwise
(i.e. if its value is <I>false</I>) the value of <I>exp</I><SUB>3</SUB>. This obviously
implies that <I>exp</I><SUB>2</SUB> and <I>exp</I><SUB>3</SUB> must have the same type. This
construct is then a binary conditional expression (i.e. with 2
branches). <FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>if</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>then</FONT><FONT SIZE=2> 1 </FONT><FONT SIZE=2>else</FONT><FONT SIZE=2> 0 </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> ...</FONT></TD></TR>
</TABLE><P>
The function <TT>f</TT> will return 1 if the effective argument
provided for <TT>x</TT> is <I>true</I>, otherwise it will return 0.
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is_too_small</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) = ... </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> = ... </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y_corrected</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>if</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is_to_small</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>then</FONT><FONT SIZE=2> 0 </FONT><FONT SIZE=2>else</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> ...</FONT></TD></TR>
</TABLE><P>
In this example, we assume we have a function <TT>is_too_small</TT>
checking if a value is &#X201C;too small&#X201D; and an identifier <TT>y</TT> bound
to a certain value. The result of the conditional expression bound to
<TT>y_corrected</TT> will be either 0 if the condition is met or <I>y</I>
otherwise.</P><!--TOC subsubsection Match expression-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc62">3.2.4.7</A>  Match expression</H4><!--SEC END --><P>
<A NAME="@default62"></A> <A NAME="@default63"></A> <A NAME="@default64"></A></P><P>The <TT>match-with</TT> construct is a generalised conditional construct
with pattern-matching. By &#X201C;generalised&#X201D;, we mean that unlike the
<TT>if-then-else</TT> which has only 2 branches, the present expression
can have several branches. The notion of condition here is not anymore
a boolean value. Instead, the construct allows to discriminate on the
different values an expression is evaluated into. The basic structure
of a <TT>match-with</TT> consists in a discriminating expression followed
by an enumeration of cases (called <B>patterns</B>). The dicriminating
expression is evaluated and its value is matched against the patterns,
following the textual ordering of these patterns, until a match
succeeds. Then the expression associated with the matching pattern is
evaluated to obtain the value of the whole expression <TT>match-with</TT>.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>match</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> + 5 </FONT><FONT SIZE=2>with</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | 0 -&gt; </FONT><FONT SIZE=2><FONT SIZE=2>"zero"</FONT></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | 5 -&gt; </FONT><FONT SIZE=2><FONT SIZE=2>"five"</FONT></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | 1 -&gt; </FONT><FONT SIZE=2><FONT SIZE=2>"one"</FONT></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | 10 -&gt; </FONT><FONT SIZE=2><FONT SIZE=2>"ten"</FONT></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | </FONT><FONT SIZE=2>_</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2><FONT SIZE=2>"other"</FONT></FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT></TD></TR>
</TABLE><P> The discriminated expression in this case is <TT>a + 5</TT> of type
<TT>int</TT>. We can then react to each (or some of the) values of this
expression. When <TT>a + 5</TT> is equal to 0 the result of the
whole <TT>match-with</TT> expression (bound to the identifier <TT>x</TT>) is
the string &#X201C;zero&#X201D;. When <TT>a + 5</TT> is equal to 1, the result is the string
&#X201C;one&#X201D;, and so on. The final pattern <TT>_</TT> stands for &#X201C;anything
that was not in the previous cases&#X201D; (also called &#X201C;catch-all
pattern&#X201D;). Hence, the order of the patterns is important. If the
case <TT>|</TT><TT>_ -&gt;</TT> was put before the case <TT>|</TT><TT>1 -&gt;</TT>,
then this last case would never be reached since the <TT>_</TT> pattern
would have caught the discriminated value.</P><P><BR>
As a consequence of the structure of this construct, type constraints
must be respected in order to have the whole expression well-typed:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The type of the discriminating expression must be compatible with the
type of the patterns.
</LI><LI CLASS="li-itemize">thus all the patterns must have compatible
types.
</LI><LI CLASS="li-itemize">The types of all the result expressions in the rightmost parts
of the cases must be compatible.
</LI><LI CLASS="li-itemize">The patterns have to be mutually exclusive (except for the catch-all
pattern, see below).
</LI><LI CLASS="li-itemize">The different cases have to capture every possible pattern.
</LI></UL><P><BR>
In the example above, the patterns were constant. A value
matches a constant pattern if and only if it is equal to this
constant. In addition, the
<TT>match-with</TT> construct provides true <B>pattern matching</B>. That
is, patterns may be built from constants, value constructors,
variables and the catch-all symbol <TT>_</TT>. Any value matches any
variable pattern and the <TT>_</TT> pattern. For general patterns built
from value constructors, variables, constants, <TT>_</TT>, roughly
speaking, a value matches a pattern if this pattern can be seen as a
prefix of this value. Then, the variables of the pattern get bound to
the parts of the discriminating expression that are &#X201C;at the same
place&#X201D; than those variables. For example:</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>e</FONT><FONT SIZE=2> = ... </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>match</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>e</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>with</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | (0, 0, 0) -&gt; 1</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | (0, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) -&gt; </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> + </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | (1, 1, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) -&gt; </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>) -&gt; </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> + </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> + </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT></TD></TR>
</TABLE><P>
According the the type-checking mechanism, the examined expression
<TT>e</TT> must have here type <TT>(int * int * int)</TT>. The first pattern
will be chosen if <TT>e</TT> is equal to the tuple (0, 0, 0). We
say here &#X201C;equal&#X201D; since there is no variable in the pattern, hence
the only way to fit the pattern is to simply be equal. If this pattern
is not fitted, the we examine the second pattern. It will be chosen if
<TT>e</TT> has a 0 as first component and any integer for the second
and the third ones. In this case, the result value will be the
evaluation of the expression <TT>x + y</TT> where x will be bound to the
effective second component of the value of <TT>e</TT> and <TT>y</TT> will be
bound to its third component. We can notice that no &#X201C;catch-all pattern&#X201D;
is needed since the enumerated patterns cover all the possible values
of tuples with 3 components (the last pattern does not put
any constraint on the tuple components, hence will match all the
remaining cases).</P><P>The previous example used tuples as matched expression and patterns,
but patterns also contain sum type value constructors, hence allowing
to &#X201C;match&#X201D; on any sum type structure. For example: <FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>t</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>A</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>B</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>C</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>e</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>A</FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>match</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>e</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>with</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | </FONT><FONT SIZE=2>A</FONT><FONT SIZE=2> -&gt; 0</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | </FONT><FONT SIZE=2>B</FONT><FONT SIZE=2> (3) -&gt; 4</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | </FONT><FONT SIZE=2>B</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>_</FONT><FONT SIZE=2>) -&gt; 10</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | </FONT><FONT SIZE=2>C</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, 10) -&gt; 5</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | </FONT><FONT SIZE=2>C</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>_</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) -&gt; </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><P>
This example shows different cases following the structure of the type
<TT>t</TT>. Note the use of the &#X201C;catch-all&#X201D; pattern
inside patterns. In fact, the &#X201C;catch-all&#X201D; pattern acts like
a variable unused in the rightmost part of the
case. It is however preferable to use &#X201C;<TT>_</TT>&#X201D; instead of a
variable since <FONT COLOR=purple>OCaml</FONT> generates warning for unused variables and the
generated <FONT COLOR=purple>OCaml</FONT> code generated by <FONT COLOR=purple>FoCaLize</FONT> will not change unused
variables into &#X201C;<TT>_</TT>&#X201D;s.</P><P><BR>
Patterns also allow to match record values
(c.f. <A HREF="#record-expression">3.2.4.10</A>), i.e. to match on values of the fields:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>t</FONT><FONT SIZE=2> = { </FONT><FONT SIZE=2>name</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>string</FONT><FONT SIZE=2> ; </FONT><FONT SIZE=2>birth</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> } ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>r</FONT><FONT SIZE=2> = ... </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>match</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>r</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>with</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | { </FONT><FONT SIZE=2>name</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2><FONT SIZE=2>"Alexandre"</FONT></FONT><FONT SIZE=2> } -&gt; ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | { </FONT><FONT SIZE=2>name</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>n</FONT><FONT SIZE=2> ; </FONT><FONT SIZE=2>birth</FONT><FONT SIZE=2> = 2003 } -&gt; ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   | { </FONT><FONT SIZE=2>name</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>n</FONT><FONT SIZE=2> } -&gt; ...</FONT></TD></TR>
</TABLE><P>
In such a pattern, fields not specified are considered as
&#X201C;catch-all&#X201D; patterns. Hence, the last case catches all the record
values not caught before since the field <TT>name</TT>&#X2019;s value is bound
to a variable (so, any value can match it) and the field
<TT>birth</TT> is absent (so, considered as <TT>birth = _</TT>).</P><!--TOC subsubsection Application expression-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc63">3.2.4.8</A>  Application expression</H4><!--SEC END --><P>
<A NAME="function-application"></A>
<A NAME="@default65"></A> <A NAME="@default66"></A> We previously
saw that the <TT>let-in</TT> construct allow for the definition of functions by
binding an identifier to a functional value. Using a function by
providing it with effective arguments to get its result value is
called <B>application</B>. Hence, in an application there are 2
distinct parts: the applicative part that must be an expression
leading to a functional value and the effective arguments that are
expressions whose values will be provided to the function to make its
computation. The syntax for application is simply the juxtaposition of
the applicative expression and the comma-separated expressions used as
arguments embraced by parentheses: <FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) = ... </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>g</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) = ... </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) ... </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>g</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (3), 4)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT></TD></TR>
</TABLE><P>
As described in <A HREF="#functional-value">3.2.4.3</A>, the evaluation of an
application of a function to its effective arguments start by the
evaluation of these arguments (the order of the evaluation of several
arguments is left unspecified). Then these effective values are
substituted to the corresponding parameters inside the body of the
function and the so-obtained expression (the substituted body) is
evaluated. For instance, having the
following function and application:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>g</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) = (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>g</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>true</FONT><FONT SIZE=2>, 1)</FONT></TD></TR>
</TABLE><P> The evaluation of the <TT>let-in</TT> expression first binds the
identifier <TT>g</TT> to a <B>functional value</B> also called <B>closure</B>. Then the application expression <TT>g (true, 1)</TT> is
evaluated. So the values of <TT>g</TT> and of the expression <TT>(true,1)</TT> are elaborated: the evaluation of <TT>g</TT> returns a
closure, <TT>true</TT> is evaluated into the boolean <B>value</B> <I>true</I>,
<TT>1</TT> into the integer <B>value</B> 1. The next step is to evaluate
the body of the <B>closure</B> of <TT>g</TT>, replacing the formal
parameter <TT>x</TT> by the effective argument <I>true</I> and <TT>y</TT> by
1. The body of <TT>g</TT> creates a tuple from its 2 arguments, putting
<TT>y</TT> in the first component and <TT>x</TT> in the second. Hence, the
result of the application is the tuple <B>value</B> (1, <I>true</I>).</P><!--TOC subsubsection Operator application expression-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc64">3.2.4.9</A>  Operator application expression</H4><!--SEC END --><P>
<A NAME="@default67"></A>
Since operators are designed to be used in infix or prefix position,
application of operators consists simply in providing arguments
according to the operator infix/prefix nature. For infix operators,
arguments are on left and right sides. For prefix operators, the
operator is in front of the argument expression.</P><!--TOC subsubsection Record expression-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc65">3.2.4.10</A>  Record expression</H4><!--SEC END --><P>
<A NAME="record-expression"></A>
<A NAME="@default68"></A>
As stated in <A HREF="#record-type-definition">3.2.1.3</A>,
record types are defined by a list of labels with their types. As
usual a record
expression follows the same structure, replacing the type expressions
of the definition by values of these types. For instance, assuming the
given record type definition, the following example shows a possible
record value:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>identity</FONT><FONT SIZE=2> = {</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>name</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>string</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>birth</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>living</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>} ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>{ </FONT><FONT SIZE=2>name</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2><FONT SIZE=2>"Nobody"</FONT></FONT><FONT SIZE=2> ; </FONT><FONT SIZE=2>birth</FONT><FONT SIZE=2> = 42 ; </FONT><FONT SIZE=2>living</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>false</FONT><FONT SIZE=2> }</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT></TD></TR>
</TABLE><P>
If the record type definition is in a different compilation unit, you
may qualify the record fields by the &#X201C;<TT>#</TT>&#X201D; notation:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>{ </FONT><FONT SIZE=2>my_file</FONT><FONT SIZE=2>#</FONT><FONT SIZE=2>name</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2><FONT SIZE=2>"Nobody"</FONT></FONT><FONT SIZE=2> ; </FONT><FONT SIZE=2>my_file</FONT><FONT SIZE=2>#</FONT><FONT SIZE=2>birth</FONT><FONT SIZE=2> = 42 ; </FONT><FONT SIZE=2>my_file</FONT><FONT SIZE=2>#</FONT><FONT SIZE=2>living</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>false</FONT><FONT SIZE=2> }</FONT></TD></TR>
</TABLE><!--TOC subsubsection Cloning a record expression-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc66">3.2.4.11</A>  Cloning a record expression</H4><!--SEC END --><P>
<A NAME="record-clone-expression"></A>
<A NAME="@default69"></A>
It is sometimes needed to create a new
value of a record type by modifying a few fields of an existing
record, leaving the other fields unchanged. If the record type
definition contains numerous fields, manually copying the old fields
values to create the new record value appears boring and error prone:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>t</FONT><FONT SIZE=2> = { </FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ; </FONT><FONT SIZE=2>b</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ; </FONT><FONT SIZE=2>c</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ; </FONT><FONT SIZE=2>d</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ; </FONT><FONT SIZE=2>e</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ; </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> } ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>v1</FONT><FONT SIZE=2> = { </FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> = 1 ; </FONT><FONT SIZE=2>b</FONT><FONT SIZE=2> = 2 ; </FONT><FONT SIZE=2>c</FONT><FONT SIZE=2> = 3 </FONT><FONT SIZE=2>d</FONT><FONT SIZE=2> = 4 ; </FONT><FONT SIZE=2>e</FONT><FONT SIZE=2> = 5 ; </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> = 6 } </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>v2</FONT><FONT SIZE=2> = {</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>v1</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> ; </FONT><FONT SIZE=2>b</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>v1</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>b</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>c</FONT><FONT SIZE=2> = 5 ;  </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* Changed value. *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>d</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>v1</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>c</FONT><FONT SIZE=2> ;  </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* an error since the requested value was  "v1.d". *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>e</FONT><FONT SIZE=2> = 6 ;  </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* Changed value. *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>v1</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> } </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT></TD></TR>
</TABLE><P>
Instead of manually copy the unchanged fields, <FONT COLOR=purple>FoCaLize</FONT> provides a way
to clone a record value, that is to create a <B>new</B>, a <B>fresh</B>
value from an existing one, only by specifying the fields whose values
differ from the old record value:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>type</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>t</FONT><FONT SIZE=2> = ... </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* Like above. *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>v1</FONT><FONT SIZE=2> = ... </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* Like above. *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>v2</FONT><FONT SIZE=2> = { </FONT><FONT SIZE=2>v1</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>with</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>c</FONT><FONT SIZE=2> = 5 ; </FONT><FONT SIZE=2>e</FONT><FONT SIZE=2> = 6 } </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT></TD></TR>
</TABLE><P>
As for other record value expressions, if the record type definition
is in a different compilation unit, you may qualify the record fields
by the &#X201C;<TT>#</TT>&#X201D; notation.</P><!--TOC subsubsection Record field access expression-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc67">3.2.4.12</A>  Record field access expression</H4><!--SEC END --><P>
<A NAME="record-field-access"></A>
<A NAME="@default70"></A>
Once a record value is created by aggregating values of its fields, it
is possible to recover the value of one field by a dot notation. For
instance, assuming the type definition and record values of the
previous example:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>... </FONT><FONT SIZE=2>v1</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>... </FONT><FONT SIZE=2>v2</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>c</FONT><FONT SIZE=2> ...</FONT></TD></TR>
</TABLE><P>
respectively get the value of the fields <TT>a</TT> of <TT>v1</TT> and
<TT>c</TT> of <TT>v2</TT>, that is, 1 and 5. If the record type
definition is in a different compilation unit, you may qualify the
record fields by the &#X201C;<TT>#</TT>&#X201D; notation: <TT>t1.my_source#a</TT>.</P><!--TOC subsubsection Parenthesised expression-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc68">3.2.4.13</A>  Parenthesised expression</H4><!--SEC END --><P>
The parentheses can be used around any expression, to enforce the
associativity or evaluation order of expressions. Simple expressions
(i.e. atomic) can also be parenthesised without changing their
values.</P><!--TOC subsection Core language expressions and definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc69">3.2.5</A>  Core language expressions and definitions</H3><!--SEC END --><P>
In the previous sections, we described the syntax of
expressions. Expressions rarely appear outside any
definition but it is still possible to have top-level
expressions. They will be directly evaluated and not bound to any
identifier, but this implies that these expressions use previously
written definitions.</P><P><BR>
As further explained in (c.f. <A HREF="#species-intro">4.1.2</A>) species are made
of methods. Some methods contain expressions (functions, properties,
theorems). Function-methods are introduced by the <TT>let</TT> keyword,
using the same syntax (hence expressions) that the <TT>let-in</TT>
construct except the fact they do not have a &#X201C;<TT>in</TT>&#X201D; expression.
The idea is that the &#X201C;<TT>in</TT>&#X201D; expression is implicitly the
remaining of the species. Properties and theorems are respectively
introduced by the keywords <TT>property</TT> and <TT>theorem</TT> and may
contain expressions. The section
<A HREF="#properties-theorems-proofs">3.2.7</A> is dedicated to their detailed explanation.
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>open</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"basics"</FONT></FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>My_Setoid</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>inherits</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Basic_object</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> ( = ) : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>element</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>different</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>basics</FONT><FONT SIZE=2>#</FONT><FONT SIZE=2>not_b</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>refl</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>symm</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>!( = ) (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) -&gt; </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P><BR>
</P><P>Toplevel-definitions are definitions introduced outside of any
species. General functions and general theorems, i.e. that do not
depend on a particular species can be introduced as
toplevel-definitions. Toplevel-functions are introduced by the <TT>let</TT> keyword and don&#X2019;t have a &#X201C;<TT>in</TT>&#X201D; expression, this part
being implicitly the remaining of the program (i.e. the current
compilation unit and those using the current). Toplevel-theorems are
introduced by the <TT>theorem</TT> keyword. These definitions must be ended by a double semi
(&#X201C;<TT>;;</TT>&#X201D;). <FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is_failed</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>match</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>with</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Failed</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>true</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Unfailed</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>_</FONT><FONT SIZE=2>) -&gt; </FONT><FONT SIZE=2>false</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>theorem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int_plus_minus</FONT><FONT SIZE=2>: </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>,</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2><EM><FONT SIZE=2>(*   x + y = z -&gt; y = z - x *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  #</FONT><FONT SIZE=2>base_eq</FONT><FONT SIZE=2> (#</FONT><FONT SIZE=2>int_plus</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>), </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>) -&gt; #</FONT><FONT SIZE=2>base_eq</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>, #</FONT><FONT SIZE=2>int_minus</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>))</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2>coq</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> {*</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>intros</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>unfold</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int_plus</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>int_minus</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>base_eq</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>syntactic_equal</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> |- *;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>intros</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>H</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>unfold</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>bi__int_minus</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>apply</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>EQ_base_eq</FONT><FONT SIZE=2>; </FONT><FONT SIZE=2>apply</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Zplus_minus_eq</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>symmetry</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> |- *;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>apply</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>decidable</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>_</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>_</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>_</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>Z_eq_dec</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> + </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>H</FONT><FONT SIZE=2>).</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>Qed</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    *}</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><!--TOC subsection Files and uses directives-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc70">3.2.6</A>  Files and uses directives</H3><!--SEC END --><P>
<A NAME="file directive"></A>
<FONT COLOR=purple>FoCaLize</FONT> provides 3 directives that are not expressions. This means
that they do not lead to values or computation.</P><P>All these directives deal with searching for files in the available
search paths. The path of the compilation unit is never specified
since it is always searched first. Hence, the file will be searched
first in the local directory, then in the stardard library directory
and finally in the library search path specified with the <TT>-I</TT>
option (c.f. <A HREF="#compiler-options">7</A>).</P><P>Note that if several files at different locations have the same name,
the directives will use the first fiound in the search path set in the
compilation command-line.</P><!--TOC subsubsection The <TT>use</TT> directive-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc71">3.2.6.1</A>  The <TT>use</TT> directive</H4><!--SEC END --><P>
<A NAME="@default71"></A>
This directive is followed by the name of the file to open between
double quotes without the &#X201C;.fo&#X201D; extension (compiled version of a &#X201C;.fcl&#X201D;).
Before being allowed to use the qualified notation for an identifier,
(i.e. the &#X201C;<TT>#</TT>&#X201D;-notation), the qualifying compilation must be
declared with a directive <TT>use</TT>. In other terms,
&#X201C;using&#X201D; a compilation units allows to access its entities from the
current compilation unit.</P><!--TOC subsubsection The <TT>open</TT> directive-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc72">3.2.6.2</A>  The <TT>open</TT> directive</H4><!--SEC END --><P>
<A NAME="@default72"></A></P><P>This directive is followed by the name of the file to open between
double quotes without the &#X201C;.fcl&#X201D; extension. As previously introduced
(c.f. <A HREF="#identifier-scoping-and-open">3.2.4.3</A> and <A HREF="#qualified-name">3.1.12</A>) the
<TT>open</TT> directive loads in the current name resolution (scoping)
environment the definitions of the compilation unit named in the <TT>open</TT> directive. This prevents the user from having to explicitly
qualify definitions of this unit by the &#X201C;<TT>#</TT>&#X201D;
notation. Definitions imported by the directive hide (&#X201C;mask&#X201D;) those
wearing the same name already defined in the current compilation unit
from the point the directive appears. Remember that it is however
possible to recover the hidden definitions, using the &#X201C;<TT>#</TT>&#X201D;
notation without compilation unit name.</P><P>Note that the <TT>open</TT> directive implicitly implies the <TT>use</TT>
directive. This means that it is not useful to add a <TT>use</TT>
together with an <TT>open</TT> directive.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>open</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"sets"</FONT></FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><P>This directive loads the definitions of the compilation unit
&#X201C;sets.fo&#X201D; in the current name resolution (scoping) environment.</P><!--TOC subsubsection The <TT>coq_require</TT> directive-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc73">3.2.6.3</A>  The <TT>coq_require</TT> directive</H4><!--SEC END --><P>
<A NAME="@default73"></A>
Some source files of a development may be directly written in <FONT COLOR=purple>Coq</FONT> to
provide external definitions (detailed further in
<A HREF="#interfacing-other-languages">9.0.5</A>) to import and use in the <FONT COLOR=purple>FoCaLize</FONT> source code. In this case, the <FONT COLOR=purple>Coq</FONT> code generated for the
<FONT COLOR=purple>FoCaLize</FONT> source code must be aware of the need to import the external
definitions from the manually written <FONT COLOR=purple>Coq</FONT> file. For this reason, the
<FONT COLOR=purple>FoCaLize</FONT> source must explicitly indicate by the <TT>coq_require</TT>
directive that it makes references to definitions hosted in this
<FONT COLOR=purple>Coq</FONT> source file. For example, the file &#X201C;wellfounded.fcl&#X201D; of the
standard library needs &#X201C;wellfounded_externals.vo&#X201D; (the compiled version of
&#X201C;wellfounded_externals.v&#X201D;) and signals this
fact in its early lines of code:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>open</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"basics"</FONT></FONT><FONT SIZE=2>;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>open</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"sets_orders"</FONT></FONT><FONT SIZE=2>;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>coq_require</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><FONT SIZE=2>"wellfounded_externals"</FONT></FONT><FONT SIZE=2>;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT></TD></TR>
</TABLE><!--TOC subsection Properties, theorems and proofs-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc74">3.2.7</A>  Properties, theorems and proofs</H3><!--SEC END --><P>
<A NAME="properties-theorems-proofs"></A>
<A NAME="@default74"></A>
<A NAME="@default75"></A></P><P>Properties are first order logic propositions and theorems are
properties with their proofs. We will study here first the structure
of logical expressions used to express the statements, show properties
and theorems forms and shortly present the 3 available ways to write
proofs.</P><!--TOC subsubsection Logical expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc75">3.2.7.1</A>  Logical expressions</H4><!--SEC END --><P>
<A NAME="logical-expressions"></A>
<A NAME="@default76"></A>
Logical expressions are those used to write first order logic
formulas.
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>all</FONT></TT> {<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP>+</SUP> <TT><FONT COLOR=blue>in</FONT></TT> <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A> <TT><FONT COLOR=blue>,</FONT></TT>  <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>ex</FONT></TT> {<A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP>+</SUP> <TT><FONT COLOR=blue>in</FONT></TT> <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>
<TT><FONT COLOR=blue>,</FONT></TT>  <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A> <TT><FONT COLOR=blue>-&gt;</FONT></TT>  <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A> <TT><FONT COLOR=blue>&lt;-&gt;</FONT></TT>  <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A> <TT><FONT COLOR=blue>/</FONT></TT><TT><FONT COLOR=blue>\</FONT></TT>  <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A> <TT><FONT COLOR=blue>\</FONT></TT><TT><FONT COLOR=blue>/</FONT></TT>  <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>~</FONT></TT> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <A HREF="#exp"><I><FONT COLOR=maroon>exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>(</FONT></TT> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A> <TT><FONT COLOR=blue>)</FONT></TT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Logical expressions contain the usual logical connectors &#X201C;imply&#X201D;
(&#X21D2;), &#X201C;and&#X201D; (&#X2227;), &#X201C;or&#X201D; (&#X2228;), &#X201C;there exists&#X201D;
(&#X2203;), &#X201C;for all&#X201D; (&#X2200;), &#X201C;is equivalent&#X201D;
(&#X21D4;) and &#X201C;not&#X201D; (¬). Moreover, logical
expressions embed the <FONT COLOR=purple>FoCaLize</FONT> expressions used in computational
methods (i.e. identifiers, conditionals, application, &#X2026;). This
allows to have connected propositions using the previously defined
functions and species methods.
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S</FONT><FONT SIZE=2> ... =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>gt</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2> ;  </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* Greater than... *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>geq</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2> ;  </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* Greater or equal... *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2> ;  </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* Equal to... *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>different</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2> ;  </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* Different of... *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>gt_is_lt</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>,</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    (!</FONT><FONT SIZE=2>gt</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) -&gt; (!</FONT><FONT SIZE=2>geq</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) /\ !</FONT><FONT SIZE=2>different</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>)))</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    /\</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    (!</FONT><FONT SIZE=2>geq</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) -&gt; (!</FONT><FONT SIZE=2>gt</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) \/ !</FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>))) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>
Since propositions in logical expressions are truth values, this
obviously imply that the arbitrary expressions used between connectors
must have type <TT>bool</TT>.</P><!--TOC subsubsection Properties-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc76">3.2.7.2</A>  Properties</H4><!--SEC END --><P>
A property is a logical expression bound to an identifier. Its
form is the name of the property, a colon character (&#X201C;:&#X201D;) and the
logical expression being its statement. See the example given in
<A HREF="#logical-expressions">3.2.7.1</A>.
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="property"><I><FONT COLOR=maroon>property</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>property</FONT></TT> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> <TT><FONT COLOR=blue>:</FONT></TT>  <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsubsection Proofs-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc77">3.2.7.3</A>  Proofs</H4><!--SEC END --><P>
<A NAME="proof-short-intro"></A>
<FONT COLOR=purple>FoCaLize</FONT> currently provides 3 ways to write proofs. We only give here a
simple description of these 3 means without going deeply in the
technical mechanisms since this problem will be especially addressed
in section <A HREF="#making-proofs">5</A> and <A HREF="#coq-proofs">9.0.6</A>. </P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Consider the proof as &#X201C;assumed&#X201D;</B>. This way is the
simplest but also the weakest one since it consists in saying that
no proof is given and the system must accept the statement as an axiom.
<FONT SIZE=2>
</FONT><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>representation</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> = (=</FONT><FONT SIZE=2>Ox</FONT><FONT SIZE=2>);</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>theorem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>symmetry</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) -&gt; </FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>assumed</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    {* </FONT><FONT SIZE=2>Machine</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>integers</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>equality</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>admitted</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>to</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>be</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>symmetric</FONT><FONT SIZE=2>  *} ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>Following the <TT>assumed</TT> keyword is a mandatory message used for
sake of information, justification, traceability of the proof
absence. Although such a proof can introduce inconsistencies if the
&#X201C;theorem&#X201D; is not a tautology and thus decrease confidence in the
correctness of the <FONT COLOR=purple>FoCaLize</FONT> program, there are several cases where
using this keyword may help.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The first case is simply that the developer doesn&#X2019;t know
(yet ?) how to make the proof, doesn&#X2019;t have time yet to write
it, or is not interested in proofs but still wants his program to
compile to get the executable code.</LI><LI CLASS="li-itemize">Second case deals with import of external code, i.e. code
not written in <FONT COLOR=purple>FoCaLize</FONT> and considered as external. In this
case, since the imported code does not fit the <FONT COLOR=purple>FoCaLize</FONT> model
and more accurately, does not have formal properties, it is
impossible to make any proof on <FONT COLOR=purple>FoCaLize</FONT>&#X2019;s side based on the
structure of this code and its non-existing implementation
properties. In other terms, things coming outside <FONT COLOR=purple>FoCaLize</FONT>
 universe can not be modeled by <FONT COLOR=purple>FoCaLize</FONT>. The developer can only
import them providing a binding is given and must trust them.</LI><LI CLASS="li-itemize">Last case addresses &#X201C;well-known&#X201D; mathematical properties
that do not actually hold in computers since they are finite
machines, working on bounded arithmetics. The most obvious
example is the fact that since an integer is coded on a
machine word (e.g. 32-bit values), the
mathematical property &#X2200; <I>x</I> &#X2208; <FONT COLOR=red>N</FONT>, <I>x</I> + 1 &gt;
<I>x</I> does not hold anymore.
<P>
However, conceptually, except when dealing with boundaries,
this property holds and we need to achieve further proofs. For
this reason, assuming that the proof holds is legitimate, if the
developer is able to guarantee that the integer computations
never overflow. If he cannot guarantee non-overflow, then this
is a true problem of specification or design which should be
re-considered.
</P></LI></UL><P>In any case, we advice the reader to use
the test tool (or another mean) to comfort the confidence in the
statement of the theorem, when such statement is admitted.</P></LI><LI CLASS="li-itemize"><B>Write an automated proof script</B>. <FONT COLOR=purple>FoCaLize</FONT> provides a
syntax, the <FONT COLOR=purple>FoCaLize</FONT> Proof Language, to split proofs into steps that
may be proved by the <FONT COLOR=purple>Zenon</FONT> theorem prover. Without entering deeply
into the syntax further described in chapter <A HREF="#making-proofs">5</A>,
the main features are the following. The user may state hypotheses,
demonstrate subgoals that will serve as lemmas for a higher level
goal and may give hints about definitions or declarations of
methods. Then <FONT COLOR=purple>Zenon</FONT> tries to automatically guess a proof of this
goal, then tries to prove those lemmas, hence building a proof tree
until the top goal (i.e. the theorem) is proved. Here is an
example of such proof.<TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2> </FONT><FONT SIZE=2>theorem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>zero_is_unique</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>o</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>,</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  (</FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, !</FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, !</FONT><FONT SIZE=2>plus</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>o</FONT><FONT SIZE=2>))) -&gt; !</FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>o</FONT><FONT SIZE=2>, !</FONT><FONT SIZE=2>zero</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>         &lt;1&gt;1 </FONT><FONT SIZE=2>assume</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>o</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>,</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>              </FONT><FONT SIZE=2>assume</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>H1</FONT><FONT SIZE=2>: </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, !</FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, !</FONT><FONT SIZE=2>plus</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>o</FONT><FONT SIZE=2>)),</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>              </FONT><FONT SIZE=2>prove</FONT><FONT SIZE=2> !</FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>o</FONT><FONT SIZE=2>, !</FONT><FONT SIZE=2>zero</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>             &lt;2&gt;1 </FONT><FONT SIZE=2>prove</FONT><FONT SIZE=2> !</FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> (!</FONT><FONT SIZE=2>zero</FONT><FONT SIZE=2>, !</FONT><FONT SIZE=2>plus</FONT><FONT SIZE=2> (!</FONT><FONT SIZE=2>zero</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>o</FONT><FONT SIZE=2>))</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>                </FONT><FONT SIZE=2>by</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>hypothesis</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>H1</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>             &lt;2&gt;3 </FONT><FONT SIZE=2>prove</FONT><FONT SIZE=2> !</FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>o</FONT><FONT SIZE=2>, !</FONT><FONT SIZE=2>zero</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>                </FONT><FONT SIZE=2>by</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>step</FONT><FONT SIZE=2> &lt;2&gt;1</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>                </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>zero_is_neutral</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>equal_transitive</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>equal_symmetric</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>             &lt;2&gt;4 </FONT><FONT SIZE=2>conclude</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>        &lt;1&gt;2 </FONT><FONT SIZE=2>conclude</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ;</FONT></TD></TR>
</TABLE></LI><LI CLASS="li-itemize"><B>Write a </B><B><FONT COLOR=purple>Coq</FONT></B><B> script</B> This way is the most difficult
since it means to directly write <FONT COLOR=purple>Coq</FONT> code. It
requires the understanding of both <FONT COLOR=purple>Coq</FONT> and the mapping the
<FONT COLOR=purple>FoCaLize</FONT> compiler does to generate <FONT COLOR=purple>Coq</FONT> code from <FONT COLOR=purple>FoCaLize</FONT> source
code. The section <A HREF="#focal-coq-mapping">9.0.6</A> describes how <FONT COLOR=purple>FoCaLize</FONT> definitions are mapped onto
<FONT COLOR=purple>Coq</FONT> names.<P>The <FONT COLOR=purple>Coq</FONT> script is introduced by the keywords
<TT>coq proof</TT> and surrounded by <TT>{*</TT> and <TT>*}</TT>.
Below follows an example of such proof.
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>theorem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int_minus_plus</FONT><FONT SIZE=2>: </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>,</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* x - y = z -&gt; x = y + z *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  #</FONT><FONT SIZE=2>base_eq</FONT><FONT SIZE=2> (#</FONT><FONT SIZE=2>int_minus</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>), </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>) -&gt; #</FONT><FONT SIZE=2>base_eq</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, #</FONT><FONT SIZE=2>int_plus</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>))</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2>coq</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> {*</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>intros</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>; </FONT><FONT SIZE=2>unfold</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int_plus</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>int_minus</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>base_eq</FONT><FONT SIZE=2>,</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>        </FONT><FONT SIZE=2>syntactic_equal</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> |- *;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>intros</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>H</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>unfold</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>bi__int_minus</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>apply</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>EQ_base_eq</FONT><FONT SIZE=2>; </FONT><FONT SIZE=2>rewrite</FONT><FONT SIZE=2> &lt;- (</FONT><FONT SIZE=2>Zplus_minus</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>);</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>apply</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Zplus_eq_compat</FONT><FONT SIZE=2>; </FONT><FONT SIZE=2>trivial</FONT><FONT SIZE=2>; </FONT><FONT SIZE=2>apply</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>decidable</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>apply</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Z_eq_dec</FONT><FONT SIZE=2>. </FONT><FONT SIZE=2>assumption</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>      </FONT><FONT SIZE=2>Qed</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    *} ;;</FONT></TD></TR>
</TABLE></LI></UL><!--TOC subsubsection Theorems-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc78">3.2.7.4</A>  Theorems</H4><!--SEC END --><P>
Now we know how to write a logical statement and
how
to write a proof, the structure of a theorem appears simple since it
contains both the statement and the proof inside the same
construct. The theorem is introduced by the keyword <TT>theorem</TT> and
the proof by the keyword <TT>proof</TT> followed by an equal character
(&#X201C;=&#X201D;).
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="theorem"><I><FONT COLOR=maroon>theorem</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>theorem</FONT></TT> <A HREF="#lident"><I><FONT COLOR=maroon>lident</FONT></I></A> <TT><FONT COLOR=blue>:</FONT></TT>  <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A>
<TT><FONT COLOR=blue>proof =</FONT></TT>  <A HREF="#proof"><I><FONT COLOR=maroon>proof</FONT></I></A></TD></TR>
</TABLE></TD></TR>
</TABLE><P>For instance:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Meet_semi_lattice</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>inherits</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Setoid</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>theorem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>inf_right_substitution_rule</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>,</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>     </FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>) -&gt; </FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2>(!</FONT><FONT SIZE=2>inf</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>), !</FONT><FONT SIZE=2>inf</FONT><FONT SIZE=2>(</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>))</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>     </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>       </FONT><FONT SIZE=2>by</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>          </FONT><FONT SIZE=2>inf_left_substitution_rule</FONT><FONT SIZE=2>,</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>          </FONT><FONT SIZE=2>inf_commutes</FONT><FONT SIZE=2>,</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>          </FONT><FONT SIZE=2>equal_transitive</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>
The kind of proof used here is written in <FONT COLOR=purple>FoCaLize</FONT> Proof Language and
must not be a matter of understanding at this point since this
particular point will be addressed with more details in chapter
<A HREF="#making-proofs">5</A>.</P><P>Notice that theorems can be hosted in a species or can be
toplevel-theorems.
Unlike theorems, properties cannot appear at
toplevel since there is no way to inherit at toplevel, hence no
way to give a proof after the property declaration in a &#X201C;parent&#X201D;.

</P><!--TOC chapter The <FONT COLOR=purple>FoCaLize</FONT> model-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc79">Chapter 4</A>  The <FONT COLOR=purple>FoCaLize</FONT> model</H1><!--SEC END --><P>As stated in section <A HREF="#glimpse">1</A>, the <FONT COLOR=purple>FoCaLize</FONT> language is designed
to build an application step by step, going from very abstract
specifications to the concrete implementation through a hierarchy of
structures. At first sight species seem quite similar to
classes in an Object-Oriented context. <EM>However, despite of
inheritance and late-binding features, </EM><EM><FONT COLOR=purple>FoCaLize</FONT></EM><EM> is definitively not an
Object-Oriented language as C++, Java, etc. are.</EM></P><P>In the following we focus on the basic concepts underlying a
<FONT COLOR=purple>FoCaLize</FONT> development, that is:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Top-level definitions
</LI><LI CLASS="li-itemize">Species
</LI><LI CLASS="li-itemize">Collections
</LI><LI CLASS="li-itemize">Parametrisation
</LI><LI CLASS="li-itemize">Inheritance
</LI><LI CLASS="li-itemize">Late-binding
</LI></UL><P>
To ensure that this part can be read independently of the section
<A HREF="#glimpse">1</A>, we duplicate some explanations.</P><!--TOC section Basic concepts-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc80">4.1</A>  Basic concepts</H2><!--SEC END --><!--TOC subsection Top-level Definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc81">4.1.1</A>  Top-level Definitions</H3><!--SEC END --><P>
<A NAME="toplevel-def"></A>
<A NAME="@default77"></A>
We call <B>toplevel-definition</B> (just one word) a definition which
appears outside species and collections. Such definitions can only be:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Species 
</LI><LI CLASS="li-itemize">collections,
</LI><LI CLASS="li-itemize">type definitions,
</LI><LI CLASS="li-itemize">general theorems (not depending on a species) 
</LI><LI CLASS="li-itemize">general functions (not depending on a species),
</LI><LI CLASS="li-itemize">expressions to be directly evaluated (but there is no way to
bind their value to an identifier).
</LI></UL><P>
Any toplevel-definition is terminated by a double semi-character
(&#X201C;;;&#X201D;).<A NAME="@default78"></A></P><!--TOC subsection Species-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc82">4.1.2</A>  Species</H3><!--SEC END --><P>
<A NAME="species-intro"></A>
<B>Species</B> <A NAME="@default79"></A> are the nodes of the <FONT COLOR=purple>FoCaLize</FONT>
hierarchy. A species is a sequence of <B>methods</B> <A NAME="@default80"></A> or
<B>fields</B><A NAME="@default81"></A>, each one being terminated by a semi
character (&#X201C;;&#X201D;)<A NAME="@default82"></A>. Hence, a basic species looks like:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>  </FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Name</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2>meth1</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2>meth2</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>Species names are always <B>capitalised</B>. As any
toplevel-definition, a species ends with a double semi-character
(&#X201C;;;&#X201D;).<A NAME="@default83"></A> There are several kinds of methods:
<BR>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<BR>
<A NAME="rep-is-method"></A>
The <B>representation</B><A NAME="@default84"></A>. It
defines<A NAME="@default85"></A> the type of the entities
manipulated in the species and is a kind of alias type (see section
<A HREF="#representation-type">3.2.3</A>). The representation can be a type
variable and then is said to be &#X201C;not yet defined&#X201D; or &#X201C;only
declared&#X201D; and is not explicitly introduced
<A NAME="@default86"></A>. It can be bound to a type defined
by a more complex type expression possibly containing type variables
(introduced via collection parameters). Either, this type value is
obtained by inheritance or is introduced by the keyword <TT>representation</TT><A NAME="@default87"></A> followed by <TT>=</TT> followed
by a type expression. Ultimately to get a <EM>complete</EM> (fully
defined) species, the representation must be a fully instantiated
type (directly or by <A HREF="#inheritance">4.3.1</A>).<P>In the context of a species, the representation is denoted by <TT>Self</TT>.</P><P>Note that a representation is never a polymorphic type. When it is
only declared, it is a type variable, which can receive only one
instantiation. In other words, this type variable is not universally
quantified, as are the type variables of polymorphic types. </P></LI><LI CLASS="li-itemize"><B>Signatures</B><A NAME="@default88"></A>. They introduce names of
constants and functions, uniquely providing their type as a type
expression. A signature
begins with the keyword <TT>signature</TT> followed by the introduced
name followed by <TT>:</TT> followed by a type expression. For
instance: 
<FONT SIZE=2>
</FONT><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2> </FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>IntStack</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>push</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE> <P>As we saw above, <TT>Self</TT> represents the representation (thus a
type) of the current species. Hence an operation pushing an integer
onto a stack takes as parameter the integer to push, the stack on
which to push and give back a new stack, that is, an entity of type
<TT>Self</TT>.</P><P><BR>
</P></LI><LI CLASS="li-itemize"><B>Functions</B><A NAME="@default89"></A>. They are implementations of
signatures, providing effective code. A function is
introduced by the <TT>let</TT> keyword followed by the name followed
by <TT>=</TT> followed by a definition, which is similar to ML
definitions. Recursive functions are
introduced by <TT>let rec</TT> to make explicit the recursivity.<TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>IntStack</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>representation</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>list</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>push</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>v</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>s</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>v</FONT><FONT SIZE=2> :: </FONT><FONT SIZE=2>s</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>Function parameters can be entities (that is, values) of the
species itself (which type is the representation, thus denoted by
<TT>Self</TT>), entities of known collections, values of known types.</P><P>Functions can use in their body other methods of the species,
toplevel-definitions of functions, methods of collections
(described further in <A HREF="#collection">4.1.5</A>), or methods of
collections parameters (see <A HREF="#collection-parameter">4.2.1</A>).</P><P><A NAME="idea-fun-using-sig"></A>
When we say &#X201C;other methods of the species&#X201D;, this includes
functions only introduced by their
signatures. This means that it is possible to use something only
declared, without yet effective implementation. We will address
this point later in detail in section <A HREF="#late-binding">4.4.1</A>.</P><P><BR>
Although <FONT COLOR=purple>FoCaLize</FONT> is a functional language, function application
must always be total. This means that any function call must be
provided all the effective arguments of the function. As
previously
described in the core syntax (c.f <A HREF="#function-application">3.2.4.8</A>),
function application is &#X201C;à la C&#X201D;, that is with arguments comma
separated and enclosed by parentheses.</P><P><BR>
</P></LI><LI CLASS="li-itemize"><B>Properties</B><A NAME="@default90"></A>. They are first order 
formulae containing names already introduced. When stating a
property, the proof that it holds is not yet provided (but will have
to be ultimately provided). A property can be viewed as a declaration.<TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>IntStack</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>push_returns_non_empty</FONT><FONT SIZE=2> :</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>v</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>s</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>push</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>v</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>s</FONT><FONT SIZE=2>) -&gt; ~ </FONT><FONT SIZE=2>is_empty</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>s</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>Proofs<A NAME="@default91"></A> of properties can be <B>delayed</B>,
that is, done afterwards
using a <TT>proof</TT> field in a species. The way to give proofs will
be seen further.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>IntStack2</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>IntStack</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>of</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>push_returns_non_empty</FONT><FONT SIZE=2> = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P><BR>
</P></LI><LI CLASS="li-itemize"><B>Theorems</B><A NAME="@default92"></A>. They are properties with their
proofs. In fact, when defining a property, we only give the
statement of a theorem, leaving its proof for later. A theorem can
be viewed as a definition.<TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>IntStack</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>theorem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>push_returns_non_empty</FONT><FONT SIZE=2> :</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>v</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>s</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>push</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>v</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>s</FONT><FONT SIZE=2>) -&gt; ~ </FONT><FONT SIZE=2>is_empty</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    (</FONT><FONT SIZE=2>s</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE></LI></UL><P><A NAME="no-polymorphism-for-methods"></A>
One important restriction on the type of the methods is that it cannot
be polymorphic<A NAME="@default93"></A>. However, <FONT COLOR=purple>FoCaLize</FONT> provides another
mechanism to circumvent this restriction, the
parametrisation<A NAME="@default94"></A> as explained further
(c.f. <A HREF="#parametrisation">4.2</A>).</P><!--TOC subsection Complete species-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc83">4.1.3</A>  Complete species</H3><!--SEC END --><P>
A species is said <EM>complete</EM><A NAME="@default95"></A> if all
its methods are <EM>defined</EM>, i.e. have an implementation. In other
words this means that there is no more methods only <EM>declared</EM>. This notion implies that:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The representation has been associated with a type definition.
</LI><LI CLASS="li-itemize">Every declaration is associated to a definition.
</LI><LI CLASS="li-itemize">A proof is given for every property.
</LI></UL><P><BR>
Obviously, it is possible to build a species without signatures and
properties, only providing functions and theorems directly. In this
case, if the representation is also defined, then the obtained species
is trivially complete.</P><P>The important point for a species to be complete is that it can be
turned into effective executable <FONT COLOR=purple>OCaml</FONT> code and effective checkable
<FONT COLOR=purple>Coq</FONT> code, since all the components are known.</P><P><BR>
<B>Important</B>: Although we said that only a complete species can
lead to effective executable code, of course species even not complete
are compiled ! This means that you do not need to have a complete
species to compile your source code ! It is very common to have
species not complete in source files since programs are written in a
modular fashion, in several files. Moreover, a library may provide
species with methods not defined, leaving the user the freedom to
chose an effective implementation for some algorithms.</P><!--TOC subsection Interfaces-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc84">4.1.4</A>  Interfaces</H3><!--SEC END --><P>
<A NAME="interface"></A>
<A NAME="@default96"></A>
The <B>interface</B> of a species is the list of the declarations of
its methods. It corresponds to the end-user point of view, who wants
to know which functions he can use, and which properties these
functions have, but doesn&#X2019;t care about the details of the
implementation.</P><P><BR>
</P><P>The interface of a species is obtained by keeping the
signatures and properties and retaining only the signatures of the let
methods and the statement of the theorems. The representation is
hidden thus abstract (only unifiable with itself). Hence, getting the
interface of a species can roughly be seen as erasing the
representation, turning the functions into signatures and the theorems
into properties.</P><P><BR>
</P><P>While this abstraction is easy within programming languages, it is not
always possible when dealing with proofs and properties. Such
problematic species are rejected by <FONT COLOR=purple>FoCaLize</FONT> and will be described
later in <A HREF="#dependencies">4.4.2</A>.</P><P>An interface has a <B>name</B>, <EM>which is the name of the underlying
species</EM>. There should be no confusion between species names and
interface names as interface names are only used to declare formal
collection parameters (see section <A HREF="#collection-parameter">4.2.1</A>) and to
apply methods of collection parameters.</P><!--TOC subsection Collections-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc85">4.1.5</A>  Collections</H3><!--SEC END --><P>
<A NAME="collection"></A>
<A NAME="@default97"></A></P><P>A <B>collection</B> is a kind of &#X201C;grey box&#X201D;, built from a <EM>complete</EM> species by abstraction of the representation. A collection
has exactly the same sequence of methods than the complete species
underlying it, apart the representation which is hidden. 
Note that creating a collection from it is the
only way to turn methods of a complete species into executable
code. This point is emphasised by the syntax:</P><P><TT>collection</TT> <EM>name-collection</EM> = <TT>implement</TT> <EM>name-species</EM> <TT>end</TT></P><P>The interface of a collection is the one of the
complete species it implements. The interface <I>I</I><SUB>1</SUB> of a collection
<I>C</I><SUB>1</SUB> is <EM>compatible</EM> with an interface <I>I</I><SUB>2</SUB> if <I>I</I><SUB>1</SUB> contains
all the components of <I>I</I><SUB>2</SUB>.</P><P><BR>
</P><P>Thus, implementing a complete species creates a collection, which is a
kind of abstract data-type. This especially
means that entities of the collection cannot be directly
created or manipulated as their type is not accessible. So they can
only be manipulated by the methods of the <EM>implemented</EM> species.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Full</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>rep</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>create_random</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>random_foc</FONT><FONT SIZE=2>#</FONT><FONT SIZE=2>random_int</FONT><FONT SIZE=2> (42) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>double</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> + </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>print</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>print_int</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>collection</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>MyFull_Instance</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>implement</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Full</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>v</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>Full</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>create_random</FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>Full</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>print</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>v</FONT><FONT SIZE=2>) ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>dv</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>Full</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>double</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>v</FONT><FONT SIZE=2>) ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>Full</FONT><FONT SIZE=2>.</FONT><FONT SIZE=2>print</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>dv</FONT><FONT SIZE=2>) ;;</FONT></TD></TR>
</TABLE><P>In this example, we define a complete species <TT>Full</TT>. Then 
we create the collection
<TT>MyFull_Instance</TT>. And we use methods of this collection to
create entities of this collection. We print the result of the
evaluation of the top-level definitions of <TT>v</TT> and <TT>dv</TT>. </P><P><BR>
</P><P><EM>Note that two collections created from a same species are
not type-compatible since their representation is abstracted making
impossible to ensure a type equivalence.</EM></P><P><BR>
As a conclusion, collections are the only way to get something that
can be executed since they are the terminal items of a
<FONT COLOR=purple>FoCaLize</FONT> development hierarchy. Since they are &#X201C;terminal&#X201D;, this also
means that no method can be added to a collection. Moreover, a
collection may not be used to create a new species by inheritance (as
explained in the next section).</P><!--TOC section Parametrisation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc86">4.2</A>  Parametrisation</H2><!--SEC END --><P>
<A NAME="@default98"></A>
<A NAME="parametrisation"></A></P><P>This section describes a first mechanism to incrementally build new
species from existing ones: the parametrisation. 
</P><!--TOC subsection Collection parameters-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc87">4.2.1</A>  Collection parameters</H3><!--SEC END --><P>
<A NAME="@default99"></A>
<A NAME="@default100"></A>
<A NAME="collection-parameter"></A>
Remember that methods cannot be polymorphic<A NAME="@default101"></A>
(c.f. <A HREF="#no-polymorphism-for-methods">4.1.2</A>). For
example, how to implement the well-known polymorphic type of 
lists ? Grouping elements in a list does not
depend of
the type of these elements. The only constraint is that all elements
have the same type. Hence, a ML-like representation of lists would be
like:
<FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><B>type</B></FONT><FONT SIZE=2> '</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>list</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Nil</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  | </FONT><FONT SIZE=2>Cons</FONT><FONT SIZE=2> </FONT><FONT SIZE=2><B>of</B></FONT><FONT SIZE=2> ('</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> * '</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>list</FONT><FONT SIZE=2>)</FONT></TD></TR>
</TABLE><P>The <TT>&#X2019;a</TT> is a parameter of the constructor type <TT>list</TT>, which
is indeed a polymorphic ML type. </P><P>In <FONT COLOR=purple>FoCaLize</FONT> we would like to create a
species looking like: <FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>List</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>nil</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>cons</FONT><FONT SIZE=2> : '</FONT><FONT SIZE=2>a</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>Instead of abstracting the type parameter and leaving it free in the
context of the species, in <FONT COLOR=purple>FoCaLize</FONT> we <EM>parametrise</EM> the species
by a <B>collection parameter</B> called <TT>Elem</TT> in the example:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>List</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>Elem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Basic_object</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>nil</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>cons</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Elem</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>Collection parameters are introduced by their name followed by the
<TT>is</TT> keyword, followed by an <B>interface name</B> (remember that
an interface has the same name as its underlying species). In the
example, <TT>Basic_object</TT> is a pre-defined species from the
standard library, containing only few methods and this name is used
here to denote the interface of this species. A
collection parameter can be instantiated by any collection which
interface is <EM>compatible</EM><A NAME="@default102"></A> with the one required by
the parametrised species (c.f <A HREF="#interface">4.1.4</A>). In the example, any
effective parameter instantiating <TT>Elem</TT> is a collection which
interface contains at least the methods listed in the interface of
<TT>Basic_object</TT>. </P><P><BR>
In the example, we use the parameter <TT>Elem</TT> to build the signature
of our method <TT>cons</TT>. Note that collection names can be used
in type expressions to denote the &#X201C;abstracted&#X201D; representation of the
collection. Here &#X201C;abstracted&#X201D; means that the
representation is not visible but we can refer to it
as an abstract type. In other words, <TT>Elem -&gt; Self -&gt; Self</TT>
stands for the type of a function:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
taking a first argument whose type is the representation of a
collection having a compatible interface with the interface <TT>Basic_object</TT>. (This especially means that such an argument is
created using methods of the compatible collection),
</LI><LI CLASS="li-itemize">taking a second argument whose type is the representation of
the current species,
</LI><LI CLASS="li-itemize">and returning a value whose type is the representation of the
current species.
</LI></UL><P><B>Why a collection parameter and not a species
parameter? </B></P><P>The answer to this question is especially important to
understand the programming model in <FONT COLOR=purple>FoCaLize</FONT>. It is a <B>collection
parameter</B> because ultimately, at the terminal nodes of the
development, this parameter will have to be instantiated by an entity
where everything is defined, so at least a complete species. Imagine
how to build an executable code if a parameter can be instantiated by
a species with some methods only declared&#X2026;This is the first
reason. </P><P>Remember that properties mentioned in the collection interface have
been proved in the underlying complete species. Indeed in the hosting
species, these theorems can be used as lemmas to do current proofs. If
the collection representation was not abstracted, then some methods of
the hosting species would have the ability to directly manipulate
entities of the collection parameter, with the risk of breaking some
invariants of the collection parameter. This is the second reason.
Thus the representation of a collection parameter is abstract for the
hosting, exactly as is the representation of a collection (c.f
<A HREF="#collection">4.1.5</A>).</P><P>To summarize, declaring a collection parameter for a parametrised
species means providing two things: the (capitalized) name of the
parameter and the interface (denoted by a species name) that the
instantiation of this parameter must satisfy.</P><P><BR>
It is important at this point to note that <FONT COLOR=purple>FoCaLize</FONT> deals with
dependent types<A NAME="@default103"></A>, and therefore that <EM>the order of the parameters is important</EM>. To define the type of a
parameter, one can use the preceding parameters. For instance, 
assuming that a parametrised species <TT>List</TT> 
declares the basic operations over lists, one can specify a new
species working on couples of respectively values and lists of values
like: <FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>MyCouple</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>E</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Basic_object</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>L</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>List</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>E</FONT><FONT SIZE=2>)) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>representation</FONT><FONT SIZE=2> = (</FONT><FONT SIZE=2>E</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>L</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>The representation of this species represents the type
<TT>(&#X2019;a * (&#X2019;a list))</TT>. This means that the type of the values in the
first component of the couple is the same than the type of the
elements of the list in the second component of the couple.</P><P>A parametrized species (like in
the example the species <TT>MyCouple</TT>) cannot be only partially
instantiated. An
instantiation for <B>all</B> its parameters is required. </P><P><BR>
<A NAME="method-qualification"></A>
<A NAME="@default104"></A>
The previous example used
a parameter to build the representation of the species. 
Collection parameters can also be used via their other methods,
i.e. signatures, functions, properties and theorems, denoted by the
parameter&#X2019;s name followed by the &#X201C;!&#X201D;<A NAME="@default105"></A>
character followed by the method name. </P><P>To create a species describing a notion of generic couple, it suffices
to use two collection parameters, one for each component of the
couple. To define a printing (i.e. returning a string, not making side
effect in our example) method, it suffices to require each collection
parameter to provide one. Now the printing method has only to
add parentheses and comma around and between what is printed by each
parameter&#X2019;s printing routine. 
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><EM><FONT SIZE=2>(* Minimal species requirement : having a print routine. *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Base_obj</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>print</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>string</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Couple</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>C1</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Base_obj</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>c2</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Base_obj</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>representation</FONT><FONT SIZE=2> = (</FONT><FONT SIZE=2>C1</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>C2</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>print</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>c</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2>match</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>c</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>with</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>     | (</FONT><FONT SIZE=2>component1</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>component2</FONT><FONT SIZE=2>) -&gt;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>       </FONT><FONT SIZE=2><FONT SIZE=2>"("</FONT></FONT><FONT SIZE=2> ^ </FONT><FONT SIZE=2>C1</FONT><FONT SIZE=2>!</FONT><FONT SIZE=2>print</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>component1</FONT><FONT SIZE=2>) ^</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>       </FONT><FONT SIZE=2><FONT SIZE=2>", "</FONT></FONT><FONT SIZE=2> ^</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>       </FONT><FONT SIZE=2>C2</FONT><FONT SIZE=2>!</FONT><FONT SIZE=2>print</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>component2</FONT><FONT SIZE=2>) ^</FONT><FONT SIZE=2><FONT SIZE=2>")"</FONT></FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>Hence, <TT>C1!print (component1)</TT> means &#X201C;call the collection
<TT>C1</TT>&#X2019;s method <TT>print</TT> with the argument <TT>component1</TT>&#X201D;. </P><P>The
qualification mechanism using &#X201C;!&#X201D; is general and can be used to
denote the method of any available species/collection, even those of
ourselves (i.e. <TT>Self</TT>). Hence, in a species instead of calling:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Foo</FONT><FONT SIZE=2> ... =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m1</FONT><FONT SIZE=2> (...) = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m2</FONT><FONT SIZE=2> (...) = </FONT><FONT SIZE=2>if</FONT><FONT SIZE=2> ... </FONT><FONT SIZE=2>then</FONT><FONT SIZE=2> ... </FONT><FONT SIZE=2>else</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m1</FONT><FONT SIZE=2> (...) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>
it is allowed to explicitly qualify the call to <TT>m1</TT> by &#X201C;!&#X201D;
with no species name, hence implicitly telling &#X201C;from myself&#X201D;:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Foo</FONT><FONT SIZE=2> ... =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m1</FONT><FONT SIZE=2> (...) = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m2</FONT><FONT SIZE=2> (...) = </FONT><FONT SIZE=2>if</FONT><FONT SIZE=2> ... </FONT><FONT SIZE=2>then</FONT><FONT SIZE=2> ... </FONT><FONT SIZE=2>else</FONT><FONT SIZE=2> !</FONT><FONT SIZE=2>m1</FONT><FONT SIZE=2> (...) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>
<A NAME="@default106"></A>
<A NAME="@default107"></A>
In fact, without explicit &#X201C;!&#X201D;, the <FONT COLOR=purple>FoCaLize</FONT> compiler performs the
name resolution itself, allowing a lighter way of writing programs
instead of always needing a &#X201C;!&#X201D; character before each method call.</P><!--TOC subsection Entity parameters-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc88">4.2.2</A>  Entity parameters</H3><!--SEC END --><P>
<A NAME="@default108"></A>
<A NAME="entity-parameter"></A>
There is a second kind of parameter: the <B>entity-parameter</B>. Such
a parameter can be instantiated by an <B>entity of a certain
collection</B>. </P><P>For example, to obtain a species offering addition modulo an
integer value, we need to parametrise it by an entity of a collection
implementing the integers and to give a way to build an entity
representing the value of the modulo. Such a parameter is called an
<B>entity parameter</B> and is introduced by the keyword <TT>in</TT>.
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>AddModN</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>Number</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>InterfaceForInts</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>val_mod</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Number</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>representation</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>Number</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>add</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2>Number</FONT><FONT SIZE=2>!</FONT><FONT SIZE=2>modulo</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>Number</FONT><FONT SIZE=2>!</FONT><FONT SIZE=2>add</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>), </FONT><FONT SIZE=2>val_mod</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT></TD></TR>
</TABLE><P>Hence, any collection created from <TT>AddModN</TT> embeds the addition
modulo the effective value instantiating <TT>val_mod</TT>. It is then
possible to create various collections with each a specific modulo
value. For instance, assuming that the species <TT>AddModN</TT> is
complete and have a method <TT>from_int</TT> able to create a value of
the representation from an integer, we can create a collection
implementing addition modulo 42. We also assume that we have a
collection <TT>ACollImplentingInts</TT> having at least <TT>InterfaceForInts</TT> as interface. </P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>collection</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>AddMod42</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>implements</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>AddModN</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  (</FONT><FONT SIZE=2>ACollImplentingInts</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>ACollImplentingInts</FONT><FONT SIZE=2>!</FONT><FONT SIZE=2>from_int</FONT><FONT SIZE=2> (42)) ;;</FONT></TD></TR>
</TABLE><P><BR>
</P><P>Currently, entity parameters must live &#X201C;<TT>in</TT>&#X201D; a
collection. It is not allowed to specify an entity parameter living in
a basic type like <TT>int</TT>, <TT>string</TT>, <TT>bool</TT>&#X2026;This
especially means that these basic types must be embedded in a
collection if we want to use their values as entity parameters.</P><!--TOC section Inheritance and its mechanisms-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc89">4.3</A>  Inheritance and its mechanisms</H2><!--SEC END --><P>
In this section, we address the second mechanism to build complex species
based on existing ones. It will cover the notion of <EM>inheritance</EM>
and its related feature the <EM>late-binding</EM>.</P><!--TOC subsection Inheritance-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc90">4.3.1</A>  Inheritance</H3><!--SEC END --><P>
<A NAME="inheritance"></A>
<A NAME="@default109"></A> <FONT COLOR=purple>FoCaLize</FONT> <EM>inheritance</EM> is the ability to create
a species, not from scratch, but by integrating methods of other
species. The inheritance mechanism also allows to redefine methods
already existing as long as they keep the same type expression. For
theorems to have the same type is simply to have the same statement
(but proofs can differ).</P><P>During inheritance, it is also possible to replace a signature by an
effective definition, to redefine a property by a theorem and in the
same idea, to add a <TT>proof of</TT> to a property in order to
conceptually redefine it as a theorem. Moreover new methods can be
added to the inheriting species.</P><P>Since inherited methods are
owned by the species that inherits, they are called exactly like if
they were defined &#X201C;from scratch&#X201D; in the species.</P><P>For instance, assuming we have a species <TT>IntCouple</TT> that
represent couples of integers, we want to create a species <TT>OrderedIntCouple</TT> in which we ensure that the first component of the
couple is lower or equal to the second. Instead of inventing again all
the species, we will take advantage of the existing <TT>IntCouple</TT>
and &#X201C;import&#X201D; all its methods. However, we will have to change the
creation function since it must ensure at creation-time of a couple
(so at run-time) that it is indeed ordered. <TT>OrderedIntCouple</TT>
has all the methods of <TT>IntCouple</TT>, except <TT>create</TT> which is
redefined and the property <TT>is_ordered</TT>) stating that the couple
is really ordered).</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>IntCouple</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>representation</FONT><FONT SIZE=2> = (</FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> * </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>print</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>create</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>) = (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>first</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>c1</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>c2</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>c1</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>OrderedIntCouple</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>IntCouple</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>create</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2>if</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> &lt; </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>then</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>else</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is_ordered</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>c</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>first</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>c</FONT><FONT SIZE=2>) &lt;= </FONT><FONT SIZE=2>scnd</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>c</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P><BR>
<A NAME="@default110"></A>
<B>Multiple inheritance</B>, i.e. inheriting from several species is
allowed by specifying several species separated by comma in the
<TT>inherit</TT> clause. The inheriting species inherits of all the
methods of inherited species. In case of a same name appears in
several inherited species, the compiler proceeds as follows. </P><P>If all the inherited species have only declared representations, then
the representation of the inheriting species is only declared, unless
it is defined in this inheriting species. If some representations are
declared, the other ones being defined, then the totally defined
representations of inherited species must be the same and this is also
the one of the inheriting species. In the following example, species
<TT>S3</TT> will be rejected while species <TT>S4</TT> has <TT>int</TT> as
representation.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S0</FONT><FONT SIZE=2>; -- </FONT><FONT SIZE=2>no</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>defined</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>representation</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2>;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S1</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>representation</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ; .. </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S2</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>representation</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2>; ... </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2>;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S3</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S1</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>S2</FONT><FONT SIZE=2>; ... </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2>;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S4</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S0</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>S1</FONT><FONT SIZE=2>; ... </FONT><FONT SIZE=2>end</FONT><FONT SIZE=2>;;</FONT></TD></TR>
</TABLE><P>If some methods of inherited species have the same name, if they are
all signatures or properties, if these species have no parameters,
then signatures must be identical, properties must be identical. If
some of these methods have already received definitions, if they have
the same type, then the definition which is retained for the
inheriting species is the one coming from the rightmost defined parent
in the <TT>inherit</TT> clause. For instance below, if species <TT>A</TT>,
<TT>B</TT> 
and <TT>C</TT> provide a method <TT>m</TT> which is defined in <TT>A</TT> and
<TT>B</TT> but only declared in <TT>C</TT>, then <TT>B!m</TT> is the one which
is inherited.
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Foo</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>A</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>B</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>C</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>D</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ... </FONT><FONT SIZE=2>m</FONT><FONT SIZE=2> (...) ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P><BR>
<A NAME="@default111"></A>
<B>Inheritance and parametrisation</B>
If a species <TT>S1</TT> inherits from a parametrised species <TT>S0</TT>,
it must instantiate all the parameters of <TT>S0</TT>. Due to the
dependent types<A NAME="@default112"></A> framework, if <TT>S1</TT> is itself
parametrised, it can use its own parameters to do that. </P><P>Assume we
have a species <TT>List</TT> parametrised by a collection parameter
representing the kind of elements of the list. We want to derive
a species <TT>ListUnique</TT> in which elements are present at most
once. We build <TT>ListUnique</TT> by inheriting from <TT>List</TT>.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>List</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>Elem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> ...) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>representation</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>Elem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>list</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>empty</FONT><FONT SIZE=2> = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>add</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>e</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Elem</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>l</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>concat</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>l1</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>l2</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>ListUnique</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>UElem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> ...) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>List</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>UElem</FONT><FONT SIZE=2>);</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>add</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>e</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>UElem</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>l</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    ... </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* Ensure the element e is not already present. *)</FONT></EM></FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>concat</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>l1</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>l2</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    ... </FONT><FONT SIZE=2><EM><FONT SIZE=2>(* Ensure elements of l1 present in l2 are not added. *)</FONT></EM></FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P> <TT>UElem</TT> is a formal collection parameter of <TT>ListUnique</TT>
which acts as an effective collection parameter in the expression <TT>ListUnique</TT>. The representation of <TT>ListUnique</TT> is <TT>UElem
list</TT>. The representation of <TT>UElem</TT> is hidden: it denotes a
collection. But, the value constructors of the type <TT>list</TT> are
available, for instance, for pattern-matching. </P><P>As a consequence, if two methods in inherited species have the same
name and if at least one of them is itself a parametrised one, then
the signatures of these methods are no longer required to be identical
but their type must have a common instance after instanciation of the
collection parameters.</P><P><A NAME="@default113"></A>
<B>Species inheriting species parametrised by </B><B><TT>Self</TT></B> 
A species can also inherit from a species parametrised by itself
(i.e. by <TT>Self</TT>). Although this is rather tricky programming, the
standard library of <FONT COLOR=purple>FoCaLize</FONT> shows such an example in the file <EM>weak_structures.fcl</EM> in the species <TT>Commutative_semi_ring</TT>. Indeed this species specifies the fact
that a commutative semi-ring is a semi-ring on itself (as a semi-ring
of scalars). In such a case, this implies that the current species
must finally (when inheritance is resolved) have an interface
compatible with the interface required by the collection parameter of
the inherited species. The <FONT COLOR=purple>FoCaLize</FONT> compiler collects the parts of the
interface of <TT>Self</TT> obtained either by inheritance or directly in
the species body. Then it checks that the obtained interface is indeed
compatible with the required interfaces of the parametrised inherited
species. if so, the compiler is able to build the new species. Thus
the compiler tries to build a kind of fix-point but this process is
always terminating, issuing either the new species or rejecting it in
case of interface non-compliance. </P><!--TOC subsection Species expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc91">4.3.2</A>  Species expressions</H3><!--SEC END --><P>
<A NAME="@default114"></A>
We summarize the different ways of building species. The first way is
to introduce a simple collection parameter, requiring that the
effective parameter can offer all the methods listed in the associated
interface. </P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>List</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>Elem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Basic_object</FONT><FONT SIZE=2>) = ... ;</FONT></TD></TR>
</TABLE><P>Then, we can iterate the process and build 
a species parametrised by a parametrised species, like in the example:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>MyCouple</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>E</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Basic_object</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>L</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>List</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>E</FONT><FONT SIZE=2>)) = ... ;;</FONT></TD></TR>
</TABLE><P>Going on, we can inherit
from species that are referenced only by their name, like in:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>OrderedIntCouple</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>IntCouple</FONT><FONT SIZE=2>; ... ;;</FONT></TD></TR>
</TABLE><P>And finally, we mix the two possibilities, building a species by
inheritance of a parametrised species, like in: <FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>ListUnique</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>UElem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>is</FONT><FONT SIZE=2> ...) = </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>List</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>UElem</FONT><FONT SIZE=2>); ... ;;</FONT></TD></TR>
</TABLE><P>Hence, we can now define more accurately the notion of <B>species
expression</B> used for both inheritance and parametrisation. It is either
a simple species name or the application of a parametrised species to
as many collection expressions as the parametrised species has
parameters.</P><!--TOC section Late-binding and dependencies-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc92">4.4</A>  Late-binding and dependencies</H2><!--SEC END --><!--TOC subsection Late-binding-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc93">4.4.1</A>  Late-binding</H3><!--SEC END --><P>
<A NAME="late-binding"></A>
<A NAME="@default115"></A> When building by multiple inheritance
(c.f. <A HREF="#inheritance">4.3.1</A>) some signatures can be replaced by functions
and properties by theorems. It is also possible to associate a
definition of function to a signature (c.f <A HREF="#idea-fun-using-sig">4.1.2</A>)or
a proof to a property. In the same order, it is possible to redefine a
method even if it is already used by an existing method.
All these features are relevant of a mechanism known as <EM>late-binding</EM>. </P><P>During compilation, the selected method is always the <B>most
recently defined</B> along the inheritance tree. This especially means
that as long as a method is a signature, in the children the effective
implementation of the method will remain undefined (that is not a
problem since in this case the species is not complete, hence cannot
lead to a collection, i.e. code that can really be executed
yet). Moreover, if a method <TT>m</TT> previously defined in the
inheritance tree uses a method <TT>n</TT> freshly <B>re</B>defined, then
this <B>fresh redefinition</B> of <TT>n</TT> will be used in the method
<TT>m</TT>.</P><P><BR>
This mechanism enables two programming features:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The mean to use a method known by its type (i.e. its prototype
in term of Software Engineering), but for which we do not know, or
we don&#X2019;t need or we don&#X2019;t want yet to provide an implementation.</LI><LI CLASS="li-itemize">To provide a new implementation of a method while keeping the
initial implementation for the inherited species. For example, the
inheriting species can provide some new information
(representation, functions, ..) which allow a more efficient
implementation of a given function.
</LI></UL><!--TOC subsection Dependencies and erasing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc94">4.4.2</A>  Dependencies and erasing</H3><!--SEC END --><P><A NAME="dependencies"></A>
We previously saw that methods of a species can use other methods of
this species and methods from its collection parameters. This induce
what we call <B>dependencies</B><A NAME="@default116"></A>. There are two kinds
of dependencies, depending on their nature:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Decl-dependencies</B>
</LI><LI CLASS="li-itemize"><B>Def-dependencies</B>
</LI></UL><P>
In order to understand the difference between, we must inspect further
the notion of representation, function, and theorem.</P><!--TOC subsubsection Decl-dependencies-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc95">4.4.2.1</A>  Decl-dependencies</H4><!--SEC END --><P>
<A NAME="@default117"></A>
When defining a function, a property or a theorem it is possible to
use another functions or signatures. For instance:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Bla</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>test</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f1</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>string</FONT><FONT SIZE=2>) = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f2</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) = ... </FONT><FONT SIZE=2>f1</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2><FONT SIZE=2>"Eat at Joe's"</FONT></FONT><FONT SIZE=2>) ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>p1</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>test</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>f2</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>)) &lt;-&gt; </FONT><FONT SIZE=2>test</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>f1</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2><FONT SIZE=2>"So what"</FONT></FONT><FONT SIZE=2>)) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>theorem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>t1</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>p1</FONT><FONT SIZE=2> &lt;-&gt;  </FONT><FONT SIZE=2>test</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>f1</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2><FONT SIZE=2>"Bar"</FONT></FONT><FONT SIZE=2>))</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>In this cases, knowing the type (or the logical statement) of the used
methods is sufficient to ensure that the using method is
well-formed. The type of a method being provided by its
<B>declaration</B>, we will call these induced dependencies
<B>decl-dependencies</B>.</P><P>Such dependencies also arise on the representation as soon as the type
of a method makes reference to the type <TT>Self</TT>. Hence we can have
dependencies on the representation as well as on other methods.</P><P>Hence, in our example, <TT>test</TT>, <TT>f2</TT>, <TT>f1</TT> (since it is
used in <TT>p1</TT> and <TT>t1</TT> as the argument of <TT>test</TT> which expects
an argument of type <TT>Self</TT>), <TT>p1</TT> and <TT>t1</TT> have a
decl-dependency on the representation. Moreover, <TT>f2</TT> has one on
<TT>f1</TT>. The property <TT>p1</TT> has decl-dependencies on <TT>test</TT>,
<TT>f1</TT> and <TT>f2</TT> and <TT>Self</TT>. And finally <TT>t1</TT>
decl-depends on <TT>p1</TT>, <TT>test</TT>, <TT>f1</TT> and <TT>Self</TT>.</P><!--TOC subsubsection Def-dependencies-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc96">4.4.2.2</A>  Def-dependencies</H4><!--SEC END --><P>
<A NAME="def-dependency"></A>
<A NAME="@default118"></A> 
A method <I>m</I> has a 
<B>def-dependency</B> over another one <I>p</I> if the system needs to
know the <B>definition</B> of <I>p</I> to ensure that <I>m</I> is well-formed.</P><P>A definition of function can create only decl-dependencies on
methods differing from the representation since the type system of
<FONT COLOR=purple>FoCaLize</FONT> only needs the types of the names present in the body of this
function. Note also that when <B>using</B> a signature in another
method, since signature only contain types, no def-dependencies can
arise.</P><P>Now remember that <TT>representation</TT> is also a method and there is
no syntactical way to forbid constructions like <TT>if representation
= int ..</TT> in function or properties. Such definitions would have a
<B>def-dependency</B> on the representation<A NAME="@default119"></A>. For consistency reasons going beyond this manual
but that will be shortly presented below in
<A HREF="#def-dep-on-representation">4.4.3.2</A>, the <B><FONT COLOR=purple>FoCaLize</FONT></B><B> system rejects
functions and properties having def-dependencies on the
representation</B>.</P><P><BR>
There remains the case of theorems. This case is the most
complex since it can lead to def-dependencies in proofs. For the same
reasons than for properties, the <B><FONT COLOR=purple>FoCaLize</FONT></B><B> system rejects theorems
which statements have def-dependencies on the representation</B>. Other
def-dependencies are accepted. These dependencies must be introduced
by the statement of the proof (with a syntax given in section
<A HREF="#zenon-an-dependencies">??</A>). Now, what does mean for a theorem to
def-depend on a method ? This basically means that to make the proof
of the theorem statement, one must use not only the declaration of a
method, but also its definition, its body. This is a needed and powerful feature.</P><!--TOC subsubsection Erasing during inheritance-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc97">4.4.2.3</A>  Erasing during inheritance</H4><!--SEC END --><P>
<A NAME="@default120"></A>
<A NAME="erasing"></A>
As a consequence of def-dependencies and late-binding, if a method is
redefined, all the proofs of theorems having def-dependencies on these
methods are erased. This means that since the body of the method
changed, may be the proof is not correct anymore and must be done
again. In practice, it can happen that the proof still holds, but the
compiler can&#X2019;t ensure this, hence will turn the theorem into a
property in the species where the redefinition occurred. The developer
will then have to provide a new proof of the inherited theorem thanks
to the <TT>proof of</TT> field. For example, any sorting list algorithm
must satisfy the invariant that its result is a sorted list with the
same elements as its effective argument but the
proof that indeed this requirement is satisfied depends on the
different possible implementations of sort. It is perhaps possible to
decompose this proof into different lemmas to minimize erasing by
redefinition, some lemmas needing only decl-dependencies over the
redefined method. </P><!--TOC subsubsection Dependencies on collection parameters-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc98">4.4.2.4</A>  Dependencies on collection parameters</H4><!--SEC END --><P>
Since collection parameters always have their representation abstracted,
hidden, only <B>decl-dependencies</B> can appear in the parametrised
species using them. Hence they can never lead to erasing. These
dependencies are only used internally by the <FONT COLOR=purple>FoCaLize</FONT> compiler in order
to generate the target code. For this reason, we will not focus anymore
on them.
</P><!--TOC subsection More about methods definition-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc99">4.4.3</A>  More about methods definition</H3><!--SEC END --><P>
We will now examine more technical points in methods definitions.
</P><!--TOC subsubsection Well-formation-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc100">4.4.3.1</A>  Well-formation</H4><!--SEC END --><P>
<A NAME="well-formation"></A>
<A NAME="@default121"></A></P><P><FONT COLOR=purple>FoCaLize</FONT> providing late-binding, it is possible to <B>declare</B> a
method <TT>m0</TT> and use it in another <B>defined method</B> <TT>m1</TT>.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S0</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m0</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m1</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>m0</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>In another species <TT>S1</TT>, it is also possible to <B>declare</B> a
method <TT>m1</TT> and use it in another <B>defined method</B> <TT>m0</TT>.
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S1</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S0</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m1</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>m0</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>As long as these two species have no interactions no problem can arise. Now, we
consider a third species <TT>S2</TT> inheriting from both <TT>S0</TT> and
<TT>S1</TT>.
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S2</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>S0</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>S1</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>The inheritance mechanism will take each method <B>definition</B> from
its hosting species: from <TT>S0</TT> for <TT>m1</TT> and from <TT>S1</TT> for
<TT>m2</TT>. We have hence a configuration where <TT>m0</TT> calls <TT>m1</TT>
and <TT>m1</TT> calls <TT>m0</TT>, i.e. the two methods are now mutually
recursive although it was not the case where each of them was
<B>defined</B>.</P><P>To avoid this situation, we will say that a species is well-formed if
and only if, once inheritance is resolved, no method initially not
recursive turns to become recursive. The <FONT COLOR=purple>FoCaLize</FONT> compiler performs this
analysis and rejects any species that is not compliant to this
criterion. In the above example, an error would be raised, explaining
how the mutual recursion (the cycle of dependencies) appears,
i.e. from <TT>m1</TT> to <TT>m0</TT> (and implicitly back to <TT>m1</TT> from
<TT>m0</TT>).</P><P><FONT SIZE=2><TT>Species &#X2019;S2&#X2019; is not well-formed. Field
&#X2019;m1&#X2019; involves a non-declared recursion<BR>
for the following dependent fields: m1 -&gt; m0.
</TT></FONT><FONT SIZE=2>
</FONT></P><!--TOC subsubsection Def-dependencies on the representation-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc101">4.4.3.2</A>  Def-dependencies on the representation</H4><!--SEC END --><P>
<A NAME="def-dep-on-representation"></A>
<A NAME="@default122"></A>
As we previously said (c.f. <A HREF="#def-dependency">4.4.2.2</A>) def-dependencies on
the representation are not allowed in properties and theorems. The reason
comes from the need to create consistent species interfaces. Let&#X2019;s
consider the following species with the definitions:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Counter</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>representation</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>int</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>inc</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>) = </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> + 1 ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>theorem</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>inc_spec</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>inc</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) &gt;= </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> + 1</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2>proof</FONT><FONT SIZE=2> = ... ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>end</FONT><FONT SIZE=2> ;;</FONT></TD></TR>
</TABLE><P>The statement of <TT>inc_spec</TT> contains a def-dependency on the
representation since to type-check this statement, one need to know
that the representation is <TT>int</TT>. To create the species&#X2019;
interface, we must make the representation abstract, hence hiding the
fact that it is <TT>int</TT>. Without this information it it now
impossible to type-check <TT>inc_spec</TT> body since it
makes explicit reference to <TT>+</TT>, <TT>&lt;=</TT>, <TT>1</TT> that are
operations about <TT>int</TT>.</P><P>In practice, such an error is reported as a typechecking error telling
that <TT>representation</TT> &#X201C;is not compatible with type&#X201D; <TT>t</TT>
where <TT>t</TT> is the type expression that was assigned to the
representation (i.e. <TT>int</TT> in our example).
</P><!--TOC chapter The <FONT COLOR=purple>FoCaLize</FONT> Proof Language-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc102">Chapter 5</A>  The <FONT COLOR=purple>FoCaLize</FONT> Proof Language</H1><!--SEC END --><P>
<A NAME="making-proofs"></A>
</P><!--TOC section Proofs of theorems-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc103">5.1</A>  Proofs of theorems</H2><!--SEC END --><P>
As presented in <A HREF="#proof-short-intro">3.2.7.3</A>, <FONT COLOR=purple>FoCaLize</FONT> proposes 3 ways to
make proof of properties. We will only deal here with proofs written
in the <FONT COLOR=purple>FoCaLize</FONT> Proof Language. As a reminder, proofs written as
direct <FONT COLOR=purple>Coq</FONT> scripts will be addressed in <A HREF="#coq-proofs">9.0.6</A>. And the
last kind of proof, by <TT><FONT COLOR="red">assumed</FONT></TT> doesn&#X2019;t need anymore description
since it consists in bypassing the formal proof mechanism.</P><P>The syntax of proofs is as follows.
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="proof"><I><FONT COLOR=maroon>proof</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
{<A HREF="#proof-step"><I><FONT COLOR=maroon>proof-step</FONT></I></A>}<SUP>*</SUP>  <A HREF="#qed-step"><I><FONT COLOR=maroon>qed-step</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>by</FONT></TT> {<A HREF="#fact"><I><FONT COLOR=maroon>fact</FONT></I></A>}<SUP>+</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>conclude</FONT></TT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>coq proof</FONT></TT> <I><FONT COLOR=maroon>enforced-dependencies</FONT></I>  <I><FONT COLOR=maroon>external-code</FONT></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><FONT COLOR=maroon>enforced-dependencies</FONT></I> <TT><FONT COLOR=blue>assumed</FONT></TT>  <I><FONT COLOR=maroon>external-code</FONT></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>A proof is either a leaf proof or a compound proof. A leaf proof
(introduced with the <TT><FONT COLOR="red">by</FONT></TT> or <TT><FONT COLOR="red">conclude</FONT></TT> keywords)
invokes <FONT COLOR=purple>Zenon</FONT> with the
assumptions being the given facts and the goal being the goal of the
proof itself (i.e. the statement that is proved by this leaf proof).
See below for the kinds of facts that can be given.</P><P>The <TT><FONT COLOR="red">conclude</FONT></TT> keyword is used to invoke <FONT COLOR=purple>Zenon</FONT> without
assumptions.</P><P>A compound proof is a sequence of steps that ends with a <TT><FONT COLOR="red">qed</FONT></TT>
step. The goal of each step is stated in the step itself, except for
the <TT><FONT COLOR="red">qed</FONT></TT> step, which has the same goal as the enclosing
proof.</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="proof-step"><I><FONT COLOR=maroon>proof-step</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#proof-step-bullet"><I><FONT COLOR=maroon>proof-step-bullet</FONT></I></A>  <A HREF="#statement"><I><FONT COLOR=maroon>statement</FONT></I></A>  <A HREF="#proof"><I><FONT COLOR=maroon>proof</FONT></I></A></TD></TR>
</TABLE></TD></TR>
</TABLE><P>A proof step starts with a proof bullet, which gives its level of
nesting. The top level of a proof is 0. In a compound proof, the
steps are at level one plus the level of the proof itself.</P><P><BR>
For example, consider the following proof.</P><PRE CLASS="verbatim">  theorem foo : A -&gt; (B -&gt; A)
  proof =
    &lt;1&gt;1 assume h1: A,
         prove B -&gt; A
      &lt;2&gt;1 assume h2: B,
           prove A
        by hypothesis h1
      &lt;2&gt;2 qed
        by step &lt;2&gt;1
    &lt;1&gt;2 qed
      conclude
</PRE><P>In this proof, the steps <CODE>&lt;1&gt;1</CODE> and <CODE>&lt;1&gt;2</CODE> are at level 1
and form a compound proof of the top-level theorem. Step <CODE>&lt;1&gt;1</CODE>
also has a compound proof, composed of steps <CODE>&lt;2&gt;1</CODE>
and <CODE>&lt;2&gt;2</CODE>. These are at level 2 (one more than the level of
their enclosing step).</P><P>After the proof bullet comes the statement of the step. This is the
statement that is asserted and proved by this step. At the end of
this step&#X2019;s proof, it becomes available as a fact for the next steps
of this proof. In our example, step <CODE>&lt;2&gt;1</CODE> is available in the
proof of <CODE>&lt;2&gt;2</CODE>, and <CODE>&lt;1&gt;1</CODE> is available in the proof of
<CODE>&lt;1&gt;2</CODE>. Note that <CODE>&lt;2&gt;1</CODE> is not available in the proof of
<CODE>&lt;1&gt;2</CODE>: see section <A HREF="#sec:scoping">5.1.1</A> for the scoping rules.</P><P>After the statement is the proof of the step. See below (under
Statements) for a description of what is the current goal for this
proof.</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="qed-step"><I><FONT COLOR=maroon>qed-step</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#proof-step-bullet"><I><FONT COLOR=maroon>proof-step-bullet</FONT></I></A> <TT><FONT COLOR=blue> qed</FONT></TT>  <A HREF="#proof"><I><FONT COLOR=maroon>proof</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP><A HREF="#proof-step-bullet"><I><FONT COLOR=maroon>proof-step-bullet</FONT></I></A> <TT><FONT COLOR=blue> conclude</FONT></TT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>A <TT><FONT COLOR="red">qed</FONT></TT> step is similar to a normal step, except that its
statement is the goal of the enclosing proof. It may be reduced to
the word <TT><FONT COLOR="red">conclude</FONT></TT> when its proof is reduced to
<TT><FONT COLOR="red">conclude</FONT></TT>. In our example, we could have replaced
<CODE>&lt;1&gt;2</CODE> with:
</P><PRE CLASS="verbatim">    &lt;1&gt;2 conclude
</PRE><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="statement"><I><FONT COLOR=maroon>statement</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
{<TT><FONT COLOR=blue>assume</FONT></TT> <A HREF="#assumption"><I><FONT COLOR=maroon>assumption</FONT></I></A> <TT><FONT COLOR=blue>,</FONT></TT>}<SUP>*</SUP>
 [<TT><FONT COLOR=blue>prove</FONT></TT> <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A>]</TD></TR>
</TABLE></TD></TR>
</TABLE><P>A statement must be non-empty: at least one <TT><FONT COLOR="red">assume</FONT></TT> or the
<TT><FONT COLOR="red">prove</FONT></TT> part must be present.</P><P>A statement appearing in a step has two readings: internal and
external. The external reading is for the rest of the
proof: the current step proves that the assumptions imply the
conclusion (i.e. the <EM>logical-exp</EM> that appears after
<TT><FONT COLOR="red">prove</FONT></TT>). The internal reading is for the proof of the step:
the current goal is the <TT><FONT COLOR="red">prove</FONT></TT> expression, and the
assumptions are available as facts.</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="assumption"><I><FONT COLOR=maroon>assumption</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A> <TT><FONT COLOR=blue>in</FONT></TT>  <A HREF="#type-exp"><I><FONT COLOR=maroon>type-exp</FONT></I></A>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP><A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A> <TT><FONT COLOR=blue> :</FONT></TT>  <A HREF="#logical-exp"><I><FONT COLOR=maroon>logical-exp</FONT></I></A></TD></TR>
</TABLE></TD></TR>
</TABLE><P>An assumption can either introduce a new (universally quantified)
variable with its type (first form), or a new named hypothesis (second
form).</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<A NAME="fact"><I><FONT COLOR=maroon>fact</FONT></I></A> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<TT><FONT COLOR=blue>definition of</FONT></TT>
{[ [<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>] <TT><FONT COLOR=blue>#</FONT></TT> ]  <A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP>+</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>hypothesis</FONT></TT>
{<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP>+</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> (<TT><FONT COLOR=blue>property</FONT></TT> &#X2223;  <TT><FONT COLOR=blue>theorem</FONT></TT>)
{[[[[<A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>] <TT><FONT COLOR=blue>#</FONT></TT>]  <A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>]
<TT><FONT COLOR=blue>!</FONT></TT>]  <A HREF="#ident"><I><FONT COLOR=maroon>ident</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP>+</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <TT><FONT COLOR=blue>step</FONT></TT>
{<A HREF="#proof-step-bullet"><I><FONT COLOR=maroon>proof-step-bullet</FONT></I></A>}(<TT><FONT COLOR=blue>,</FONT></TT>)<SUP>+</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>A fact used in a leaf proof can be a definition, a hypothesis, a
property, a theorem, or a step.</P><P>Giving a definition as a fact allows <FONT COLOR=purple>Zenon</FONT> to unfold this
definition in the goal and in the other facts.</P><P>Giving a hypothesis/property/theorem as a fact allows <FONT COLOR=purple>Zenon</FONT> to use
this hypothesis/property/theorem to prove the goal.</P><P>Giving a <EM>proof-step-bullet</EM> as a fact allows <FONT COLOR=purple>Zenon</FONT> to use the
(external reading of the) corresponding step as an assumption to prove
the goal. Note that even if several steps are labelled with this
proof bullet, only one of them is in scope at any point, so there is
no ambiguity (see section <A HREF="#sec:scoping">5.1.1</A>).</P><!--TOC subsection Scoping rules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc104">5.1.1</A>  Scoping rules</H3><!--SEC END --><P><A NAME="sec:scoping"></A></P><P>The scope of a step bullet extends from the end of the proof of that
step to the end of the proof of the enclosing step (i.e. the end of
the proof of the <TT><FONT COLOR="red">qed</FONT></TT> step that has the same level as this
step). This means that proof bullets can be reused in other branches
of the proof to name different steps.</P><P>The scope of an assumption is the proof of the step where this
assumption appears.
</P><!--TOC chapter Recursive function definitions-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc105">Chapter 6</A>  Recursive function definitions</H1><!--SEC END --><P>
<A NAME="recursive-function"></A>
<A NAME="@default123"></A></P><P><A NAME="@default124"></A>
In the current alpha-release, the logical counterpart of recursive functions
is not completely handled (<FONT COLOR=purple>Coq</FONT> code generation). We are still working on the
point: recursive functions are planed to be fully supported as soon as
possible, in addition with new material to help writing the required termination
proofs.
</P><!--TOC chapter Compiler options-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc106">Chapter 7</A>  Compiler options</H1><!--SEC END --><P><A NAME="@default125"></A>
<A NAME="compiler-options"></A>
When invoking the <FONT COLOR=purple>FoCaLize</FONT> compiler with the <FONT COLOR=purple>focalizec</FONT> command,
various command line options can be provided. The compiler can process
several files in their order of apparition in the command line.
Several types of files are handled. By default, if no option is
specified, the default behaviour is of the compiler is:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
&#X201C;.ml&#X201D; and &#X201C;.mli&#X201D; files are compiled with the <FONT COLOR=purple>OCaml</FONT>
 compiler producing bytecode. It is possible to customise the
compiler code generation using the <TT>-ocaml-comp-mode</TT> option.
The version of <FONT COLOR=purple>OCaml</FONT> used is automatically selected from the
configuration options selected during <FONT COLOR=purple>FoCaLize</FONT>&#X2019;s
installation. The <FONT COLOR=purple>FoCaLize</FONT> standard library path is implicitly
passed to <FONT COLOR=purple>OCaml</FONT>.
</LI><LI CLASS="li-itemize">&#X201C;.v&#X201D; files are compiled with the <FONT COLOR=purple>Coq</FONT>compiler. The
version of <FONT COLOR=purple>Coq</FONT> used is automatically selected from the
configuration options selected during <FONT COLOR=purple>FoCaLize</FONT>&#X2019;s installation.
The <FONT COLOR=purple>FoCaLize</FONT> standard library path is implicitly passed to
<FONT COLOR=purple>Coq</FONT>.
</LI><LI CLASS="li-itemize">&#X201C;.zv&#X201D; files are compiled by <FONT COLOR=purple>Zenon</FONT> via <FONT COLOR=purple>zvtov</FONT>. The
generated &#X201C;.v&#X201D; file is then compiled by <FONT COLOR=purple>Coq</FONT> as describe
above.
</LI><LI CLASS="li-itemize">&#X201C;.fcl&#X201D; files are compiled by <FONT COLOR=purple>focalizec</FONT>, generating both
the &#X201C;.ml&#X201D; <FONT COLOR=purple>OCaml</FONT> source and the &#X201C;.zv&#X201D; pre-<FONT COLOR=purple>Coq</FONT>source. The
&#X201C;.ml&#X201D; file is then sent to <FONT COLOR=purple>OCaml</FONT>and the &#X201C;.zv&#X201D; file is sent
to <FONT COLOR=purple>Zenon</FONT>to finally get a &#X201C;.v&#X201D; file that is sent to <FONT COLOR=purple>Coq</FONT>.
</LI></UL><P>
It is possible to control the kind of files generated by
<FONT COLOR=purple>focalizec</FONT> (no <FONT COLOR=purple>Coq</FONT>, no <FONT COLOR=purple>OCaml</FONT>, &#X201C;.zv&#X201D;, &#X201C;.v&#X201D; using options
described bellow.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
* <B>&#X2212;</B><B>dot-non-rec-dependencies</B> <EM>directory name</EM>.
Dumps non-let-rec dependencies of the species present in the
compiled source file. The output format is suitable to be
graphically displayed by <FONT COLOR=purple>dotty</FONT> (free software available via the
<FONT COLOR=purple>graphviz</FONT> package). Each species will lead to a <FONT COLOR=purple>dotty</FONT> file into
the argument directory. Files are names by &#X201C;deps_&#X201D; + the source
file base name (i.e. without path and suffix) + the species name +
the suffix &#X201C;.dot&#X201D;.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>focalize-doc</B> Generates documentation. The
result file gets located in the same directory than the compiled
file, replacing the suffix &#X201C;.fcl&#X201D; by &#X201C;.fcd&#X201D;. This file contains
XML in plain ASCII text and need to be processed before being read.
Consult section <A HREF="#foc-doc">??</A> for more details.</LI><LI CLASS="li-itemize">* <B>&#X2013;</B><B>experimental</B> Reserved for development purpose.
Never use. Invoking the compiler with this option may trigger
unpredictable results.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>i</B>. Prints the interfaces of the species present in
the compiled source file. Result is sent to the standard output.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>I</B> <EM>directory name</EM>. Adds the specified
directory to the path list where to search for 
compilation units. Several &#X2212;I options can be used. The search order is
in the local directory, then in the standard library directory (unless the
&#X2212;no-stdlib-path option is used, see below), then in the
directories specified by the &#X2212;I options in their apparition
order on the command line.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>impose-termination-proof</B>. Make termination proofs
mandatory for recursive functions. If a recursive function doesn&#X2019;t
have its termination proof, then the field will be considered as
not fully defined and no collection will be built on the
species hosting the function. By default this option is not
enabled and if a recursive function does not have any termination
proof, a warning is printed during compilation when trying to make
a collection from this species.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>methods-history-to-text</B> <EM>directory
name</EM>. Dumps the methods&#X2019; inheritance history of the species
present in the compilation unit. The result is sent as plain text files
into the argument directory. For each method of each species a file
is generated wearing the name made of &#X201C;history_&#X201D; + the source
file base name (i.e. without path and suffix) + &#X201C;_&#X201D; + the
hosting species name + the suffix &#X201C;.txt&#X201D;.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>no-ansi-escape</B>. Disables ANSI escape sequences in
the error messages. By default, when an error is reported, bold,
italic, underline fonts are used to make easier reading the
message. Using this option removes all these text attributes and
may be used if your terminal doesn&#X2019;t support ANSI escape sequences
or, for example, if compiling under <FONT COLOR=purple>emacs</FONT>.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>no-coq-code</B>. Disables the <FONT COLOR=purple>Coq</FONT> code
generation. By default <FONT COLOR=purple>Coq</FONT> code is always generated.</LI><LI CLASS="li-itemize">* <B>&#X2013;</B><B>no-ocaml-code</B>. Disables the <FONT COLOR=purple>OCaml</FONT> code
generation. By default <FONT COLOR=purple>OCaml</FONT> code is always generated.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>no-stdlib-path</B>. Does not include the standard
library installation directory in the libraries search path. This
option is rarely useful and mostly dedicated to the
<FONT COLOR=purple>FoCaLize</FONT> compiler build process.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>ocaml-comp-mode</B> <EM>file name</EM>. Specifies the
<FONT COLOR=purple>OCaml</FONT> compiler code generation mode. This option is folowed by
a string that can be "byt" for bytecode compilation, "bin" for
native code compilation, or "both" for bytecode and native code
compilation. This option has no effect if <B>&#X2013;</B><B>no-ocaml-code</B>
is used.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>pretty</B> <EM>file name</EM>. (Undocumented: mostly for
debug purpose). Pretty-prints the parse tree of the <FONT COLOR=purple>FoCaLize</FONT> file
as a <FONT COLOR=purple>FoCaLize</FONT> source into the argument file.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>raw-ast-dump</B>. (Undocumented: mostly for debug
purpose). Prints on stderr the raw AST structure after parsing
stage.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>scoped_pretty</B> <EM>file name</EM>. (Undocumented:
mostly for debug purpose). Pretty-prints the parse tree of the
<FONT COLOR=purple>FoCaLize</FONT> file once scoped as a <FONT COLOR=purple>FoCaLize</FONT> source into the argument
file.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>stop-before-coq</B> When <FONT COLOR=purple>Coq</FONT> code generation is
activated, stops the compilation process before passing the
generated file to <FONT COLOR=purple>Coq</FONT>. The generated pre-<FONT COLOR=purple>Coq</FONT> source is sent to
<FONT COLOR=purple>Zenon</FONT> then the compilation process stops. The produced file is
hence ended by the suffix &#X201C;.v&#X201D;. This option has no effect if
<B>&#X2212;</B><B>no-coq-code</B> or <B>&#X2212;</B><B>stop-before-zenon</B> is used.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>stop-before-zenon</B>. When <FONT COLOR=purple>Coq</FONT> code generation is
activated, stops the compilation process before passing the
generated file to <FONT COLOR=purple>Zenon</FONT>. The produced file is then a pre-<FONT COLOR=purple>Coq</FONT>
 source file, ended by the suffix &#X201C;.zv&#X201D;. This option has no
effect if <B>&#X2212;</B><B>no-coq-code</B> is used.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>verbose</B>. Sets the compiler in verbose mode. It
will then generate the trace of the steps and operations is does
during the compilation. This feature is mostly used for debugging
purpose but can also explain the elaboration of the model during
compilation for people interested in <FONT COLOR=purple>FoCaLize</FONT>&#X2019;s compilation
process.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>v</B>. Prints the <FONT COLOR=purple>FoCaLize</FONT> version then exits.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>version</B>. Prints the full <FONT COLOR=purple>FoCaLize</FONT> version,
sub-version and release date, then exits.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>where</B>. Prints the binaries and libraries
installation directories then exits.</LI><LI CLASS="li-itemize">* <B>&#X2212;</B><B>help</B> <B>&#X2013;</B><B>help</B>. Prints the summary of command
line options (i.e. this documentation) on the standard output.
</LI></UL><!--TOC chapter Documentation generation-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc107">Chapter 8</A>  Documentation generation</H1><!--SEC END --><P>
<A NAME="documentation-generation"></A>
When invoked with the <TT>-</TT><TT>focalize-doc</TT> option, the command
<TT>focalizec</TT> generates an extra file (with the &#X201C;.fcd&#X201D; suffix)
containing &#X201C;documentation&#X201D; information extracted from the compiled
source file.</P><P>This information describes the different elements found in the source
file (species, collections, methods, toplevel definitions, type
definitions) with various annotations like type,
definition/inheritance locations. It also contains the special comments
previously called <B>annotations</B> (c.f <A HREF="#annotation">3.1.3</A>) and that
were kept during the compilation process. Moreover, these annotations
can contain special tags used by the documentation generator of
<FONT COLOR=purple>FoCaLize</FONT>.</P><!--TOC subsection Special tags-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc108">8.0.2</A>  Special tags</H3><!--SEC END --><P>
<FONT COLOR=purple>FoCaLize</FONT>&#X2019;s documentation system currently supports 5 kinds of
tags. They impact the content of the final generated document,
either in its content or in the way information is displayed depending
on the output format. These tags start with the &#X201C;@&#X201D; character and
the content of the tag follows until the end of the line. It is then
possible in an annodation to mix regular text that will not be
interpreted and tags.</P><!--TOC subsubsection @title-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc109">8.0.2.1</A>  @title</H4><!--SEC END --><P>
This tag must appear (i.e. is only taken into account) in the first
annotations block of the source file. The following text is considered
to be the title of the source file and will appear in the header of
the final document.</P><P>See example provided for the <TT>@description</TT> tag below.</P><!--TOC subsubsection @author-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc110">8.0.2.2</A>  @author</H4><!--SEC END --><P>
This tag must appear (i.e. is only taken into account) in the first
annotations block of the source file. The following text is considered
to be the author of the source file and will appear in the header of
the final document.</P><P>See example provided for the <TT>@description</TT> tag below.</P><!--TOC subsubsection @description-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc111">8.0.2.3</A>  @description</H4><!--SEC END --><P>
This tag must appear (i.e. is only taken into account) in the first
annotations block of the source file. The following text is considered
to be the description of the content of the source file (what services
it implements) and will appear in the header of the final document.</P><P>For example:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><EM><FONT SIZE=2>(***********************************************************************)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2><EM><FONT SIZE=2>(*                        FoCaL compiler                               *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2><EM><FONT SIZE=2>(*  Copyright 2007 LIP6 and INRIA                                      *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2><EM><FONT SIZE=2>(*  Distributed only by permission.                                    *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2><EM><FONT SIZE=2>(***********************************************************************)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2><EM><FONT SIZE=2>(**</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2> @title FoC Project. Basic algebra.</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2> @author The FoC project</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2> @description Basic sets operations, orderings and lattices.</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>*)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>...</FONT></TD></TR>
</TABLE><P>
will lead to a document header like (displayed in HTML format):</P><P><BR>
<IMG SRC="refman001.gif"></P><P>You may notice in the above source code example that the header
information is located in an annotation that is not the <B>first</B>
one. In effect, the top-most banner starting by
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><EM><FONT SIZE=2>(***********************************************************************)</FONT></EM></FONT></TD></TR>
</TABLE><P>
is in fact also an annotation since it starts by the sequence
&#X201C;(**&#X201D;. However all these annotation belong to the same annotations
block as requiered.</P><!--TOC subsubsection @mathml-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc112">8.0.2.4</A>  @mathml</H4><!--SEC END --><P>
This tag must appear in the document comment preceding a method
definition. It indicates the sequence of MathML code to use to replace
the name of the method everywhere in the current document. This tag
only affects the HTML display since it allows to show more usual
symbols rather than identifiers in a browser. This is expecially
useful for mathematical formulaes where one prefer to see the sign =
rather than an identifier &#X201C;<TT>equal</TT>&#X201D;.</P><P>For example:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><EM><FONT SIZE=2>(** In a setoid, we can test the equality (note for logicians: this is</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>   a congruence). *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>species</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Setoid</FONT><FONT SIZE=2> =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>inherit</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Basic_object</FONT><FONT SIZE=2>;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2><EM><FONT SIZE=2>(** @mathml &lt;eq/&gt; *)</FONT></EM></FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>signature</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2> -&gt; </FONT><FONT SIZE=2>bool</FONT><FONT SIZE=2> ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>property</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>equal_transitive</FONT><FONT SIZE=2> : </FONT><FONT SIZE=2>all</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>x</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>Self</FONT><FONT SIZE=2>,</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>    </FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>) -&gt; </FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>y</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>) -&gt; </FONT><FONT SIZE=2>equal</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>, </FONT><FONT SIZE=2>z</FONT><FONT SIZE=2>) ;</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT></TD></TR>
</TABLE><P>
will replace any occurrence of the method <TT>equal</TT> by the
&#X201C;<CODE>&lt;eq/&gt;</CODE>&#X201D; MathML sequence that displays a = sign when
displayed by an HTML browser.</P><P><BR>
<IMG SRC="refman002.gif"></P><!--TOC subsection Transforming the generated documentation file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc113">8.0.3</A>  Transforming the generated documentation file</H3><!--SEC END --><P>
The generated documentation file is a plain ASCII text containing some
XML compliant with <FONT COLOR=purple>FoCaLize</FONT>&#X2019;s DTD
(<TT>focalize/focalizec/src/docgen/focdoc.dtd</TT>). Like for any XML
files processing is performed thank to the command <FONT COLOR=purple>xsltproc</FONT> with
XSL stylesheets (&#X201C;.xsl&#X201D; files).</P><P>You may write custom XSL stylesheets to process this XML but the
distribution already provides 2 stylesheets to format this
information.</P><!--TOC subsubsection XML to HTML-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc114">8.0.3.1</A>  XML to HTML</H4><!--SEC END --><P>
Transformation from &#X201C;.fcd&#X201D; to a format that can be read by a WEB
browser is performed in two passes.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Convert the &#X201C;.fcl&#X201D; file to HTML with MathML annotations.
This is done applying the stylesheet
<TT>focalize/focalizec/src/docgen/focdoc2html.xsl</TT> with the command
<FONT COLOR=purple>xsltproc</FONT>.<P>For example:
</P><PRE CLASS="verbatim"><FONT SIZE=2>  xsltproc ''directory to the stylesheet''/focdoc2html.xsl mysrc.fcd &gt; tmp
  </FONT></PRE></LI><LI CLASS="li-enumerate">Convert the HTML+MathML temporary file into HTML.
This is done applying the stylesheet
<TT>focalize/focalizec/src/docgen/focdoc2html.xsl</TT> with the command
<FONT COLOR=purple>xsltproc</FONT>.<P>For example:
</P><PRE CLASS="verbatim"><FONT SIZE=2>  xsltproc ''directory to the stylesheet''/mmlctop2_0.xsl mysrc.fcd &gt; mysrc.xml
  </FONT></PRE><P>
<BR>
<B>Attention:</B>
You may note that the final result file name must be ended by the
suffix &#X201C;.xml&#X201D; otherwise your browser won&#X2019;t be able to interpret it
correctly and won&#X2019;t display symbols (&#X21D2;, &#X2208;, &#X2203;,
&#X2192;, &#X2026;) correctly.
</P></LI></OL><!--TOC subsection XML to LaTeX-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc115">8.0.4</A>  XML to LaTeX</H3><!--SEC END --><P>Currently not officially available.
</P><!--TOC chapter Hacking deeper-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc116">Chapter 9</A>  Hacking deeper</H1><!--SEC END --><!--TOC subsection Interfacing <FONT COLOR=purple>FoCaLize</FONT> with other languages-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc117">9.0.5</A>  Interfacing <FONT COLOR=purple>FoCaLize</FONT> with other languages</H3><!--SEC END --><P>
<A NAME="interfacing-other-languages"></A></P><!--TOC subsection Dealing with hand-written <FONT COLOR=purple>Coq</FONT> proofs-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc118">9.0.6</A>  Dealing with hand-written <FONT COLOR=purple>Coq</FONT> proofs</H3><!--SEC END --><P>
<A NAME="coq-proofs"></A>
<A NAME="focal-coq-mapping"></A>
</P><!--TOC chapter Compiler error messages-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc119">Chapter 10</A>  Compiler error messages</H1><!--SEC END --><P>
<A NAME="compiler-error-mesgs"></A>
</P><!--TOC section Unable to find file &#X2019;<I>name</I>&#X2019; in the search path.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Unable to find file &#X2019;<I>name</I>&#X2019; in the search path.</H2><!--SEC END --><P><EM>Description</EM>: The source file made reference to a <FONT COLOR=purple>FoCaLize</FONT>
compilation unit 
<I>name</I> (by the <TT>open</TT> or <TT>use</TT> directives, or by explicit
qualification with the &#X201C;#&#X201D; notation) but the related
<FONT COLOR=purple>FoCaLize</FONT> file was not found in the current libraries search
path.</P><P><EM>Hints</EM>: Locate in which directory the missing file is
and add this directory to the libraries search path with the <TT>-I</TT>
compiler option.</P><!--TOC section Invalid or corrupted compilation unit &#X2019;<I>name</I>&#X2019;. May be it
was compiled with another version of the compiler.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Invalid or corrupted compilation unit &#X2019;<I>name</I>&#X2019;. May be it
was compiled with another version of the compiler.</H2><!--SEC END --><P>
<EM>Description</EM>: The source file made reference to a <FONT COLOR=purple>FoCaLize</FONT>
compilation unit
<I>name</I> (by the <TT>open</TT> or <TT>use</TT> directives, or by explicit
qualification with the &#X201C;#&#X201D; notation but the related
<FONT COLOR=purple>FoCaLize</FONT>  file was found with an incorrect format.</P><P><EM>Hints</EM>: May be the compilation unit was compiled with another
version of <FONT COLOR=purple>FoCaLize</FONT> or was mangled and you must compile it again with
your current version.</P><!--TOC section Invalid file extension for &#X2019;<I>name</I>&#X2019;.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Invalid file extension for &#X2019;<I>name</I>&#X2019;.</H2><!--SEC END --><P>
<EM>Description</EM>: The <FONT COLOR=purple>FoCaLize</FONT> compiler expects compilation units to be
ended by the suffix &#X201C;.fcl&#X201D;, &#X201C;.ml&#X201D;, &#X201C;.mli&#X201D;, &#X201C;.zv&#X201D;or &#X201C;.v&#X201D;. If
the submitted input file doesn&#X2019;t end by one of these suffixes, this
error message arises with the name, <I>name</I> of the involved file.</P><P><EM>Hints</EM>: Change the extension of the input file name or ensure the
submitted input file name is the correct one.</P><!--TOC section System error - <I>sysmsg</I>.-->
<H2 CLASS="section"><!--SEC ANCHOR -->System error - <I>sysmsg</I>.</H2><!--SEC END --><P>
<EM>Description</EM>: During the compilation process an error related to
the operating system occurred (I/O error, permission error, file-system
error, &#X2026;). The original message <I>sysmsg</I> of the system explaining
the problem follows the <FONT COLOR=purple>FoCaLize</FONT>&#X2019;s message.</P><P><EM>Hints</EM>: Consult the original message of the system and get an
appropriate solution depending on this message.</P><!--TOC section Invalid OCaml compiler kind "<I>string</I>" for option -ocaml-comp-mode. Must be "byt", "bin" or "both".-->
<H2 CLASS="section"><!--SEC ANCHOR -->Invalid OCaml compiler kind "<I>string</I>" for option -ocaml-comp-mode. Must be "byt", "bin" or "both".</H2><!--SEC END --><P>
<EM>Description</EM>: By default, if some <FONT COLOR=purple>OCaml</FONT> code was generated, the
<FONT COLOR=purple>FoCaLize</FONT> compiler sends the generated code to the <FONT COLOR=purple>OCaml</FONT> compiler. The
default compilation mode is bytecode production. It is possible to
select the native code production using the option <TT>-ocaml-comp-mode</TT>
followed by the string &#X201C;bin&#X201D; or to select both code production modes
by the string &#X201C;both&#X201D;. The argument string &#X201C;byt&#X201D; is not required
since it is the default mode. Any other string is invalid and leads to
the present error message.</P><P><EM>Hints</EM>: Select &#X201C;byt&#X201D;, &#X201C;bin&#X201D; or &#X201C;both&#X201D; as argument to the
<TT>-ocaml-comp-mode</TT> option.</P><!--TOC section No input file. FoCaL is cowardly and gives up...-->
<H2 CLASS="section"><!--SEC ANCHOR -->No input file. FoCaL is cowardly and gives up...</H2><!--SEC END --><P>
<EM>Description</EM>: The <FONT COLOR=purple>FoCaLize</FONT> compiler needs one input file to
compile. If none is supplied, this error message arises.</P><P><EM>Hints</EM>: Add the input source file to compile on the command
line.</P><!--TOC section Lexical error <I>str</I>-->
<H2 CLASS="section"><!--SEC ANCHOR -->Lexical error <I>str</I></H2><!--SEC END --><P>
<EM>Description</EM>: In the currently submitted source file, a sequence
of characters is not recognised as legal according to the
<FONT COLOR=purple>FoCaLize</FONT> programming language legal words structure. The involved
character <I>str</I> follows in the error message.</P><P><EM>Hints</EM>: Change the source code at the indicated location.</P><!--TOC section Syntax error-->
<H2 CLASS="section"><!--SEC ANCHOR -->Syntax error</H2><!--SEC END --><P>
<EM>Description</EM>: In the currently submitted source file, a phrase of
the program doesn&#X2019;t follow <FONT COLOR=purple>FoCaLize</FONT>&#X2019;s syntax.</P><P><EM>Hints</EM>: Change the source code at the indicated location. It
sometimes happens that the location gets fuzzy due to the parsing
process. If the error is not immediate to you, explore the neighbours of
the specified location. If you still can&#X2019;t find out the error,
have the following emergency process: comment your code and
incrementally uncomment it to find the point where the error appears
without having to search in the whole file. Once the error appears,
have a look at the part of code you uncommented since the previous
successful compilation and try to guess the syntactic cause.</P><!--TOC section Unclear syntax error <I>msg</I>.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Unclear syntax error <I>msg</I>.</H2><!--SEC END --><P>
<EM>Description</EM>: An error occurred during the syntactic analysis but
was not reported to be due to a syntax non-compliance. This error is
not clearly identified and this message is displayed as post-mortem
report with the exception <I>msg</I> that caused the error.</P><P><EM>Hints</EM>: None</P><!--TOC section Compilation unit &#X2019;<I>m</I>&#X2019; was not declared as "use"-->
<H2 CLASS="section"><!--SEC ANCHOR -->Compilation unit &#X2019;<I>m</I>&#X2019; was not declared as "use"</H2><!--SEC END --><P>
<EM>Description</EM>: It not possible to use a qualified notation for a
compilation unit name (i.e. using an entity from this compilation unit
by explicitly specifying the unit with the &#X201C;#&#X201D;-notation) before this
compilation unit is declared &#X201C;use&#X201D; or &#X201C;open&#X201D;. This error message
indicates the location where an identifier refers to a compilation
unit that was not qualified either by the <TT>use</TT> or <TT>open</TT>
directive. Note that the <TT>open</TT> directive implicitly implies
<TT>use</TT>.</P><P><EM>Hints</EM>: Use the <TT>use</TT> directive on the compilation detected
unit.</P><!--TOC section Parameterised species expected <I>n</I><SUB>1</SUB> arguments but
was provided <I>n</I><SUB>2</SUB>.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Parameterised species expected <I>n</I><SUB>1</SUB> arguments but
was provided <I>n</I><SUB>2</SUB>.</H2><!--SEC END --><P>
<EM>Description</EM>: A species expression (used in species parameter
expression or <TT>inherit</TT> clause) applies a species with <I>n</I><SUB>1</SUB>
argument(s) although its definition declared it as using <I>n</I><SUB>2</SUB>
argument(s).</P><P><EM>Hints</EM>: None.</P><!--TOC section Non-logical let must not bind &#X2019;<I>ident</I>&#X2019; to a property.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Non-logical let must not bind &#X2019;<I>ident</I>&#X2019; to a property.</H2><!--SEC END --><P>
<EM>Description</EM>: A <TT>let</TT> construct (not a <TT>logical let</TT>)
attempts to bind the identifier <I>ident</I> to a logical expression
although it can only bind it to a computational expression.</P><P><EM>Hints</EM>: Source program to fix. May be the <TT>let</TT> should be
turned into a <TT>logical let</TT> if the body of the binding is really a
logical expression.</P><!--TOC section Delayed termination proof refers to an unknown method
&#X2019;<I>ident</I>&#X2019; of the species.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Delayed termination proof refers to an unknown method
&#X2019;<I>ident</I>&#X2019; of the species.</H2><!--SEC END --><P>
<EM>Description</EM>: A <TT>proof of</TT> clause was found in a species for
the property <I>ident</I> but this property was not found in the species.</P><P><EM>Hints</EM>: None.</P><!--TOC section Ambiguous logical expression. Add explicit parentheses to
associate the <I>side</I> argument of the <TT><FONT COLOR="red">/</FONT></TT><TT><FONT COLOR="red">\</FONT></TT> properly.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Ambiguous logical expression. Add explicit parentheses to
associate the <I>side</I> argument of the <TT><FONT COLOR="red">/</FONT></TT><TT><FONT COLOR="red">\</FONT></TT> properly.</H2><!--SEC END --><P>
<EM>Description</EM>: A logical expression contains a
<TT><FONT COLOR="red">/</FONT></TT><TT><FONT COLOR="red">\</FONT></TT> (logical &#X201C;and&#X201D;) with at least one argument being a
<TT><FONT COLOR="red">-&gt;</FONT></TT> (logical &#X201C;implication&#X201D;) or a <TT><FONT COLOR="red">&lt;-&gt;</FONT></TT> (logical
&#X201C;equivalence&#X201D;) without parentheses around the <I>side</I> argument (&#X201C;left&#X201D;
or &#X201C;right&#X201D;). Since this is not clear of how to associate, we ask
the user to explicitly add parentheses.</P><P><EM>Hints</EM>: Explicitly add the parentheses to make the association
non-ambiguous.</P><!--TOC section Ambiguous logical expression. Add explicit parentheses to
associate the <I>side</I> argument of the <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">/</FONT></TT> properly.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Ambiguous logical expression. Add explicit parentheses to
associate the <I>side</I> argument of the <TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">/</FONT></TT> properly.</H2><!--SEC END --><P>
<EM>Description</EM>: A logical expression contains a
<TT><FONT COLOR="red">\</FONT></TT><TT><FONT COLOR="red">/</FONT></TT> (logical &#X201C;or&#X201D;) with at least one argument being a
<TT><FONT COLOR="red">-&gt;</FONT></TT> (logical &#X201C;implication&#X201D;) or a <TT><FONT COLOR="red">&lt;-&gt;</FONT></TT> (logical
&#X201C;equivalence&#X201D;) without parentheses around the <I>side</I> argument (&#X201C;left&#X201D;
or &#X201C;right&#X201D;). Since this is not clear of how to associate, we ask
the user to explicitly add parentheses.</P><P><EM>Hints</EM>: Explicitly add the parentheses to make the association
non-ambiguous.</P><!--TOC section Unbound sum type value constructor &#X2019;<I>name</I>&#X2019;.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Unbound sum type value constructor &#X2019;<I>name</I>&#X2019;.</H2><!--SEC END --><P>
<EM>Description</EM>: An identifier representing a sum type value constructor
was not found among the available sum type definitions.</P><P><EM>Hints</EM>: Source program to fix. Since in core expressions
capitalized identifiers are considered as sum type value constructors,
may be you tried to use a capitalized name for one of your
variables. In this case, as any variables, make it starting with a
lowercase letter. Otherwise, may be your type definition is missing or
not reachable in the current scope (missing explicit qualification
with the &#X201C;#&#X201D; notation or <TT>open</TT> directive if your type
definition is hosted in another source file).</P><!--TOC section Unbound record type label &#X2019;<I>name</I>&#X2019;.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Unbound record type label &#X2019;<I>name</I>&#X2019;.</H2><!--SEC END --><P>
<EM>Description</EM>: An identifier representing a record type label
was not found among the available record type definitions.</P><P><EM>Hints</EM>: Source program to fix. May be your type definition is
missing or not reachable in the current scope (missing explicit
qualification with the &#X201C;#&#X201D; notation or <TT>open</TT> directive if your
type definition is hosted in another source file).</P><!--TOC section Unbound identifier &#X2019;<I>name</I>&#X2019;.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Unbound identifier &#X2019;<I>name</I>&#X2019;.</H2><!--SEC END --><P>
<EM>Description</EM>: An identifier (expected to be bound by a <TT>let</TT>,
a pattern of a function parameter declaration) was not found.</P><P><EM>Hints</EM>: Source program to fix. May be your definition should be
toplevel and is missing or not reachable in the current scope (missing
explicit qualification with the &#X201C;#&#X201D; notation or <TT>open</TT>
directive if your definition is hosted in another source file).</P><!--TOC section Unbound type &#X2019;<I>name</I>&#X2019;.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Unbound type &#X2019;<I>name</I>&#X2019;.</H2><!--SEC END --><P>
<EM>Description</EM>: The definition of an identifier expected to be a
type constructor was not found.</P><P>May be your type definition is missing or not reachable in the current
scope (missing explicit qualification with the &#X201C;#&#X201D; notation or
<TT>open</TT> directive if your type definition is hosted in another
source file).</P><!--TOC section Unbound compilation unit &#X2019;<I>name</I>&#X2019;.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Unbound compilation unit &#X2019;<I>name</I>&#X2019;.</H2><!--SEC END --><P> <EM>Description</EM>: A
<TT>open</TT> or <TT>use</TT> directive or an explicit qualification by the
&#X201C;#&#X201D; notation makes reference to a compilation unit that was not
found in the current libraries search path.</P><P><EM>Hints</EM>: Locate in which directory the missing file is
and add this directory to the libraries search path with the <TT>-I</TT>
compiler option.</P><!--TOC section Unbound species &#X2019;<I>name</I>&#X2019;.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Unbound species &#X2019;<I>name</I>&#X2019;.</H2><!--SEC END --><P>
<EM>Description</EM>: The definition of the species <I>name</I> was not found
in the current scope.</P><P><EM>Hints</EM>: May be your species definition is missing or not
reachable in the current scope (missing explicit qualification with
the &#X201C;#&#X201D; notation or <TT>open</TT> directive if your species definition is
hosted in another source file).</P><!--TOC section Type name &#X2019;<I>name</I>&#X2019; already bound in the current scope.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Type name &#X2019;<I>name</I>&#X2019; already bound in the current scope.</H2><!--SEC END --><P>
<EM>Description</EM>: In a source file it is not allowed to redefine a
type definition. This means that each type name definition must be
unique inside a file. However, it is possible to have several type
definitions with the same names as long as they are in different
source files (even if they are used together via <TT>open</TT> directives
of explicit qualification by the &#X201C;#&#X201D; notation).</P><P><EM>Hints</EM>: None.</P><!--TOC section Species name &#X2019;<I>name</I>&#X2019; already bound in the current scope.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Species name &#X2019;<I>name</I>&#X2019; already bound in the current scope.</H2><!--SEC END --><P>
<EM>Description</EM>: In a source file it is not allowed to redefine a
species definition. This means that each species name definition must
be unique inside a file. However, it is possible to have several species
definitions with the same names as long as they are in different
source files (even if they are used together via <TT>open</TT> directives
of explicit qualification by the &#X201C;#&#X201D; notation).</P><P><EM>Hints</EM>: None.</P><!--TOC section Types <I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB> are not compatible.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Types <I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB> are not compatible.</H2><!--SEC END --><P>
<EM>Description</EM>: The typechecking system detected a type conflict
between two expressions <I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB> that were expected to be
type-compatible.</P><P><EM>Hints</EM>: Source program to fix. This is mostly due to an attempt
to use the type of a <TT>representation</TT> although it is turned
abstracted by the collection or parametrisation mechanisms. In this
case, ensure that you are not trying to make assumptions on the type
of a collection parameter or a collection.</P><!--TOC section Type <I>t</I><SUB>1</SUB> occurs in <I>t</I><SUB>2</SUB> and would lead to a cycle.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Type <I>t</I><SUB>1</SUB> occurs in <I>t</I><SUB>2</SUB> and would lead to a cycle.</H2><!--SEC END --><P>
<EM>Description</EM>: The <FONT COLOR=purple>FoCaLize</FONT> type system does not allow cyclic
types. This especially means that a type expression must not be a
sub-part of itself to prevent cycles.</P><P><EM>Hints</EM>: None.</P><!--TOC section Type constructor &#X2019;<I>name</I>&#X2019; used with conflicting arities:
<I>n</I><SUB>1</SUB> and <I>n</I><SUB>2</SUB>.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Type constructor &#X2019;<I>name</I>&#X2019; used with conflicting arities:
<I>n</I><SUB>1</SUB> and <I>n</I><SUB>2</SUB>.</H2><!--SEC END --><P>
<EM>Description</EM>: A type expression applies a type constructor <I>name</I>
to <I>n</I><SUB>1</SUB> argument(s) although its definition declared it as using <I>n</I><SUB>2</SUB>
argument(s) (or in the other order, depending on the way the error was
detected: in any way the definition and the usage of the type involve
2 different numbers of arguments).</P><P><EM>Hints</EM>: None.</P><!--TOC section No expected argument(s).-->
<H2 CLASS="section"><!--SEC ANCHOR -->No expected argument(s).</H2><!--SEC END --><P>
<EM>Description</EM>: A type expression applies a type constructor to
arguments although this constructor needs none.</P><P><EM>Hints</EM>: None.</P><!--TOC section In method &#X2019;<I>name</I>&#X2019;, type scheme <I>sch</I> contains free variables.-->
<H2 CLASS="section"><!--SEC ANCHOR -->In method &#X2019;<I>name</I>&#X2019;, type scheme <I>sch</I> contains free variables.</H2><!--SEC END --><P><EM>Description</EM>: As presented in <A HREF="#no-polymorphism-for-methods">4.1.2</A>,
species methods cannot be polymorphic. The method <I>name</I> has a
type scheme shown by <I>sch</I> which is polymorphic. </P><P><EM>Hints</EM>: You may explicitly add type
annotations (constraints) on the arguments or/and return type of your
method definition. If you need some kind of such polymorphism, use the
collection parameter mechanism. </P><!--TOC section Sum type value constructor &#X2019;<I>name</I>&#X2019; expected <I>n</I><SUB>1</SUB> arguments but
was used with <I>n</I><SUB>2</SUB> arguments.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Sum type value constructor &#X2019;<I>name</I>&#X2019; expected <I>n</I><SUB>1</SUB> arguments but
was used with <I>n</I><SUB>2</SUB> arguments.</H2><!--SEC END --><P><EM>Description</EM>: The sum type constructor <I>name</I> is used with a bad
number of arguments. It was declared to use <I>n</I><SUB>1</SUB> arguments but is
used with <I>n</I><SUB>2</SUB>.</P><P><EM>Hints</EM>: None.</P><!--TOC section Unbound type variable <I>name</I>.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Unbound type variable <I>name</I>.</H2><!--SEC END --><P><EM>Description</EM>: In a type expression, a type variable <I>name</I> is not
bound.</P><P><EM>Hints</EM>: Source program to fix. May be the type expression appears
in a parametrised type definition where you forgot to specify the type
constructor&#X2019;s parameter in head of the definition.</P><!--TOC section Method &#X2019;<I>mname</I>&#X2019; multiply defined in species &#X2019;<I>sname</I>&#X2019;.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Method &#X2019;<I>mname</I>&#X2019; multiply defined in species &#X2019;<I>sname</I>&#X2019;.</H2><!--SEC END --><P><EM>Description</EM>: Like for toplevel definitions, method definitions
inside a species must not bind several times the same name. In the
species <I>sname</I>, the method <I>mname</I> is defined several times.</P><P><EM>Hints</EM>: Source program to fix. May be you defined several times
the same method and in this case, remove one of the definitions. Or if
the different occurrences of <I>mname</I> refer to different conceptual
functions, change the names to make them different.</P><!--TOC section Delayed proof of &#X2019;<I>name</I>&#X2019; was found several times in the
species. Other occurrence is at: <I>loc</I>.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Delayed proof of &#X2019;<I>name</I>&#X2019; was found several times in the
species. Other occurrence is at: <I>loc</I>.</H2><!--SEC END --><P><EM>Description</EM>: A delayed proof of the property <I>name</I> was found
several times in the same species (i.e. not via inheritance but
directly in the species body). Only one must be kept.</P><P><EM>Hints</EM>: None.</P><!--TOC section In species &#X2019;<I>sname</I>&#X2019;, proof of &#X2019;<I>pname</I>&#X2019; is not related to
an existing property.-->
<H2 CLASS="section"><!--SEC ANCHOR -->In species &#X2019;<I>sname</I>&#X2019;, proof of &#X2019;<I>pname</I>&#X2019; is not related to
an existing property.</H2><!--SEC END --><P><EM>Description</EM>: In the species <I>sname</I> a delayed proof of the
property <I>pname</I> was found but the statement of this property doesn&#X2019;t
exist in the current species even via inheritance.</P><P><EM>Hints</EM>: May be you forgot to write the property, or you mistook
on the property name the proof is related to or you forgot to inherit
from a species having this property.</P><!--TOC section Representation is multiply defined.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Representation is multiply defined.</H2><!--SEC END --><P><EM>Description</EM>: In a species, the method <TT>representation</TT> is
multiply defined in the body of the species although at most one
definition must be provided.</P><P><EM>Hints</EM>: Source program to fix. Remove the spurious definitions.</P><P>If the <TT>representation</TT> method is not directly present in the
body, that is because the species inherits from a parent where the
representation is already defined. In this last case, since the parent&#X2019;s
structure is already established, you must remove the <TT>representation</TT> method
in the species where the error was reported.</P><!--TOC section Representation is multiply defined by multiple
inheritance and was formerly found of type <I>t</I><SUB>1</SUB> and newly found of
type <I>t</I><SUB>2</SUB>.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Representation is multiply defined by multiple
inheritance and was formerly found of type <I>t</I><SUB>1</SUB> and newly found of
type <I>t</I><SUB>2</SUB>.</H2><!--SEC END --><P><EM>Description</EM>: In the species, several parents brought by
inheritance several incompatible definitions of the representation. The error message reports <I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB>, two incompatible
types found for the representation definition.</P><P><EM>Hints</EM>: None.</P><!--TOC section &#X2019;Self&#X2019; can&#X2019;t be parametrised by itself.-->
<H2 CLASS="section"><!--SEC ANCHOR -->&#X2019;Self&#X2019; can&#X2019;t be parametrised by itself.</H2><!--SEC END --><P><EM>Description</EM>: This error appears when <TT>Self</TT> appears as a
species identifier used in a species expression that is a parameter of
the current defined species.</P><P><EM>Hints</EM>: None.</P><!--TOC section A "is" parameter can only be instantiated by an identifier of a collection.-->
<H2 CLASS="section"><!--SEC ANCHOR -->A "is" parameter can only be instantiated by an identifier of a collection.</H2><!--SEC END --><P><EM>Description</EM>: In a species expression, a parametrised species by
an entity parameter (<TT>is</TT>-parameter) is provided an effective
argument that is not a collection identifier.</P><P><EM>Hints</EM>: None.</P><!--TOC section Collection &#X2019;<I>s</I><SUB>1</SUB>&#X2019; is not compatible with &#X2019;<I>s</I><SUB>2</SUB>&#X2019;. In method
&#X2019;<I>name</I>&#X2019;, types <I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB> are not compatible.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Collection &#X2019;<I>s</I><SUB>1</SUB>&#X2019; is not compatible with &#X2019;<I>s</I><SUB>2</SUB>&#X2019;. In method
&#X2019;<I>name</I>&#X2019;, types <I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB> are not compatible.</H2><!--SEC END --><P><EM>Description</EM>: During collection parameter instantiation, the
interface of the provided collection <I>s</I><SUB>1</SUB> is not compatible with the
interface <I>s</I><SUB>2</SUB>, because it doesn&#X2019;t have a signature containing at
least <I>s</I><SUB>2</SUB>&#X2019;s methods with compatibles types. The wrong field <I>name</I>
is reported with the two types <I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB> expected and actually
found.</P><P><EM>Hints</EM>: None.</P><!--TOC section Collection &#X2019;<I>s</I><SUB>1</SUB>&#X2019; is not compatible with &#X2019;<I>s</I><SUB>2</SUB>&#X2019;. In method
&#X2019;<I>fname</I>&#X2019;, type <I>t</I><SUB>1</SUB> occurs in <I>t</I><SUB>2</SUB> and would lead to a cycle.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Collection &#X2019;<I>s</I><SUB>1</SUB>&#X2019; is not compatible with &#X2019;<I>s</I><SUB>2</SUB>&#X2019;. In method
&#X2019;<I>fname</I>&#X2019;, type <I>t</I><SUB>1</SUB> occurs in <I>t</I><SUB>2</SUB> and would lead to a cycle.</H2><!--SEC END --><P><EM>Description</EM>: During collection parameter instantiation, the
interface of the 
provided collection <I>s</I><SUB>1</SUB> is not compatible with the interface <I>s</I><SUB>2</SUB>, since type compatibility check detected a cyclic
type. This means that the type <I>t</I><SUB>1</SUB> is a sub-part of itself via the
type <I>t</I><SUB>2</SUB>.</P><P><EM>Hints</EM>: None.</P><!--TOC section Collection &#X2019;<I>s</I><SUB>1</SUB>&#X2019; is not compatible with &#X2019;<I>s</I><SUB>2</SUB>&#X2019;. In method
&#X2019;<I>fname</I>&#X2019;, the type constructor &#X2019;<I>tname</I>&#X2019; is used with the different
arities <I>n</I><SUB>1</SUB> and <I>n</I><SUB>2</SUB>.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Collection &#X2019;<I>s</I><SUB>1</SUB>&#X2019; is not compatible with &#X2019;<I>s</I><SUB>2</SUB>&#X2019;. In method
&#X2019;<I>fname</I>&#X2019;, the type constructor &#X2019;<I>tname</I>&#X2019; is used with the different
arities <I>n</I><SUB>1</SUB> and <I>n</I><SUB>2</SUB>.</H2><!--SEC END --><P><EM>Description</EM>: During collection parameter instantiation, the
interface of the 
provided collection <I>s</I><SUB>1</SUB> is not compatible with the interface <I>s</I><SUB>2</SUB>, since the type constructor (not sum type constructor)
<I>tname</I> is used with an improper number of arguments <I>n</I><SUB>1</SUB> versus
<I>n</I><SUB>2</SUB>.</P><P><EM>Hints</EM>: None.</P><!--TOC section Collection &#X2019;<I>s</I><SUB>1</SUB>&#X2019; is not compatible with &#X2019;<I>s</I><SUB>2</SUB>&#X2019;. Method &#X2019;<I>name</I>&#X2019;
is not present in &#X2019;<I>s</I><SUB>1</SUB>&#X2019;.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Collection &#X2019;<I>s</I><SUB>1</SUB>&#X2019; is not compatible with &#X2019;<I>s</I><SUB>2</SUB>&#X2019;. Method &#X2019;<I>name</I>&#X2019;
is not present in &#X2019;<I>s</I><SUB>1</SUB>&#X2019;.</H2><!--SEC END --><P><EM>Description</EM>: During collection parameter instantiation, the
interface of the 
provided collection <I>s</I><SUB>1</SUB> is not compatible with the interface <I>s</I><SUB>2</SUB>,
because it doesn&#X2019;t have a signature containing at
least <I>s</I><SUB>2</SUB>&#X2019;s methods and especially not the method <I>name</I>.</P><P><EM>Hints</EM>: None.</P><!--TOC section Parameterised species is applied to <I>n</I> arguments.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Parameterised species is applied to <I>n</I> arguments.</H2><!--SEC END --><P><EM>Description</EM>: A parameterised species is applied to a wrong
number <I>n</I> of effective arguments.</P><P><EM>Hints</EM>: None.</P><!--TOC section Species &#X2019;<I>sname</I>&#X2019; cannot be turned into a collection. Method
&#X2019;<I>fname</I>&#X2019; is not defined.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Species &#X2019;<I>sname</I>&#X2019; cannot be turned into a collection. Method
&#X2019;<I>fname</I>&#X2019; is not defined.</H2><!--SEC END --><P><EM>Description</EM>: A collection is built out of a completely defined species
(c.f. <A HREF="#collection">4.1.5</A>), i.e. a species where <B>all</B> the methods
are <B>defined</B> and not only declared. In the species <I>sname</I>, the
method <I>mname</I> is only declared, hence the species is not complete and
no collection can be extracted from it.</P><P><EM>Hints</EM>: Add an effective definition of the method, either by
writing it code or by inheritance, according to your program model.</P><!--TOC section Species &#X2019;<I>sname</I>&#X2019; cannot be turned into a collection. Method
&#X2019;<I>fname</I>&#X2019; does not have a termination proof.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Species &#X2019;<I>sname</I>&#X2019; cannot be turned into a collection. Method
&#X2019;<I>fname</I>&#X2019; does not have a termination proof.</H2><!--SEC END --><P><EM>Description</EM>: A collection is built out of a completely defined species
(c.f. <A HREF="#collection">4.1.5</A>), i.e. a species where <B>all</B> the methods
are <B>defined</B> and in particular proofs of properties are
done. This also applies to recursive functions which must have a
termination proof provided. The recursive function <I>fname</I> of the
species <I>sname</I> doesn&#X2019;t have its termination proof.</P><P>This error message only arises if the <TT>-impose-termination-proof</TT>
option is used on the command line. Otherwise, it is turned into a
warning and the compiler will automatically generate an assumed
proof.</P><P><EM>Hints</EM>: Add an effective termination proof to the function or do
not invoke the <TT>-impose-termination-proof</TT> option when compiling
the source file.</P><!--TOC section In the delayed termination proof, parameter &#X2019;<I>name</I>&#X2019; does
not refer to a parameter of the original function.-->
<H2 CLASS="section"><!--SEC ANCHOR -->In the delayed termination proof, parameter &#X2019;<I>name</I>&#X2019; does
not refer to a parameter of the original function.</H2><!--SEC END --><P><EM>Description</EM>: As any proof, termination proofs can be made later
after the function definition. However it must refer to the original
function&#X2019;s parameters names. In the current proof, the identifier
<I>name</I> doesn&#X2019;t exist among the original function&#X2019;s parameters.</P><P><EM>Hints</EM>: Change the parameter name in the proof to make it
matching the function definition&#X2019;s ones.</P><!--TOC section Method &#X2019;<I>mname</I>&#X2019; was found with incompatible types during
inheritance. In species &#X2019;<I>s</I><SUB>1</SUB>&#X2019;: &#X3C4;<SUB>1</SUB>, in species &#X2019;<I>s</I><SUB>2</SUB>&#X2019;:
&#X3C4;<SUB>2</SUB>.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Method &#X2019;<I>mname</I>&#X2019; was found with incompatible types during
inheritance. In species &#X2019;<I>s</I><SUB>1</SUB>&#X2019;: &#X3C4;<SUB>1</SUB>, in species &#X2019;<I>s</I><SUB>2</SUB>&#X2019;:
&#X3C4;<SUB>2</SUB>.</H2><!--SEC END --><P><EM>Description</EM>: During inheritance, a method <I>nmane</I> was found with
2 incompatible types. Remind that all along the inheritance tree,
methods must not change their type. The two found types and the
species hosting the definitions having these types are provided by
&#X2019;<I>s</I><SUB>1</SUB>&#X2019;and &#X3C4;<SUB>1</SUB> (resp. &#X2019;<I>s</I><SUB>2</SUB>&#X2019;and &#X3C4;<SUB>2</SUB>).</P><P><EM>Hints</EM>: None.</P><!--TOC section Logical method &#X2019;<I>mname</I>&#X2019; appearing in species &#X2019;<I>s</I><SUB>1</SUB>&#X2019; should
have the same statement than in species &#X2019;<I>s</I><SUB>2</SUB>&#X2019; at
<I>source</I>&#X2212;<I>location</I>.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Logical method &#X2019;<I>mname</I>&#X2019; appearing in species &#X2019;<I>s</I><SUB>1</SUB>&#X2019; should
have the same statement than in species &#X2019;<I>s</I><SUB>2</SUB>&#X2019; at
<I>source</I>&#X2212;<I>location</I>.</H2><!--SEC END --><P><EM>Description</EM>: During inheritance, a theorem or a property <I>nmane</I>
was redefined but with a different statement. As described at the
beginning of <A HREF="#inheritance">4.3.1</A>, the inheritance mechanism also allows
to redefine methods already existing as long as they keep the same
type expression. For theorems to have the same type is simply to have
the same statement. A same property can be written in several
semantically equivalent ways. For instance, transitivity of an
operation &#X2299; can be written by:
&#X2200; <I>x</I>, <I>y</I>, <I>z</I> &#X2208; <I>S</I>, <I>x</I> &#X2299; <I>y</I> &#X21D2; <I>y</I> &#X2299; <I>z</I> &#X21D2;
<I>x</I> &#X2299; <I>z</I>
or
&#X2200; <I>x</I>, <I>y</I>, <I>z</I> &#X2208; <I>S</I>, (<I>x</I> &#X2299; <I>y</I> &#X2227; <I>y</I> &#X2299; <I>z</I>) &#X21D2;
<I>x</I> &#X2299; <I>z</I>.
<FONT COLOR=purple>FoCaLize</FONT> does not try to establish the equality of these two
expressions. It only compares syntactically the statements modulo
variables renaming (i.e. &#X3B1;-conversion) and non-significant
parentheses.</P><P><EM>Hints</EM>: The simplest way is to rewrite the logical statement of
the inheriting species as it was written in the inherited species.</P><!--TOC section Definition &#X2019;<I>name</I>&#X2019; is considered as both logical and
non-logical.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Definition &#X2019;<I>name</I>&#X2019; is considered as both logical and
non-logical.</H2><!--SEC END --><P><EM>Description</EM>: In the inheritance tree of the current species, a
method <I>name</I> was previously found a &#X201C;logical&#X201D; and is now found no
more &#X201C;logical&#X201D;.</P><P><EM>Hints</EM>: Ensure that you did not define 2 methods with the same
name but for different purposes (one to help in stating logical
expressions and the other for your computational behaviour).</P><!--TOC section Species &#X2019;sname&#X2019; is not well-formed. Method &#X2019;<I>name</I>&#X2019; involves
a non-declared recursion for the following dependent methods: &#X2026;-->
<H2 CLASS="section"><!--SEC ANCHOR -->Species &#X2019;sname&#X2019; is not well-formed. Method &#X2019;<I>name</I>&#X2019; involves
a non-declared recursion for the following dependent methods: &#X2026;</H2><!--SEC END --><P><EM>Description</EM>: The species <I>sname</I> doesn&#X2019;t respect the
well-formation rule presented in <A HREF="#well-formation">4.4.3.1</A>. The chain of
functions involved in the cycle is given in the error message as a
sequence of methods names
<I>m</I><SUB>1</SUB> &#X2192; <I>m</I><SUB>2</SUB> &#X2192; &#X2026; &#X2192; <I>m</I><SUB><I>n</I></SUB> with the
implicit final path <I>m</I><SUB><I>n</I></SUB> &#X2192; <I>m</I><SUB>1</SUB>.</P><P><EM>Hints</EM>: None.</P><!--TOC section No <I>lang</I> mapping given for the external value definition
&#X2019;<I>name</I>&#X2019;.-->
<H2 CLASS="section"><!--SEC ANCHOR -->No <I>lang</I> mapping given for the external value definition
&#X2019;<I>name</I>&#X2019;.</H2><!--SEC END --><P><EM>Description</EM>: The external value definition allowing to link
<FONT COLOR=purple>FoCaLize</FONT> code to foreign languages doesn&#X2019;t specify how to map the value
identifier <I>name</I> in the language <I>lang</I>.</P><P><EM>Hints</EM>: Supply a binding for this language in the external
definition.</P><!--TOC section No <I>lang</I> mapping given for the external type definition
&#X2019;<I>name</I>&#X2019;.-->
<H2 CLASS="section"><!--SEC ANCHOR -->No <I>lang</I> mapping given for the external type definition
&#X2019;<I>name</I>&#X2019;.</H2><!--SEC END --><P><EM>Description</EM>: The external type definition allowing to link
<FONT COLOR=purple>FoCaLize</FONT> code to foreign languages doesn&#X2019;t specify how to map the type
identifier <I>name</I> in the language <I>lang</I>.</P><P><EM>Hints</EM>: Supply a binding for this language in the external
definition.</P><!--TOC section No <I>lang</I> mapping given for the external sum type value
constructor &#X2019;<I>name</I>&#X2019;.-->
<H2 CLASS="section"><!--SEC ANCHOR -->No <I>lang</I> mapping given for the external sum type value
constructor &#X2019;<I>name</I>&#X2019;.</H2><!--SEC END --><P><EM>Description</EM>: The external sum type definition allowing to link
<FONT COLOR=purple>FoCaLize</FONT> code to foreign languages doesn&#X2019;t specify how to map the sum
type constructor <I>name</I> in the language <I>lang</I>.</P><P><EM>Hints</EM>: Supply a binding for this language in the external
definition.</P><!--TOC section No <I>lang</I> mapping given for the external record field
&#X2019;<I>name</I>&#X2019;.-->
<H2 CLASS="section"><!--SEC ANCHOR -->No <I>lang</I> mapping given for the external record field
&#X2019;<I>name</I>&#X2019;.</H2><!--SEC END --><P><EM>Description</EM>: The external record type definition allowing to
link <FONT COLOR=purple>FoCaLize</FONT> code to foreign languages doesn&#X2019;t specify how to map the
record field <I>name</I> in the language <I>lang</I>.</P><P><EM>Hints</EM>: Supply a binding for this language in the external
definition.</P><!--TOC section Unable to find OCaml generation information for compiled
file &#X2019;<I>file</I>&#X2019;. Compilation unit may have been compiled without OCaml code
generation enabled.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Unable to find OCaml generation information for compiled
file &#X2019;<I>file</I>&#X2019;. Compilation unit may have been compiled without OCaml code
generation enabled.</H2><!--SEC END --><P><EM>Description</EM>: The <FONT COLOR=purple>FoCaLize</FONT> compilation unit file <I>file</I>.fcl was compiled but
the object file doesn&#X2019;t contain information about <FONT COLOR=purple>OCaml</FONT> code
generation. The <FONT COLOR=purple>FoCaLize</FONT> compiler allows to disable the <FONT COLOR=purple>OCaml</FONT> code
production by the <TT>--no-ocaml-code</TT> option. May be this option was used.</P><P><EM>Hints</EM>: Invoke the compiler on the source file <I>file</I>.fcl without
the <TT>--no-ocaml-code</TT> option.</P><!--TOC section Record type definition contains a mutable field &#X2019;<I>name</I>&#X2019; that can&#X2019;t
be compiled to Coq.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Record type definition contains a mutable field &#X2019;<I>name</I>&#X2019; that can&#X2019;t
be compiled to Coq.</H2><!--SEC END --><P><EM>Description</EM>: <FONT COLOR="red"> Never raised in the current version
since mutable record fields are not yet available</FONT>.</P><!--TOC section Unable to find Coq generation information for compiled file
&#X2019;<I>file</I>&#X2019;. Compilation unit may have been compiled without Coq code
generation enabled.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Unable to find Coq generation information for compiled file
&#X2019;<I>file</I>&#X2019;. Compilation unit may have been compiled without Coq code
generation enabled.</H2><!--SEC END --><P><EM>Description</EM>: The <FONT COLOR=purple>FoCaLize</FONT> compilation unit <I>file</I>.fcl was
compiled but the object file doesn&#X2019;t contain information about <FONT COLOR=purple>Coq</FONT>
code generation. The <FONT COLOR=purple>FoCaLize</FONT> compiler allows to disable the <FONT COLOR=purple>Coq</FONT> code
production by the <TT>--no-coq-code</TT> option. May be this option was
used.</P><P><EM>Hints</EM>: Invoke the compiler on the source file <I>file</I>.fcl without
the <TT>--no-coq-code</TT> option.</P><!--TOC section Using a collection parameter&#X2019;s method (<I>name</I>) in a Zenon proof
with "by definition" is not allowed.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Using a collection parameter&#X2019;s method (<I>name</I>) in a Zenon proof
with "by definition" is not allowed.</H2><!--SEC END --><P><EM>Description</EM>: The current proof tries to used the definition of a
method <I>name</I> of a species parameter. Since species parameters are
always abstracted, <B>definitions</B> (i.e. &#X201C;bodies&#X201D;) of their methods
are <B>not</B> available in the parametrised species. For this reason,
it is impossible to provide this definition to <FONT COLOR=purple>Zenon</FONT>.</P><P><EM>Hints</EM>: None.</P><!--TOC section Using an only declared method of Self (<I>name</I>) in a Zenon
proof with "by definition" is not allowed.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Using an only declared method of Self (<I>name</I>) in a Zenon
proof with "by definition" is not allowed.</H2><!--SEC END --><P><EM>Description</EM>: The current proof tries to used the definition of a
method <I>name</I> <B>only declared</B> in the current species. Since the
definition is not available, it is impossible to provide it to
<FONT COLOR=purple>Zenon</FONT>.</P><P><EM>Hints</EM>: None.</P><!--TOC section Using a local identifier (<I>name</I>) in a Zenon proof with "by
definition" is not allowed.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Using a local identifier (<I>name</I>) in a Zenon proof with "by
definition" is not allowed.</H2><!--SEC END --><P><EM>Description</EM>: The current proof tries to used a local variable
<I>name</I>, i.e. an identifier not representing a method, hence
meaningless for <FONT COLOR=purple>Zenon</FONT>.</P><P><EM>Hints</EM>: None.</P><!--TOC section Using a local identifier (<I>name</I>) in a Zenon proof with "by
property" is not allowed.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Using a local identifier (<I>name</I>) in a Zenon proof with "by
property" is not allowed.</H2><!--SEC END --><P><EM>Description</EM>: The current proof tries to used a local variable
<I>name</I>, i.e. an identifier not representing a method, hence
meaningless for <FONT COLOR=purple>Zenon</FONT>.</P><P><EM>Hints</EM>: None.</P><!--TOC section Assumed hypothesis &#X2019;<I>hyp</I>&#X2019; in a Zenon proof was not found.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Assumed hypothesis &#X2019;<I>hyp</I>&#X2019; in a Zenon proof was not found.</H2><!--SEC END --><P><EM>Description</EM>: The current proof makes a reference to an
hypothesis <I>hyp</I> that was not found in the current proof tree.</P><P><EM>Hints</EM>: None.</P><!--TOC section Step &#X2019;&lt;&#X2026;&gt;&#X2026;&#X2019; in a Zenon proof was not found.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Step &#X2019;&lt;&#X2026;&gt;&#X2026;&#X2019; in a Zenon proof was not found.</H2><!--SEC END --><P><EM>Description</EM>: The current proof makes a reference to an
proof step that was not found in the current proof tree.</P><P><EM>Hints</EM>: None.</P><!--TOC section Mutual recursion is not yet supported for Coq code
generation. At least functions &#X2019;<I>name</I><SUB>1</SUB>&#X2019; and &#X2019;<I>name</I><SUB>2</SUB>&#X2019; are
involved in a mutual recursion.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Mutual recursion is not yet supported for Coq code
generation. At least functions &#X2019;<I>name</I><SUB>1</SUB>&#X2019; and &#X2019;<I>name</I><SUB>2</SUB>&#X2019; are
involved in a mutual recursion.</H2><!--SEC END --><P><EM>Description</EM>: The current version of <FONT COLOR=purple>FoCaLize</FONT> does not yet handle
<FONT COLOR=purple>Coq</FONT> code generation for mutual recursive functions. At least the two
functions <I>name</I><SUB>1</SUB> and <I>name</I><SUB>2</SUB> were found as mutually recursive but
may be the recursion involves more functions. It is then impossible to
produce <FONT COLOR=purple>Coq</FONT> source code.</P><P><EM>Hints</EM>: Until this feature is available in <FONT COLOR=purple>FoCaLize</FONT>  do not try to
generate the <FONT COLOR=purple>Coq</FONT> code for the source file containing these functions
by using the <TT>--no-coq-code</TT> option.</P><!--TOC section Recursive call to &#X2019;<I>name</I>&#X2019; contains nested recursion.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Recursive call to &#X2019;<I>name</I>&#X2019; contains nested recursion.</H2><!--SEC END --><P><EM>Description</EM>: The function contains a recursive call to <I>name</I>
inside a recursive call. The current version of <FONT COLOR=purple>FoCaLize</FONT> doesn&#X2019;t
support the <FONT COLOR=purple>Coq</FONT> code generation for nested recursive calls.</P><P><EM>Hints</EM>: Try to rewrite your function with the nested call
performed before the outer recursive call. For instance:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>rec</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>bla</FONT><FONT SIZE=2>))</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT></TD></TR>
</TABLE><P>
should be turned into:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>rec</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>tmp</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>bla</FONT><FONT SIZE=2>) </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>tmp</FONT><FONT SIZE=2>)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT></TD></TR>
</TABLE><!--TOC section Recursive call to &#X2019;<I>name</I>&#X2019; is incomplete.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Recursive call to &#X2019;<I>name</I>&#X2019; is incomplete.</H2><!--SEC END --><P><EM>Description</EM>: The function contains a recursive occurrence of
<I>name</I> with an incomplete number of parameters. Since application
syntactically requires all the arguments to be present, this can arise
if the recursive identifier is used in non-applicative
position. However the error message is more general since future
extensions may involve partial applications. Below follows an example
of such invalid usage of a recursive function identifier:
<FONT SIZE=2>
</FONT></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>rec</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (</FONT><FONT SIZE=2>x</FONT><FONT SIZE=2>) =</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>tmp</FONT><FONT SIZE=2> = </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>let</FONT><FONT SIZE=2> ...  = </FONT><FONT SIZE=2>tmp</FONT><FONT SIZE=2> (...) ... </FONT><FONT SIZE=2>in</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  </FONT><FONT SIZE=2>f</FONT><FONT SIZE=2> (...)</FONT><FONT SIZE=2>
</FONT><FONT SIZE=2>  ...</FONT></TD></TR>
</TABLE><P><EM>Hints</EM>: None</P><!--TOC section Unexpected error: "<I>msg</I>". Please report.-->
<H2 CLASS="section"><!--SEC ANCHOR -->Unexpected error: "<I>msg</I>". Please report.</H2><!--SEC END --><P><EM>Description</EM>: An error was raised and not expected during a
normal execution of the compiler. This is a failure of the compiler
and must be fixed by the <FONT COLOR=purple>FoCaLize</FONT> development team. The error message
display the internal reason of the failure and must be reported to the
<FONT COLOR=purple>FoCaLize</FONT> development team.</P><P><EM>Hints</EM>: <CODE>http://focal.inria.fr/</CODE>, link &#X201C;Bug tracking&#X201D;.
</P><!--TOC chapter References-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->References</H1><!--SEC END --><DL CLASS="thebibliography"><DT CLASS="dt-thebibliography">
<A NAME="TTSS08"><FONT COLOR=purple>[1]</FONT></A></DT><DD CLASS="dd-thebibliography">
P. Ayrault, T. Hardin, and F. Pessaux.
Development life cycle of critical software under FoCal.
In ENTCS-Elsevier, editor, <EM>Harnessing Theories for Tool
Support in Software-TTSS&#X2019;08</EM>, 2008.</DD><DT CLASS="dt-thebibliography"><A NAME="ZenonBDD"><FONT COLOR=purple>[2]</FONT></A></DT><DD CLASS="dd-thebibliography">
R. Bonichon, D. Delahaye, and D. Doligez.
<FONT COLOR=purple>Zenon</FONT>: An Extensible Automated Theorem Prover Producing
Checkable Proofs.
In <EM>Logic for Programming Artificial Intelligence and Reasoning
(LPAR)</EM>, volume 4790 of <EM>LNCS/LNAI</EM>, pages 151&#X2013;165, Yerevan (Armenia),
Oct. 2007. Springer.</DD><DT CLASS="dt-thebibliography"><A NAME="BoulmePhD00"><FONT COLOR=purple>[3]</FONT></A></DT><DD CLASS="dd-thebibliography">
S. Boulmé.
<EM>Spécification d&#X2019;un environnement dédié à la
programmation certifiée de bibliothèques de Calcul Formel</EM>.
Thèse de doctorat, Université Paris 6, 2000.</DD><DT CLASS="dt-thebibliography"><A NAME="ThRRCalculemus"><FONT COLOR=purple>[4]</FONT></A></DT><DD CLASS="dd-thebibliography">
S. Boulmé, T. Hardin, and R. Rioboo.
Some hints for polynomials in the Foc project.
In <EM>Calculemus 2001 Proceedings</EM>, June 2001.</DD><DT CLASS="dt-thebibliography"><A NAME="Focal-UML"><FONT COLOR=purple>[5]</FONT></A></DT><DD CLASS="dd-thebibliography">
D. Delahaye, J.-F. Étienne, and V. Viguié Donzeau-Gouge.
A Formal and Sound Transformation from <FONT COLOR=purple>FoCaLize</FONT> to UML: An
Application to Airport Security Regulations.
In <EM>UML and Formal Methods (UML&amp;FM)</EM>, Innovations in Systems and
Software Engineering (ISSE) NASA Journal, Kitakyushu-City (Japan), Oct. 2008.
Springer.</DD><DT CLASS="dt-thebibliography"><A NAME="EDEMOI-All"><FONT COLOR=purple>[6]</FONT></A></DT><DD CLASS="dd-thebibliography">
D. Delahaye, J.-F. Étienne, and V. Viguié Donzeau-Gouge.
Formal Modeling of Airport Security Regulations using the
<FONT COLOR=purple>FoCaLize</FONT> Environment.
In <EM>Requirements Engineering and Law (RELAW)</EM>, Barcelona (Spain),
Sept. 2008. IEEE CS Press.</DD><DT CLASS="dt-thebibliography"><A NAME="EDEMOI-Model"><FONT COLOR=purple>[7]</FONT></A></DT><DD CLASS="dd-thebibliography">
D. Delahaye, J.-F. Étienne, and V. Viguié Donzeau-Gouge.
Certifying Airport Security Regulations using the <FONT COLOR=purple>FoCaLize</FONT>
Environment.
In <EM>Formal Methods (FM)</EM>, volume 4085 of <EM>LNCS</EM>, pages
48&#X2013;63. Springer, Aug. 2006.</DD><DT CLASS="dt-thebibliography"><A NAME="EDEMOI-Proof"><FONT COLOR=purple>[8]</FONT></A></DT><DD CLASS="dd-thebibliography">
D. Delahaye, J.-F. Étienne, and V. Viguié Donzeau-Gouge.
Reasoning about Airport Security Regulations using the <FONT COLOR=purple>FoCaLize</FONT>
Environment.
In <EM>International Symposium on Leveraging Applications of Formal
Methods, Verification and Validation (ISoLA)</EM>, pages 45&#X2013;52. IEEE CS Press,
Nov. 2006.</DD><DT CLASS="dt-thebibliography"><A NAME="zenon0.4.1"><FONT COLOR=purple>[9]</FONT></A></DT><DD CLASS="dd-thebibliography">
D. Doligez.
Zenon, version 0.4.1.
http://focal.inria.fr/zenon/, 2006.</DD><DT CLASS="dt-thebibliography"><A NAME="HardinRiobooTSI04"><FONT COLOR=purple>[10]</FONT></A></DT><DD CLASS="dd-thebibliography">
T. Hardin and R. Rioboo.
Les objets des mathématiques.
<EM>RSTI - L&#X2019;objet</EM>, 2004.</DD><DT CLASS="dt-thebibliography"><A NAME="traps"><FONT COLOR=purple>[11]</FONT></A></DT><DD CLASS="dd-thebibliography">
É. Jaeger and T. Hardin.
A few remarks about formal development of secure systems.
In <EM>HASE</EM>, pages 165&#X2013;174. IEEE Computer Society, 2008.</DD><DT CLASS="dt-thebibliography"><A NAME="jias06"><FONT COLOR=purple>[12]</FONT></A></DT><DD CLASS="dd-thebibliography">
M. Jaume and C. Morisset.
A formal approach to implement access control.
<EM>Journal of Information Assurance and Security</EM>, 2:137&#X2013;148,
2006.</DD><DT CLASS="dt-thebibliography"><A NAME="fcsarspa06"><FONT COLOR=purple>[13]</FONT></A></DT><DD CLASS="dd-thebibliography">
M. Jaume and C. Morisset.
Towards a formal specification of access control.
In <EM>Joint Workshop on Foundations of Computer Security and
Automated Reasoning for Security Protocol Analysis </EM><EM>FCS-ARSPA</EM><EM>&#X2019;06 (Satellite
Workshop to </EM><EM>LICS</EM><EM>&#X2019;2006)</EM>, 2006.</DD><DT CLASS="dt-thebibliography"><A NAME="MaarekCalculemus03"><FONT COLOR=purple>[14]</FONT></A></DT><DD CLASS="dd-thebibliography">
M. Maarek and V. Prevosto.
Focdoc: The documentation system of foc.
In <EM>Proceedings of the 11th Calculemus Symposium</EM>, Rome, sep
2003.</DD><DT CLASS="dt-thebibliography"><A NAME="CarlierDuboisLNCS2008"><FONT COLOR=purple>[15]</FONT></A></DT><DD CLASS="dd-thebibliography">
M.Carlier and C.Dubois.
Functional testing in the focal environment.
In B.Beckert and R.Hähnle, editors, <EM>Tests and Proofs, Second
International Conference, </EM><EM>TAP</EM><EM> 2008, Prato, Italy, April 9-11, 2008.
Proceedings</EM>, volume 4966 of <EM>Lecture Notes in Computer Science</EM>, pages
84&#X2013;98. Springer, 2008.</DD><DT CLASS="dt-thebibliography"><A NAME="MorissetPhd"><FONT COLOR=purple>[16]</FONT></A></DT><DD CLASS="dd-thebibliography">
C. Morisset.
<EM>Sémantique des systèmes de contrôle d&#X2019;accès</EM>.
PhD thesis, Université Pierre et Marie Curie - Paris 6, 2007.</DD><DT CLASS="dt-thebibliography"><A NAME="PrevostoPhD03"><FONT COLOR=purple>[17]</FONT></A></DT><DD CLASS="dd-thebibliography">
V. Prevosto.
<EM>Conception et Implantation du langage </EM><EM>FoC</EM><EM> pour le
développement de logiciels certifiés</EM>.
PhD thesis, Université Paris 6, sep 2003.</DD><DT CLASS="dt-thebibliography"><A NAME="TLCA2005"><FONT COLOR=purple>[18]</FONT></A></DT><DD CLASS="dd-thebibliography">
V. Prevosto and S. Boulmé.
Proof contexts with late binding.
In <EM>Typed Lambda Calculi and Applications</EM>, volume 3461 of <EM>LNCS</EM>, pages 324&#X2013;338. Springer, 2005.</DD><DT CLASS="dt-thebibliography"><A NAME="PrevostoJAR02"><FONT COLOR=purple>[19]</FONT></A></DT><DD CLASS="dd-thebibliography">
V. Prevosto and D. Doligez.
Algorithms and proof inheritance in the Foc language.
<EM>Journal of Automated Reasoning</EM>, 29(3-4):337&#X2013;363, dec 2002.</DD><DT CLASS="dt-thebibliography"><A NAME="TPHOL2002"><FONT COLOR=purple>[20]</FONT></A></DT><DD CLASS="dd-thebibliography">
V. Prevosto, D. Doligez, and T. Hardin.
Algebraic structure and dependent records.
In <EM>TPHOL</EM><EM>s&#X2019;2002</EM>, volume 2410 of <EM>LNCS</EM>. Springer-Verlag,
2002.</DD><DT CLASS="dt-thebibliography"><A NAME="PrevostoJaume2003"><FONT COLOR=purple>[21]</FONT></A></DT><DD CLASS="dd-thebibliography">
V. Prevosto and M. Jaume.
Making proofs in a hierarchy of mathematical structures.
In <EM>Proceedings of the 11th Calculemus Symposium</EM>, Rome, sep
2003.</DD></DL><!--TOC chapter Index-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Index</H1><!--SEC END --><P></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv">
;;, <A HREF="#@default78">4.1.1</A>, <A HREF="#@default82">4.1.2</A>, <A HREF="#@default83">4.1.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">annotation, <A HREF="#@default7">3.1.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
block, <A HREF="#@default9">3.1.3</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">bang character, <A HREF="#@default105">4.2.1</A>
</LI><LI CLASS="li-indexenv">blank, <A HREF="#@default5">3.1.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">category of identifiers, <A HREF="#@default15">3.1.4.5</A>
</LI><LI CLASS="li-indexenv">collection, <A HREF="#@default97">4.1.5</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
parameter, <A HREF="#@default100">4.2.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">comment, <A HREF="#@default6">3.1.2</A>
</LI><LI CLASS="li-indexenv">compilation unit, <A HREF="#@default1">2.5</A>
</LI><LI CLASS="li-indexenv">compiler option, <A HREF="#@default125">7</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">defining a prefix operator, <A HREF="#@default22">3.1.4.9</A>
</LI><LI CLASS="li-indexenv">defining an infix operator, <A HREF="#@default21">3.1.4.9</A>
</LI><LI CLASS="li-indexenv">defining operators, <A HREF="#@default20">3.1.4.9</A>
</LI><LI CLASS="li-indexenv">dependency, <A HREF="#@default116">4.4.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
decl, <A HREF="#@default117">4.4.2.1</A>
</LI><LI CLASS="li-indexenv">def, <A HREF="#@default118">4.4.2.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
on
representation, <A HREF="#@default119">4.4.2.2</A>
</LI><LI CLASS="li-indexenv">on representation, <A HREF="#@default122">4.4.3.2</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-indexenv">directive<UL CLASS="indexenv"><LI CLASS="li-indexenv">
coq_require, <A HREF="#@default73">3.2.6.3</A>
</LI><LI CLASS="li-indexenv">open, <A HREF="#@default32">3.1.12</A>, <A HREF="#@default55">3.2.4.3</A>, <A HREF="#@default72">3.2.6.2</A>
</LI><LI CLASS="li-indexenv">use, <A HREF="#@default71">3.2.6.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">documentation, <A HREF="#@default8">3.1.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">erasing, <A HREF="#@default120">4.4.2.3</A>
</LI><LI CLASS="li-indexenv">expression, <A HREF="#@default45">3.2.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
application, <A HREF="#@default66">3.2.4.8</A>
</LI><LI CLASS="li-indexenv">constant, <A HREF="#@default47">3.2.4.1</A>
</LI><LI CLASS="li-indexenv">identifier, <A HREF="#@default50">3.2.4.3</A>
</LI><LI CLASS="li-indexenv">if, <A HREF="#@default60">3.2.4.6</A>
</LI><LI CLASS="li-indexenv">let-in, <A HREF="#@default58">3.2.4.4</A>
</LI><LI CLASS="li-indexenv">literal, <A HREF="#@default46">3.2.4.1</A>
</LI><LI CLASS="li-indexenv">logical, <A HREF="#@default76">3.2.7.1</A>
</LI><LI CLASS="li-indexenv">match, <A HREF="#@default63">3.2.4.7</A>
</LI><LI CLASS="li-indexenv">operator, <A HREF="#@default67">3.2.4.9</A>
</LI><LI CLASS="li-indexenv">record, <A HREF="#@default68">3.2.4.10</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
clone, <A HREF="#@default69">3.2.4.11</A>
</LI><LI CLASS="li-indexenv">field, <A HREF="#@default70">3.2.4.12</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">sum type constructor, <A HREF="#@default48">3.2.4.2</A>
</LI><LI CLASS="li-indexenv">type, <A HREF="#@default34">3.2.1.2</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">field, <A HREF="#@default81">4.1.2</A>
</LI><LI CLASS="li-indexenv">fixity of identifiers, <A HREF="#@default11">3.1.4.3</A>
</LI><LI CLASS="li-indexenv">function, <A HREF="#@default89">4.1.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
recursive, <A HREF="#@default123">6</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">functional value, <A HREF="#@default51">3.2.4.3</A>, <A HREF="#@default65">3.2.4.8</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">identifier, <A HREF="#@default10">3.1.4</A>, <A HREF="#@default49">3.2.4.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
delimited, <A HREF="#@default26">3.1.5</A>
</LI><LI CLASS="li-indexenv">extended, <A HREF="#@default25">3.1.5</A>
</LI><LI CLASS="li-indexenv">operator, <A HREF="#@default18">3.1.4.8</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">identifier binding, <A HREF="#@default59">3.2.4.4</A>
</LI><LI CLASS="li-indexenv">if, <A HREF="#@default61">3.2.4.6</A>
</LI><LI CLASS="li-indexenv">infix identifier, <A HREF="#@default12">3.1.4.3</A>
</LI><LI CLASS="li-indexenv">infix in prefix position, <A HREF="#@default24">3.1.4.10</A>
</LI><LI CLASS="li-indexenv">inheritance, <A HREF="#@default109">4.3.1</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
multiple, <A HREF="#@default110">4.3.1</A>
</LI><LI CLASS="li-indexenv">parametrised by <TT>Self</TT>, <A HREF="#@default113">4.3.1</A>
</LI><LI CLASS="li-indexenv">parametrised species, <A HREF="#@default111">4.3.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">installation, <A HREF="#@default0">2.4</A>
</LI><LI CLASS="li-indexenv">interface, <A HREF="#@default96">4.1.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
compatibility, <A HREF="#@default102">4.2.1</A>
</LI></UL>
</LI></UL></TD><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv">late-binding, <A HREF="#@default115">4.4.1</A>
</LI><LI CLASS="li-indexenv">let-in, <A HREF="#@default57">3.2.4.4</A>
</LI><LI CLASS="li-indexenv">lexical conventions, <A HREF="#@default4">3.1</A>
</LI><LI CLASS="li-indexenv">linking files, <A HREF="#@default3">2.5.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">match, <A HREF="#@default62">3.2.4.7</A>
</LI><LI CLASS="li-indexenv">method, <A HREF="#@default80">4.1.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
qualification, <A HREF="#@default56">3.2.4.3</A>, <A HREF="#@default104">4.2.1</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">name<UL CLASS="indexenv"><LI CLASS="li-indexenv">
qualification, <A HREF="#@default31">3.1.12</A>, <A HREF="#@default53">3.2.4.3</A>
</LI><LI CLASS="li-indexenv">resolution, <A HREF="#@default30">3.1.12</A>, <A HREF="#@default52">3.2.4.3</A>, <A HREF="#@default106">4.2.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">nature of identifiers, <A HREF="#@default16">3.1.4.6</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">operator, <A HREF="#@default19">3.1.4.8</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">parameter<UL CLASS="indexenv"><LI CLASS="li-indexenv">
collection, <A HREF="#@default99">4.2.1</A>
</LI><LI CLASS="li-indexenv">entity, <A HREF="#@default108">4.2.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">parametrisation, <A HREF="#@default94">4.1.2</A>, <A HREF="#@default98">4.2</A>
</LI><LI CLASS="li-indexenv">pattern matching, <A HREF="#@default64">3.2.4.7</A>
</LI><LI CLASS="li-indexenv">polymorphism, <A HREF="#@default93">4.1.2</A>, <A HREF="#@default101">4.2.1</A>
</LI><LI CLASS="li-indexenv">precedence of identifiers, <A HREF="#@default14">3.1.4.4</A>
</LI><LI CLASS="li-indexenv">prefix form notation, <A HREF="#@default23">3.1.4.10</A>
</LI><LI CLASS="li-indexenv">prefix identifier, <A HREF="#@default13">3.1.4.3</A>
</LI><LI CLASS="li-indexenv">proof, <A HREF="#@default2">2.5.1</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
delayed, <A HREF="#@default91">4.1.2</A>
</LI><LI CLASS="li-indexenv">step bullet, <A HREF="#@default28">3.1.11</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">property, <A HREF="#@default75">3.2.7</A>, <A HREF="#@default90">4.1.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">qualified name, <A HREF="#@default29">3.1.12</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">recursion, <A HREF="#@default124">6</A>
</LI><LI CLASS="li-indexenv">regular identifiers, <A HREF="#@default17">3.1.4.7</A>
</LI><LI CLASS="li-indexenv">representation, <A HREF="#@default84">4.1.2</A>, <A HREF="#@default87">4.1.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
declared, <A HREF="#@default86">4.1.2</A>
</LI><LI CLASS="li-indexenv">defined, <A HREF="#@default85">4.1.2</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">scoping, <A HREF="#@default54">3.2.4.3</A>, <A HREF="#@default107">4.2.1</A>
</LI><LI CLASS="li-indexenv">signature, <A HREF="#@default88">4.1.2</A>
</LI><LI CLASS="li-indexenv">species, <A HREF="#@default79">4.1.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
complete, <A HREF="#@default95">4.1.3</A>
</LI><LI CLASS="li-indexenv">expression, <A HREF="#@default114">4.3.2</A>
</LI><LI CLASS="li-indexenv">name, <A HREF="#@default27">3.1.6</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">sum type, <A HREF="#@default39">3.2.1.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">theorem, <A HREF="#@default74">3.2.7</A>, <A HREF="#@default92">4.1.2</A>
</LI><LI CLASS="li-indexenv">toplevel, <A HREF="#@default77">4.1.1</A>
</LI><LI CLASS="li-indexenv">tuple, <A HREF="#@default35">3.2.1.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
as sum type value constructor arg, <A HREF="#@default41">3.2.1.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">type<UL CLASS="indexenv"><LI CLASS="li-indexenv">
compatible, <A HREF="#@default44">3.2.2</A>
</LI><LI CLASS="li-indexenv">definition, <A HREF="#@default36">3.2.1.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
alias, <A HREF="#@default37">3.2.1.3</A>
</LI><LI CLASS="li-indexenv">record, <A HREF="#@default43">3.2.1.3</A>
</LI><LI CLASS="li-indexenv">sum, <A HREF="#@default38">3.2.1.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">dependent, <A HREF="#@default103">4.2.1</A>, <A HREF="#@default112">4.3.1</A>
</LI><LI CLASS="li-indexenv">expression, <A HREF="#@default33">3.2.1.2</A>
</LI><LI CLASS="li-indexenv">recursive, <A HREF="#@default42">3.2.1.3</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">value constructor, <A HREF="#@default40">3.2.1.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">well-formation, <A HREF="#@default121">4.4.3.1</A>
</LI></UL></TD></TR>
</TABLE><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
