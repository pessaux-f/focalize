\subsection{Types}
Before dealing with expressions and in general, constructs that allow
to compute, we first examine datatype definitions since to emit a
result an algorithm must manipulate data that have a certain type,
hence must know about their type definitions.

Type definitions allow to build new types or more complex types by
combining previously existing types. They always appear at
``toplevel'', in other words, outside species and collections. Hence
they are a kind of ``global'' definitions that are visible in the
whole compilation unit (and also in other units by using the
{\tt open} directive or by qualifying the type name as described in
\ref{qualified_name}).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Type expressions}
\index{type!expression}
Type definitions require type expressions to build more complex
datatypes. For this reason we present here the shape of type
expressions.

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Type expressions:}
\tau & ::= & lowercase\ ident   & Type constructor \\
     & \mid & uppercase\ ident & Species carrier \\
     & \mid & {\tt '}lowercase\ ident & Type variable \\
     & \mid & uppercase\ ident (\tau \{, \tau \}) & Parameterised type constructor \\
     & \mid & \tau -> \tau & Functional type \\
     & \mid & (\tau * \tau \{* \tau \}) & Tuple type \\
     & \mid & {\tt Self} & Current species carrier \\
     & \mid & (\tau) & Parenthesed type expression
\end{syntax}
\vspace{0.2cm}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Type definitions}
\index{type!definition}


\subsection{Carrier (type) definition}

\subsection{Expressions}

\subsection{Value and function definitions}

\subsection{Files and uses directives}

\subsection{Theorems and proofs}
