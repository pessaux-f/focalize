%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Types}
Before dealing with expressions and in general, constructs that allow
to compute, we first examine data-type definitions since to emit a
result an algorithm must manipulate data that have a certain type,
hence must know about their type definitions.

Type definitions allow to build new types or more complex types by
combining previously existing types. They always appear at
``toplevel'', in other words, outside species and collections. Hence
they are a kind of ``global'' definitions that are visible in the
whole compilation unit (and also in other units by using the
{\tt open} directive or by qualifying the type name as described in
\ref{qualified-name}).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Type expressions}
\index{type!expression}
Type definitions require type expressions to build more complex
data-types. For this reason we present here the shape of type
expressions.

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Type expressions:}
\tau & ::= & lowercase\ ident   & Type constructor \\
     & \mid & uppercase\ ident & Species carrier \\
     & \mid & \terminal{'}lowercase\ ident & Type variable \\
     & \mid & uppercase\ ident
              \terminal{(}\tau \{\terminal{,} \tau\}+\terminal{)} &
               Parametrised type constructor \\
     & \mid & \tau \terminal{\rightarrow} \tau & Functional type \\
     & \mid & \terminal{(}\tau \terminal{*} \tau
              \{\terminal{*}\ \tau\}+\terminal{)} & Tuple type \\
     & \mid & \terminal {Self} & Current species carrier \\
     & \mid & \terminal{(}\tau\terminal{)} & Parenthesised type expression
\end{syntax}
\vspace{0.2cm}

A type expression can be a type ``constructor'', i.e. the name given
to a type during its definition. \focal\ provides the basic builtin
types (constructors):
\begin{itemize}
  \item {\tt int} for signed machine integers,
  \item {\tt bool} for boolean values ({\tt true} and {\tt false} that
    are hardwired in the syntax or {\tt True} and {\tt False} that are
    defined in ``basics.foc''),
  \item {\tt float} for floating point numbers,
  \item {\tt unit} for the trivial type whose only value is {\tt ()},
  \item {\tt char} for characters literals,
  \item {\tt string} for strings literals.
\end{itemize}
Types constructors can be parametrised by type expressions separated
by commas and between parentheses. Each type {\bf definition} will
lead to a new type {\bf constructor}.

A type expression can also denote the carrier of a species by using
the name of the species. In this case, they always look like
capitalized name since species names are so. The special case of
{\tt Self} represents the carrier of the current species. Hence,
obviously {\tt Self} is only bound in the scope of a species.

Type expressions representing functions types are written using the
arrow notation ({\tt ->} in which the type of the argument of the
function is the left type expression and its return type is right
one. As usual in functional languages, a function with several (say
$n$) arguments is considered a function with {\bf 1} argument
returning a function with $n-1$ arguments. Hence,
{\tt int -> int -> bool} is the type of a function taking 2 integers
and returning a boolean.

\focal\ provides native tuples (generalisation of pairs). The type of
a tuple is the type of each of its components separated by a *
character and surrounded by parentheses. Hence,
{\tt (int * bool * string) } is the type of triplets whose first
component is an integer, second component is a boolean and third
component is a string.

Finally, type expression can be written between parentheses without
change of their semantics.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Type definitions}
\index{type!definition}
\label{type-definition}
As stated before, each type {\bf definition} will lead to a new type
{\bf constructor} that will be available among the constructors that
can be used in type {\bf expressions}. Hence, defining a type is the
way to give a name to a new type structure. \focal\ proposes 3 kinds
of type definitions: sum types, aliases and record types.



\vspace{0.5cm}\noindent{\bf Sum types}
\index{type!definition!sum}

They provide the way to create new {\bf values} that
will belong to the same {\bf type}. Like {\tt 1} or {\tt 42} are
{\bf values} of {\bf type} {\tt int}, one may want to have {\tt Red},
{\tt Blue} and {\tt Green} as the {\bf only} values of a {\tt color}
type. We says {\bf only} since it means that the created {\tt color}
type will be inhabited only by these 3 (wished) values. To defined
such a type, we itemize its values names (that are always capitalized
identifiers), each one preceded by a ``$\mid$'' character :
{\scriptsize
\begin{lstlisting}
type color =
  | Red
  | Blue
  | Green
;;
\end{lstlisting}
}
Note that the first ``$\mid$'' character is required: it is not a
separator. This especially means that when writing a sum type
definition on one line, the first ``$\mid$'' must be written:
{\scriptsize
\begin{lstlisting}
type color = | Red | Blue | Green ;;
\end{lstlisting}
}
Values of a sum type definitions are built from its
{\bf sum type constructors}, i.e. from the names enumerated in the
definition (that must not be confused with the {\bf type constructor}
that is the name of a type, here {\tt color}). For, instance,
{\tt Red} is a {\bf value} of our type {\tt color}.

It is possible to define {\bf parametrised} sum type constructors. In
this case, the constructors may carry a {\bf value}. For instance,
let's define the type of playing cards as king, queen, jack and simply
numbered cards:
{\scriptsize
\begin{lstlisting}
type card =
  | King
  | Queen
  | Jack
  | Numbered (int)
;;
\end{lstlisting}
}
Hence, the {\tt Numbered} constructor carries the integer value
written on the card. In our example, here are some values of type
{\tt card}: {\tt King}, {\tt (Numbered 4)}, {\tt (Numbered 42)}.

It is possible to parametrise constructors by any type expression,
even recursive.
\index{type!recursive}
For instance, the type of lists of boolean $\times$ integer pairs
could be defined like:
{\scriptsize
\begin{lstlisting}
type b_i_list =
  | Empty
  | Cons ((bool * int) * b_i_list)
;;
\end{lstlisting}
}
From this type definition, a list is either empty (constructor
{\tt Empty}) or contains one element in head (the first component of
the {\tt Cons} constructor) and a trailing list (the second component
of this constructor). Example of value of type {\tt b\_i\_list}:
{\tt Cons ((false, 2), (Cons ((true, 1), Empty)))}. This list's length
is 2 and its elements are {\tt (false, 2)} followed by
{\tt (true, 1)}.

Like for any type definition, it is possible to parametrise the
{\bf definition}, i.e. create a type with a {\bf type variable} that
can be instantiate by any type expression. For instance, the type
definition of generic (polymorphic) lists may be defined by:
{\scriptsize
\begin{lstlisting}
type list ('a) =
  | Empty
  | Cons ('a * list ('a))
;;
\end{lstlisting}
}
A type variable is written as an identifier preceded by a {\tt '}
(quote) character. In the above definition, we see that the sum
constructor {\tt Cons} carries a value of type ``unknown'' (of type
``variable'') and the tail of the list, i.e. a value of type
{\tt list} with its parameter instantiated by the same type
variable. This explicitly says that all the elements of such a list
have the same type. It is now possible to use the {\tt list} type in
type {\bf expressions} by providing a type {\bf expression} as
argument of the {\bf type constructor} {\tt list}. For instance,
{\tt list (int)} is the type of lists containing integers,
{\tt list (list (char))} is the type of lists containing lists of
characters.

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Sum types definitions:}
opt\_params & ::= & \epsilon
    \mid \terminal{(}\ \terminal{'}ident \{\terminal{,} \terminal{'}ident \}*
    \ \terminal{)} & \\
opt\_args & ::= & \epsilon
    \mid \terminal{(}\ \tau\ \{\terminal{,} \tau \}*\ \terminal{)} & \\
constructor & ::= & \terminal{\mid}\ uident\ opt\_args & \\
sum\_type\_def & ::= &
    \terminal{type}\ ident\ opt\_params\  \terminal{=} \  constructor+
\end{syntax}
\vspace{0.2cm}



\vspace{0.5cm}\noindent {\bf Aliases}
\index{type!definition!alias}

They provide a way to create type abbreviations. It it common to
manipulate large {\bf type expressions} like for instance, a tuple of
5 components: {\tt (int * int * int * int * int)}. However, is it not
handy to always write this expression each time we manipulate
it. Moreover, several kind of information can be represented by such a
tuple. For instance, x, y, z 3D-coordinates and temperature and
pressure. For another example, year, month, day, hours, minutes. In
these two cases, the manipulated type expression will be the same and
can' be easily differentiated. Type aliases allows to give a name to a
(complex) type expression, for sake of readability or to shorten the
code. Example:
{\scriptsize
\begin{lstlisting}
type experiment\_conditions = alias (int * int * int * int * int) ;;
type date = alias (int * int * int * int * int) ;;
\end{lstlisting}
}

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Alias type definitions:}
alias\_type\_def & ::= & \terminal{type}\ ident\ \terminal{=}
   \ \terminal{alias}\ \tau
\end{syntax}
\vspace{0.2cm}

In the remaining of the development, the type names
{\tt  experiment\_conditions} and {\tt date} will be known to be
tuples of 5 integers and will be compatible with any other type being
also a tuple of 5 integers. This especially means that a type alias
does not create a really ``new'' type, it only gives a name to a type
expression and this name is type-compatible with any occurrence of the
type expression it is bound to. Obviously, it is possible to use
aliases with and in any type expression, type definition. For
instance:
{\scriptsize
\begin{lstlisting}
type t1 =
 | A
 | B
;;

type t2 = (t1 * bool) ;

type t3 ('a) =
 | C (t2)
 | D ('a)
;;

type t4 = t3 (int * bool) ;;
\end{lstlisting}
}



\vspace{0.5cm}\noindent {\bf Record types}
\label{record-type-definition}
\index{type!definition!record}

They provide a way to aggregate data of various types, a bit like
tuples, but naming the components of the group, instead of
differentiating them by their position like in tuples. Hence, a record
type is like the {\tt struct} of C or Java-like languages. A record is
a sequence of names and types between braces. For example:
{\scriptsize
\begin{lstlisting}
type experiment_conditions = {
  x : int ;
  y : int ;
  z : int ;
  temperature : int ;
  pressure : int
} ;;

type identity = {
  name : string ;
  birth : int ;
  living : bool
} ;;
\end{lstlisting}
}

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Record types definitions:}
field & ::= & ident\ \terminal{:}\ \tau\ \terminal{;} & \\
opt\_params & ::= & \epsilon
    \mid \terminal{(}\ \terminal{'}ident \{\terminal{,} \terminal{'}ident \}*
    \ \terminal{)} & \\
record\_type\_def & ::= &
    \terminal{type}\ ident\ opt\_params\  \terminal{=}
    \ \terminal{\{} field+ \terminal{\}}
\end{syntax}
\vspace{0.2cm}

To create a {\bf value} of a record type, a value of the related
type must be provided for each field of the record.
{\scriptsize
\begin{lstlisting}
{ name = "Alexandre" ; birth = 2003 ; living = true }
\end{lstlisting}
}
Like in tuples, records can mix types of fields. Like for any type
definition, it it possible to have parametrised record types:
{\scriptsize
\begin{lstlisting}
type pair ('a, 'b) = {
  first : 'a ;
  second : 'b
} ;;

type int_bool_pair = pair (int, bool) ;;
\end{lstlisting}
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Carrier (type) definition}
As previously introduced (c.f. \ref{rep-is-method}) the carrier is a
special kind of method of species that describes the internal
data structure the species manages. Hence, it is a
special {\bf type definition}, more accurately a
{\bf alias type definition}. This means that a carrier {\bf does not
define a new type}, it only ``assign'' the carrier a {\bf type
expression} representing the species ``internal state''. Moreover,
like for any other methods (c.f. \ref{no-polymorphism-for-methods}),
the carrier must not be polymorphic. This means that is can't contain
type variables. Defining a species carrier is simply done by adding
the {\tt rep} method:
{\scriptsize
\begin{lstlisting}
open "basics" ;;

species IntPair =
  rep = (int * int) ;
end ;;
\end{lstlisting}
}
Hence, the method {\tt rep} defines the type {\tt Self}'s structure.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Expressions}
\label{expressions}
Expressions are constructs of the language that are evaluated into a
{bf value} of a certain {\bf type}. Hence values and types are not at
the same level. Types serve to classify values into categories.
Although proofs may contain expressions, we will not describe the part
of \focal\ dealing with them in this section. We will take care of
them in a next section, in \ref{making-proofs}. In effect, proofs are
not expressions and live at another level. The reason is that proofs
do not lead to \focal\ values.

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Expressions:}
exp & ::= & integer\_literal & \\
    &     & \mid\ string\_literal & \\
    &     & \mid\ character\_literal & \\
    &     & \mid\ float\_literal & \\
    &     & \mid\ {\tt true}\ \mid\ {\tt false} & Boolean constant \\
    &     & \mid\ [[ident] \terminal{\#}]uident & Sum type constructor
                                       or species/collection identifier \\
    &     & \mid\ [\terminal{Self}] \terminal{!} uident &
                       Method of the current species \\
    &     & \mid\ [[ident] \terminal{\#}] [uident \terminal{!}] lident &
               Method from specified species/collection \\
    &     & \mid\ [[ident] \terminal{\#}] [uident \terminal{!}]
               \terminal{(} operator \terminal{)} & Infix or prefix
            operator used in functional position \\
    &     & \mid \terminal{let}\ [\terminal{rec}]\ let\_binding
               \ \{\terminal{and}\ let\_binding \}* &  Let bound definition \\
    &     & \ \ \ \terminal{in}\ exp & \\
    &     & \mid \terminal{if}\ exp\ \terminal{then}\ exp
                 \ \terminal{else}\ exp & Conditional \\
    &     & \mid \terminal{match}\ exp\ \terminal{with}\ match\_binding+ &
                     Pattern matching \\
    &     & \mid exp\ \terminal{(} [exp*] \terminal{)} & Function application \\
    &     & \mid unary\_operator\ exp & Application of unary operator \\
    &     & \mid exp\ binary\_operator\ exp & Application of binary operator \\
    &     & \mid \terminal{\{}\ record\_field\_value & Record value \\
    &     &     \hspace{0.6cm}  \{\ \terminal{;}\ record\_field\_value\ \}+
                \ \terminal{\}} & \\
    &     & \mid \terminal{\{}\ exp\ \terminal{with}\ record\_field\_value &
                  Record value clone \\
    &     &      \hspace{1.0cm}  \{\ \terminal{;}\ record\_field\_value\ \}+
                  \ \terminal{\}} & \\
    &     & \mid expr\ \terminal{.}[ident\terminal{\#}]lident &
                 Record field access \\
    &     & \mid \terminal{(} exp \terminal{)} & Parenthesised expression
\end{syntax}

\begin{syntax}
\syntaxclass{Record field value:}
record\_field\_value & ::= &
     [[ident] \terminal{\#}] lident\ \terminal{=}\ exp &
\end{syntax}

\begin{syntax}
\syntaxclass{Let bindings:}
let\_binding & ::= & \mid lident\ [\terminal{in}\ type\_expression]
           \ \terminal{=}\ exp & Definition without parameter \\
   & ::= & \mid lident\
                \terminal{(}lident\ [\terminal{in}\ type\_expression] &
                 Definition with parameter(s) \\
   &     &      \hspace{1.3cm} \{\ \terminal{,}\ lident
                  \ [\terminal{in}\ type\_expression]\}* \terminal{)} & \\
   &     &       \ \ \ \ [\terminal{in}\ type\_expression]\ \terminal{=}\ exp &
\end{syntax}

\begin{syntax}
\syntaxclass{Match bindings:}
 match\_binding & ::= &
   \terminal{\mid}\ pattern\ \terminal{-}\/\terminal{>}\ exp &
\end{syntax}

\begin{syntax}
\syntaxclass{Patterns:}
pattern & ::= & integer\_literal & \\
    &     & \mid\ string\_literal & \\
    &     & \mid\ character\_literal & \\
    &     & \mid\ float\_literal & \\
    &     & \mid\ {\tt true}\ \mid\ {\tt false} & Boolean constant \\
    &     & \mid\ lident & Variable \\
    &     & \mid [[ident] \terminal{\#}]uident & 0-ary sum type constructor \\
    &     & \mid [[ident] \terminal{\#}]uident
               \ \terminal{(}pattern \{\terminal{,}\ pattern\}*\terminal{)}&
               N-ary sum type constructor \\
    &     & \mid \_ & ``Catch-all'' pattern \\
    &     & \mid \terminal{\{}
                   record\_field\_pattern\
                   \{ \terminal{;}\ record\_field\_pattern \}*
                 \terminal{\}} & Record \\
    &     & \mid \terminal{(} pattern\ \{ \terminal{,}\ pattern\}+
                  \terminal{)} & Tuple \\
    &     & \mid \terminal{(} pattern \terminal{)} & Parenthesised pattern
\end{syntax}

\begin{syntax}
\syntaxclass{Record field pattern:}
record\_field\_pattern & ::= &
     [[ident] \terminal{\#}] lident\ \terminal{=}\ lident &
\end{syntax}
\vspace{0.2cm}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Literal expressions}
The five literal expressions (integer, string, character, float and
boolean) are evaluated into the constant represented by the literal.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Sum type constructor expressions}
We presented in section \ref{type-definition} the way to define sum
types. We saw that {\bf values} of such a {\bf type} are built using
its constructors.

Hence, for constructors with no argument, the constructor itself is an
expression that gets evaluated in a value wearing the same
name.

For constructors with parameters, a value is created by evaluating an
expression applying the constructor to as many expressions as the
constructor's arity. Obviously, sub-expressions used as arguments of
the constructor must we well-typed according to the type of the
constructor. The obtained value, after evaluation, is written by the
name of the constructor followed by the tuple of values provided as
arguments. For instance, with the following type definition:
{\scriptsize
\begin{lstlisting}
type t =
  | A
  | B (int * bool)
;;
\end{lstlisting}
}
the expression {\tt A} is evaluated into $A$, the expression
{\tt B ((2 + 3), true)} is evaluated into the value $B (5, true)$.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Identifier expressions}
\label{identifier-expressions}
\index{identifier}
An identifier expression (also called ``variable'') is evaluated into
the value bound to this variable. A variable is said {\bf bound} by
its definition, i.e. the construct that assigned a value to it. In
\focal\, there a three ways to bind a variable:
\begin{itemize}
  \item By a {\tt let-in} construct,
  \item By a toplevel definition ({\tt let} or {\tt theorem}),
  \item by a method definition,
  \item by a pattern inside a {\tt match-with} construct,
  \item or by a function definition where parameters are referenced as
    variables.
\end{itemize}
Each of these cases will be described in their related
section. Assuming a variable {\tt v} was bound to the result
{\bf value} of the computation of the {\bf expression} {\tt 2 + 5},
then each occurrence of {\tt v} in a expression will be ``replaced''
by 7 in this expression. This is basically the principle of by-value
evaluation.
\label{functional-value}
\index{functional value}
Like in any functional language, a function definition binds an
identifier to a value functional value that is the evaluation of the
function's body expression. Such a value is slightly different from
other ones since it embeds both the code of the function (i.e. a kind
of evaluation of its body expression) and its environment (i.e. bound
variable present in the scope of the function). This closure will be
kept untouched until it appears in a functional application
expression as described further in \ref{function-application}.



\medskip
Identifiers forms differ depending on the class of entity they refers
to. In the simplest form, an identifier expression is a lowercase
identifier. The \focal\ compiler will determine its definition from
the current scoping context.
\index{name!resolution}
\index{name!qualification}
\index{scoping}
It searches for the closest definition with this name, starting by the
local variables present in the current definition (i.e. formal
parameters if in a function and {\tt let-in} and {\tt match-with}
bound identifiers). If no variable definition with this name is found,
the search goes on among the methods of the current species. If a
method is found with this name, it will be retained, otherwise it
searches among the past toplevel definitions of the current
compilation unit.
\label{identifier-scoping-and-open}
\index{directive!open} If no suitable definition is found, then the
ones imported by the {\tt open} directives are examined to find one
with the searched name. Finally if no definition is found, the
identifier is reported unbound by an error message. Note that
{\tt open} directive may arise anywhere at toplevel in the source
code. Hence, the order of search between the current file's toplevel
definitions and the imported ones by {\tt open} is not really
separated: the name resolver looks for the most recent definition
considering that the toplevel definitions and the imported ones are
ordered according to the apparition of the effective definitions in
the file themselves and the imported ones. In other words, if a
toplevel definition exists for an entity {\tt foo}, if later an
{\tt open} directive imports another {\tt foo}, then this last one
will be the remained one.



\medskip
Identifiers can manually disambiguated in term of compilation unit
location using the sharp (\#) notation as explained in
\ref{qualified-name}.



\medskip
\index{method!qualification}
As presented in \ref{method-qualification}, species methods
identifiers are made explicit using the ``!'' notation. The notation
{\tt Spe!meth} stands for ``the method {\tt meth} of the species
{\tt Spe}''. By extension, {\tt !meth} stands for the method
{\tt meth} of the current species. It is possible to make explicit
{\tt Self} in the naming scheme using the syntax {\tt Self!meth}. This
last point could be useful in the case where a more recent local
identifier would exist in the scope of the current definition, hiding
a method of our species:
{\scriptsize
\begin{lstlisting}
species S =
  let m (x in ...) = ... ;
  let n (y in ...) =
    ...
    let m = ... in
    (* Want to call the *method* "m" with argument "m" !!! *)
    !m (m) ;
end ;;
\end{lstlisting}
}

Hence, the name resolution mechanism allows to omit the ``!'' but
making it explicit can help for conflicts resolution. Moreover, when
invoking species parameters' methods, the name resolution never
searches among methods of species parameters, hence the explicit ``!''
notation is required.

As the grammar shows, name qualification by compilation unit and
hosting species are not incompatible. We can build identifiers like
{\tt my\_file\#My\_species!my\_method} to refer to the method
{\tt my\_method} hosted in the species {\tt My\_species} located in
the \focal\ source file ``my\_file.foc''. These two disambiguation
means are orthogonal.



\medskip
Finally, infix/postfix operators can be used as regular
identifiers. Usually, an operator is syntactically used according to
it prefix or infix nature. For instance, the binary {\tt +} operator
is used in forms like {\tt x + 4}, the unary operator {\tt $\sim$} is
used in {\tt $\sim$ x}. \focal\ allows to make them visible like an
identifier of function definition. This allows two things: 
\begin{itemize}
  \item Using them in functional position,
  \item use then as regular identifiers in expressions, for example to
    pass them as arguments of other functions.
\end{itemize}
To get an identifier from an operator, its symbol
(c.f. \ref{extended-identifiers}) must be surrounded by parentheses.
For example: {\tt (\ + )}, {\tt (\ !!== )}.

We clearly advice to add spaces around the operator symbol, to prevent
parentheses from being not separated from it. This especially avoid
the following common and cryptic error:
{\scriptsize
\begin{lstlisting}
...
let (*) (x, y) = ...
\end{lstlisting}
}
where unfortunately {\tt (*} is parsed as a beginning of comment,
leading to a syntax error. The symmetry obviously arises with the
{\tt *)} considered as an end of comment. This pitfall exists indeed
only for the ``{\tt *}-starting'' and ``{\tt *}-ending'' operators,
but a good practice is to have a homogeneous naming scheme, hence
always adding extra spaces.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt let-in} expression}
\index{let-in}
This expression allows binding a value to an identifier in order to
evaluate a trailing expression (the ``body'') where this ident may
appear. During the evaluation of the trailing expression, any
occurence of the bound identifier is ``replaced'' by the value bound
to this identifier. For instance:
{\scriptsize
\begin{lstlisting}
let x = 5 in (x, x)
\end{lstlisting}
}
will bind the evaluation of the {\bf expression} {\tt 5} (i.e. the
integer {\bf value} $5$) to the identifier {\tt x} and then, the
evaluation of the body will lead to the tuple {\bf value} $(5, 5)$.
From the syntax, it is clearly possible to nest {\tt let-in}
constructs:
{\scriptsize
\begin{lstlisting}
let x = 5 in
  let y = (x, x) in
  let z = true in
  (y, z, y, z)
\end{lstlisting}
}
which leads when evaluated to the value
$((5,\ 5),\ true,\ (5,\ 5),\ true)$ of type
{\tt ((int * int) * bool * (int * int) * bool)}.



\medskip
\index{identifier binding}
The notion of ``binding a value to an ident'' is different from the
notion of assignment of imperative languages. In such languages (like
C, Java, Pascal,\ldots) a variable is declared, then a value is
assigned. It is possible to assign several times different values to a
variable. For example in C:
{\scriptsize
\begin{lstlisting}
...
{
  int i ;
  ... ;
  i = 10 ;
  while (i > 0) i = i-- ;
}
...
\end{lstlisting}
}
The variable {\tt i} is declared, then assigned the initial value
$10$, then the {\tt while} loop makes it decreasing by successive
assignments.

In a {\tt let-in} binding construct, an identifier is given a value
once: it is impossible to change its ``assigned'' value once it is
bound. We have no assignment construct. Each new definition, binding
an already bound identifier will hide it from the point of this
definition. For instance:
{\scriptsize
\begin{lstlisting}
let x = 5 in
  let y = (x, x) in
  let x = true in
  let z = (x, x) in
  (y, x, y, x)
\end{lstlisting}
}
leads when evaluated to the value $((5,\ 5),\ true, (5,\ 5),\ true)$
of type {\tt ((int * int) * bool * (int * int) * bool)} when it
clearly appears that the first value bound to {\tt x} lasts until it
is bound again: $5$ is used to create {\tt y} but to create
{\tt z}, the used value of {\tt x} is now $true$.



\medskip
The {\tt let-in} construct serves to bind a value to an
identifier. By consequence, it can be used to bind a functional value
to an identifier, hence allowing to define {\bf functions}. The only
difference is that the bound identifier has arguments:
{\scriptsize
\begin{lstlisting}
let f (x, y) = x + y in
f (6, 7)
\end{lstlisting}
}
In this example, we bind {\tt f} to a function with 2 parameters
{\tt x} and {\tt y}, whose body is the addition of these 2
parameters. Then the body of the {\tt let-in} construct uses (by
application as explained further in \ref{application-expression})
this function by passing it 2 effectives arguments {\tt 6} and
{\tt 7} (obviously we expect the result to be $13$).

It is possible to provide type constraints on the return value
(which is trivially the bound value in case where the definition is
not a function) and/or (some of) the parameters of a {\tt let-in}
definition:
{\scriptsize
\begin{lstlisting}
let f (x : int, y) = x + y in
f (6, 7)
\end{lstlisting}
}
{\scriptsize
\begin{lstlisting}
let f (x : int, y) in int = x + y in
f (6, 7)
\end{lstlisting}
}
{\scriptsize
\begin{lstlisting}
let a in int = 3 in
(a, a)
\end{lstlisting}
}



\medskip
It is possible to define several functions at the same time separating
each definition by the keyword {\tt and}.
{\scriptsize
\begin{lstlisting}
...
let f (x) = ...
and g (y) = ... f (...) ...
and h (z) = g (...) ... f (...) ... in
...
\end{lstlisting}
}
This acts exactly like a sequence of {\tt let-in} like in:
{\scriptsize
\begin{lstlisting}
...
let f (x) = ... in
let g (y) = ... f (...) ... in
let h (z) = g (...) ... f (...) ... in
...
\end{lstlisting}
}
However, this allows to define mutually recursive functions, that is,
functions that must know each other because in their bodies, they call
the other functions. In this case, the keyword {\tt let} must be
followed by the keyword {\tt rec}.
{\scriptsize
\begin{lstlisting}
...
let rec even (x) =
   if x = 0 then true else odd (x - 1)
and odd (y) =
   if y = 0 then false else even (y - 1) in
...
\end{lstlisting}
}

{\large {\bf Attention:}} in the current version of \focal\ mutually
recursive functions cannot be compiled into \coq\ code. Only
\ocaml\ code generation is available. Moreover, for \coq, recursive
functions imply termination proofs. This last point will be covered in
the section \ref{recursive-function} especially dedicated to
recursive (non-mutually) function definitions.



\medskip
{\color{red}To to: logical and local}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Conditional expression}
\label{conditional-expression}
\index{if}
The simple conditional expression {\tt if} $exp_1$ {\tt then}
$exp_2$ {\tt else} $exp_3$ evaluates the $exp_1$ expression which must
be of type boolean. If its value is $true$ then the result value of
the whole expression is the value of $exp_2$, otherwise (i.e. if its
value is $false$) the value of $exp_3$. This obviously implies that
$exp_2$ and $exp_3$ must have the same type. This construct is then a
binary conditional expression (i.e. with 2 branches).
{\scriptsize
\begin{lstlisting}
let f (x) = if x then 1 else 0 in ...
\end{lstlisting}
}
The function {\tt f} will return $1$ if its affective argument
(provided to {\tt x} is $true$, otherwise it will return $0$.
{\scriptsize
\begin{lstlisting}
let is_to\_small (x) = ... in
let y = ... in
let y_corrected = if is_to_small (y) then 0 else y in ...
\end{lstlisting}
}
In this example, we assume we have a function {\tt is\_to\_small}
checking if a value is ``too small'' and an identifier {\tt y} bound
to a certain value. The result of the conditional expression bound to
{\tt y\_corrected} will be either $0$ if the condition is met or $y$
otherwise.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Match expression}
\index{match}
\index{pattern matching}
The {\tt match-with} construct is a generalised conditional construct
with pattern-matching. By ``generalised'', we mean that conversely to
the {\tt if-then-else} which has only 2 branches, the present
expression can have several. The notion of condition here is not
anymore a boolean value. Instead, the construct allows to discriminate
on the different values an expression is evaluated into. The basic
structure of a {\tt match-with} consists in an examined expression
followed by an enumeration of cases (called {\bf patterns}) the examined
expression can have and for each, the result expression to ``return''.
{\scriptsize
\begin{lstlisting}
let x =
  match ... + ... with
   | 0 -> "zero"
   | 5 -> "five"
   | 1 -> "one"
   | 10 -> "ten"
   | _ -> "other" in
...
\end{lstlisting}
}
The ``examined'' expression in this case is {\tt ... + ...} and we
assume it has type {\tt int}. We can then react to each (or some of
the) value of this expression. When it {\bf is equal} to $0$ the
result of the whole {\tt match-with} expression (bound to the
identifier {\tt x} is the string ``zero''. When equal to $1$, the
result is the string ``one'', and so on. The final pattern {\tt \_}
stands for ``anything that was not in the previous cases'' (also
called ``catch-all pattern''). Hence, the
order of the patterns can be important. If the case {\tt $\mid$ \_ ->}
was put before the case {\tt $\mid$ 1 ->}, then this last case would
never be reached since the {\tt \_} pattern would have caught the
discriminated value.



\smallskip
As a consequence of the structure of this construct, type constraints
must be respected in order to have the whole expression well-typed:
\begin{itemize}
  \item The type of the examined expression must be compatible with the
    type of the patterns.
  \item By trivial consequence, all the patterns must have compatible
    types.
  \item The types of all the result expressions in the rightmost parts
    of the cases must be compatible.
\end{itemize}



\medskip
In addition to this mulmti-branches conditional feature, the
{\tt match-with} construct provides {\bf pattern matching}. In
patterns it is possible to insert variables instead of constant
literals like we did in the example above. If the examined value
``fits'' ({\bf matches}) the pattern, that is has the same structure
for specified constants/sum type constructors, then the case of the
pattern is chosen and the variables of the pattern get bound to the
parts of the examined expression that are ``at the same place'' than
these variables. For example:
{\scriptsize
\begin{lstlisting}
let e = ... in
...
let x =
  match e with
   | (0, 0, 0) -> 1
   | (0, x, y) -> x + y
   | (1, 1, x) -> x
   | (x, y, z) -> x + y + z
...
\end{lstlisting}
}
According the the typechecking mechanism, the examined expression
{\tt e} must have here type {\tt (int * int * int)}. The first pattern
will be chosen if {\tt e} is {\bf equal to} the tuple $(0, 0, 0)$. We
say here ``equal'' since there is no variable in the pattern, hence
the only way to fit the pattern is to be simply equal. If this pattern
is not fitted, the we examine the second pattern. It will be chosen if
{\tt e} has a $0$ as first component and any integer for the second
and the third ones. In this case, the result value will be the
evaluation of the expression {\tt x + y} where x will be bound to the
effective second component of the value of {\tt e} and {\tt y} will be
bound to its third component. We can notice that no ``catch-all pattern''
is needed since the enumerated patterns cover all the possible values
of tuples with 3 components (look at the last pattern that do not put
any constraint on the tuple components, hence will catch all the
remaining cases).

The previous example used tuples as matched expression and patterns,
but patterns also contain sum type constructors, hence allowing to
``match'' on any sum type structure. For example:
{\scriptsize
\begin{lstlisting}
type t =
  | A
  | B (int)
  | C (int * int)
;;
...
let e = ... in
let x =
  match e with
   | A -> 0
   | B (3) -> 4
   | B (_) -> 10
   | C (x, 10) -> 5
   | C (_, y) -> y
;;
\end{lstlisting}
}
This example shows different cases following the structure of the type
{\tt t}. It can be noticed that the ``catch-all'' pattern can be used
inside compound patterns. In fact, the ``catch-all'' pattern acts like
a variable that would never be used in the rightmost part of the
case. It is however preferable to use ``{\tt \_}'' instead of a
variable since \ocaml\ generates warning for unused variables and the
generated \ocaml\ code generated by \focal\ will not change unused
variables into ``{\tt \_}''s.


\smallskip
Patterns also allow to match record values
(c.f. \ref{record-expression}), i.e. to match on values of the fields:
{\scriptsize
\begin{lstlisting}
type t = { name : string ; birth : int } ;;
let r = ... in
let x =
  match r with
   | { name = "Benjamin" } -> ...
   | { name = n ; birth = 2003 } -> ...
   | { name = n } -> ...
\end{lstlisting}
}
In such a pattern, fields not specified are considered as
``catch-all'' patterns. Hence, the last case catches all the record
values not caught before since the field {\tt name}'s value is bound
to a variable (so, non constraint is put on it) and the field
{\tt birth} is absent (so, considered as {\tt birth = \_}).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Application expression}
\label{function-application}
\index{functional value}
We previously saw that the {\tt let-in} construct allows to define
functions by binding an identifier to a functional value. Using a
function by providing it effective arguments to get its result value
is called {\bf application}. Hence, in an application there are 2
distinct parts: the applicative part that must be a an expression
leading to a functional value and the effective arguments that are
expressions whose value will be provided to the function to make its
computation. The syntax for application is simply the juxtaposition of
the applicative expression and the comma-separated expressions used as
arguments embraced by parentheses:
{\scriptsize
\begin{lstlisting}
let f (x) = ... in
let g (x, y) = ... f (y) ... in
g (f (3), 4)
...
\end{lstlisting}
}
Like described in \ref{functional-value}, during an application,
arguments expressions to provide to the function are evaluated first
(however, there is no specification whether left to right or right to
left) then the body of the function get evaluated ``replacing'' each
occurrence of each parameter by its related value among those
effectively passed in the application. For instance, having the
following function and application:
{\scriptsize
\begin{lstlisting}
let g (x, y) = (y, x) in
g (true, 1)
\end{lstlisting}
}
during the application {\tt g} is evaluated as a {\bf functional value},
{\tt true} is evaluated into the boolean {\bf value} $true$, {\tt 1}
into the integer {\bf value} $1$. The next step of application is then
to evaluate the body of the {\bf functional value} of {\tt f},
replacing the formal parameter {\tt x} by the effective argument
$true$ and {\tt y} by $1$. The body of {\tt f} creates a tuple from
its 2 arguments, putting {\tt y} in the first component and {\tt x} in
the second. Hence, the result of the application is the tuple
{\bf value} $(1,\ true)$.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Operator application expressions}
Since operators are designed to be used in infix or prefix position,
application of operators consists simply in providing arguments
according to the operator infix/prefix nature. For infix operators,
arguments are on left and right sides. For prefix operators, the
operator is in front of the argument expression.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Record expression}
\label{record-expression}
As introduced in \ref{record-type-definition} about type definitions,
record are defined by labels with their types. Hence, a record
expression follows the same structure, replacing the type expressions
of the definition by value of these types. For instance, assuming the
given record type definition, the following example show a possible
record value: 
{\scriptsize
\begin{lstlisting}
type identity = {
  name : string ;
  birth : int ;
  living : bool
} ;;

...
{ name = "Nobody" ; birth = 42 ; living = false }
...
\end{lstlisting}
}
If the record type definition is in a different compilation unit, you
may qualify the record fields by the ``{\tt\#}'' notation:
{\scriptsize
\begin{lstlisting}
{ my_file#name = "Nobody" ; my_file#birth = 42 ; my_file#living = false }
\end{lstlisting}
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Record expression}
\label{record-clone-expression}
It is sometimes useful to create a new value of record by copying a
few values of an existing one, leaving the other values unchanged. If
the record type definition contains numerous fields, manually copying
the old fields values to create the new record value appears boring
and error prone:
{\scriptsize
\begin{lstlisting}
type t = { a : int ; b : int ; c : int ; d : int ; e : int ; f : int } ;;
...
let v1 = { a = 1 ; b = 2 ; c = 3 d = 4 ; e = 5 ; f = 6 } in
...
let v2 = {
  a = v1.a ; b = v1.b ;
  c = 5 ;  (* Changed value. *)
  d = v1.c ;  (* Indeed, developer mistook, he wanted to write "v1.d". *)
  e = 6 ;  (* Changed value. *)
  f = v1.f } in
...
\end{lstlisting}
}
Instead of manually copy the unchanged fields, \focal\ provides a way
to clone a record value (i.e. to create a {\bf new}, a {\bf fresh}
value from an existing one only specifying the fields whose values
differ from the old record value:
{\scriptsize
\begin{lstlisting}
type t = ... (* Like above. *)
let v1 = ... (* Like above. *)
...
let v2 = { v1 with c = 5 ; e = 6 } in
...
\end{lstlisting}
}
As for other record value expressions, if the record type definition
is in a different compilation unit, you may qualify the record fields
by the ``{\tt\#}'' notation.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Record field access expression}
\label{record-field-access}
Once a record value is created by aggregating value of its fields, it
is possible to recover the value of one field by a dot notation. For
instance, assuming the type definition and record values of the
previous example:
{\scriptsize
\begin{lstlisting}
... t1.a ...
... t2.c ...
\end{lstlisting}
}
respectively get the value of the fields {\tt a} of {\tt v1} and
{\tt c} of {\tt v2}, that is, $1$ and $5$. If the record type
definition is in a different compilation unit, you may qualify the
record fields by the ``{\tt\#}'' notation: {\tt t1.my\_source\#a}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Parenthesised expression}
The parentheses can be used around any expression, to enforce the
associativity or evaluation order of expressions. Simple expressions
(i.e. atomic) can also be parenthesised without changing their
semantics.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Files and uses directives}
\label{file directive}
\focal\ provides 3 directives that are not expressions. This means
that they do not lead to values or computation.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{The {\tt use} directive}
{\color{red}To to}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{The {\tt open} directive}
\index{directive!open}
As previously introduced (c.f. \ref{identifier-scoping-and-open} and
\ref{qualified-name}) the {\tt open} directive loads in the current
name resolution (scoping) environment the definitions of the argument
compilation unit. This prevents the user from having to explicitly
qualify definitions of this unit by the ``{\tt\#}''
notation. Definitions imported by the directive hide (``mask'') those
wearing the same name already defined in the current compilation
unit from the point the directive appears. Remember that it is however
possible to recover them, using the ``{\tt\#}'' notation without
compilation unit name.

This directive is followed by the name of the file to open between
double quotes without the ``.foc'' extension.
{\scriptsize
\begin{lstlisting}
open "sets";;
\end{lstlisting}
}
will load the definitions of the file ``sets.foc'' in the current name
resolution (scoping) environment.

The path of the file is never specified. The file
will be searched in the library search path specified with the
{\tt -I} option (c.f. \ref{compiler-options}).




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{The {\tt coq\_require} directive}
\index{directive!coq\_require}
Some source files of a development may be directly written in \coq\ to
provide external definitions (more detailed further in
\ref{interfacing-other-languages}) to import and use in the
\focal\ source code. In this case, the \coq\ code generated for the
\focal\ source code must be aware of the need to import the external
definitions from the manually written \coq\ file. For this reason, the
\focal\ source must explicitly indicate by the {\tt coq\_require}
directive that it makes references to definitions hosted in this
\coq\ source file. For example, the file ``wellfounded.foc'' of the
standard library needs ``wellfounded\_externals.v'' and signals this
fact in its early lines of code:
{\scriptsize
\begin{lstlisting}
...
open "basics";;
open "sets_orders";;
coq_require "wellfounded_externals";;
...
\end{lstlisting}
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Theorems and proofs}
