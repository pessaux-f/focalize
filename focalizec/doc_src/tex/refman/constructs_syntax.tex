\subsection{Types}
Before dealing with expressions and in general, constructs that allow
to compute, we first examine datatype definitions since to emit a
result an algorithm must manipulate data that have a certain type,
hence must know about their type definitions.

Type definitions allow to build new types or more complex types by
combining previously existing types. They always appear at
``toplevel'', in other words, outside species and collections. Hence
they are a kind of ``global'' definitions that are visible in the
whole compilation unit (and also in other units by using the
{\tt open} directive or by qualifying the type name as described in
\ref{qualified_name}).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Type expressions}
\index{type!expression}
Type definitions require type expressions to build more complex
datatypes. For this reason we present here the shape of type
expressions.

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Type expressions:}
\tau & ::= & lowercase\ ident   & Type constructor \\
     & \mid & uppercase\ ident & Species carrier \\
     & \mid & \terminal{'}lowercase\ ident & Type variable \\
     & \mid & uppercase\ ident
              \terminal{(}\tau \{\terminal{,} \tau\}+\terminal{)} &
               Parametrised type constructor \\
     & \mid & \tau \terminal{\rightarrow} \tau & Functional type \\
     & \mid & \terminal{(}\tau \terminal{*} \tau \{\terminal{*}\ \tau\}+\terminal{)} &
               Tuple type \\
     & \mid & \terminal {Self} & Current species carrier \\
     & \mid & \terminal{(}\tau\terminal{)} & Parenthesised type expression
\end{syntax}
\vspace{0.2cm}

A type expression can be a type ``constructor'', i.e. the name given
to a type during its definition. \focal\ provides the basic builtin
types (constructors):
\begin{itemize}
  \item {\tt int} for signed machine integers,
  \item {\tt bool} for boolean values ({\tt true} and {\tt false} that
    are hardwired in the syntax or {\tt True} and {\tt False} that are
    defined in ``basics.foc''),
  \item {\tt float} for floating point numbers,
  \item {\tt unit} for the trivial type whose only value is {\tt ()},
  \item {\tt char} for characters literals,
  \item {\tt string} for strings literals.
\end{itemize}
Types constructors can be parametrised by type expressions separated
by commas and between parentheses. Each type {\bf definition} will
lead to a new type {\bf constructor}.

A type expression can also denote the carrier of a species by using
the name of the species. In this case, they always look like
capitalized name since species names are so. The special case of
{\tt Self} represents the carrier of the current species. Hence,
obviously {\tt Self} is only bound in the scope of a species.

Type expressions representing functions types are written using the
arrow notation ({\tt ->} in which the type of the argument of the
function is the left type expression and its return type is right
one. As usual in functional languages, a function with several (say
$n$) arguments is considered a function with {\bf 1} argument
returning a function with $n-1$ arguments. Hence,
{\tt int -> int -> bool} is the type of a function taking 2 integers
and returning a boolean.

\focal\ provides native tuples (generalisation of pairs). The type of
a tuple is the type of each of its components separated by a *
character and surrounded by parentheses. Hence,
{\tt (int * bool * string) } is the type of triplets whose first
component is an integer, second component is a boolean and third
component is a string.

Finally, type expression can be written between parentheses without
change of their semantics.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Type definitions}
\index{type!definition}
As stated before, ach type {\bf definition} will lead to a new type
{\bf constructor} that will be available among the constructors that
can be used in type {\bf expressions}. Hence, defining a type is the
way to give a name to a new type structure. \focal\ proposes 3 kinds
of type definitions: sum types, aliases and record types.




\paragraph{Sum types} provides the way to create new {\bf values} that
will belong to the same {\bf type}. Like {\tt 1} or {\tt 42} are
{\bf values} of {\bf type} {\tt int}, one may want to have {\tt Red},
{\tt Blue} and {\tt Green} as the {\bf only} values of a {\tt color}
type. We says {\bf only} since it means that the created {\tt color}
type will be inhabited only by these 3 (wished) values. To defined
such a type, we itemize its values names (that are always capitalized
identifiers), each one preceded by a ``|'' character :
{\scriptsize
\begin{lstlisting}
type color =
  | Red
  | Blue
  | Green
;;
\end{lstlisting}
}
Note that the first ``|'' character is required: it is not a
separator. This espacially means that when writing a sum type
definition on one line, the first ``|'' must be written:
{\scriptsize
\begin{lstlisting}
type color = | Red | Blue | Green ;;
\end{lstlisting}
}
Values of a sum type definitions are also called
{\bf sum type constructors} (that must not be confused with
{\bf type constructors} that are the name of a type, here {\tt color}).

It is possible to define {\bf parametrised} sum type constructors. In
this case, the constructors may carry a {\bf value}. For instance,
let's define the type of playing cards as king, queen, jack and simply
numbered cards:
{\scriptsize
\begin{lstlisting}
type card =
  | King
  | Queen
  | Jack
  | Numbered (int)
;;
\end{lstlisting}
}
Hence, the {\tt Numbered} constructor carries the integer value
written on the card. It is possible to parametrise constructors by any
type expression, even recursive.
\index{type!recursive}
For instance, the type of lists of boolean $\times$ integer pairs
could be defined like:
{\scriptsize
\begin{lstlisting}
type b\_i\_list =
  | Empty
  | Cons ((bool * int) * b\_i\_list)
;;
\end{lstlisting}
}
From this type definition, a list is either empty (constructor
{\tt Empty}) or contains one element in head (the first component of
the {\tt Cons} constructor) and a trailing list (the second component
of this constructor).

Like for any type definition, it is possible to parametrise the
{\bf definition}, i.e. create a type with a {\bf type variable} that
can be instanciate by any type expression. For instance, the type
definition of generic (polymorphic) lists may be defined by:
{\scriptsize
\begin{lstlisting}
type list ('a) =
  | Empty
  | Cons ('a * list ('a))
;;
\end{lstlisting}
}
A type variable is writen as an identifier preceded by a {\tt '}
(quote) character. In the above definition, we see that the sum
constructor {\tt Cons} carries a value of type ``unknown'' (of type
``variable'') and the tail of the list, i.e. a value of type
{\tt list} with its parameter instanciated by the same type
variable. This explicitely says that all the elements of such a list
have the same type. It is now possible to use the {\tt list} type in
type {\bf expressions} by providing a type {\bf expression} as
argument of the {\bf type constructor} {\tt list}. For instance,
{\tt list (int)} is the type of lists containing integers,
{\tt list (list (char))} is the type of lists containing lists of
characters.



\paragraph{Aliases} provide a way to create type abbreviations. It it
common to manipulate large {\bf type expressions} like for instance, a
tuple of 5 components: {\tt (int * int * int * int * int)}. However,
is it not handy to always write this expression each time we
manipulate it. Moreover, several kind of information can be
represented by such a tuple. For instance, x, y, z 3D-coordinates and
temperature and presure. For another example, year, month, day, hours,
minutes. In these two cases, the manipulated type expression will be
the same and can' be easily differenciated. Type aliases allows to
give a name to a (complex) type expression, for sake of redeability or
to shorten the code. Example:
{\scriptsize
\begin{lstlisting}
type experiment\_conditions = (int * int * int * int * int) ;;
type date = (int * int * int * int * int) ;;
\end{lstlisting}
}
In the remaining of the development, the type names
{\tt  experiment\_conditions} and {\tt date} will be known to be
tuples of 5 integers and will be compatible with any other type being
also a tuple of 5 integers. This especially means that a type alias
does not create a really ``new'' type, it only gives a name to a type
expression and this name is type-compatible with any occurrence of the
type expression it is bound to. Obviously, it is possible to use
aliases with and in any type expression, type definition. For
instance:
{\scriptsize
\begin{lstlisting}
type t1 =
 | A
 | B
;;

type t2 = (t1 * bool) ;

type t3 ('a) =
 | C (t2)
 | D ('a)
;;

type t4 = t3 (int * bool) ;;
\end{lstlisting}
}



\paragraph{Record types} provide a way to aggregate data of various
types, a bit like tuples, but naming the components of the group,
instead of differenciating them by their position like in
tuples. Hence, a record type is like the {\tt struct} of C or
Java-like languages. A record is a sequence of names and types between
braces. For example:
{\scriptsize
\begin{lstlisting}
type experiment\_conditions = {
  x : int ;
  y : int ;
  z : int ;
  temperature : int ;
  presure : int
} ;;

type identity = {
  name : string ;
  birth : int ;
  living : bool
} ;;
\end{lstlisting}
}

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Record types definitions:}
field & ::= & ident\ \terminal{:}\ \tau\ \terminal{;} & \\
opt\_params & ::= & \epsilon
    \mid \terminal{(}\ \tau\ \{\terminal{,} \tau \}*\ \terminal{)} & \\
record\_type\_def & ::= &
    \terminal{type}\ ident\ opt\_params\  \terminal{=}
    \ \terminal{\{} field+ \terminal{\}}
\end{syntax}
\vspace{0.2cm}

To create a {\bf value} of a record type, a value of the related
type must be provided for each field of the record.
{\scriptsize
\begin{lstlisting}
{ name = "Alexandre" ; birth = 2003 ; living = true }
\end{lstlisting}
}
Like in tuples, records can mix types of fields. Like for any type
definition, it it possible to have parameterised record types:
{\scriptsize
\begin{lstlisting}
type pair ('a, 'b) = {
  first : 'a ;
  second : 'b
} ;;

type int_bool_pair = pair (int, bool) ;;
\end{lstlisting}
}


\subsection{Carrier (type) definition}

\subsection{Expressions}

\subsection{Value and function definitions}

\subsection{Files and uses directives}

\subsection{Theorems and proofs}
