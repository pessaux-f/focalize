%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Types}
Before dealing with expressions and in general, constructs that allow
to compute, we first examine datatype definitions since to emit a
result an algorithm must manipulate data that have a certain type,
hence must know about their type definitions.

Type definitions allow to build new types or more complex types by
combining previously existing types. They always appear at
``toplevel'', in other words, outside species and collections. Hence
they are a kind of ``global'' definitions that are visible in the
whole compilation unit (and also in other units by using the
{\tt open} directive or by qualifying the type name as described in
\ref{qualified_name}).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Type expressions}
\index{type!expression}
Type definitions require type expressions to build more complex
datatypes. For this reason we present here the shape of type
expressions.

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Type expressions:}
\tau & ::= & lowercase\ ident   & Type constructor \\
     & \mid & uppercase\ ident & Species carrier \\
     & \mid & \terminal{'}lowercase\ ident & Type variable \\
     & \mid & uppercase\ ident
              \terminal{(}\tau \{\terminal{,} \tau\}+\terminal{)} &
               Parametrised type constructor \\
     & \mid & \tau \terminal{\rightarrow} \tau & Functional type \\
     & \mid & \terminal{(}\tau \terminal{*} \tau
              \{\terminal{*}\ \tau\}+\terminal{)} & Tuple type \\
     & \mid & \terminal {Self} & Current species carrier \\
     & \mid & \terminal{(}\tau\terminal{)} & Parenthesised type expression
\end{syntax}
\vspace{0.2cm}

A type expression can be a type ``constructor'', i.e. the name given
to a type during its definition. \focal\ provides the basic builtin
types (constructors):
\begin{itemize}
  \item {\tt int} for signed machine integers,
  \item {\tt bool} for boolean values ({\tt true} and {\tt false} that
    are hardwired in the syntax or {\tt True} and {\tt False} that are
    defined in ``basics.foc''),
  \item {\tt float} for floating point numbers,
  \item {\tt unit} for the trivial type whose only value is {\tt ()},
  \item {\tt char} for characters literals,
  \item {\tt string} for strings literals.
\end{itemize}
Types constructors can be parametrised by type expressions separated
by commas and between parentheses. Each type {\bf definition} will
lead to a new type {\bf constructor}.

A type expression can also denote the carrier of a species by using
the name of the species. In this case, they always look like
capitalized name since species names are so. The special case of
{\tt Self} represents the carrier of the current species. Hence,
obviously {\tt Self} is only bound in the scope of a species.

Type expressions representing functions types are written using the
arrow notation ({\tt ->} in which the type of the argument of the
function is the left type expression and its return type is right
one. As usual in functional languages, a function with several (say
$n$) arguments is considered a function with {\bf 1} argument
returning a function with $n-1$ arguments. Hence,
{\tt int -> int -> bool} is the type of a function taking 2 integers
and returning a boolean.

\focal\ provides native tuples (generalisation of pairs). The type of
a tuple is the type of each of its components separated by a *
character and surrounded by parentheses. Hence,
{\tt (int * bool * string) } is the type of triplets whose first
component is an integer, second component is a boolean and third
component is a string.

Finally, type expression can be written between parentheses without
change of their semantics.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Type definitions}
\index{type!definition}
As stated before, ach type {\bf definition} will lead to a new type
{\bf constructor} that will be available among the constructors that
can be used in type {\bf expressions}. Hence, defining a type is the
way to give a name to a new type structure. \focal\ proposes 3 kinds
of type definitions: sum types, aliases and record types.



\vspace{0.5cm}\noindent{\bf Sum types}

They provide the way to create new {\bf values} that
will belong to the same {\bf type}. Like {\tt 1} or {\tt 42} are
{\bf values} of {\bf type} {\tt int}, one may want to have {\tt Red},
{\tt Blue} and {\tt Green} as the {\bf only} values of a {\tt color}
type. We says {\bf only} since it means that the created {\tt color}
type will be inhabited only by these 3 (wished) values. To defined
such a type, we itemize its values names (that are always capitalized
identifiers), each one preceded by a ``$\mid$'' character :
{\scriptsize
\begin{lstlisting}
type color =
  | Red
  | Blue
  | Green
;;
\end{lstlisting}
}
Note that the first ``$\mid$'' character is required: it is not a
separator. This espacially means that when writing a sum type
definition on one line, the first ``$\mid$'' must be written:
{\scriptsize
\begin{lstlisting}
type color = | Red | Blue | Green ;;
\end{lstlisting}
}
Values of a sum type definitions are built from its
{\bf sum type constructors}, i.e. from the names enumerated in the
definition (that must not be confused with the {\bf type constructor}
that is the name of a type, here {\tt color}). For, instance,
{\tt Red} is a {\bf value} of our type {\tt color}.

It is possible to define {\bf parametrised} sum type constructors. In
this case, the constructors may carry a {\bf value}. For instance,
let's define the type of playing cards as king, queen, jack and simply
numbered cards:
{\scriptsize
\begin{lstlisting}
type card =
  | King
  | Queen
  | Jack
  | Numbered (int)
;;
\end{lstlisting}
}
Hence, the {\tt Numbered} constructor carries the integer value
written on the card. In our example, here are some values of type
{\tt card}: {\tt King}, {\tt (Numbered 4)}, {\tt (Numbered 42)}.

It is possible to parametrise constructors by any type expression,
even recursive.
\index{type!recursive}
For instance, the type of lists of boolean $\times$ integer pairs
could be defined like:
{\scriptsize
\begin{lstlisting}
type b_i_list =
  | Empty
  | Cons ((bool * int) * b_i_list)
;;
\end{lstlisting}
}
From this type definition, a list is either empty (constructor
{\tt Empty}) or contains one element in head (the first component of
the {\tt Cons} constructor) and a trailing list (the second component
of this constructor). Example of value of type {\tt b\_i\_list}:
{\tt Cons ((false, 2), (Cons ((true, 1), Empty)))}. This list's length
is 2 and its elements are {\tt (false, 2)} followed by
{\tt (true, 1)}.

Like for any type definition, it is possible to parametrise the
{\bf definition}, i.e. create a type with a {\bf type variable} that
can be instanciate by any type expression. For instance, the type
definition of generic (polymorphic) lists may be defined by:
{\scriptsize
\begin{lstlisting}
type list ('a) =
  | Empty
  | Cons ('a * list ('a))
;;
\end{lstlisting}
}
A type variable is writen as an identifier preceded by a {\tt '}
(quote) character. In the above definition, we see that the sum
constructor {\tt Cons} carries a value of type ``unknown'' (of type
``variable'') and the tail of the list, i.e. a value of type
{\tt list} with its parameter instanciated by the same type
variable. This explicitely says that all the elements of such a list
have the same type. It is now possible to use the {\tt list} type in
type {\bf expressions} by providing a type {\bf expression} as
argument of the {\bf type constructor} {\tt list}. For instance,
{\tt list (int)} is the type of lists containing integers,
{\tt list (list (char))} is the type of lists containing lists of
characters.

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Sum types definitions:}
opt\_params & ::= & \epsilon
    \mid \terminal{(}\ \terminal{'}ident \{\terminal{,} \terminal{'}ident \}*
    \ \terminal{)} & \\
opt\_args & ::= & \epsilon
    \mid \terminal{(}\ \tau\ \{\terminal{,} \tau \}*\ \terminal{)} & \\
constructor & ::= & \terminal{\mid}\ uident\ opt\_args & \\
sum\_type\_def & ::= &
    \terminal{type}\ ident\ opt\_params\  \terminal{=} \  constructor+
\end{syntax}
\vspace{0.2cm}



\vspace{0.5cm}\noindent {\bf Aliases}

They provide a way to create type abbreviations. It it common to
manipulate large {\bf type expressions} like for instance, a tuple of
5 components: {\tt (int * int * int * int * int)}. However, is it not
handy to always write this expression each time we manipulate
it. Moreover, several kind of information can be represented by such a
tuple. For instance, x, y, z 3D-coordinates and temperature and
presure. For another example, year, month, day, hours, minutes. In
these two cases, the manipulated type expression will be the same and
can' be easily differenciated. Type aliases allows to give a name to a
(complex) type expression, for sake of redeability or to shorten the
code. Example:
{\scriptsize
\begin{lstlisting}
type experiment\_conditions = (int * int * int * int * int) ;;
type date = (int * int * int * int * int) ;;
\end{lstlisting}
}

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Alias type definitions:}
alias\_type\_def & ::= & \terminal{type}\ ident\ \terminal{=}\ \tau
\end{syntax}
\vspace{0.2cm}

In the remaining of the development, the type names
{\tt  experiment\_conditions} and {\tt date} will be known to be
tuples of 5 integers and will be compatible with any other type being
also a tuple of 5 integers. This especially means that a type alias
does not create a really ``new'' type, it only gives a name to a type
expression and this name is type-compatible with any occurrence of the
type expression it is bound to. Obviously, it is possible to use
aliases with and in any type expression, type definition. For
instance:
{\scriptsize
\begin{lstlisting}
type t1 =
 | A
 | B
;;

type t2 = (t1 * bool) ;

type t3 ('a) =
 | C (t2)
 | D ('a)
;;

type t4 = t3 (int * bool) ;;
\end{lstlisting}
}



\vspace{0.5cm}\noindent {\bf Record types}

They provide a way to aggregate data of various types, a bit like
tuples, but naming the components of the group, instead of
differenciating them by their position like in tuples. Hence, a record
type is like the {\tt struct} of C or Java-like languages. A record is
a sequence of names and types between braces. For example:
{\scriptsize
\begin{lstlisting}
type experiment_conditions = {
  x : int ;
  y : int ;
  z : int ;
  temperature : int ;
  presure : int
} ;;

type identity = {
  name : string ;
  birth : int ;
  living : bool
} ;;
\end{lstlisting}
}

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Record types definitions:}
field & ::= & ident\ \terminal{:}\ \tau\ \terminal{;} & \\
opt\_params & ::= & \epsilon
    \mid \terminal{(}\ \terminal{'}ident \{\terminal{,} \terminal{'}ident \}*
    \ \terminal{)} & \\
record\_type\_def & ::= &
    \terminal{type}\ ident\ opt\_params\  \terminal{=}
    \ \terminal{\{} field+ \terminal{\}}
\end{syntax}
\vspace{0.2cm}

To create a {\bf value} of a record type, a value of the related
type must be provided for each field of the record.
{\scriptsize
\begin{lstlisting}
{ name = "Alexandre" ; birth = 2003 ; living = true }
\end{lstlisting}
}
Like in tuples, records can mix types of fields. Like for any type
definition, it it possible to have parameterised record types:
{\scriptsize
\begin{lstlisting}
type pair ('a, 'b) = {
  first : 'a ;
  second : 'b
} ;;

type int_bool_pair = pair (int, bool) ;;
\end{lstlisting}
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Carrier (type) definition}
As previously introduced (c.f. \ref{rep-is-method}) the carrier is a
special kind of method of species that describes the internal
data structure the species manages. Hence, it is a
special {\bf type definition}, more accurately a
{\bf alias type definition}. This means that a carrier {\bf does not
define a new type}, it only ``assign'' the carrier a {\bf type
expression} representing the species ``internal state''. Moreover,
like for any other methods (c.f. \ref{no-polymorphism-for-methods}),
the carrier must not be polymorphic. This means that is can't contain
type variables. Defining a species carrier is simply done by adding
the {\tt rep} method:
{\scriptsize
\begin{lstlisting}
open "basics" ;;

species IntPair =
  rep = (int * int) ;
end ;;
\end{lstlisting}
}
Hence, the method {\tt rep} defines the type {\tt Self}'s structure.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Expressions}
\label{expressions}
Expressions are constructs of the language that are evaluated into a
{bf value} of a certain {\bf type}. Hence values and types are not at
the same level. Types serve to classify values into categories.
Although proofs may contain expressions, we will not describe the part
of \focal\ dealing with them in this section. We will take care of
them in a next section, in \ref{making-proofs}. In effect, proofs are
not expressions and live at another level. The reason is that proofs
do not lead to \focal\ values.

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Expressions:}
exp & ::= & integer\_literal & \\
    &     & \mid\ string\_literal & \\
    &     & \mid\ character\_literal & \\
    &     & \mid\ float\_literal & \\
    &     & \mid\ {\tt true}\ \mid\ {\tt false} & Boolean \\
    &     & \mid\ [[ident] \terminal{\#}]uident & Sum type constructor
                                       or species/collection identifier \\
    &     & \mid\ [\terminal{Self}] \terminal{!} uident &
                       Method of the current species \\
    &     & \mid\ [[ident] \terminal{\#}] [uident \terminal{!}] lident & \\
    &     & \mid\ [[ident] \terminal{\#}] [uident \terminal{!}]
               \terminal{(} operator \terminal{)} & Infix or prefix
            operator used in functional position \\
    &     & \mid \terminal{let}\ [\terminal{rec}]\ let\_binding
               \ [\terminal{and}\ let\_binding]* & \\
    &     & \ \ \ \terminal{in}\ exp & \\
    &     & \mid \terminal{if}\ exp\ \terminal{then}\ exp
                 \ \terminal{else}\ exp & Conditional \\
    &     & \mid \terminal{match}\ exp\ \terminal{with}\ match\_binding+ &
                     Pattern matching \\
    &     & \mid exp\ \terminal{(} [exp*] \terminal{)} & Function application \\
    &     & \mid unary\_operator\ exp & Application of unary operator \\
    &     & \mid exp\ binary\_operator\ exp & Application of binary operator \\
    &     & \mid expr\ \terminal{.}[ident\terminal{\#}]lident &
                 Record field access \\
    &     & \mid \terminal{\{}\ record\_field\_value+\ \terminal{\}} &
                                                               Record value \\
    &     & \mid \terminal{\{}\ exp\ \terminal{with}\ record\_field\_value+
                  \ \terminal{\}} & Record value clone \\
    &     & \mid \terminal{(} exp \terminal{)} & Parenthesed expression
\end{syntax}

\begin{syntax}
\syntaxclass{Let bindings:}
let\_binding & ::= & \mid lident\ [\terminal{in}\ type\_expression]
           \ \terminal{=}\ exp & \\
   & ::= & \mid lident\
                \terminal{(}lident\ [\terminal{in} type\_expression] & \\
   &     &      \hspace{1.3cm} \{\terminal{,}lident
                    [\terminal{in} type\_expression]\}* \terminal{)} & \\
   &     &       \ \ \ \ [\terminal{in}\ type\_expression]\ \terminal{=}\ exp &
\end{syntax}

\begin{syntax}
\syntaxclass{Match bindings:}
 match\_binding & ::= &
   \terminal{\mid}\ pattern\ \terminal{-}\/\terminal{>}\ exp &
\end{syntax}

\begin{syntax}
\syntaxclass{Patterns:}
pattern & ::= & integer\_literal & \\
    &     & \mid\ string\_literal & \\
    &     & \mid\ character\_literal & \\
    &     & \mid\ float\_literal & \\
    &     & \mid\ {\tt true}\ \mid\ {\tt false} & Boolean \\
    &     & \mid\ lident & Variable \\
    &     & \mid [[ident] \terminal{\#}]uident & Sum type constructor \\
    &     & \mid \_ & ``Catch-all'' pattern \\
    &     & \mid \terminal{\{}
                   record\_field\_pattern\
                   [\terminal{;}\ record\_field\_pattern]*
                 \terminal{\}} &
\end{syntax}

\begin{syntax}
\syntaxclass{Record field value:}
record\_field\_value & ::= &
     [[ident] \terminal{\#}] lident\ \terminal{=}\ exp &
\end{syntax}
\vspace{0.2cm}

\subsection{Files and uses directives}

\subsection{Theorems and proofs}
