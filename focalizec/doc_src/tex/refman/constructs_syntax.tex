%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Types}
Before dealing with expressions and in general, constructs that allow
to compute, we first examine datatype definitions since to emit a
result an algorithm must manipulate data that have a certain type,
hence must know about their type definitions.

Type definitions allow to build new types or more complex types by
combining previously existing types. They always appear at
``toplevel'', in other words, outside species and collections. Hence
they are a kind of ``global'' definitions that are visible in the
whole compilation unit (and also in other units by using the
{\tt open} directive or by qualifying the type name as described in
\ref{qualified_name}).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Type expressions}
\index{type!expression}
Type definitions require type expressions to build more complex
datatypes. For this reason we present here the shape of type
expressions.

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Type expressions:}
\tau & ::= & lowercase\ ident   & Type constructor \\
     & \mid & uppercase\ ident & Species carrier \\
     & \mid & \terminal{'}lowercase\ ident & Type variable \\
     & \mid & uppercase\ ident
              \terminal{(}\tau \{\terminal{,} \tau\}+\terminal{)} &
               Parametrised type constructor \\
     & \mid & \tau \terminal{\rightarrow} \tau & Functional type \\
     & \mid & \terminal{(}\tau \terminal{*} \tau
              \{\terminal{*}\ \tau\}+\terminal{)} & Tuple type \\
     & \mid & \terminal {Self} & Current species carrier \\
     & \mid & \terminal{(}\tau\terminal{)} & Parenthesised type expression
\end{syntax}
\vspace{0.2cm}

A type expression can be a type ``constructor'', i.e. the name given
to a type during its definition. \focal\ provides the basic builtin
types (constructors):
\begin{itemize}
  \item {\tt int} for signed machine integers,
  \item {\tt bool} for boolean values ({\tt true} and {\tt false} that
    are hardwired in the syntax or {\tt True} and {\tt False} that are
    defined in ``basics.foc''),
  \item {\tt float} for floating point numbers,
  \item {\tt unit} for the trivial type whose only value is {\tt ()},
  \item {\tt char} for characters literals,
  \item {\tt string} for strings literals.
\end{itemize}
Types constructors can be parametrised by type expressions separated
by commas and between parentheses. Each type {\bf definition} will
lead to a new type {\bf constructor}.

A type expression can also denote the carrier of a species by using
the name of the species. In this case, they always look like
capitalized name since species names are so. The special case of
{\tt Self} represents the carrier of the current species. Hence,
obviously {\tt Self} is only bound in the scope of a species.

Type expressions representing functions types are written using the
arrow notation ({\tt ->} in which the type of the argument of the
function is the left type expression and its return type is right
one. As usual in functional languages, a function with several (say
$n$) arguments is considered a function with {\bf 1} argument
returning a function with $n-1$ arguments. Hence,
{\tt int -> int -> bool} is the type of a function taking 2 integers
and returning a boolean.

\focal\ provides native tuples (generalisation of pairs). The type of
a tuple is the type of each of its components separated by a *
character and surrounded by parentheses. Hence,
{\tt (int * bool * string) } is the type of triplets whose first
component is an integer, second component is a boolean and third
component is a string.

Finally, type expression can be written between parentheses without
change of their semantics.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Type definitions}
\index{type!definition}
\label{type-definition}
As stated before, each type {\bf definition} will lead to a new type
{\bf constructor} that will be available among the constructors that
can be used in type {\bf expressions}. Hence, defining a type is the
way to give a name to a new type structure. \focal\ proposes 3 kinds
of type definitions: sum types, aliases and record types.



\vspace{0.5cm}\noindent{\bf Sum types}

They provide the way to create new {\bf values} that
will belong to the same {\bf type}. Like {\tt 1} or {\tt 42} are
{\bf values} of {\bf type} {\tt int}, one may want to have {\tt Red},
{\tt Blue} and {\tt Green} as the {\bf only} values of a {\tt color}
type. We says {\bf only} since it means that the created {\tt color}
type will be inhabited only by these 3 (wished) values. To defined
such a type, we itemize its values names (that are always capitalized
identifiers), each one preceded by a ``$\mid$'' character :
{\scriptsize
\begin{lstlisting}
type color =
  | Red
  | Blue
  | Green
;;
\end{lstlisting}
}
Note that the first ``$\mid$'' character is required: it is not a
separator. This especially means that when writing a sum type
definition on one line, the first ``$\mid$'' must be written:
{\scriptsize
\begin{lstlisting}
type color = | Red | Blue | Green ;;
\end{lstlisting}
}
Values of a sum type definitions are built from its
{\bf sum type constructors}, i.e. from the names enumerated in the
definition (that must not be confused with the {\bf type constructor}
that is the name of a type, here {\tt color}). For, instance,
{\tt Red} is a {\bf value} of our type {\tt color}.

It is possible to define {\bf parametrised} sum type constructors. In
this case, the constructors may carry a {\bf value}. For instance,
let's define the type of playing cards as king, queen, jack and simply
numbered cards:
{\scriptsize
\begin{lstlisting}
type card =
  | King
  | Queen
  | Jack
  | Numbered (int)
;;
\end{lstlisting}
}
Hence, the {\tt Numbered} constructor carries the integer value
written on the card. In our example, here are some values of type
{\tt card}: {\tt King}, {\tt (Numbered 4)}, {\tt (Numbered 42)}.

It is possible to parametrise constructors by any type expression,
even recursive.
\index{type!recursive}
For instance, the type of lists of boolean $\times$ integer pairs
could be defined like:
{\scriptsize
\begin{lstlisting}
type b_i_list =
  | Empty
  | Cons ((bool * int) * b_i_list)
;;
\end{lstlisting}
}
From this type definition, a list is either empty (constructor
{\tt Empty}) or contains one element in head (the first component of
the {\tt Cons} constructor) and a trailing list (the second component
of this constructor). Example of value of type {\tt b\_i\_list}:
{\tt Cons ((false, 2), (Cons ((true, 1), Empty)))}. This list's length
is 2 and its elements are {\tt (false, 2)} followed by
{\tt (true, 1)}.

Like for any type definition, it is possible to parametrise the
{\bf definition}, i.e. create a type with a {\bf type variable} that
can be instantiate by any type expression. For instance, the type
definition of generic (polymorphic) lists may be defined by:
{\scriptsize
\begin{lstlisting}
type list ('a) =
  | Empty
  | Cons ('a * list ('a))
;;
\end{lstlisting}
}
A type variable is written as an identifier preceded by a {\tt '}
(quote) character. In the above definition, we see that the sum
constructor {\tt Cons} carries a value of type ``unknown'' (of type
``variable'') and the tail of the list, i.e. a value of type
{\tt list} with its parameter instantiated by the same type
variable. This explicitly says that all the elements of such a list
have the same type. It is now possible to use the {\tt list} type in
type {\bf expressions} by providing a type {\bf expression} as
argument of the {\bf type constructor} {\tt list}. For instance,
{\tt list (int)} is the type of lists containing integers,
{\tt list (list (char))} is the type of lists containing lists of
characters.

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Sum types definitions:}
opt\_params & ::= & \epsilon
    \mid \terminal{(}\ \terminal{'}ident \{\terminal{,} \terminal{'}ident \}*
    \ \terminal{)} & \\
opt\_args & ::= & \epsilon
    \mid \terminal{(}\ \tau\ \{\terminal{,} \tau \}*\ \terminal{)} & \\
constructor & ::= & \terminal{\mid}\ uident\ opt\_args & \\
sum\_type\_def & ::= &
    \terminal{type}\ ident\ opt\_params\  \terminal{=} \  constructor+
\end{syntax}
\vspace{0.2cm}



\vspace{0.5cm}\noindent {\bf Aliases}

They provide a way to create type abbreviations. It it common to
manipulate large {\bf type expressions} like for instance, a tuple of
5 components: {\tt (int * int * int * int * int)}. However, is it not
handy to always write this expression each time we manipulate
it. Moreover, several kind of information can be represented by such a
tuple. For instance, x, y, z 3D-coordinates and temperature and
pressure. For another example, year, month, day, hours, minutes. In
these two cases, the manipulated type expression will be the same and
can' be easily differentiated. Type aliases allows to give a name to a
(complex) type expression, for sake of readability or to shorten the
code. Example:
{\scriptsize
\begin{lstlisting}
type experiment\_conditions = (int * int * int * int * int) ;;
type date = (int * int * int * int * int) ;;
\end{lstlisting}
}

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Alias type definitions:}
alias\_type\_def & ::= & \terminal{type}\ ident\ \terminal{=}\ \tau
\end{syntax}
\vspace{0.2cm}

In the remaining of the development, the type names
{\tt  experiment\_conditions} and {\tt date} will be known to be
tuples of 5 integers and will be compatible with any other type being
also a tuple of 5 integers. This especially means that a type alias
does not create a really ``new'' type, it only gives a name to a type
expression and this name is type-compatible with any occurrence of the
type expression it is bound to. Obviously, it is possible to use
aliases with and in any type expression, type definition. For
instance:
{\scriptsize
\begin{lstlisting}
type t1 =
 | A
 | B
;;

type t2 = (t1 * bool) ;

type t3 ('a) =
 | C (t2)
 | D ('a)
;;

type t4 = t3 (int * bool) ;;
\end{lstlisting}
}



\vspace{0.5cm}\noindent {\bf Record types}

They provide a way to aggregate data of various types, a bit like
tuples, but naming the components of the group, instead of
differentiating them by their position like in tuples. Hence, a record
type is like the {\tt struct} of C or Java-like languages. A record is
a sequence of names and types between braces. For example:
{\scriptsize
\begin{lstlisting}
type experiment_conditions = {
  x : int ;
  y : int ;
  z : int ;
  temperature : int ;
  pressure : int
} ;;

type identity = {
  name : string ;
  birth : int ;
  living : bool
} ;;
\end{lstlisting}
}

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Record types definitions:}
field & ::= & ident\ \terminal{:}\ \tau\ \terminal{;} & \\
opt\_params & ::= & \epsilon
    \mid \terminal{(}\ \terminal{'}ident \{\terminal{,} \terminal{'}ident \}*
    \ \terminal{)} & \\
record\_type\_def & ::= &
    \terminal{type}\ ident\ opt\_params\  \terminal{=}
    \ \terminal{\{} field+ \terminal{\}}
\end{syntax}
\vspace{0.2cm}

To create a {\bf value} of a record type, a value of the related
type must be provided for each field of the record.
{\scriptsize
\begin{lstlisting}
{ name = "Alexandre" ; birth = 2003 ; living = true }
\end{lstlisting}
}
Like in tuples, records can mix types of fields. Like for any type
definition, it it possible to have parametrised record types:
{\scriptsize
\begin{lstlisting}
type pair ('a, 'b) = {
  first : 'a ;
  second : 'b
} ;;

type int_bool_pair = pair (int, bool) ;;
\end{lstlisting}
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Carrier (type) definition}
As previously introduced (c.f. \ref{rep-is-method}) the carrier is a
special kind of method of species that describes the internal
data structure the species manages. Hence, it is a
special {\bf type definition}, more accurately a
{\bf alias type definition}. This means that a carrier {\bf does not
define a new type}, it only ``assign'' the carrier a {\bf type
expression} representing the species ``internal state''. Moreover,
like for any other methods (c.f. \ref{no-polymorphism-for-methods}),
the carrier must not be polymorphic. This means that is can't contain
type variables. Defining a species carrier is simply done by adding
the {\tt rep} method:
{\scriptsize
\begin{lstlisting}
open "basics" ;;

species IntPair =
  rep = (int * int) ;
end ;;
\end{lstlisting}
}
Hence, the method {\tt rep} defines the type {\tt Self}'s structure.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Expressions}
\label{expressions}
Expressions are constructs of the language that are evaluated into a
{bf value} of a certain {\bf type}. Hence values and types are not at
the same level. Types serve to classify values into categories.
Although proofs may contain expressions, we will not describe the part
of \focal\ dealing with them in this section. We will take care of
them in a next section, in \ref{making-proofs}. In effect, proofs are
not expressions and live at another level. The reason is that proofs
do not lead to \focal\ values.

\vspace{0.2cm}
\begin{syntax}
\syntaxclass{Expressions:}
exp & ::= & integer\_literal & \\
    &     & \mid\ string\_literal & \\
    &     & \mid\ character\_literal & \\
    &     & \mid\ float\_literal & \\
    &     & \mid\ {\tt true}\ \mid\ {\tt false} & Boolean constant \\
    &     & \mid\ [[ident] \terminal{\#}]uident & Sum type constructor
                                       or species/collection identifier \\
    &     & \mid\ [\terminal{Self}] \terminal{!} uident &
                       Method of the current species \\
    &     & \mid\ [[ident] \terminal{\#}] [uident \terminal{!}] lident &
               Method from specified species/collection \\
    &     & \mid\ [[ident] \terminal{\#}] [uident \terminal{!}]
               \terminal{(} operator \terminal{)} & Infix or prefix
            operator used in functional position \\
    &     & \mid \terminal{let}\ [\terminal{rec}]\ let\_binding
               \ \{\terminal{and}\ let\_binding \}* &  Let bound definition \\
    &     & \ \ \ \terminal{in}\ exp & \\
    &     & \mid \terminal{if}\ exp\ \terminal{then}\ exp
                 \ \terminal{else}\ exp & Conditional \\
    &     & \mid \terminal{match}\ exp\ \terminal{with}\ match\_binding+ &
                     Pattern matching \\
    &     & \mid exp\ \terminal{(} [exp*] \terminal{)} & Function application \\
    &     & \mid unary\_operator\ exp & Application of unary operator \\
    &     & \mid exp\ binary\_operator\ exp & Application of binary operator \\
    &     & \mid expr\ \terminal{.}[ident\terminal{\#}]lident &
                 Record field access \\
    &     & \mid \terminal{\{}\ record\_field\_value & Record value \\
    &     &     \hspace{0.6cm}  \{\ \terminal{;}\ record\_field\_value\ \}+
                \ \terminal{\}} & \\
    &     & \mid \terminal{\{}\ exp\ \terminal{with}\ record\_field\_value &
                  Record value clone \\
    &     &      \hspace{1.0cm}  \{\ \terminal{;}\ record\_field\_value\ \}+
                  \ \terminal{\}} & \\
    &     & \mid \terminal{(} exp \terminal{)} & Parenthesised expression
\end{syntax}

\begin{syntax}
\syntaxclass{Record field value:}
record\_field\_value & ::= &
     [[ident] \terminal{\#}] lident\ \terminal{=}\ exp &
\end{syntax}

\begin{syntax}
\syntaxclass{Let bindings:}
let\_binding & ::= & \mid lident\ [\terminal{in}\ type\_expression]
           \ \terminal{=}\ exp & Definition without parameter \\
   & ::= & \mid lident\
                \terminal{(}lident\ [\terminal{in}\ type\_expression] &
                 Definition with parameter(s) \\
   &     &      \hspace{1.3cm} \{\ \terminal{,}\ lident
                  \ [\terminal{in}\ type\_expression]\}* \terminal{)} & \\
   &     &       \ \ \ \ [\terminal{in}\ type\_expression]\ \terminal{=}\ exp &
\end{syntax}

\begin{syntax}
\syntaxclass{Match bindings:}
 match\_binding & ::= &
   \terminal{\mid}\ pattern\ \terminal{-}\/\terminal{>}\ exp &
\end{syntax}

\begin{syntax}
\syntaxclass{Patterns:}
pattern & ::= & integer\_literal & \\
    &     & \mid\ string\_literal & \\
    &     & \mid\ character\_literal & \\
    &     & \mid\ float\_literal & \\
    &     & \mid\ {\tt true}\ \mid\ {\tt false} & Boolean constant \\
    &     & \mid\ lident & Variable \\
    &     & \mid [[ident] \terminal{\#}]uident & 0-ary sum type constructor \\
    &     & \mid [[ident] \terminal{\#}]uident
               \ \terminal{(}pattern \{\terminal{,}\ pattern\}*\terminal{)}&
               N-ary sum type constructor \\
    &     & \mid \_ & ``Catch-all'' pattern \\
    &     & \mid \terminal{\{}
                   record\_field\_pattern\
                   \{ \terminal{;}\ record\_field\_pattern \}*
                 \terminal{\}} & Record \\
    &     & \mid \terminal{(} pattern\ \{ \terminal{,}\ pattern\}+
                  \terminal{)} & Tuple \\
    &     & \mid \terminal{(} pattern \terminal{)} & Parenthesised pattern
\end{syntax}

\begin{syntax}
\syntaxclass{Record field pattern:}
record\_field\_pattern & ::= &
     [[ident] \terminal{\#}] lident\ \terminal{=}\ lident &
\end{syntax}
\vspace{0.2cm}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Literal expressions}
The five literal expressions (integer, string, character, float and
boolean) are evaluated into the constant represented by the literal.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Sum type constructor expressions}
We presented in section \ref{type-definition} the way to define sum
types. We saw that {\bf values} of such a {\bf type} are built using
its constructors.

Hence, for constructors with no argument, the constructor itself is an
expression that gets evaluated in a value wearing the same
name.

For constructors with parameters, a value is created by evaluating an
expression applying the constructor to as many expressions as the
constructor's arity. Obviously, sub-expressions used as arguments of
the constructor must we well-typed according to the type of the
constructor. The obtained value, after evaluation, is written by the
name of the constructor followed by the tuple of values provided as
arguments. For instance, with the following type definition:
{\scriptsize
\begin{lstlisting}
type t =
  | A
  | B (int * bool)
;;
\end{lstlisting}
}
the expression {\tt A} is evaluated into $A$, the expression
{\tt B ((2 + 3), true)} is evaluated into the value $B (5, true)$.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Identifier expressions}
\label{identifier-expressions}
An identifier expression (also called ``variable'') is evaluated into
the value bound to this variable. A variable is said {\bf bound} by
its definition, i.e. the construct that assigned a value to it. In
\focal\, there a three ways to bind a variable:
\begin{itemize}
  \item By a {\tt let-in} construct,
  \item By a toplevel definition ({\tt let} or {\tt theorem}),
  \item by a method definition,
  \item by a pattern inside a {\tt match-with} construct,
  \item or by a function definition where parameters are referenced as
    variables.
\end{itemize}
Each of these cases will be described in their related
section. Assuming a variable {\tt v} was bound to the result
{\bf value} of the computation of the {\bf expression} {\tt 2 + 5},
then each occurrence of {\tt v} in a expression will be ``replaced''
by 7 in this expression. This is basically the principle of by-value
evaluation.
\index{functional value}
Like in any functional language, a function definition binds an
identifier to a value functional value that is the evaluation of the
function's body expression. Such a value is slightly different from
other ones since it embeds both the code of the function (i.e. a kind
of evaluation of its body expression) and its environment (i.e. bound
variable present in the scope of the function). This closure will be
kept untouched until it appears in a functional application
expression as described further in \ref{function-application}.



\medskip
Identifiers forms differ depending on the class of entity they refers
to. In the simplest form, an identifier expression is a lowercase
identifier. The \focal\ compiler will determine its definition from
the current scoping context.
\index{name!resolution}
\index{name!qualification}
\index{scoping}
It searches for the closest definition with this name, starting by the
local variables present in the current definition (i.e. formal
parameters if in a function and {\tt let-in} and {\tt match-with}
bound identifiers). If no variable definition with this name is found,
the search goes on among the methods of the current species. If a
method is found with this name, it will be retained, otherwise it
searches among the past toplevel definitions of the current
compilation unit.
\index{directive!open} If no suitable definition is found, then the
ones imported by the {\tt open} directives are examined to find one
with the searched name. Finally if no definition is found, the
identifier is reported unbound by an error message. Note that
{\tt open} directive may arise anywhere at toplevel in the source
code. Hence, the order of search between the current file's toplevel
definitions and the imported ones by {\tt open} is not really
separated: the name resolver looks for the most recent definition
considering that the toplevel definitions and the imported ones are
ordered according to the apparition of the effective definitions in
the file themselves and the imported ones. In other words, if a
toplevel definition exists for an entity {\tt foo}, if later an
{\tt open} directive imports another {\tt foo}, then this last one
will be the remained one.



\medskip
Identifiers can manually disambiguated in term of compilation unit
location using the sharp (\#) notation as explained in
\ref{qualified_name}.



\medskip
\index{method!qualification}
As presented in \ref{method-qualification}, species methods
identifiers are made explicit using the ``!'' notation. The notation
{\tt Spe!meth} stands for ``the method {\tt meth} of the species
{\tt Spe}''. By extension, {\tt !meth} stands for the method
{\tt meth} of the current species. It is possible to make explicit
{\tt Self} in the naming scheme using the syntax {\tt Self!meth}. This
last point could be useful in the case where a more recent local
identifier would exist in the scope of the current definition, hiding
a method of our species:
{\scriptsize
\begin{lstlisting}
species S =
  let m (x in ...) = ... ;
  let n (y in ...) =
    ...
    let m = ... in
    (* Want to call the *method* "m" with argument "m" !!! *)
    !m (m) ;
end ;;
\end{lstlisting}
}

Hence, the name resolution mechanism allows to omit the ``!'' but
making it explicit can help for conflicts resolution. Moreover, when
invoking species parameters' methods, the name resolution never
searches among methods of species parameters, hence the explicit ``!''
notation is required.

As the grammar shows, name qualification by compilation unit and
hosting species are not incompatible. We can build identifiers like
{\tt my\_file\#My\_species!my\_method} to refer to the method
{\tt my\_method} hosted in the species {\tt My\_species} located in
the \focal\ source file ``my\_file.foc''. These two disambiguation
means are orthogonal.



\medskip
Finally, infix/postfix operators can be used as regular
identifiers. Usually, an operator is syntactically used according to
it prefix or infix nature. For instance, the binary {\tt +} operator
is used in forms like {\tt x + 4}, the unary operator {\tt $\sim$} is
used in {\tt $\sim$ x}. \focal\ allows to make them visible like an
identifier of function definition. This allows two things: 
\begin{itemize}
  \item Using them in functional position,
  \item use then as regular identifiers in expressions, for example to
    pass them as arguments of other functions.
\end{itemize}
To get an identifier from an operator, its symbol
(c.f. \ref{extended-identifiers}) must be surrounded by parentheses.
For example: {\tt (\ + )}, {\tt (\ !!== )}.

We clearly advice to add spaces around the operator symbol, to prevent
parentheses from being not separated from it. This especially avoid
the following common and cryptic error:
{\scriptsize
\begin{lstlisting}
...
let (*) (x, y) = ...
\end{lstlisting}
}
where unfortunately {\tt (*} is parsed as a beginning of comment,
leading to a syntax error. The symmetry obviously arises with the
{\tt *)} considered as an end of comment. This pitfall exists indeed
only for the ``{\tt *}-starting'' and ``{\tt *}-ending'' operators,
but a good practice is to have a homogeneous naming scheme, hence
always adding extra spaces.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{tt let-in} expression}
This expression allows binding a value to an identifier in order to
evaluate a trailing expression (the ``body'') where this ident may
appear. During the evaluation of the trailing expression, any
occurence of the bound identifier is ``replaced'' by the value bound
to this identifier. For instance:
{\scriptsize
\begin{lstlisting}
let x = 5 in (x, x)
\end{lstlisting}
}
will bind the evaluation of the {\bf expression} {\tt 5} (i.e. the
integer {\bf value} $5$) to the identifier {\tt x} and then, the
evaluation of the body will lead to the tuple {\bf value} $(5, 5)$.
From the syntax, it is clearly possible to nest {\tt let-in}
constructs:
{\scriptsize
\begin{lstlisting}
let x = 5 in
  let y = (x, x) in
  let z = true in
  (y, z, y, z)
\end{lstlisting}
}
which leads when evaluated to the value
$((5,\ 5),\ true,\ (5,\ 5),\ true)$ of type
{\tt ((int * int) * bool * (int * int) * bool)}.



\medskip
\index{identifier binding}
The notion of ``binding a value to an ident'' is different from the
notion of assignment of imperative languages. In such languages (like
C, Java, Pascal,\ldots) a variable is declared, then a value is
assigned. It is possible to assign several times different values to a
variable. For example in C:
{\scriptsize
\begin{lstlisting}
...
{
  int i ;
  ... ;
  i = 10 ;
  while (i >0) i = i-- ;
}
...
\end{lstlisting}
}
The variable {\tt i} is declared, then assigned the initial value
$10$, then the {\tt while} loop makes it decreasing by successive
assignments.

In a {\tt let-in} binding construct, an identifier is given a value
once: it is impossible to change its ``assigned'' value once it is
bound. We have no assignment construct. Each new definition, binding
an already bound identifier will hide it from the point of this
definition. For instance:
{\scriptsize
\begin{lstlisting}
let x = 5 in
  let y = (x, x) in
  let x = true in
  let z = (x, x) in
  (y, x, y, x)
\end{lstlisting}
}
leads when evaluated to the value $((5,\ 5),\ true, (5,\ 5),\ true)$
of type {\tt ((int * int) * bool * (int * int) * bool)} when it
clearly appears that the first value bound to {\tt x} lasts until it
is bound again: $5$ is used to create {\tt y} but to create
{\tt z}, the used value of {\tt x} is now $true$.



\medskip
The {\tt let-in} construct serves to bind a value to an
identifier. By consequence, it can be used to bind a functional value
to an identifier, hence allowing to define {\bf functions}. The only
difference is that the bound identifier has arguments:
{\scriptsize
\begin{lstlisting}
let f (x, y) = x + y in
f (6, 7)
\end{lstlisting}
}
In this example, we bind {\tt f} to a function with 2 parameters
{\tt x} and {\tt y}, whose body is the addition of these 2
parameters. Then the body of the {\tt let-in} construct uses (by
application as explained further in \ref{application-expression})
this function by passing it 2 effectives arguments {\tt 6} and
{\tt 7} (obviously we expect the result to be $13$).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Application expression}
\label{function-application}
\index{functional value}






\subsection{Files and uses directives}

\subsection{Theorems and proofs}
