\documentclass{book}
\usepackage[francais]{babel}
\usepackage[latin1]{inputenc}
\usepackage{color}
\usepackage{listings}


\input{macros}

%% Pour afficher les listings de manière plus sexy... ;)
\lstdefinelanguage{Focal}
  {morekeywords={property, let, signature, species, is, in, inherits,
      all, exists, rep, if, then, else, proof, of, by, definition,
      collection, implements},
    sensitive=false,
    morecomment=[n]{(*}{*)},  %% Autoriser les nested comments
    morecomment=[n]{(**}{*)},  %% Autoriser les nested comments
    morestring=[b]",
  }

\lstset{
  language=Focal, tabsize=2, frame=none, breaklines=true,
  basicstyle=\ttfamily, framexleftmargin=1mm, xleftmargin=1mm
}


\begin{document}

\chapter{Introduction}

\section{Motivations}
 The \focal\ project was launched in 1998 by T. Hardin and R. Rioboo
\cite{HardinRiobooTSI04} with the 
objective of helping all stages of development of critical software
within safety and security framework, at least when formal methods are
required or chosen. The idea was to elaborate a development
environment able to provide high-level and justified confidence to
users. One the other hand, this system had to remain easy to use by
well-trained engineers.

Currently, \focal\ can be seen as still a prototype of an Integrated
Development Environment (IDE), for a language providing high level
mechanisms such as inheritance, late binding, redefinition,
parametrization, etc.  Confidence in proofs submitted by developers
relies on formal proof verification.

This support language was formally described and designed to provide
means for formal specification by declaring names and
properties. Then, design and implementation can incrementally be done
by adding definitions of functions and proving that the implementation
meets the specification or design requirements. Thus, developing in
\focal\ is a kind of refinement process from  formal model to design
and code, completely done within \focal. Taking the global development
in consideration within a same environment brings some conciseness,
helps documentation and reviewing.

A \focal\ development is organised as a hierarchy that may have
several roots. The upper levels of the hierarchy are built along the
specification stage while the lower ones correspond to
implementation. Each node of the hierarchy corresponds to a progress
toward a complete implementation.  We call here {\em refinement} the
process of building a top-down hierarchy.


\section{Presentation and requirements}
This manual describes the main constructions of the \focal\ language,
as well as the main tools given by the \focal\ environment. Basic
expressions of the \focal\ language are quite similar to the core
expressions of \ocaml\
({\tt http://caml.inria.fr}).A prior knowledge of some functional
languages might be helpful to better understand the \focal's core
language concepts. Last a good knowledge of \coq\ is needed if you
intend to manuall write proofs in \focal\. However, this task may be
helped by the \zenon\ automated theorem prover, as long as the user
write his proofs using the \zenon\ Proof Language embedded in the
\focal\ language.



\section{Output}
As we will see further, a \focal\ development contains both
``computational code'' (i.e. code performing operations that lead to
an effect, a result) and logical properties. When compiled, two
outputs are generated:
\begin{itemize}
  \item The ``computational code'' is compiled into \ocaml\ source
    that can then be compiled with the \ocaml\ compiler to lead to an
    executable binary. In this pass, logical properties are discarded
    since they do not lead to executable code.
  \item Both the ``computational code'' and the logical properties are
    compiled into a \coq\ model. This model can then be sent to the
    \coq\ proof assistant who will verify the consistency of both the
    ``computational code'' and the logical properties (whose proofs
    must be obviously provided) of the \focal\ development. This means
    that the \coq\ code generated is not intended to be used to
    generate an \ocaml\ source code by automated extraction. As stated
    above, the executable generation is prefered using directly the
    generated \ocaml\ code. In this idea, \coq\ acts as an assessor of
    the development instead of a code generator.
\end{itemize}



\section{Basic concepts}
As stated in the introduction, \focal\ language is designed to build
an application step by step, going from very abstract specifications
to the concrete implementation through a hierarchy of structures which
are quite similar to \emph{classes} in an Object-Oriented context.
However, as we will insist later, \focal\ is not Object-Oriented as
C++, Java are. It only owns features ``smelling objects''.

We will now present the basic concepts underlying a
\focal\ development, that is:
\begin{itemize}
  \item Species
  \item Collections
  \item Inheritance
  \item Late-binding
  \item Parameterisation
\end{itemize}

\subsection{Species}
{\bf Species} are the nodes of the \focal\ hierarchy. A species can be
roughly seen as a list of {\bf methods} or {\bf fields}. Hence, a
basic species looks like:
{\scriptsize
\begin{lstlisting}
  species Name =
    ... ;
    ... ;
  end ;;
\end{lstlisting}
}

Species names are always capitalized. Inside the species' body methods
are enumerated. These methods represent the internal datatype of the
species, functions to manipulate this datatype and properties that
must hold in the species.

One important restriction on the type of the methods is that it cannot
be polymorphic. However, \focal\ provides another mechanism to
circumvent this restriction, the parameterisation as explained
further.

A species can hence be seen as an abstract data type. On another hand,
it can be seen as a kind of object, with its internal state (private
variables) and its methods.

There are several kinds of methods:
\begin{itemize}
  \item The {\bf carrier}. This is a type definition that defines the
    type of the values embedded in the species. When ``instanciated'',
    a species will lead to \underline{a value having this type}. This
    especially means that an instanciation of a species is NOT, like
    in Object-Oriented languages an entity embedding data and
    code. The instanciation of a species will be a
    {\underline value}. The carrier is named {\tt rep}. For instance,
    we can define a species that implements couples of native integers
    data structure as:
    {\scriptsize
      \begin{lstlisting}
species IntCouple =
  rep = (int * int) ;
end ;;
      \end{lstlisting}
    }
    Each ``instance'' of this species will encapsulate \underline{1}
    value of type ``couple of integers''. This especially means that
    the species doesn't represent a ``set'' of couples but
    \underline{1} value that has type {\tt (int * int)}.

    The carrier may remain not specified in a species. However, in
    order to finally get a fully defined species that will be
    instanciated, the carrier must be defined \underline{once} at one
    moment (during inheritance).

    In the context of a species, the type denoted by the carrier is
    named {\tt Self}.

  \item {\bf Signatures}. They introduce the ``prototype'' of a
    function, that is provide their type. As a first introduction,
    types expressions are closely like ML-like type expressions.
    A signature can be viewed as de declaration. It specifies the name
    of the operation then its type. For instance:
    {\scriptsize
      \begin{lstlisting}
 species IntStack =
   signature push : int -> Self -> Self ;
 end ;;
      \end{lstlisting}
    }
    As we saw above, {\tt Self} represents the underlying carrier type
    of the current species. Hence an operation pushing an integer onto
    a stack will take as parameter the integer to push, the stack on
    which to push and give back a new configuration of stack (where
    the pushed element is on the top), that is of type {\tt Self}. 

  \item {\bf Functions}. They are operations that are allowed on the
    carrier's elements. They are implementations of signatures,
    providing effective code to execute. A function is introduced by
    the {\tt let} keyword. Recursive functions are introduced by
    {\tt let rec} to make explicit the recursivity. A function can be
    viewed as de definition.
    {\scriptsize
      \begin{lstlisting}
species IntStack =
  rep = int list ;
  let push (v in int, s in Self) = v :: s ;
end ;;
      \end{lstlisting}
    }

  \item {\bf Properties}. They are first order logic propositions
    describing requierements that functions must meet. When stating a
    property, the proof that it holds is not yet provided. However it
    will have to finally to get a species that can be
    instanciated. A property can be viewed as a declaration.
    {\scriptsize
      \begin{lstlisting}
species IntStack =
  ...
  property push_returns_non_empty :
    all v in int, all s in Self, push (v, s) -> ~ is\_empty (s) ;
end ;;
      \end{lstlisting}
    }

    Proofs of properties can be done afterwards using a {\tt proof}
    field in a species.The way to give proofs will be seen further.
    {\scriptsize
      \begin{lstlisting}
species IntStack2 inherits IntStack =
  proof of push_returns_non_empty = ... ;            
end ;;
      \end{lstlisting}
    }

  \item {\bf Theorems}. They are properties with their proofs. In
    fact, when defining a property, we only give the statement of a
    theorem, leaving its proof for later. A theorem can be viewed as a
    definition.
    {\scriptsize
      \begin{lstlisting}
species IntStack =
  ...
  theorem push_returns_non_empty :
    all v in int, all s in Self, push (v, s) -> ~ is_empty
    (s)
  proof : ... ;
end ;;
      \end{lstlisting}
    }

\end{itemize}

\subsection{Collections}
A {\bf collection} is a kind o ``instance'' of a complete species. A
species is said {\em complete} if all its methods are {\em defined},
i.e. have an implementation. In other words this means that there is
no more methods only {\em declared}. This notion implies that:
\begin{itemize}
  \item The carrier is defined by providing a type definition for
    {\tt rep}.
  \item For signature an effective function exists.
  \item For each property, a proof is given.
\end{itemize}

Obviously, it is possible to build a species without signatures and
properties, only providing functions and theorems directly. In this
case, if the carrier is also defined, then the obtained species is
trivially complete.

The important point for a species to be complete is that it can be
turned into effective executable code. In effect, since it is
complete, all its components are known then can be translated into a
target code.

The process of getting this effective executable code is by making a
collection that {\em implements} the species. As a result, one get an
entity whose internal representation has the type of the carrier of
the {\em implemented} species and thatcan be manipulated by the
methods present in this {\em implemented} species. However, the
manupilations will be done via the collection and not anymore via the
species.

\begin{lstlisting}
species Full =
  rep = int ;
  let create_random in Self = random_foc#random_int (42) ;
  let double (x in Self) = x + x ;
  let print (x in Self) = print_int (x) ;
end ;;

collection MyFull_Instance implements Full ;;

let v = Full.create_random ;;
Full.print (v) ;;
let dv = Full.double () ;;
Full.print (dv) ;;
\end{lstlisting}

In the above example, we defined a complete species {\tt Full}. Then
we ``take an instance'' of such a species by creating the collection
{\tt MyFull\_Instance}. We can then use methods of this collection on
values of this collection.

A very important point is that when creating a collection, the
representation of the carrier contained in the ``implemented'' species
gets opaque. In other words, the collection becomes an abstract
datatype. This especially means that it will be impossible to
manipulate values of the carrier without the collection's
methods. Moreover, two collections created from a same species will
not be type-compatible since their carriers got abstracted making now
impossible to ensure a type equivalence.

As a conclusion, collections are the only way to get something that
can be executed since they are the terminal items of a
\focal\ development hierarchy. Since thay are ``terminal'', this also
means that no method can be added to a collection. Moreover, a
collection may not be used to create a new species by inheritance (as
explained in the next section).


\subsection{Interfaces}
The {\bf interface} of a species is the list of the declarations of
its methods. It corresponds to the end-user point of view, who wants
to know which functions he can use, and which properties these
functions have, but doesn't care about the details of the
implementation.

To get the interface of a species, we keep the methods only declared
(as previously stated, signatures and properties) and we forget the
bodies of the defined methods (carrier, functions and theorems).
Discarding the body of the carrier means we consider it was not given
at all, for a function we only keep its type and for a theorem we only
keep its statement. Hence, getting the interface of a species can
roughly be seen as erasing the carrier, turning the functions into
signatures and the theorems into properties.

While this abstraction is easy within programming languages, it is not
always possible when dealing with proofs and properties. Such
problematic species are rejected by \focal\ and will be described
later.




\section{Building species}
In this chapter, we describe the relations between species to build
incrementally more complex species from previously existing ones. Two
mechanisms are available for this purpose: parameterisation and
inheritance.

\subsection{Parameterisation}
\subsection{Collection parameters}
Remember that methods cannot be polymorphics. So it seems difficult to
create a species whose methods work on a carrier having a type
structure in which we would like to have some parts unconstrained. For
example, who to implement the well-known polymorphic type of the
lists ? A list is a structure grouping elements but independently of
the type of these elements. The only constraint is that all elements
have the same type. Hence, a ML-like representation of lists would be
like:
\begin{lstlisting}
type 'a list =
  | Nil
  | Cons of ('a * 'a list)
\end{lstlisting}

The {\tt 'a} is then a parameter of the type and is polymorphic.
In \focal\ we would like to create a species looking like:
\begin{lstlisting}
species List =
  signature nil : Self ;
  signature cons : 'a -> Self -> Self ;
end ;;
\end{lstlisting}

Instead of abstracting the type parameter and leaving it free in the
context of the species, in \focal\ we parameterise the species by
another species:
\begin{lstlisting}
species List (Elem is Basic_object) =
  signature nil : Self ;
  signature cons : Elem -> Self -> Self ;
end ;;
\end{lstlisting}

The {\tt Elem} is called a {\bf collection parameter} and is expected
to be a species having at least the methods of a species called
{\tt Basic\_object}\footnote{{\tt Basic\_object} is a basic and poor
species from the standard library, containing only few methods.} with
the same types. Collection parameters are introduced by the {\tt is}
keyword. When a parameterised species will be used, \focal\ expects it
to be applied to effective collection parameters having compatible
species interfaces. In other words the effective parameter will have
to present an interface with at least the functions of
{\tt Basic\_object} and each method will have to have the same type
than the corresponding one in {\tt Basic\_object}.

Although the parameters looks like a species, why is it called a
{\bf collection parameter} ? The answer to this question is especially
important to understand the programming model in \focal. It is called
a collection because finally, at the terminal nodes of the
development, this parameter will have to be instanciated by a
collection, that is an entity where everything is defined ! Imagine
how to build a code we could execute if a parameter was instanciated
with an entity with methods only declared\ldots

So, even if the collection parameter {\bf is} a species name,
\underline{it will not be a species}. It will be
\underline{a collection having an interface compatible} with the
interface of the species. Hence, declaring a collection parameter for
a parameterised species means providing two things: the name of the
parameter and the signature that the instanciation of this parameter
must satisfy.

It is important to note that we deal with dependent types here, and
therefore that the order of the parameters is important. To define the
type of a parameter, one can use the preceding parameters. For
instance, if we assume that there exists a parameterised species
{\tt List} which declares the basic operations over lists, one can
specify a new species working on couples of value and lists of values
like:
\begin{lstlisting}
species MyCouple (E is Basic_object, L is List (E)) =
  rep = (E * L) ;
  ... ;
end ;;
\end{lstlisting}

The carrier of this species will represent the type
{\tt ('a * ('a list))}. This means that the type of the values in the
first component of the coupel is the same than the type of the
elements of the list in the second component of the couple.

.......

If a collection parameter implements a parameterized species, it must provide an
instantiation for all its parameters. Once again, the preceding parameters can
be used to achieve this purpose.

\subsection{Inheritance and its mechanisms}
\subsubsection{Inheritance}
\subsubsection{Late-binding}


\end{document}
