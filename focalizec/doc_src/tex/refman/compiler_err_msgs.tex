% $Id: compiler_err_msgs.tex,v 1.8 2008-11-21 10:05:43 pessaux Exp $



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Unable to find file 'name' in the search path.}

{\em Description}: The source file made reference to a \focal\ module
$name$ (by the {\tt open} or {\tt use} directives, or by explicit
qualification with the ``\#'' notation but the related
\focal\ interface file was not found in the current libraries search
path.

{\em Hints}: Locate in which directory the missing interface file is
and add this directory to the libraries search path with the {\tt -I}
compiler option.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Invalid or corrupted compiled interface '$name$'.}
{\em Description}: The source file made reference to a \focal\ module
$name$ (by the {\tt open} or {\tt use} directives, or by explicit
qualification with the ``\#'' notation but the related
\focal\ interface file was found with an incorrect format.

{\em Hints}: May be the interface was compiled with another version
of \focal\ or was mangled and you must compile it again with your
current version.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Invalid file extension for '$name$'.}
{\em Description}: The \focal\ compiler expects input files to be
ended by the suffix ``.foc''. If the submitted input file doesn't end
by this suffix, this error message arises with the name, $name$ of the
involved file.

{\em Hints}: Change the extension of the input file name or ensure the
submitted input file name is the correct one.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{System error - $sysmsg$.}
{\em Description}: During the compilation process an error related to
the operating system occurred (I/O error, permission error, file-system
error, \ldots). The original message $sysmsg$ of the system explaining
the problem follows the \focal's message.

{\em Hints}: Consult the original message of the system and get an
appropriate solution depending on this message.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Input file name is already set.}
{\em Description}: The \focal\ compiler only compiles one file at
once. If several files are specified on the command line this message
arises.

{\em Hints}: If several input files are specified, invoke the
compiler once for each separately. Check if among what is considered
as an input file, you didn't forget to put a dash (``-'') character,
hence turning an option into a regular string considered as another
input file name.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{No input file. FoCaL is cowardly and gives up...}
{\em Description}: The \focal\ compiler needs one input file to
compile. If none is supplied, this error message arises.

{\em Hints}: Add the input source file to compile on the command
line.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Lexical error $str$}
{\em Description}: In the currently submitted source file, a sequence
of characters is not recognised as legal according to the
\focal\ programming language legal words structure. The involved
character $str$ follows in the error message.

{\em Hints}: Change the source code at the indicated location.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Syntax error.}
{\em Description}: In the currently submitted source file, a phrase of
the program doesn't follow \focal's syntax.

{\em Hints}: Change the source code at the indicated location. It
sometimes happen that the location gets fuzzy due to the parsing
process. If the error is not immediate to you, think to have a look at
around the specified location. If you still can't find out the error,
have the following emergency process: comment your code and
incrementally uncomment it to find the point where the error appears
without having to search in the whole file. Once the error appears,
have a look at the part of code you uncommented since the previous
successful compilation and try to guess the syntactic cause.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Unclear syntax error $msg$.}
{\em Description}: An error occurred during the syntactic analysis but
was not reported to be due to a syntax non-compliance. This error is
not clearly identified and this message is displayed as post-mortem
report with the exception $msg$ that caused the error.

{\em Hints}: None



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Module '$m$' was "use" several times.}
{\em Description}: Several occurrences of a {\tt use} directive
specify the same module $m$.

{\em Hints}: Remove the spurious occurrences.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Module '$m$' was not declared as "use"}
{\em Description}: {\color{red}To to once ``use'' really works.}

{\em Hints}: {\color{red}To to once ``use'' really works.}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Species application expression expected $n_1$ arguments but
  was provided $n_2$.}
{\em Description}: A species expression (used in species parameter
expression or {\tt inherits} clause) applies a species with $n_1$
argument(s) although its definition declared it as using $n_2$
argument(s).

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Non-logical let must not bind '$ident$' to a property.}
{\em Description}: A {\tt let} construct (not a {\tt logical let})
attempts to bind the identifier $ident$ to a logical expression
although it can only bind it to a computational expression.

{\em Hints}: Source program to fix. May be the {\tt let} should be
turned into a {\tt logical let} if the body of the binding is really a
logical expression.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Delayed termination proof refers to an unknown method
  '$ident$' of the species.}
{\em Description}: A {\tt proof of} clause was found in a species for
the property $ident$ but this property was not found in the species.

{\em Hints}: Source program to fix.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Ambiguous logical expression. Add explicit parentheses to
  associate the $side$ argument of the $/\setminus$ properly.}
{\em Description}: A logical expression contains a
{\tt $/\setminus$} (logical ``and'') with at least one argument being a
{\tt -> } (logical ``implication'') or a {\tt <->} (logical
``equivalence'') without parentheses around the $side$ argument (``left''
or ``right''). Since this is not clear of how to associate, we prefer
to asks the user to explicitly add parentheses.

{\em Hints}: Explicitly add the parentheses to make the association
non-ambiguous.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Ambiguous logical expression. Add explicit parentheses to
  associate the $side$ argument of the {\tt $\setminus/$} properly.}
{\em Description}: A logical expression contains a
{\tt $\setminus/$} (logical ``or'') with at least one argument being a
{\tt -> } (logical ``implication'') or a {\tt <->} (logical
``equivalence'') without parentheses around the $side$ argument (``left''
or ``right''). Since this is not clear of how to associate, we prefer
to asks the user to explicitly add parentheses.

{\em Hints}: Explicitly add the parentheses to make the association
non-ambiguous.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Unbound sum type constructor '$name$'.}
{\em Description}: An identifier representing a sum type constructor
was not found among the available sum type definitions.

{\em Hints}: Source program to fix. Since in core expressions
capitalized identifiers are considered as sum types constructors, may
be you tried to use a capitalized name for one of your variables. In
this case, as any variables, make it starting with a lowercase
letter. Otherwise, may be your type definition is missing or not
reachable in the current scope (missing explicit qualification with
the ``\#'' notation or {\tt open} directive if your type definition is
hosted in another source file).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Unbound record field label '$name$'.}
{\em Description}: An identifier representing a record type label
was not found among the available record type definitions.

{\em Hints}: Source program to fix. May be your type definition is
missing or not reachable in the current scope (missing explicit
qualification with the ``\#'' notation or {\tt open} directive if your
type definition is hosted in another source file).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Unbound identifier '$name$'.}
{\em Description}: An identifier (expected to be bound by a {\tt let},
a pattern of a function parameter declaration) was not found.

{\em Hints}: Source program to fix. May be your definition should be
toplevel and is missing or not reachable in the current scope (missing
explicit qualification with the ``\#'' notation or {\tt open}
directive if your definition is hosted in another source file).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Unbound type '$name$'.}
{\em Description}: The definition of an identifier expected to be a
type constructor was not found.

May be your type definition is missing or not reachable in the current
scope (missing explicit qualification with the ``\#'' notation or
{\tt open} directive if your type definition is hosted in another
source file).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Unbound module '$name$'.}
{\em Description}: A {\tt open} or {\tt use} directive or an explicit
qualification by the ``\#'' notation makes reference to a module that
(interface file) was not found in the current libraries search path.

{\em Hints}: Locate in which directory the missing interface file is
and add this directory to the libraries search path with the {\tt -I}
compiler option.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Unbound species '$name$'.}
{\em Description}: The definition of the species $name$ was not found
in the current scope.

{\em Hints}: May be your species definition is missing or not
reachable in the current scope (missing explicit qualification with
the ``\#'' notation or {\tt open} directive if your type definition is
hosted in another source file).




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Type name '$name$' already bound in the current scope}.
{\em Description}: In a source file it is not allowed to redefine a
type definition. This means that each type name definition must be
unique inside a file. However, it is possible to have several type
definitions with the same names as long as they are in different
source files (even if they are used together via {\tt open} directives
of explicit qualification by the ``\#'' notation).

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Species name '$name$' already bound in the current scope.}
{\em Description}: In a source file it is not allowed to redefine a
species definition. This means that each species name definition must
be unique inside a file. However, it is possible to have several species
definitions with the same names as long as they are in different
source files (even if they are used together via {\tt open} directives
of explicit qualification by the ``\#'' notation).

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Types $t_1$ and $t_2$ are not compatible.}
{\em Description}: The typechecking system detected a type conflict
between two expressions $t_1$ and $t_2$ that were expected to be
type-compatible.

{\em Hints}: Source program to fix. This message sometimes involves
one the the types being {\tt Self}. This is mostly due to an attempt
to use the type structure of {\tt rep} although is turned abstracted
by the collection or parametrisation mechanisms. In this case, ensure
that you are not trying to make assumptions on the type {\tt Self} of
a species parameter or a collection.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Type $t_1$ occurs in $t_2$ and would lead to a cycle.}
{\em Description}: The \focal\ type system does not allow cyclic
types. This especially means that a type expression must not be a
sub-part of itself to prevent cycles.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Type constructor '$name$' used with the different arities
  $n_1$ and $n_2$.}
{\em Description}: A type expression applies a type constructor $name$
to $n_1$ argument(s) although its definition declared it as using $n_2$
argument(s) (or in the other order, depending on the way the error was
detected: in any way the definition and the usage of the type involve
2 different numbers of arguments).

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{No expected argument(s).}
{\em Description}: A type expression applies a type constructor to
arguments although this constructor needs none.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{In field '$name$', type scheme $sch$ contains variables than
  cannot be generalized or is polymorphic.}

{\em Description}: As presented in \ref{no-polymorphism-for-methods},
species methods cannot be polymorphic. The method $name$ has a
polymorphic type scheme shown by $sch$.

{\em Hints}: Source program to fix. You may explicitly add type
annotations (constraints) on the arguments or/and return type of your
method definition.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Sum type constructor '$name$' expected $n_1$ argument but
  was used with $n_2$ argument.}

{\em Description}: The sum type constructor $name$ is used with a bad
number of arguments. It was declared to use $n_1$ arguments but is
used with $n_2$.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Unbound type variable $name$.}

{\em Description}: In a type expression, a type variable $name$ is not
bound.

{\em Hints}: Source program to fix. May be the type expression appears
in a parametrised type definition where you forgot to specify the type
constructor's parameter in head of the definition.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Method '$mname$' multiply defined in species '$sname$'.}

{\em Description}: Like for toplevel definitions, method definitions
inside a species must not bind several time the same name. In the
species $sname$, the methode $mname$ is defined several times.

{\em Hints}: Source program to fix. May be you defined several times
the same method and in this case, remove one of the definitions. Or if
the different occurrences of $mname$ refer to different conceptual
functions, change the names to make them different.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Type constructor '$name$' expected $n_1$ arguments but was
  used with $n_2$ arguments.}

{\em Description}: In a type expression, the type constructor $name$
(not the sum type constructor !) is used with a wrong number of
arguments. It was declared to have $n_1$ arguments but is used with
$n_2$.

{\em Hints}: None.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{In species@ '$sname$', proof of '$pname$' is not related to
  an existing property.}

{\em Description}: In the species $sname$ a delayed proof of the
property $pname$ was found but the statement of this property doesn't
exist in the current species even via inheritance.


{\em Hints}: May be you forgot to write the property, or you mistook
on the property name the proof is related to or you forgot to inherit
from a species having this property.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Carrier 'rep' is multiply defined.}

{\em Description}: In a species, the method {\tt rep} defining the
carrier representation is multiply defined in the body of the species
although at most one definition must be provided.

{\em Hints}: Source program to fix. Remove the spurious definitions.

If the {\tt rep} field is not directly present in the
body, that is because the species inherits from a parent where the
carrier is already defined. In this last case, since the parent's
structure is already established, you must remove the {\tt rep} field
in the species where the error was reported.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Carrier 'rep' is multiply defined by multiple inheritance and
  was formerly found of type $t_1$ and newly found of type $t_2$}.

{\em Description}: In the species, several parents brought by
inheritance several incompatible definitions of the carrier
{\tt rep}. The error message reports $t_1$ and $t_2$, two incompatible
types found for the carrier definition.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{'Self' can't be parametrised by itself.}

{\em Description}: This error appears when {\tt Self} appears as a
species identifier used in a species expression that is a parameter of
the current defined species.
{\color{red} Unsure, not appearing raised anymore. Check if this is
  for further analysis or if it is a remaining spurious stuff.}

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{A "is" parameter can only be a collection identifier.}

{\em Description}: In a species expression, a parametrised species by
an entity parameter ({\tt in}-parameter) is provided an effective
argument that is not a collection identifier.

{\em Hints}: Source program to fix. Although an entity parameter
denotes a {\bf value} (and not a {\bf species} like for
{\tt is}-parameters), this value must have the {\bf type} of a
collection carrier. Hence in a species expression, a
{\tt in}-parameter) must be instantiated by a {\tt collection}
identifier.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Species '$s_1$' is not a subspecies of '$s_2$'. In field
  '$name$', types $t_1$ and $t_2$ are not compatible.}

{\em Description}: During species parameter instantiation, the
provided species $s_1$ is not a subspecies of the expected species
signature $s_2$, because it doesn't have a signature containing at
least $s_2$'s methods with compatibles types. The wrong field $name$
is reported with the two types $t_1$ and $t_2$ expected and actually
found.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Species '$s_1$' is not a subspecies of '$s_2$'. In field
  '$fname$', type $t_1$ occurs in $t_2$ and would lead to a cycle.}

{\em Description}: During species parameter instantiation, the
provided species $s_1$ is not a subspecies of the expected species
signature $s_2$, since type compatibility check detected a cyclic
type. This means that the type $t_1$ is a sub-part of itself via the
type $t_2$.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Species '$s_1$' is not a subspecies of '$s_2$'. In field
  '$fname$', the type constructor '$tname$' is used with the different
  arities $n_1$ and $n_2$.}

{\em Description}: During species parameter instantiation, the
provided species $s_1$ is not a subspecies of the expected species
signature $s_2$, since the type constructor (not sum type constructor)
$tname$ is used with an improper number of arguments $n_1$ versus
$n_2$.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Species '$s_1$' is not a subspecies of '$s_2$'. Field '$name$'
  is not present in '$s_1$'.}

{\em Description}: During species parameter instantiation, the
provided species $s_1$ is not a subspecies of the expected species
signature $s_2$, because it doesn't have a signature containing at
least $s_2$'s methods and especially not the method $name$.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Species '$sname$' cannot be turned into a collection. Field
  '$fname$' is not defined.}

{\em Description}: A collection is a completely defined species
(c.f. \ref{collection}), i.e. a species where {\bf all} the methods
are {\bf defined} and not only declared. In the species $sname$, the
method $mname$ is only declared, hence the species is not complete and
no collection can be extracted from it.

{\em Hints}: Add an effective definition of the method, either by
writing it code or by inheritance, according to your program model.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{In the delayed termination proof, parameter '$name$' does
  not refer to a parameter of the original function.}

{\em Description}: As any proof, termination proofs can be made later
after the function definition. However it must refer to the original
function's parameters names. In the current proof, the identifier
$name$ doesn't exist among the original function's parameters.

{\em Hints}: Change the parameter name in the proof to make it
matching the function definition's ones.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Species 'sname' is not well-formed. Field '$name$' involves
  a non-declared recursion for the following dependent fields: \ldots}

{\em Description}: The species $sname$ doesn't respect the
well-formation rule presented in \ref{well-formation}. The chain of
functions involved in the cycle is given in the error message as a
sequence of methods names
$m_1 \rightarrow m_2 \rightarrow \ldots \rightarrow m_n$ with the
implicit final path $m_n \rightarrow m_1$.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{No $lang$ mapping given for the external value definition
  '$name$'.}

{\em Description}: The external value definition allowing to link
\focal\ code to foreign languages doesn't specify how to map the value
identifier $name$ in the language $lang$.

{\em Hints}: Supply a binding for this language in the external
definition.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{No $lang$ mapping given for the external type definition
  '$name$'.}

{\em Description}: The external type definition allowing to link
\focal\ code to foreign languages doesn't specify how to map the type
identifier $name$ in the language $lang$.

{\em Hints}: Supply a binding for this language in the external
definition.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{No $lang$ mapping given for the external sum type
  constructor '$name$'.}

{\em Description}: The external sum type definition allowing to link
\focal\ code to foreign languages doesn't specify how to map the sum
type constructor $name$ in the language $lang$.

{\em Hints}: Supply a binding for this language in the external
definition.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{No $lang$ mapping given for the external record field
  '$name$'.}

{\em Description}: The external record type definition allowing to
link \focal\ code to foreign languages doesn't specify how to map the
record field $name$ in the language $lang$.

{\em Hints}: Supply a binding for this language in the external
definition.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Unable to find OCaml generation information for compiled
  file '$file$'. Source file may have been compiled without OCaml code
  generation enabled.}

{\em Description}: The \focal\ source file $file$.foc was compiled but
the object file doesn't contain information about \ocaml\ code
generation. The \focal\ compiler allows to disable the \ocaml\ code
production by the {\tt --no-ocaml-code} option. May be this option was used.

{\em Hints}: Invoke the compiler on the source file $file$.foc without
the {\tt --no-ocaml-code} option.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Type definition contains a mutable field '$name$' that can't
  be compiled to Coq.}

{\em Description}: {\color{red} Never raised in the current version
  since mutable record fields are not yet available}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Unable to find Coq generation information for compiled file
  '$file$'. Source file may have been compiled without Coq code
  generation enabled.}

{\em Description}: The \focal\ source file $file$.foc was compiled but
the object file doesn't contain information about \coq\ code
generation. The \focal\ compiler allows to disable the \coq\ code
production by the {\tt --no-coq-code} option. May be this option was used.

{\em Hints}: Invoke the compiler on the source file $file$.foc without
the {\tt --no-coq-code} option.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Using a species parameter's method ($name$) in a Zenon proof
  with "by definition" is not allowed.}

{\em Description}: The current proof tries to used the definition of a
method $name$ of a species parameter. Since species parameters are
always abstracted, {\bf definitions} (i.e. ``bodies'') of their methods
are {\bf not} available in the parametrised species. For this reason,
it is impossible to provide this definition to \zenon.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Using an only declared method of Self ($name$) in a Zenon
  proof with "by definition" is not allowed.}

{\em Description}: The current proof tries to used the definition of a
method $name$ {\bf only declared} in the current species. Since the
definition is not available, it is impossible to provide it to
\zenon.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Using a local identifier ($name$) in a Zenon proof with "by
  definition" is not allowed.}

{\em Description}: The current proof tries to used a local variable
$name$, i.e. an identifier not representing a method, hence
meaningless for \zenon.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Using a local identifier ($name$) in a Zenon proof with "by
  property" is not allowed.}

{\em Description}: The current proof tries to used a local variable
$name$, i.e. an identifier not representing a method, hence
meaningless for \zenon.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Assumed hypothesis '$hyp$' in a Zenon proof was not found.}

{\em Description}: The current proof makes a reference to an
hypothesis $hyp$ that was not found in the current proof tree.

{\em Hints}: None.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Step '$<$\ldots$>$\ldots' in a Zenon proof was not found.}

{\em Description}: The current proof makes a reference to an
proof step that was not found in the current proof tree.

{\em Hints}: None.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Recursive call to '$name$' contains nested recursion.}

{\em Description}: The function contains a recursive call to $name$
inside a recursive call. The current version of \focal\ doesn't
support the \coq\ code generation for nested recursive calls.

{\em Hints}: Try to rewrite your function with the nested call
performed before the outer recursive call. For instance:
{\scriptsize
\begin{lstlisting}
let rec f (x) =
  ...
  f (f (bla))
  ...
\end{lstlisting}
}
should be turned into:
{\scriptsize
\begin{lstlisting}
let rec f (x) =
  ...
  let tmp = f (bla) in
  f (tmp)
  ...
\end{lstlisting}
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Recursive call to '$name$' is incomplete.}

{\em Description}: The function contains a recursive occurrence of
$name$ with an incomplete number of parameters. Since application
syntactically requires all the arguments to be present, this can arise
if the recursive identifier is used in non-applicative
position. However the error message is more general since future
extensions may involve partial applications. Below follows an example
of such invalid usage of a recursive function identifier:
{\scriptsize
\begin{lstlisting}
let rec f (x) =
  ...
  let tmp = f in
  let ...  = tmp (...) ... in
  f (...)
  ...
\end{lstlisting}
}

{\em Hints}: None



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Unexpected error: "$msg$". Please report.}

{\em Description}: An error was raised and not expected during a
normal execution of the compiler. This is a failure of the compiler
and must be fixed by the \focal\ development team. The error message
display the internal reason of the failure and must be reported to the
\focal\ development team.

{\em Hints}: \verb+http://focal.inria.fr/+, link ``Bug tracking''.
