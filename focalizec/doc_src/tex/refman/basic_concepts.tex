% $Id: basic_concepts.tex,v 1.9 2008-12-11 10:48:24 hardin Exp $




As stated in section \ref{glimpse}, the \focal\ language is designed
to build an application step by step, going from very abstract
specifications to the concrete implementation through a hierarchy of
structures. At first sight  species seem quite similar to
classes in an Object-Oriented context.  {\em However, despite of
inheritance and late-binding features, \focal\ is definitively not an
Object-Oriented language as C++, Java, etc.  are.}

 In the following 
we  present the basic concepts underlying a
\focal\ development, that is:
\begin{itemize}
\item Top-level definitions
  \item Species
  \item Collections
  \item Parametrisation
  \item Inheritance
  \item Late-binding
\end{itemize}
To ensure that this part can be read independently of the section
\ref{glimpse}, we duplicate some explanations. 

\subsection{Top-level Definitions}
\label{topleve-def}
\index{toplevel} 
We call {\bf toplevel-definition} (just one word)  a definition  which appears outside species and
collections. Such definitions can  only be:
\begin{itemize}
  \item Species,
  \item collections,
  \item type definitions,
  \item general theorems (not depending on a species),
  \item general functions (not depending on a species),
  \item expressions to be directly evaluated (but there is no way to
    bind their value to an identifier).
\end{itemize}
Any toplevel-definition is
ended by a double semi-character (``;;'').\index{;;}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Species}
\label{species-intro}
{\bf Species} \index{species} are the nodes of the
\focal\ hierarchy. A species is  a sequence of
{\bf methods} \index{method} or {\bf fields}\index{field}, each ended
by a semi character (``;'')\index{;;}. Hence, a
basic species looks like:
{\scriptsize
\begin{lstlisting}
  species Name =
    meth1 ;
    meth2 ;
  end ;;
\end{lstlisting}
}

Species names are always {\bf capitalized}. As any toplevel-definition, a species is
ended by a double semi-character (``;;'').\index{;;} There are several kinds of methods:
\smallskip
\begin{itemize}
  \medskip
  \label{rep-is-method}
\item The {\bf representation}\index{representation}. This is a type
  definition that defines\index{representation!defined} the type of
  the entities manipulated in the species.  The representation is
  bound to a \focal\ type (see \ref{focal-type}) which is similar,
  roughly speaking, to a ML type. Thus, the representation can be a
  type variable and then is said to be ``not yet defined'' or ``only
  declared'' and is not explicitly introduced
  \index{representation!declared}.  It can be bound to a type defined
  by a more complex type expression possibly containing type variables
  (introduced via collection parameters). Either, this type value is
  obtained by inheritance or is introduced by the keyword {\tt
    representation}\index{representation} followed by {\tt =} followed
  by a type expression.  Ultimately to get a {\em complete} (fully
  defined) species, the representation must be a fully instantiated type
  (directly or by \ref{inheritance}).


In the context of a species, the
  representation is denoted by {\tt Self}.


%  For instance, we can define a species to manipulate couples of native integers  as:
%     {\scriptsize
%       \begin{lstlisting}
% species IntCouple =
%   representation = (int * int) ;
% let element = (1,1); 
% let increment (x,y) : self -> self  = (x+1, y+1);  
% end ;;
%       \end{lstlisting}
%     }




\item {\bf Signatures}\index{signature}. They introduce names of
  constants and functions, uniquely providing their type. Types
  expressions are  ML-like type expressions. A signature
  begins with the keyword {\tt signatre} followed by the introduced
  name followed by {\tt :} followed by a type expression. For
  instance: 
{\scriptsize
      \begin{lstlisting}
 species IntStack =
   signature push : int -> Self -> Self ;
 end ;;
      \end{lstlisting}
    } 

As we saw above, {\tt Self} represents the representation (thus a type)
     of the current species. Hence an operation pushing an integer
    onto a stack  takes as parameter the integer to push, the stack
    on which to push and give back a new stack, that is, an entity of
    type {\tt Self}.

  \medskip

  \item {\bf Functions}\index{function}.  They are implementations of
    signatures, providing effective code. A function is
    introduced by the {\tt let} keyword followed by the name followed
    by {\tt =} followed by a definition, which is similar to ML
    definitions. Recursive functions are
    introduced by {\tt let rec} to make explicit the recursivity.

    {\scriptsize
      \begin{lstlisting}
species IntStack =
  representation = int list ;
  let push (v in int, s in Self) = v :: s ;
end ;;
      \end{lstlisting}
    }

 Function parameters can be entities (that is, values) of the
    species itself (which type is the representation, thus denoted by
    {\tt Self}), entities of known collections, values of known types.

    Functions can use in their body other methods of the species,
    toplevel-definitions of functions, methods of collections
    (described further in \ref{collection}), or methods of
    collections parameters (see \ref{collection-parameter}).

    \label{idea-fun-using-sig}
    When we say ``other methods of the species'', this includes
    functions only introduced by their
    signatures. This means that it is possible to use something only
    declared, without yet effective implementation. We will address
    this point later in detail in section \label{late-binding}.

    \smallskip
    Although \focal\ is a functional language, function application
    must always be total. This means that any function call must be
    provided all the effective arguments of the function. As
    described further in the core syntax (c.f \ref{core-syntax}),
    function application is ``à la C'', that is with arguments comma
    separated and enclosed by parentheses.

  \medskip
\item {\bf Properties}\index{property}. They are first order logic
  formulae containing names already introduced. When stating a
  property, the proof that it holds is not yet provided (but will have
  to be ultimately  provided). A
  property can be viewed as a declaration. 

 {\scriptsize
      \begin{lstlisting}
species IntStack =
  ...
  property push_returns_non_empty :
    all v in int, all s in Self, push (v, s) -> ~ is_empty (s) ;
end ;;
      \end{lstlisting}
    }

    Proofs\index{proof!delayed} of properties can be done afterwards
    using a {\tt proof} field in a species.The way to give proofs will
    be seen further.

    {\scriptsize
      \begin{lstlisting}
species IntStack2 inherits IntStack =
  proof of push_returns_non_empty = ... ;            
end ;;
      \end{lstlisting}
    }

  \medskip
  \item {\bf Theorems}\index{theorem}. They are properties with their
    proofs. In fact, when defining a property, we only give the
    statement of a theorem, leaving its proof for later. A theorem can
    be viewed as a definition.

    {\scriptsize
      \begin{lstlisting}
species IntStack =
  ...
  theorem push_returns_non_empty :
    all v in int, all s in Self, push (v, s) -> ~ is_empty
    (s)
  proof = ... ;
end ;;
      \end{lstlisting}
    }

\end{itemize}

\label{no-polymorphism-for-methods}
One important restriction on the type of the methods is that it cannot
be polymorphic\index{polymorphism}. However, \focal\ provides another
mechanism to circumvent this restriction, the
parametrisation\index{parametrisation} as explained further
(c.f. \ref{parametrisation}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Complete species}
 A species is said {\em complete}\index{species!complete} if all
its methods are {\em defined}, i.e. have an implementation. In other
words this means that there is no more methods only {\em
  declared}. This notion implies that:
\begin{itemize}
  \item The representation has been associated with a type definition. 
  \item Every declaration is associated to a definition.
  \item A proof is given for every property. 
\end{itemize}

\smallskip
Obviously, it is possible to build a species without signatures and
properties, only providing functions and theorems directly. In this
case, if the representation is also defined, then the obtained species is
trivially complete.

The important point for a species to be complete is that it can be
turned into effective executable \ocaml\ code and effective checkable
\coq\ code, since all the components are
known.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Interfaces}
\label{interface}
\index{interface}
The {\bf interface} of a species is the list of the declarations of
its methods. It corresponds to the end-user point of view, who wants
to know which functions he can use, and which properties these
functions have, but doesn't care about the details of the
implementation.

\smallskip 

The interface of a species is obtained by keeping the
signatures and properties and retaining only the signatures of the let
methods and the statement of the theorems. The representation is
hidden thus abstract (only unifiable with itself).  Hence, getting the
interface of a species can roughly be seen as erasing the
representation, turning the functions into signatures and the theorems
into properties.

\smallskip

While this abstraction is easy within programming languages, it is not
always possible when dealing with proofs and properties. Such
problematic species are rejected by \focal\ and will be described
later in \ref{species-constraints}.

An interface has a name, which is the name of the underlying
species. There should be no confusion between species names and
interface names as interface names are only used to qualify formal
collection parameters (see section \ref{collection-parameter}) and to
apply methods of collection parameters. 



\subsection{Collections}
\label{collection}
\index{collection} 

A {\bf collection} is a kind of ``grey box'', built from a {\em
  complete} species by abstraction of the representation. A collection
has exactly the same sequence of methods than the complete species
underlying it, apart the representation which is hidden.

The interface of a collection is, roughly speaking, the one of the
complete species it implements. The interface $I_1$ of a collection
$C_1$ is {\em compatible} with an interface $I_2$ if $I_1$ contains a
common instantiation of all the components of $I_2$.

\medskip

Note that creating a collection from it  is the
only way to turn methods of a complete species into executable
code. This point is emphasized by the syntax: 

{\tt collection} {\em name-collection} {\tt implements} {\em name-species}

\medskip

Thus, implementing a complete species creates a collection, which is a
kind of abstract data-type. This especially
means that entities of the collection cannot be directly
created or manipulated as their type is not accessible.  So they can
only  be
manipulated by the methods of the {\em implemented} species.



{\scriptsize
\begin{lstlisting}
species Full =
  rep = int ;
  let create_random in Self = random_foc#random_int (42) ;
  let double (x in Self) = x + x ;
  let print (x in Self) = print_int (x) ;
end ;;

collection MyFull_Instance implements Full ;;

let v = Full.create_random ;;
Full.print (v) ;;
let dv = Full.double (v) ;;
Full.print (dv) ;;
\end{lstlisting}
}

In the above example, we define a complete species {\tt Full}. Then
we  create the collection
{\tt MyFull\_Instance}. We can then use methods of this collection on
entities of this collection.

\smallskip

{\em  Note that two collections created from a same species are
not type-compatible since their representation is abstracted making
impossible to ensure a type equivalence.}

\smallskip
As a conclusion, collections are the only way to get something that
can be executed since they are the terminal items of a
\focal\ development hierarchy. Since they are ``terminal'', this also
means that no method can be added to a collection. Moreover, a
collection may not be used to create a new species by inheritance (as
explained in the next section).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
