% $Id: output.tex,v 1.5 2008-12-15 22:50:38 hardin Exp $



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compilation process and outputs}

We call {\em compilation unit}\index{compilation unit} a file
containing source code for toplevel-definitions, species,
collections. Visibility rules, described in section
\ref{qualified-name}, are defined according to compilation units status.
From a compilation unit, the compiler issues several files described
on the following.

\subsection{Outputs}
A \focal\ development contains both
``computational code'' (i.e. code performing operations that lead to
an effect, a result) and logical properties.

\smallskip
When compiled, two outputs are generated:
\begin{itemize}
  \item The ``computational code'' is compiled into \ocaml\ source
    that can then be compiled with the \ocaml\ compiler to lead to an
    executable binary. In this pass, logical properties are discarded
    since they do not lead to executable code.
  \item Both the ``computational code'' and the logical properties are
    compiled into a \coq\ model. This model can then be sent to the
    \coq\ proof assistant who will verify the consistency of both the
    ``computational code'' and the logical properties (whose
    proofs\index{proof} must be obviously provided) of the
    \focal\ development. This means that the \coq\ code generated is
    not intended to be used to generate an \ocaml\ source code by
    automated extraction. As stated above, the executable generation
    is preferred using directly the generated \ocaml\ code. In this
    idea, \coq\ acts as an assessor of the development instead of a
    code generator.

    More accurately, \focal\ first generates a pre-\coq\ code, i.e. a
    file containing \coq\ syntax plus ``holes'' in place of proofs
    written in the \focal\ Proof Language. This kind of files is
    suffixed by ``.zv'' instead of directly ``.v''. When sending this
    file to \zenon\ these ``holes'' will be filled by effective
    \coq\ code automatically generated by \zenon (if it succeed in
    finding a proof), hence leading to a pure \coq\ code file that can
    be compiled by \coq.

\end{itemize}
In addition, several other outputs can be generated for documentation
or debug purposes. See the section \ref{compiler-options} for
details. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Compiling a source}
In the current version of the \focal\ compiler, compiling a \focal\
program involves several steps:
\begin{enumerate}
  \item {\bf \focal\ source compilation}. This step takes the \focal\
    source code and generates the \ocaml\ and/or ``pre-''\coq\ code.
    You can disable the code generation for one of these languages
    (see page \ref{compiler-options}), or both, in this case, no code is
    produced and you only get the \focal\ object code produced without
    anymore else output and the process ends at this point. If you
    disable one of the target languages, then you won't get any
    generated file for it, hence no need to address its related
    compilation process described below.

  The command to invoke is {\tt focalizec} with the optional extra
  directories to include in the search path, depending on other
  \focal\ files your program depends on. Note that by default, it is
  useless to specify the standard library installation path since
  \focal\ will automatically search in it.
  \begin{center}
  {\tt focalizec -I mylibs -I myotherlibs source.foc}
  \end{center}
  Assuming you generate code for both \ocaml\ and \coq, you will get
  two generated files: {\tt source.ml} (the \ocaml\ code) and
  {\tt source.zv} (the ``pre-''\coq\ code).

  \item {\bf \ocaml\ code compilation}. This step takes the generated
    \ocaml\ code (it is an \ocaml\ source file) and compile it. This
    is done like any regular \ocaml\ compilation, the only difference
    is that you must provide to it a search path containing the
    \focal\ installation path and your own used extra \focal\ source
    files directories.
    \begin{verbatim}
ocamlc -c -I/usr/local/lib/focalize -I mylibs
   -I myotherlibs source.ml
    \end{verbatim}
    This will produce the \ocaml\ object file {\tt source.cmo}. Do
    this for each of your generated \ocaml\ files. The last action is
    to make the final link, providing the same search path than above
    and the {\tt .cmo} files corresponding to all the generated
    \ocaml\ files from all your \focal\ {\tt .foc} files. You also
    need to add the {\tt .cmo} files corresponding to the modules of
    the standard library you use (currently, this must be done by the
    user, next versions will automate this process).
    \begin{verbatim}
ocamlc -I mylibs -I myotherlibs
  install_dir/ml_builtins.cmo install_dir/basics.cmo
  install_dir/sets.cmo ...
  mylibs/src1.cmo mylibs/src2.cmo ...
  myotherlibs src3.cmo mylibs/src3.cmo ...
  source1.cmo source2.cmo ...
  -o exec_name
    \end{verbatim}

    Note that you can also compile the \ocaml\ code in native mode
    using the {\tt ocamlopt} version of the \ocaml\ compiler. See
    \ocaml\ reference manual for more information. In this case, the
    object files are the {\tt .cmx} files instead of the {\tt .cmo}
    ones.\\
    Once this step is done, you have the executable program done.

  \item {\bf ``Pre-''\coq\ code compilation}. This step takes the
    generated {\tt .zv} file and attempts to produce a real \coq\
    {\tt .v} source file by replacing proofs written in \focal\ Proof
    Language by some effective \coq\ proofs found by the \zenon\
    theorem prover. Note that if \zenon\ fails in finding a proof, a
    hole will remain in the final \coq\ {\tt .v} file. Such a hole
    appears as the text ``{\tt TO\_BE\_DONE\_MANUALLY.}'' in place of
    the effective proof. In this case, \coq\ will obviously fail
    in compiling the file, so the user must do the proof by hand or
    modify his original \focal\ source file to get a working proof.
    For each {\tt .zv} file:
    \begin{center}
      {\tt zvtov -new source1.zv}
    \end{center}
    For more about the \zenon\ options, consult section
    \ref{zenon_options}.

  \item{\bf \coq\ code compilation}. This step takes the generated
    {\tt .v} code and compiles it with \coq. This is done like any
    regular \coq\ compilation, the only difference is that you must
    provide to it a search path containing the \focal\ installation
    path and your own used extra \focal\ source files directories.
    \begin{verbatim}
coqc -I/usr/local/lib/focalize -I mylibs
  -I myotherlibs source.v
    \end{verbatim}
    Once this step is done, you have the \coq\ object files and you
    are sure that \coq\ validated you program model, properties and
    proofs. The final ``assessor'' of the toolchain accepted your
    program.
\end{enumerate}
