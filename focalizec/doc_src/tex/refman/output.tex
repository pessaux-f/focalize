% $Id: output.tex,v 1.11 2009-09-02 17:14:52 weis Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compilation process and outputs}

We call {\em compilation unit}\index{compilation unit} a file
containing source code for toplevel-definitions, species,
collections. Visibility rules, described in section
\ref{qualified-name}, are defined according to compilation units status.
From a compilation unit, the compiler issues several files described
thereafter.

%%%%%%%%%%%%%%%%%%%%
\subsection{Outputs}
A {\focal} development contains both
computational code (i.e. code performing operations leading to
an effect, a result) and logical properties.

\smallskip
When compiled, two outputs are generated:
\begin{itemize}
  \item The ``computational code'' is compiled into {\ocaml} source
    that can then be compiled with the {\ocaml} compiler to lead to an
    executable binary. In this pass, logical properties are discarded
    since they do not lead to executable code.
  \item Both the ``computational code'' and the logical properties are
    compiled into a {\coq} model. This model can then be sent to the
    {\coq} proof assistant who will verify the consistency of both the
    ``computational code'' and the logical properties (whose
    proofs\index{proof} must be obviously provided) of the
    {\focal} development. This means that the {\coq} code generated is
    not intended to be used to generate an {\ocaml} source code by
    automated extraction. As stated above, the executable generation
    is preferred using directly the generated {\ocaml} code. In this
    idea, {\coq} acts as an assessor of the development instead of a
    code generator.

    More accurately, {\focal} first generates a pre-{\coq} code, i.e. a
    file containing {\coq} syntax plus ``holes'' in place of proofs
    written in the {\focal} Proof Language. This kind of files is
    suffixed by ``.zv'' instead of directly ``.v''. When sending this
    file to {\zenon} these ``holes'' will be filled by effective
    {\coq} code automatically generated by {\zenon} (if it succeed in
    finding a proof), hence leading to a pure {\coq} code file that can
    be compiled by {\coq}.

\end{itemize}
In addition, several other outputs can be generated for documentation
or debug purposes. See the section \ref{compiler-options} for
details.

%%%%%%%%%%%%%%%%%%%%
\subsection{Compiling a source}
Compiling a {\focal} program involves several steps (numbered here 1, 2, 3 and 4) that are
automatically handled by the {\focalizec} command. Using the command
line options, it is possible to tune the code generations steps as
described in \ref{compiler-options}.

\begin{enumerate}
  \item {\bf {\focal} source compilation}. This step reads the {\focal}
    source code and generates the {\ocaml} and/or ``pre-''{\coq} code.
    You can disable the code generation for one of these languages
    (see page \ref{compiler-options}), or both, in this case, no code is
    produced and you only get the {\focal} object code produced without
    anymore else output and the process ends at this point. If you
    disable one of the target languages, then you won't get any
    generated file for it, hence no need to address its related
    compilation process described below.

    Assuming you generate code for both \ocaml\ and {\coq}, you will get
    two generated files: {\tt source.ml} (the \ocaml\ code) and
    {\tt source.zv} (the ``pre-''{\coq} code).

  \item {\bf {\ocaml} code compilation}. This step takes the generated
    {\ocaml} code (it is an {\ocaml} source file) and compile it. This
    is done like any regular {\ocaml} compilation, the only difference
    is that the search path containing the {\focal} installation path
    and your own used extra {\focal} source files directories are
    automatically passed to the \ocaml\ compiler.
    This step acts like the direct invocation:
    \begin{verbatim}
ocamlc -c -I /usr/local/lib/focalize -I mylibs
   -I myotherlibs source.ml
    \end{verbatim}
    This produces the {\ocaml} object file {\tt source.cmo}. Note that
    you can also ask to use the {\ocaml} code in native mode, in this
    case the {\tt ocamlopt} version of the {\ocaml} compiler is
    selected (see {\ocaml} reference manual for more information) and
    the object files are {\tt .cmx} files instead of {\tt .cmo}.
    ones.

  \item {\bf ``Pre-''{\coq} code compilation}. This step reads the
    generated {\tt .zv} file and produces a real {\coq}
    {\tt .v} source file. The proofs written in the {\focal} Proof
    Language are replaced by the effective {\coq} proofs found by the {\zenon}
    theorem prover. Note that if {\zenon} fails to find a proof, a
    {\em hole} appears in the final {\coq} {\tt .v} file:
    the text ``{\tt TO\_BE\_DONE\_MANUALLY.}'' is written in place of
    an effective proof. The {\coq} compiler then obviously fails
    to compile the file, and the user must modify his original {\focal}
    source file to provide a tractable proof script for {\zenon} or insert a direct
    {\coq} proof either in the {\focal} or in the generated {\coq} source file.
    This step acts like the direct invocation:
    \begin{center}
      {\tt zvtov -new source.zv}
    \end{center}
    For more about the {\zenon} options, consult the section
    \ref{zenon-options}.

  \item{\bf {\coq} code compilation}. This step takes the generated
    {\tt .v} code and compiles it with {\coq}. This is done like any
    regular {\coq} compilation. The only difference is that the search
    path containing the {\focal} installation path and your own used
    extra {\focal} source files directories are automatically passed
    to the {\coq} compiler.
    This step acts like the direct invocation:
    \begin{verbatim}
coqc -I /usr/local/lib/focalize -I mylibs
  -I myotherlibs source.v
    \end{verbatim}
    Once this step is done, you have the {\coq} object files and you
    are sure that {\coq} validated you program model, properties and
    proofs. The final ``assessor'' of the tool-chain accepted your
    program.
\end{enumerate}

\medskip
\index{linking files}
Once all separate files are compiled, to get an executable from the
\ocaml\ object files, you must link them together, providing the same
search path than above and the {\tt .cmo} files corresponding to all
the generated {\ocaml} files from all your {\focal} {\tt .foc}
files. You also need to add the {\tt .cmo} files corresponding to the
modules of the standard library you use (currently, this must be done
by the user, next versions will automate this process).
    \begin{verbatim}
ocamlc -I mylibs -I myotherlibs
  install_dir/ml_builtins.cmo install_dir/basics.cmo
  install_dir/sets.cmo ...
  mylibs/src1.cmo mylibs/src2.cmo ...
  myotherlibs src3.cmo mylibs/src3.cmo ...
  source1.cmo source2.cmo ...
  -o exec_name
    \end{verbatim}
