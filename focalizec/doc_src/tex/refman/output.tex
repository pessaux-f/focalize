% $Id: output.tex,v 1.2 2008-11-17 15:39:03 pessaux Exp $



As we will see further, a \focal\ development contains both
``computational code'' (i.e. code performing operations that lead to
an effect, a result) and logical properties.

\smallskip
When compiled, two outputs are generated:
\begin{itemize}
  \item The ``computational code'' is compiled into \ocaml\ source
    that can then be compiled with the \ocaml\ compiler to lead to an
    executable binary. In this pass, logical properties are discarded
    since they do not lead to executable code.
  \item Both the ``computational code'' and the logical properties are
    compiled into a \coq\ model. This model can then be sent to the
    \coq\ proof assistant who will verify the consistency of both the
    ``computational code'' and the logical properties (whose
    proofs\index{proof} must be obviously provided) of the
    \focal\ development. This means that the \coq\ code generated is
    not intended to be used to generate an \ocaml\ source code by
    automated extraction. As stated above, the executable generation
    is preferred using directly the generated \ocaml\ code. In this
    idea, \coq\ acts as an assessor of the development instead of a
    code generator.

    More accurately, \focal\ first generates a pre-\coq\ code, i.e. a
    file containing \coq\ syntax plus ``holes'' in place of proofs
    written in the \focal\ Proof Language. This kind of files is
    suffixed by ``.zv'' instead of directly ``.v''. When sending this
    file to \zenon\ these ``holes'' will be filled by effective
    \coq\ code automatically generated by \zenon (if it succeed in
    finding a proof), hence leading to a pure \coq\ code file that can
    be compiled by \coq.
\end{itemize}
