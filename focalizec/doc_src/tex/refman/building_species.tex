% $Id: building_species.tex,v 1.8 2008-12-11 10:48:24 hardin Exp $



In this chapter, we describe the two mechanisms to build
incrementally more complex species from previously existing ones: parametrisation and
inheritance.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Parametrisation}
\index{parametrisation}
\label{parametrisation}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Collection parameters}
\index{parameter!collection}
\index{collection!parameter}
\label{collection-parameter}
Remember that methods cannot be polymorphic\index{polymorphism}
(c.f. \ref{no-polymorphism-for-methods}). For
example, how to implement the well-known polymorphic type of the
lists ? A list is a structure grouping elements but independently of
the type of these elements. The only constraint is that all elements
have the same type. Hence, a ML-like representation of lists would be
like:
{\scriptsize
\lstset{language=Caml}
\begin{lstlisting}
type 'a list =
  | Nil
  | Cons of ('a * 'a list)
\end{lstlisting}
}

The {\tt 'a} is then a parameter of the type, which is indeed a
polymorphic ML type.
In \focal\ we would like to create a species looking like:
{\scriptsize
\begin{lstlisting}
species List =
  signature nil : Self ;
  signature cons : 'a -> Self -> Self ;
end ;;
\end{lstlisting}
}

Instead of abstracting the type parameter and leaving it free in the
context of the species, in \focal\ we {\em parameterise} the species
by a {\bf collection parameter} called  {\tt Elem} in the example:
{\scriptsize
\begin{lstlisting}
species List (Elem is Basic_object) =
  signature nil : Self ;
  signature cons : Elem -> Self -> Self ;
end ;;
\end{lstlisting}
}

Collection parameters are introduced by their name followed by the
{\tt is} keyword, followed by an {\bf interface name} (remember that
an interface has the same name as its uderlying species). In the
example, {\tt Basic\_object} is a pre-defined species  from the
standard library, containing only few methods and this name is used
here to denote the interface of this species.   A
collection parameter can be instantiated by any collection which
interface ``contains'' at least the interface which name follows the
{\tt is} keyword. More precisely, a collection can be used as an
effective parameter if its interface is {\em
  compatible}\index{interface!compatibility} with the one required by
the parameterized species (c.f \ref{interface}). In the example, any
effective parameter instantiating {\tt Elem} is a collection which
interface contains at least the methods of {\tt Basic\_object}, the
type of each of them being an instantiation of the type of the
corresponding one in {\tt Basic\_object}.

\smallskip
In the example, we use the parameter {\tt Elem} to build the signature
of our method {\tt cons}. Note that collection names can be used
in type expressions to denote the ``abstracted'' representation of the
collection. Here ``abstracted'' means that the
representation is not visible but we can refer to it
as an abstract type. In other words, {\tt Elem -> Self -> Self}
stands for the type of a function:
\begin{itemize}
\item taking a first argument whose type is the representation  of a
  collection having a compatible interface with the interface {\tt
    Basic\_object}. (This especially means that such an argument is created using methods of the compatible collection),
  \item taking a second argument whose type is the representation of the current
    species,
  \item and returning a value whose type is the representation  of the
    current species.
\end{itemize}

\smallskip Why a {\bf collection parameter} and not a ``species
parameter''? The answer to this question is especially important to
understand the programming model in \focal. It is a {\bf collection
  parameter} because ultimately, at the terminal nodes of the
development, this parameter will have to be instantiated by an entity
where everything is defined, that is a collection ! Imagine how to
build an executable code if a parameter can be instantiated by a
species with some methods only declared\ldots This is the first
reason. 
 
Thus the representation of
a collection parameter is abstract for the hosting, exactly as is the
representation of a collection is (c.f \ref{collection}). Remember that
properties mentionned in the collection interface have been proved in
the underlying complete species. Indeed in the hosting species, these
theorems can be used as lemmas to do current proofs. If the
collection representation was not abstracted, then some methods of the
hosting species would have the ability to directly manipulate entities
of the collection parameter, with the risk of breaking some invariants
of the collection parameter. This is the second reason. 

To summarize, declaring a collection parameter for a parametrised
species means providing two things: the name of the parameter and the
interface (denoted by a species name) that the instantiation of this
parameter must satisfy.



\smallskip It is important at this point to note that \focal\ deals with
dependent types \index{type!dependent}, and therefore that {\em
  the order of the parameters is important}. To define the type of a
parameter, one can use the preeceding parameters. For instance, 
assuming that a parametrised species {\tt List} 
declares the basic operations over lists, one can specify a new
species working on couples of respectively values and lists of values
like: {\scriptsize
\begin{lstlisting}
species MyCouple (E is Basic_object, L is List (E)) =
  representation = (E * L) ;
  ... ;
end ;;
\end{lstlisting}
}

The representation of this species  represents the type
{\tt ('a * ('a list))}. This means that the type of the values in the
first component of the couple is the same than the type of the
elements of the list in the second component of the couple.

\smallskip
A parametrized species (like in
the example  the species {\tt List}) cannot be only partially
instantiated.  An
instantiation for {\bf all} its parameters is required. 

% Once again, the preceding
% parameters can be used to achieve this purpose (like we did to create
% our parameter {\tt L}, instantiating the {\tt List}'s parameter by our
% first collection parameter {\tt E}).

\smallskip
\label{method-qualification}
\index{method!qualification}
Till now, in the example we used
the parameter to build the representation of our species. But obviously,
collection parameters can also be used via their other methods,
i.e. signatures, functions, properties and theorems. Suppose that we want to create
a  species describing a notion of generic couple. This species uses two collection parameters,
one for each component of the couple. If we want to have a printing
(i.e. returning a string, not making side effect in our example)
method, we  require that each collection parameter provides one. Hence
our printing method will only have to add parentheses and comma
around and between what is printed by each parameter's printing
routine. Hence we now need to know how to call a collection parameter
method. The syntax is to give the method name followed by the
parameter's name, separating them by the ``!''\index{bang character}
character.
{\scriptsize
\begin{lstlisting}
(* Minimal species requirement : having a print routine. *)
species Base_obj =
  signature print : Self -> string ;
end ;;

species Couple (C1 is Base_obj, c2 is Base_obj) =
  representation = (C1 * C2) ;
  let print (c in Self) =
    match (c) with
     | (component1, component2) ->
       "(" ^ C1!print (component1) ^
       ", " ^
       C2!print (component2) ^")" ;
end ;;
\end{lstlisting}
}

Hence, {\tt C1!print (component1)} means ``call the collection
{\tt C1}'s method {\tt print} with the argument {\tt component1}''. 

The
qualification mechanism using ``!'' is general and can be used to
denote the method of any available species/collection, even those of
ourselves (i.e. {\tt Self}). Hence, in a species instead of calling:
{\scriptsize
\begin{lstlisting}
species Foo ... =
  let m1 (...) = ... ;
  let m2 (...) = if ... then ... else m1 (...) ;
end ;;
\end{lstlisting}
}
it is allowed to explicitly qualify the call to {\tt m1} by ``!''
with no species name, hence implicitly telling ``from myself'':
{\scriptsize
\begin{lstlisting}
species Foo ... =
  let m1 (...) = ... ;
  let m2 (...) = if ... then ... else !m1 (...) ;
end ;;
\end{lstlisting}
}
\index{name!resolution}
\index{scoping}
In fact, without explicit ``!'', the \focal\ compiler performs the
name resolution itself, allowing a lighter way of writing programs
instead of always needing a ``!'' character before each method call.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Entity parameters}
\index{parameter!entity}
\label{entity-parameter}
There is a second kind of parameter: the {\bf entity-parameter}. Such
a parameter can be instantiated by an {\bf entity of a certain
  collection}.  To obtain a species offering addition modulo an
integer value, we need to parametrise it by an entity of a collection
implementing the integers and to give a way to build an entity
representing the value of the modulo. Such a parameter is called an
{\bf entity parameter} and is introduced by the keyword {\tt in}.
{\scriptsize
\begin{lstlisting}

species AddModN (Number is InterfaceForInts, val_mod in Number) =
  representation = Number ;
  let add (x in Self, y in Self) =
    Number!modulo (Number!add (x, y), val_mod) ;
end ;;

species
\end{lstlisting}
}

Hence, any collection created from {\tt AddModN} embeds the addition
modulo the effective value instantiating {\tt val\_mod}. it is then
possible to create various collections with each a specific modulo
value. For instance, assuming that the species {\tt AddModN} is
complete and have a method {\tt from\_int} able to create a value of
the representation from an integer, we can create a collection
implementing addition modulo 42. We also assume that we have a
collection {\tt ACollImplentingInts} having at least {\tt
  InterfaceForInts} as interface. 

 {\scriptsize
\begin{lstlisting}
collection AddMod42 implements AddModN
  (ACollImplentingInts, ACollImplentingInts!from_int (42)) ;;
\end{lstlisting}
}


\smallskip

 Currently, entity parameters must live ``{\tt in}'' a
collection. It is not allowed to specify an entity parameter living in
a basic type like {\tt int}, {\tt string}, {\tt bool}\ldots This
especially means that these basic types must be embedded in a
collection if we want to use on of their values  as an entity parameter.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Inheritance and its mechanisms}
In this section, we address the second mean to build complex species
based on existing ones. It will cover the notion of {\em inheritance}
and its related feature the {\em late-binding}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Inheritance}
\label{inheritance}
\index{inheritance} \focal\ {\em inheritance} is the ability to create
a species, not from scratch, but by integrating methods of other
species.  The inheritance mechanism also allows to redefine methods
already existing as long as they keep ``the same'' type. To have the
same type means for functions that their type is an instanciation of
the type f the redefined function, according to some instantiation of
type variables, thus to some instantiation of collection
parameters. For theorems to have the same type is simply to have the
same statement (but proofs can differ).

For instance, assuming we have a species {\tt IntCouple} that
represent couples of integers, we want to create a species {\tt
  OrderedIntCouple} in which we ensure that the first component of the
couple is lower or equal to the second. Instead of inventing again all
the species, we will take advantage of the existing {\tt IntCouple}
and ``import'' its printing, equality, etc functions. However, we will
have to change the creation function since it must ensure at
creation-time of a couple that it is indeed ordered. We also may add
new methods in the newly built species. 

 {\scriptsize
\begin{lstlisting}
species IntCouple =
  representation = (int * int) ;
  let print (x in Self) = ... ;
  let create (x in int, y in int) = (x, y) ;
  let equal (c1, c2) =
    match (c1, c2) with
     | ((c11, c12), (c21, c22)) -> c11 = c21 && c12 = c22 ;
  ...
end ;;

species OrderedIntCouple inherits (IntCouple) =
  let create (x in int, y in int) =
    if x < y then (x, y) else (y, x) ;

  property is_ordered : all c in Self, first (c) <= scnd (c) ;
end ;;
\end{lstlisting}
}

In the example above, {\tt OrderedIntCouple} has all the methods
of {\tt IntCouple}, except the redefined ones (here {\tt create}, plus
the methods newly defined in {\tt OrderedIntCouple} (here, the
property {\tt is\_ordered}) stating that the couple is really
ordered).

 During inheritance, it is also possible to redefine a
signature, replacing it by an effective definition, to redefine a
property by a theorem and in the same idea, to add a {\tt proof of} to
a property in order to conceptually redefine is as a theorem. Since
inherited methods are now owned by the species that inherits, they are called exactly like if they were defined ``from scratch'' in the
species.

\smallskip
\index{inheritance!multiple}
Multiple inheritance, i.e. inheriting from several species is
allowed by specifying several species separated by comma in the
{\tt inherits} clause. In case of methods appearing in several
parents, there are several cases. Either, all the methods are only
signatures. As they have the same name, they have
compatible types, the one with the most instantiated type is
retained. Or some of these methods have already received
definitions. Then the definition which is retained for the inheriting
species is the one  coming from the rightmost parent in
the {\tt inherits} clause. For instance below, if species {\tt A} and
{\tt C} provide a method {\tt m}, {\tt C's} one will be kept.
{\scriptsize
\begin{lstlisting}
species Foo inherits A, B, C, D =
  ... m (...) ... ;
end ;;
\end{lstlisting}
}

\smallskip
\index{inheritance!parametrised species}
If a species {\tt S1} inherits from a parametrised species {\tt S0},
it must instantiate all the parameters of {\tt S0}. Because of our
dependent types\index{type!dependent} framework, if {\tt S1} is itself
parametrised, it can use its own parameters to do that. Assuming we
have a species {\tt List} parametrised by a collection parameter
representing the kind of elements of the list. We want to derive
a species {\tt ListUnique} in which elements are present at most
once. We build {\tt ListUnique} by inheriting from {\tt
  List}.

{\scriptsize
\begin{lstlisting}
species List (Elem is ...) =
  let empty = ... ;
  let add (e in Elem, l in Self) = ... ;
  let concat (l1 in Self, l2 in Self) = ... ;
end ;;

species ListUnique (UElem is ...) inherits List (UElem) =
  let add (e in UElem, l in Self) =
    ... (* Ensure the element e is not already present. *) ;
  let concat (l1 in Self, l2 in Self) =
    ... (* Ensure elements of l1 present in l2 are not added. *) ;
end ;;
\end{lstlisting}
}

\index{inheritance!parametrised by {\tt Self}}
A species can also inherit from a species parametrised by itself
(i.e. by {\tt Self}). Although this is rather tricky programming, the
standard library of \focal\ shows such an example in the file
{\em weak\_structures.fcl} in the species
{\tt Commutative\_semi\_ring}. Indeed this species specifies the fact
that a commutative semi-ring is a semi-ring on itself (as a semi-ring of
scalars).  In such a case, this implies that the
current species must finally (when inheritance is resolved) have an
interface compatible with the interface required by the collection
parameter of the inherited species. The \focal\ compiler collects 
the parts of the interface of {\tt Self}  obtained either by
inheritance or directly in the species body. Then  it checks that the
obtained interface is indeed compatible with the required interfaces
of the parameterized inherited species. if so, the compiler is able to
build the new species. Thus the compiler builds a kind of fix-point
but it is known at compile-time that this process will terminate. 




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Conclusion on species expressions}
\index{species!expression}
% At the beginning of this presentation, when dealing with collection
% parameters (section \ref{parametrisation}) we explained that
% collection parameters ``expressions'' were, first, species names. Like
% in the example:
We summarize the different ways of building species. The first way is
to introduce a simple collection parameter, requiring that the
effective parameter can offer all the methods listed in the associated
interface. 

{\scriptsize
\begin{lstlisting}
species List (Elem is Basic_object) = ... ;
\end{lstlisting}
}

Then, we can iterate the process and build 
a species parametrised by a parametrised species, like in the example:
{\scriptsize
\begin{lstlisting}
species MyCouple (E is Basic_object, L is List (E)) = ... ;;
\end{lstlisting}
}

Going on, we can  inherit
from species that are referenced only by their name, like in:
{\scriptsize
\begin{lstlisting}
species OrderedIntCouple inherits (IntCouple) = ... ;;
\end{lstlisting}
}

And finally, we mix the two possibilities, building a species by
inheritance of a parametrised species, like in: {\scriptsize
\begin{lstlisting}
species ListUnique (UElem is ...) inherits List (UElem) = ... ;;
\end{lstlisting}
}

Hence, we can now defined more accurately the notion of {\bf species
expression} used for both inheritance and parametrisation. It is either
a simple species name or the application of a parametrised species to
as many species expressions as the parametrised species has
parameters.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Late-binding}
\label{late-binding}
\index{late-binding} When building by multiple inheritance
(c.f. \ref{inheritance}) some signatures can be replaced by functions
and properties by theorems. It is also possible to associate a
definition of function to a signature (c.f \ref{idea-fun-using-sig})or
a proof o a property. In the same order, it is possible to redefine a
method already used by an existing method.
All these features are relevant of a mechanism known as {\em
  late-binding}. 


During compilation, the selected method is always the {\bf most
recently defined} along the inheritance tree. This especially means
that as long as a method is a signature, in the children the effective
implementation of the method will remain undefined (that is not a
problem since in this case the species is not complete, hence cannot
lead to a collection, i.e. code that can really be executed
yet). Moreover, if a method {\tt m} previously defined in the
inheritance tree uses a method {\tt n} freshly {\bf re}defined, then
this {\bf fresh redefinition} of {\tt n} will be used in the method
{\tt m}.

\smallskip
This mechanism enables two programming features:
\begin{itemize}
  \item The mean to use a method known by its type (i.e. its prototype
    in term of Software Engineering), but for which we do not know, or
    we don't need or we don't want yet to provide an implementation.

  \item To provide a new implementation of a method while  keeping the
    initial implementation for the inherited species. For example, the
    inheriting species can provide some new information
    (representation, functions, ..) which allow a more efficient
    implementatio of a given function.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Dependencies and erasing}
We previously saw that methods of a species can use other methods of
this species and methods from its collection parameters. This induce
what we call {\bf dependencies}\index{dependency}. There are two kinds
of dependencies, depending on their nature:
\begin{itemize}
  \item {\bf Decl-dependencies}
  \item {\bf Def-dependencies}
\end{itemize}
In order to understand the difference between, we must inspect further
the notion of representation, function, and theorem.



\paragraph{Decl-dependencies}
\index{dependency!decl}
When defining a function, a property or a theorem it is possible to
use another functions or signatures. For instance:
{\scriptsize
\begin{lstlisting}
species Bla =
  signature test : Self -> bool ;
  let f1 (x in string) = ... ;
  let f2 (y in Self) = ... f1 ("Eat at Joe's") ... ;
  property p1 : all x in Self, test (f2 (x)) <-> test (f1 ("So what")) ;
  theorem t1 : all x in Self, p1 <->  test (f1 ("Bar"))
  proof = ... ;
end ;;
\end{lstlisting}
}

In this cases, knowing the type of the used methods is sufficient to
ensure that the using method is well-formed. We remind that the type
of a function and a signature is the ML-like type. And for a property
and a theorem, this type is their logical statement. The type of a
method being provided by its {\bf declaration}, we will call these induced
dependencies {\bf decl-dependencies}.

Such dependencies also arise on the representation as soon as the type
of a method makes reference to the type {\tt Self}. Hence we can have
dependencies on the representation as well as on other methods (as
previously stated in \ref{rep-is-method}, {\tt representation} is a
method).

Hence, in our example, {\tt test}, {\tt f2}, {\tt f1} (since it is
used in {\tt p1} and {\tt t1} as the argument of {\tt test} which expects
an argument of type {\tt Self}), {\tt p1} and {\tt t1} have a
decl-dependency on the representation. Moreover, {\tt f2} has one on
{\tt f1}. The property {\tt p1} has decl-dependencies on {\tt test},
{\tt f1} and {\tt f2} and {\tt Self}. And finally {\tt t1} decl-depends on {\tt p1},
{\tt test}, {\tt f1} and {\tt Self}.



\paragraph{Def-dependencies}
\label{def-dependency}
\index{dependency!def} 
A method $m$ has a 
{\bf def-dependency} over another one $p$ (differing from the
representation)  if the system needs to
know the {\bf definition} of $p$   to ensure that $m$ is well-formed.

A definition of function can create only only decl-dependencies on
methods differing from the representation since the type system of
\focal\ only needs the types of the names present in the body of this
function. Note also that when {\bf using} a signature in another
method, since signature only contain types, no def-dependencies can
arise.

Now remember that {\tt representation} is also a method and there is
no syntactical way to forbid constructions like {\tt if representation
  = int ..} in function or properties. Such definitions would have a
{\bf def-dependency} on the representation\index{dependency!def!on
  representation}.  For consistency reasons going beyond this manual
but that will be shortly presented below in
\ref{def-dep-on-representation}, the {\bf \focal\ system rejects
  functions and properties having def-dependencies on the
  representation}.

\smallskip There remains the case of theorems. This case is the most
complex since it can lead to def-dependencies in proofs.  For the same
reasons than for properties, the {\bf \focal\ system rejects theorems
  having def-dependencies on the representation}. Other
def-dependencies are accepted.  These dependencies must be introduced
by the statement of the proof (with a syntax given in section
\ref{zenon-an-dependencies}).  Now, what does mean for a theorem to
def-depend on a method ? This basically means that to make the proof
of the theorem statement, one must use not only the declaration of a
method, but also its definition, its body. For instance, a theorem
needs to have visibility on the code of a function to have its proof
possible. This is a needed and powerful feature. 



\paragraph{Erasing during inheritance}
\index{erasing}
\label{erasing}
As a consequence of def-dependencies and late-binding, if a method is
redefined, all the proofs of theorems having def-dependencies on these
methods are erased. This means that since the body of the method
changed, may be the proof is not correct anymore and must be done
again. In practice, it can happen that the proof still holds, but the
compiler can't ensure this, hence will turn the theorem into a property
in the species where the redefinition occurred. The developer will
then have to provide a new proof of the inherited theorem thanks the
{\tt proof of} field.



\paragraph{Dependencies on collection parameters}
Since collection parameters always have their representation abstracted,
hidden, only {\bf decl-dependencies} can appear in the parametrised
method using them. Hence they can never lead to erasing. These
dependencies are only used internally by the \focal\ compiler in order
to generate the target code. For this reason, we will not focus anymore
on them.
