<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>A Short Tutorial for FoCaLize: 
Implementing Sets
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
BODY{background:white;}
.title{padding:1ex;background:#00B200;}
.titlemain{padding:1ex;background:#00B200;}
.titlerest{padding:1ex;background:#00B200;}
.part{padding:1ex;background:#00CC00;}
.section{padding:.5ex;background:#2DE52D;}
.subsection{padding:0.3ex;background:#66FF66;}
.subsubsection{padding:0.5ex;background:#99FF99;}
.fmarginpar{border:solid thin #66FF66; width:20%; text-align:left;}
.ffootnoterule{border:none;margin:1em auto 1em 0px;width:50%;background:#00CC00;}
.ftoc1{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #00CC00;}
.ftoc2{list-style:none;margin:1ex 1ex;padding:0ex 1ex;border-left:1ex solid #2DE52D;}
.ftoc3{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #66FF66;}
.ftoc4{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #99FF99;}
.ftoc5{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #CCFFCC;}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/pkg/bin/hevea -fix tutorial.hva tutorial.tex -->
<!--CUT DEF section 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">A Short Tutorial for FoCaLize:<BR>
Implementing Sets</H1><H3 CLASS="titlerest">The FoCaLize Team</H3><H3 CLASS="titlerest">July 2009</H3></TD></TR>
</TABLE><!--TOC section Contents-->
<H2 CLASS="section"><!--SEC ANCHOR -->Contents</H2><!--SEC END --><UL CLASS="ftoc1"><LI CLASS="li-toc">
<A HREF="#htoc1">1&#XA0;&#XA0;Forewords</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc2">1.1&#XA0;&#XA0;Content</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc3">1.2&#XA0;&#XA0;Notations and Recommandations</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">2&#XA0;&#XA0;A Quick Overview of <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">3&#XA0;&#XA0;The Development Case: Sets and Subsets</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">4&#XA0;&#XA0;Specifying Supersets</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc7">4.1&#XA0;&#XA0;The Superset Species</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">4.2&#XA0;&#XA0;A First Proof</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc9">4.3&#XA0;&#XA0;A First Definition</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">4.4&#XA0;&#XA0;Clearing of the Superset Species</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc11">5&#XA0;&#XA0;Specifying Subsets</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc12">5.1&#XA0;&#XA0;Generic Subsets</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc13">5.2&#XA0;&#XA0;Extensional Subsets</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc14">5.2.1&#XA0;&#XA0;Inclusion</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc15">5.2.2&#XA0;&#XA0;Extensional Equality</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">5.2.3&#XA0;&#XA0;A Few Trivial Properties</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc17">5.2.4&#XA0;&#XA0;Proving Non Trivial Properties</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">5.3&#XA0;&#XA0;Finite Subsets</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">6&#XA0;&#XA0;Specifying Lists</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc20">6.1&#XA0;&#XA0;Co-Lists</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc21">6.2&#XA0;&#XA0;Finite Lists</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">7&#XA0;&#XA0;Refining Lists</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc23">7.1&#XA0;&#XA0;Enumerable Lists</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc24">7.1.1&#XA0;&#XA0;Recursive Membership</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc25">7.1.2&#XA0;&#XA0;Recursive Deletion</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">7.2&#XA0;&#XA0;Inductive Lists</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc27">7.2.1&#XA0;&#XA0;Non Empty Supersets</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">7.2.2&#XA0;&#XA0;A Type for Lists</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc29">7.2.3&#XA0;&#XA0;Inductive Lists</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc30">7.2.4&#XA0;&#XA0;Higher-Order Proofs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc31">7.2.5&#XA0;&#XA0;Proofs on Inductive Types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc32">7.2.6&#XA0;&#XA0;Structural Recursion</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">8&#XA0;&#XA0;A Complete Implementation</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc34">8.1&#XA0;&#XA0;Integers</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc35">8.1.1&#XA0;&#XA0;Adding Inputs and Outputs to Supersets</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">8.1.2&#XA0;&#XA0;A Complete Integer Species</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc37">8.1.3&#XA0;&#XA0;An Integer Collection</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc38">8.2&#XA0;&#XA0;Lists if Integers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc39">8.3&#XA0;&#XA0;Subsets</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc40">8.3.1&#XA0;&#XA0;A Complete Subset Species</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">8.3.2&#XA0;&#XA0;A Subset Collection</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc42">8.4&#XA0;&#XA0;Using Subsets</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc43">8.4.1&#XA0;&#XA0;Top Level Use</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc44">8.4.2&#XA0;&#XA0;Producing an Executable</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">9&#XA0;&#XA0;Some Remarks</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc46">9.1&#XA0;&#XA0;Over-specifications</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc47">9.2&#XA0;&#XA0;Closure Reasoning&#X2019;s</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc48">9.3&#XA0;&#XA0;Observability Considerations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc49">9.4&#XA0;&#XA0;Functional Representations</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">A&#XA0;&#XA0;Inheritance Graph</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc51">B&#XA0;&#XA0;Full Sources</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc52">B.1&#XA0;&#XA0;superset.fcl</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">B.2&#XA0;&#XA0;subset.fcl</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc54">B.3&#XA0;&#XA0;mylist.fcl</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc55">B.4&#XA0;&#XA0;main.fcl</A>
</LI></UL>
</LI></UL><!--TOC section Forewords-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc1">1</A>&#XA0;&#XA0;Forewords</H2><!--SEC END --><P>
<A NAME="foreword"></A></P><!--TOC subsection Content-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc2">1.1</A>&#XA0;&#XA0;Content</H3><!--SEC END --><P>
<A NAME="foreword_content"></A></P><P>This document is a short tutorial for <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>, version <FONT COLOR=purple>0.6.0</FONT> released in December 2009 <SUP><A NAME="text1" HREF="#note1">1</A></SUP>.
It describes a full but simple
development using the main features of the <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> language, from the specification to the
implementation, including proofs of correction.</P><P>The reader is expected to have some basic knowledge of the <SPAN STYLE="font-variant:small-caps">OCaml</SPAN> language, of object-oriented
programming as well as an understanding of the standard logical operators (&#X2200;,
&#X21D2;, etc.) and notions about proofs.</P><P>This tutorial is not intended to be complete with regard to the <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> features, nor does it
recommend a specific design philosophy. In particular, It does not make use of the <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> library (providing numerous mathematical structures) but on the contrary builds from scratch
such a structure, for the sake of illustration.</P><!--TOC subsection Notations and Recommandations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc3">1.2</A>&#XA0;&#XA0;Notations and Recommandations</H3><!--SEC END --><P>
<A NAME="foreword_notation"></A></P><P>In the rest of this tutorial, pieces of <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> code will be presented in frames, as in this
example:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>use</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I> =</I></FONT></TD></TR>
</TABLE><P>This type of code has to be inserted in <SPAN STYLE="font-variant:small-caps">Unix</SPAN> ASCII files with a <EM>fcl</EM> extension. <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> keywords, types or identifiers can also be inserted directly in the text, for example

<CODE>#1</CODE>.</P><P>The <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> syntax is case sensitive, uppercase and lowercase identifier being associated to
different sorts of entities. Delimiters (blank spaces, tabulations, line feeds) are often
required to separate syntactical constructs. Finally, the use in <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> sources of <SPAN STYLE="font-variant:small-caps">OCaml</SPAN> or
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> keywords (such as 
<CODE>#1</CODE>) or of standard library file names (such as 
<CODE>#1</CODE>)
may result in name clashes. For these reasons, the reader is advised to respect as much as
possible the form and the names used in this tutorial.</P><P>The <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> syntax includes several forms of comments. Single line comments start with a

<CODE>#1</CODE> and go to the end of the line. Block comments are delimited by 
<CODE>#1</CODE> and

<CODE>#1</CODE>, and can be nested, that is, it is possible to comment a block of code which
includes comments. However, for the sake of readability, we will not use comments in our
examples; the reader is free to add comments were he feels appropriate. It is advised to avoid
some forms of comments, such as 
<CODE>#1</CODE>, 
<CODE>#1</CODE>, or 
<CODE>#1</CODE> (double quote) in block
comments; please refer to the <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> reference manual for detailed explanations.</P><P>Commands, file names as well as outputs or error messages are in bold font, for example
<B>focalizec superset.fcl</B>. Terms representing specific <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> concepts are introduced
using an emphasised font, for example <EM>collection</EM>. Finally, mathematical statements are
presented using the standard notations, for example &#X2200; (<I>x</I>:<I>T</I>), <I>x</I>=<I>x</I> (for any
<I>x</I> belonging to the set/type <I>T</I>, <I>x</I> is equal to <I>x</I>).</P><!--TOC section A Quick Overview of <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc4">2</A>&#XA0;&#XA0;A Quick Overview of <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN></H2><!--SEC END --><P>
<A NAME="overview"></A></P><P><SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> is an integrated development environment (IDE) with formal features. Beyond the compiler,
that from a <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> source file produces source code for <SPAN STYLE="font-variant:small-caps">OCaml</SPAN> and proof scripts to be checked
by <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> also provides an automated prover (<SPAN STYLE="font-variant:small-caps">Zenon</SPAN>), a test tool (<SPAN STYLE="font-variant:small-caps">FoCTest</SPAN>), a
documentation tool (<SPAN STYLE="font-variant:small-caps">FoCDoc</SPAN>), and other utilities. We mainly focus in this tutorial on
the use of the compiler (<B>focalizec</B>) and of the <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> automated prover
(<B>zvtov</B>). Note that <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> is the successor of the <SPAN STYLE="font-variant:small-caps">FoC</SPAN> and <SPAN STYLE="font-variant:small-caps">FoCaL</SPAN> tools,
with a fully redeveloped compiler.</P><P><SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> being a formal method, a typical development includes not only data structures and
programs, but also logical properties. This allows for the description of specifications and
of implementations, while providing a mathematical guarantee that implementations are indeed
compliant with their specifications. A <EM>specification</EM> consists of function signatures,
but also of associated properties that have to be satisfied, as in the following example
describing a commutative binary operation <I>f</I> over a set S with a left neutral
element:

</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP>&#XA0;<I>f</I>:S&#X2192;S&#X2192;S</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>&#XA0;&#X2200;&#XA0;<I>x</I>&#XA0;<I>y</I>,&#XA0;<I>f</I>(<I>x</I>,<I>y</I>)=<I>f</I>(<I>y</I>,<I>x</I>)</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>&#XA0;&#X2200;&#XA0;<I>x</I>,&#XA0;<I>f</I>(<I>Z</I>,<I>x</I>)=<I>x</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>

The left part is frequently encountered in classical, non-formal languages, under the names
signature, interface, prototype or specification. The two properties on the right part, on the
other hand, are less usual; in a formal method, they do not represent comments or assertions
checked at runtime, but a true requirement constraining <EM>implementations</EM> &#X2013; that is the
programs with concrete datatypes and algorithms. The correctness of the implementations has to
be statically ensured at compilation time by proving that they satisfy the properties, an
activity relying on <EM>formal proofs</EM> (in the mathematical sense), whose production is only
partially automated but which are mechanically checked.</P><P>The cost of develop ping formal specifications and proofs is compensated by the important gain
w.r.t. the confidence in the development. Various studies furthermore indicate that the total
development and ownership cost is likely to be reduced, due to disambiguation of the
specifications, earlier detection of problems, lighter test obligations and reduced
maintenance activities. Note also that it is possible to further assess the specification
itself by deriving consequences, to check that the specification is both correct and
sufficiently detailed; taking our previous example, it is possible to show that a valid
implementation of <I>f</I> is such that <I>f</I>(<I>x</I>,<I>Z</I>)=<I>x</I> &#X2013; just combining required properties,
without having to know what is this implementation.</P><P>The <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> language therefore combines a pure functional programming language inspired by <SPAN STYLE="font-variant:small-caps">OCaml</SPAN> and a logical language. It is also object-flavoured, developments being organised through a
hierarchy of <EM>species</EM>, build by <EM>inheritance</EM> or <EM>parameterisation</EM>. In
essence, a <EM>species</EM> is a kind of record combining function <EM>signatures</EM> (that is
their type), function <EM>definitions</EM> (that is their code), <EM>logical properties</EM> and
<EM>proofs</EM>.</P><P>When a species <I>S</I><SUB>2</SUB> <EM>inherits</EM> from a species <I>S</I><SUB>1</SUB>, that means that <I>S</I><SUB>2</SUB> includes at
least all the features of <I>S</I><SUB>1</SUB>, and can be enriched with its own functions or properties &#X2013;
intuitively speaking, any correct implementation of <I>S</I><SUB>2</SUB> is therefore also a correct
implementation of <I>S</I><SUB>1</SUB>.</P><P>A species can also use the implementation of other species to build its own definitions,
properties and proofs, through a <EM>parameterisation mechanism</EM>. The parameters are
required to be effective and consistent, that is to be such that every function declaration
has an associated definition, and every property a proof that it holds. Furthermore, the
validity of the properties of these effective parameters is likely to depend upon the
implementation choices done during their development, and it is therefore very important to
preserve them. This is addressed in <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> by the notion of <EM>collection</EM>: the
implementation of a complete species (that is a species whose all functions are defined and
all properties are proved) whose concrete data representation is hidden &#X2013; a form of abstract
data type. A collection only exposes the declaration of its functions and the statement of its
properties, through a structure called the <EM>interface</EM> of the collection; collections can
therefore be used safely as effective parameters.</P><P>Practically, if a species <I>S</I> has a formal parameter <I>C</I> of interface <I>I</I>, then <I>S</I> can use
all the functions and properties named in <I>I</I> in its body to build the definition of its
functions and to prove its properties, but cannot modify these functions or even examine their
definition. The compiler ensures that any collection <I>D</I> given as an effective parameter for
<I>C</I> indeed offers all the functions and properties stated in <I>I</I>. Note that species can also
be parameterised by entities, that is values of a collection. This is a powerful feature, e.g.
to describe structures such as &#X2124;/<I>n</I>&#X2124; where <I>n</I> is such a parameter, but we will not use
it in this tutorial.</P><!--TOC section The Development Case: Sets and Subsets-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc5">3</A>&#XA0;&#XA0;The Development Case: Sets and Subsets</H2><!--SEC END --><P>
<A NAME="case"></A></P><P>We deal in this tutorial with the classical example of subsets. We want to describe the
implementation of subsets of values, ensuring that it is bug-free, at least w.r.t. a
specification that we will make as complete as possible.</P><P>It is important, in such a development, to learn to abstract the fundamental concepts. Indeed,
one can easily describe such mathematical structures having a precise idea about their
implementation in mind, and consequently describing this implementation rather that the
structure itself. For example, in the case of subsets, a classical choice is to use sorted
and injective<SUP><A NAME="text2" HREF="#note2">2</A></SUP> lists;
whereas this is a valid implementation, there are other choices, and it would be a mistake to
capture too early some of the specificities of this encoding, such as for example the
existence of a comparison between values or of an order inside the concrete representation of
a subset.</P><P>As we will see, we adopt here a progressive approach, justified by various engineering
considerations regarding <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> developments, but also by the will to stick to the formal vision
presented just before. An interesting consequence of this vision is that a genuine freedom is
given to the developer, that can choose between various approaches for example to favour
genericity and reusability, or to optimize algorithms.</P><P>The rest of this paper describes the various stages of the development, distinguishing between
specification activities (the &#X201C;what to do&#X201D;) and refinements, that is the activities ensuring
progress toward an implementation (the &#X201C;how to do&#X201D;). We describe supersets, from which
values are obtained, and subsets of these supersets, before implementing these specifications.
Our main objective is to implement finite subsets as lists of values, but we will consider 
possible alternatives as well.</P><!--TOC section Specifying Supersets-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc6">4</A>&#XA0;&#XA0;Specifying Supersets</H2><!--SEC END --><P>
<A NAME="specsuperset"></A></P><P>When attempting to specify what is a subset of a superset &#X2013; for example subsets of &#X2115; &#X2013;
we need first to specify this superset. The simplest approach would be to decide to represent
subsets of a given superset, for example subsets of values from 
<CODE>#1</CODE>. Yet of course that
would force us to fully redevelop such an implementation for any relevant type, a rather
inappropriate strategy.</P><P>We therefore favour the generic approach, through a form of polymorphic specification. In
<SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>, this is possible by using parametrisation. Species can indeed be parametrised by an
<EM>interface</EM>, which means that implementation of the species will have to instantiate
this parameter by a collection having the required interface. In practice, this means that
before defining a species for subset, parametrized by an interface describing what is a
superset, we need first to define the superset interface. This is done by creating first a
species for superset, whose only role is to be passed as a parameter.</P><!--TOC subsection The Superset Species-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc7">4.1</A>&#XA0;&#XA0;The Superset Species</H3><!--SEC END --><P>
<A NAME="specsuperset_species"></A></P><P>What do we expect from a superset? Not much, as we can consider subsets of nearly anything.
Furthermore we do not need to enforce supersets to have a rich structure with powerful
operations. For now, only one very generic operator appears useful, an equivalence relation &#X2013;
representing a form of equality, for example to be able to test whether or not a subset
contains a value. Note that we do not require this equivalence to be a strict equality, for
example if we store strings that encodes natural values, we may decide that &#X201C;1&#X201D;, &#X201C;01&#X201D;
and &#X201C;+001&#X201D; are equivalent &#X2013; and checking if a given subset contains for example
&#X201C;+1&#X201D; will return true even if the stored value is in fact &#X201C;01&#X201D;.</P><P>We therefore edit a <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> source file, named <B>superset.fcl</B>, and type in the following
code:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>use</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>equal</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><P>The first line of our code indicates that we
intend to
use declarations and definitions from the file
<B>basics.fcl</B> (or more precisely its compiled version, <B>basics.fo</B>, which has to
be in the library path of the compiler). This standard file contains the definition of the
type 
<CODE>#1</CODE> which is needed here, as well as other utilities, and is generally required
for any <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> development.</P><DIV CLASS="theorem"><B>Tip&#XA0;1</B>&#XA0;&#XA0;<EM>[Compilation Units] Access to declarations and definitions from other files
is possible with the </EM><EM>
</EM><CODE><EM>#1</EM></CODE><EM> or </EM><EM>
</EM><CODE><EM>#1</EM></CODE><EM> directives; the latter allows for shorter
notations (e.g. </EM><EM>
</EM><CODE><EM>#1</EM></CODE><EM> or </EM><EM>
</EM><CODE><EM>#1</EM></CODE><EM> instead of </EM><EM>
</EM><CODE><EM>#1</EM></CODE><EM>
which is referred to &#X201C;file qualified notation&#X201D;. We will see later a similar mechanism to
invoke species methods that we call &#X201C;species qualified notation&#X201D;. In absence of
ambiguity between these two qualification mechanisms, we will generally use the shorter
term of &#X201C;qualified notation&#X201D;
). Note that the
</EM><EM>
</EM><CODE><EM>#1</EM></CODE><EM> and </EM><EM>
</EM><CODE><EM>#1</EM></CODE><EM> directives are not transitive, that is for example if </EM><EM><I>B</I></EM><EM> opens </EM><EM><I>A</I></EM><EM>
and </EM><EM><I>C</I></EM><EM> opens </EM><EM><I>B</I></EM><EM>, </EM><EM><I>C</I></EM><EM> does not have access to declaration and definitions of </EM><EM><I>A</I></EM><EM>.
</EM></DIV><P>We then define a species 
<CODE>#1</CODE> to represent the very abstract entity that we call a
superset. This species represents in fact any collection (any implementation) whose interface
contains a function 
<CODE>#1</CODE> with the required type; as we do not provide the definition
(the code) of this function, but just its type, we use the keyword 
<CODE>#1</CODE>. The type
of the function is <EM>Self</EM>&#X2192;<EM>Self</EM>&#X2192;<EM>bool</EM>, which means that it takes two
parameters of the current species<SUP><A NAME="text3" HREF="#note3">3</A></SUP> and
returns a boolean value.</P><DIV CLASS="theorem"><B>Tip&#XA0;2</B>&#XA0;&#XA0;<EM>[Syntax] Species names have to start with an uppercase character.
</EM></DIV><DIV CLASS="theorem"><B>Tip&#XA0;3</B>&#XA0;&#XA0;<EM>[Syntax] Separators (that is blank spaces, tabulations, line feeds) are often
required between syntactical constructs.
</EM></DIV><P>At this stage, we are not using any formal feature; indeed, we are just specifying here a form
of object with a given method. To have a meaningful specification, we further require the
equal function to represent an equivalence relation (that is to be reflexive, symmetric and
transitive). In addition, we also change the name of the method 
<CODE>#1</CODE>: to be easier
to read, we benefit from the <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> ability to manage symbols, and use the much more explicit
symbol 
<CODE>#1</CODE> instead. We therefore modify 
<CODE>#1</CODE> as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> ( = ) : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_refl</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_symm</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_tran</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>z</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>z</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>z</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><P>The symbol 
<CODE>#1</CODE>, in <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>, is associated to infix notations (but can still be used as a
prefix operator, when put between parentheses, as in its signature). This allows for a very
user-friendly presentation of the three properties that we expect about an equivalence
relation, namely reflexivity, symmetry and transitivity. We use the keyword 
<CODE>#1</CODE>,
hence we do not prove anything at this stage. We just require any collection implementing
this species to provide such a proof at some point of the development &#X2013; for example as soon
as 
<CODE>#1</CODE> is defined.</P><DIV CLASS="theorem"><B>Tip&#XA0;4</B>&#XA0;&#XA0;<EM>[Using Symbols] Methods can be denoted by names or symbols; the choice of an
appropriate symbol may greatly improve the readability of a code.
</EM></DIV><P>
<CODE>#1</CODE> now specifies any collection offering a function named 
<CODE>#1</CODE> taking two
parameters in the collection and returning a boolean, that is a relation; but it also requires
this relation to be reflexive, transitive and symmetric. This is a pure specification: there
are no definitions, no code. We explain what we expect, but the developer is free to
propose any compliant implementation. Note by the way that our specification does not even
enforce 
<CODE>#1</CODE> to contain a value: it can be implemented by an empty type.</P><P>At this stage, it is possible to compile our development with the command
<B>focalizec superset.fcl</B> &#X2013; of course, there is not much to expect from this
compilation, except for checking the syntax. It invokes the <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> compiler, as well as <SPAN STYLE="font-variant:small-caps">OCaml</SPAN> compiler, the <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> prover &#X2013; but there are no proof obligations at this stage, the species
only containing properties &#X2013; and the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> proof checker, producing the following files:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>File name</TD><TD ALIGN=center NOWRAP>Produced by</TD><TD ALIGN=center NOWRAP>Used by</TD><TD ALIGN=left NOWRAP>Description</TD></TR>
<TR><TD ALIGN=left NOWRAP><B>superset.fcl</B></TD><TD ALIGN=center NOWRAP>Text editor</TD><TD ALIGN=center NOWRAP><B>focalizec</B></TD><TD ALIGN=left NOWRAP><SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> source file</TD></TR>
<TR><TD ALIGN=left NOWRAP><B>superset.fo</B></TD><TD ALIGN=center NOWRAP><B>focalizec</B></TD><TD ALIGN=center NOWRAP><B>focalizec</B></TD><TD ALIGN=left NOWRAP><SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> object file</TD></TR>
<TR><TD ALIGN=left NOWRAP><B>superset.zv</B></TD><TD ALIGN=center NOWRAP><B>focalizec</B></TD><TD ALIGN=center NOWRAP><B>zvtov</B></TD><TD ALIGN=left NOWRAP>Proof obligations</TD></TR>
<TR><TD ALIGN=left NOWRAP><B>superset.ml</B></TD><TD ALIGN=center NOWRAP><B>focalizec</B></TD><TD ALIGN=center NOWRAP><B>ocamlc</B></TD><TD ALIGN=left NOWRAP>Program source file</TD></TR>
<TR><TD ALIGN=left NOWRAP><B>superset.pfc</B></TD><TD ALIGN=center NOWRAP><B>zvtov</B></TD><TD ALIGN=center NOWRAP><B>zvtov</B></TD><TD ALIGN=left NOWRAP><SPAN STYLE="font-variant:small-caps">Zenon</SPAN> proof cache</TD></TR>
<TR><TD ALIGN=left NOWRAP><B>superset.v</B></TD><TD ALIGN=center NOWRAP><B>zvtov</B></TD><TD ALIGN=center NOWRAP><B>coqc</B></TD><TD ALIGN=left NOWRAP>Proofs</TD></TR>
<TR><TD ALIGN=left NOWRAP><B>superset.vo</B></TD><TD ALIGN=center NOWRAP><B>coqc</B></TD><TD ALIGN=center NOWRAP><B>coqc</B></TD><TD ALIGN=left NOWRAP><SPAN STYLE="font-variant:small-caps">Coq</SPAN> object file</TD></TR>
<TR><TD ALIGN=left NOWRAP><B>superset.cmi</B></TD><TD ALIGN=center NOWRAP><B>ocamlc</B></TD><TD ALIGN=center NOWRAP><B>ocamlc</B></TD><TD ALIGN=left NOWRAP><SPAN STYLE="font-variant:small-caps">OCaml</SPAN> interface file</TD></TR>
<TR><TD ALIGN=left NOWRAP><B>superset.cmo</B></TD><TD ALIGN=center NOWRAP><B>ocamlc</B></TD><TD ALIGN=center NOWRAP><B>ocamlc</B></TD><TD ALIGN=left NOWRAP><SPAN STYLE="font-variant:small-caps">OCaml</SPAN> object code</TD></TR>
</TABLE><!--TOC subsection A First Proof-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc8">4.2</A>&#XA0;&#XA0;A First Proof</H3><!--SEC END --><P>
<A NAME="specsuperset_proof"></A></P><P>Whereas 
<CODE>#1</CODE> is a very short and simple specification, it can be enriched with
additional results without further requirements. For example, combining reflexivity and
transitivity, it is possible to prove the following property about 
<CODE>#1</CODE> of the

<CODE>#1</CODE> species as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_symmtran</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>z</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>z</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>z</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_symm</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>eq_tran</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><P>We use the keyword 
<CODE>#1</CODE> instead of 
<CODE>#1</CODE> to indicate that the proof
follows &#X2013; it is provided after the keyword 
<CODE>#1</CODE>.
Hence, a 
<CODE>#1</CODE> accompanied by its 
<CODE>#1</CODE> is equivalent to a 
<CODE>#1</CODE>.
In fact, we do not detail a real
proof, but rather tips that allow <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> to automatically derive the proof<SUP><A NAME="text4" HREF="#note4">4</A></SUP>; we claim that 
<CODE>#1</CODE> is a direct consequence of

<CODE>#1</CODE> and 
<CODE>#1</CODE>. At this stage, we can invoke the compiler to check that
indeed <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> succeeds.</P><DIV CLASS="theorem"><B>Tip&#XA0;5</B>&#XA0;&#XA0;<EM>[Derived properties] Once primitive properties have been introduced, other
results can be proved, for example user-relevant corollaries, to check the validity and the
completeness of the specification.
</EM></DIV><P>Note that 
<CODE>#1</CODE> and 
<CODE>#1</CODE> are in fact used as hypothesis to prove

<CODE>#1</CODE>, in other words we have proven
<EM>eq_symm</EM>&#X21D2;<EM>eq_tran</EM>&#X21D2;<EM>eq_symmtran</EM>. That means
that the validity of the latter depends upon the
consistence
of the formers, and that there is
therefore no real assurance until proofs are provided for them.</P><P>In the rest of this tutorial, we will not further mention standard compilation steps; the
reader is invited to compile when he considers it is relevant.</P><!--TOC subsection A First Definition-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc9">4.3</A>&#XA0;&#XA0;A First Definition</H3><!--SEC END --><P>
<A NAME="specsuperset_definition"></A></P><P>To further illustrate the <EM>late binding</EM> feature of <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>, that is in essence the ability
to describe and use entities which are not yet defined, we again enrich the species

<CODE>#1</CODE>, this time with the <EM>definition</EM> of a function:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( &lt;&gt; ) (</I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( ~~ )(</I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>diff_irrefl</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, ~(</I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> &lt;&gt; </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( &lt;&gt; ) </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_refl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>diff_symm</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> &lt;&gt; </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> &lt;&gt; </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( &lt;&gt; ) </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_symm</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><P>In this case, we provide the code for the function 
<CODE>#1</CODE>, introduced by the keyword

<CODE>#1</CODE>. Without surprise, we indicate that 
<CODE>#1</CODE> is the negation of 
<CODE>#1</CODE>, but one
should note that 
<CODE>#1</CODE> itself is not yet defined. However, this is sufficient to prove
properties of 
<CODE>#1</CODE>, such as 
<CODE>#1</CODE> and 
<CODE>#1</CODE>. The proof of these
properties is again automatically derived by <SPAN STYLE="font-variant:small-caps">Zenon</SPAN>, the tips in this case also ensuring that
the definition of 
<CODE>#1</CODE> is visible from the proof context.</P><P>A definition of 
<CODE>#1</CODE> is provided in the species 
<CODE>#1</CODE>, but it is possible to
override it later (in inheriting species or collection), for example to optimize the
implementation, once more information about the structure are provided.</P><P>It is fundamental to remember that <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> enforces encapsulation; this means that any definition
in a species, such as the one for 
<CODE>#1</CODE> here, is visible only in this species (or the
inheriting ones). As definitions are never visible outside a species, we recommend for such
early definition to associate dedicated properties capturing the essence of the definition in
a logical form, visible from other species, such as 
<CODE>#1</CODE> that we add to our species
as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>diff_eq</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> &lt;&gt; </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> &lt;-&gt; ~(</I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( &lt;&gt; ) ;</I></FONT></TD></TR>
</TABLE><P>
<CODE>#1</CODE> is here described as a theorem whose proof depends upon the definition of

<CODE>#1</CODE>. Any later redefinition of 
<CODE>#1</CODE> will delete this proof, and transform
back

<CODE>#1</CODE> into a proof obligation. The interest of a property like 
<CODE>#1</CODE> is
that it can be used instead of the definition of 
<CODE>#1</CODE> to prove 
<CODE>#1</CODE> and

<CODE>#1</CODE>: if 
<CODE>#1</CODE> is indeed redefined later, only the proof of 
<CODE>#1</CODE>
will have to be redone.</P><DIV CLASS="theorem"><B>Tip&#XA0;6</B>&#XA0;&#XA0;<EM>[Early Definitions] Definitions can be introduced at any stage of a </EM><EM><SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN></EM><EM> development; it is recommended to capture the meaning of early definitions in properties
(proved using the definition), and to use these properties in proofs, instead of the
definitions themselves, to limit the consequences of redefinitions.
</EM></DIV><!--TOC subsection Clearing of the Superset Species-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc10">4.4</A>&#XA0;&#XA0;Clearing of the Superset Species</H3><!--SEC END --><P>
<A NAME="specsuperset_clear"></A></P><P>We have enriched our 
<CODE>#1</CODE> species just to illustrate some of the features of <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>.
As these artificial examples are not used later in this tutorial, we suggest to delete them.
The file <B>superset.fcl</B> should be modified as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>use</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> ( = ) : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_refl</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_symm</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_tran</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>z</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>z</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>z</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><!--TOC section Specifying Subsets-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc11">5</A>&#XA0;&#XA0;Specifying Subsets</H2><!--SEC END --><P>
<A NAME="specsubset"></A></P><P>It is now time to specify subsets of values from a superset in a new species. It is possible
to append the new code in the previous file, but we prefer to create a new file named
<B>subset.fcl</B>.
As previously stated, the directives 
<CODE>#1</CODE> or 
<CODE>#1</CODE> can be used to access previous
definitions. Remember that with 
<CODE>#1</CODE> explicit and detailed names are required, for
example 
<CODE>#1</CODE>, whereas 
<CODE>#1</CODE> is sufficient if we
use 
<CODE>#1</CODE> instead.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>use</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>open</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>superset</I></FONT><FONT SIZE=2><I>" ;;</I></FONT></TD></TR>
</TABLE><!--TOC subsection Generic Subsets-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc12">5.1</A>&#XA0;&#XA0;Generic Subsets</H3><!--SEC END --><P>
<A NAME="specsubset_generic"></A></P><P>The species 
<CODE>#1</CODE> is parametrised by a collection 
<CODE>#1</CODE> which implements the
interface defined by the species 
<CODE>#1</CODE>. Regarding the method, we provide a
membership operation deciding whether or not a value belongs to a subset, denoted 
<CODE>#1</CODE>;
practically, membership defines a subset, as any subset is characterised by the values it
contains<SUP><A NAME="text5" HREF="#note5">5</A></SUP>:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Subset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> ( &lt;&lt; ) : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I>;;</I></FONT></TD></TR>
</TABLE><P>Of course using only this method we cannot do much: neither do we have a way to exhibit a
subset, nor to express any property about membership. So additional methods have to be
declared, in association with properties that sufficiently describe what we expect from these
methods. However, we also have to be cautious not to add too powerful methods, that would lead
to over-specify the species and reduce the acceptable implementations (or logical models).</P><P>It appears reasonable to add a method to build an empty subset. Indeed, it always exists such
a subset, even if for example 
<CODE>#1</CODE> is itself empty. Another seemingly harmless feature
(in the sense that it is likely to be implementable whatever the concrete representation we
choose) is the ability to derive subsets from other subsets by adding or removing a value.
Following these principles, our species is enriched as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_empty</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, ~(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> ( + ) : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                       </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> + </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> &lt;-&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                       (</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>) \/ </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> ( - ) : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                       </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> &lt;-&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                       (~(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>)) /\ </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT></TD></TR>
</TABLE><P>In this specification, each method producing a subset is associated to a property detailing
its behaviour with regard to membership. As membership indeed characterises a specific subset,
such properties are as precise as a definition. This is typical of <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> specifications, where
the concrete datatype stays hidden from outside the species: properties are generally
relations between methods, describing the structure of a species.</P><P>We have adopted a very dense presentation of these properties: 
<CODE>#1</CODE> claims that a
value is a member of 
<CODE>#1</CODE> if and only if this is 
<CODE>#1</CODE> or if it was already a
member of 
<CODE>#1</CODE>. It could have been split in three different properties, but we here
trust <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> to exploit automatically all variants of this properties, and we favor this form
to reduce the number of tips to be provided for proofs.</P><P>Note that the notation 
<CODE>#1</CODE>, in the context of the species 
<CODE>#1</CODE>, would refer
either to a method defined in the current species or to a method defined at <EM>top level</EM>
(that is outside a species or a collection), possibly in one of the included files. As we want
to use the equality of the parameter 
<CODE>#1</CODE>, we need the explicit notation

<CODE>#1</CODE>, which is a prefix notation.</P><P>Are additional methods desirable at this stage of the specification? We choose here not to go
further, yet this is a matter of taste and style. For example, it may be acceptable to specify
union and intersection, as it does not seem to restrict the possible concrete representations
for subsets. On the other hand, from a practical point of view, that means that any
implementation of the species 
<CODE>#1</CODE>, in addition to providing the definition for

<CODE>#1</CODE>, 
<CODE>#1</CODE>, 
<CODE>#1</CODE> as well as the proofs of the associated properties, would also
have to provide a definition and the proofs for union and intersection, even if these last
operations are not useful for a given application. So it may be more appropriate to add such
operations in a later species and let developers to choose to use the 
<CODE>#1</CODE>
specification or one of its extended versions.</P><!--TOC subsection Extensional Subsets-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">5.2</A>&#XA0;&#XA0;Extensional Subsets</H3><!--SEC END --><P>
<A NAME="specsubset_extensional"></A></P><P>Whereas our main objective is to implement finite subsets as lists, we choose here to
introduce very gradually various levels of specifications. Note that nothing enforces at this
stage the species 
<CODE>#1</CODE> to only describe finite subsets, and we do not want to further
constrain it by requiring other methods and properties in 
<CODE>#1</CODE>. We prefer to adopt a
smoother approach, adding another level of specification by creating a new species to
represent finite subsets, or more precisely extensional subsets.</P><P>Indeed, it is not trivial to specify finite subsets. One of the most classical approaches is
to define a cardinal operator in <I>Self</I>&#X2192;&#X2115;, returning the number of elements in the
subset. The simple existence of this operator, total over <I>Self</I>, combined with
properties indicating its semantics, is indeed sufficient. Yet that would require using
natural values, that is to have a collection parameter with a species representing &#X2115;.
Appropriate species exist in the <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> standard library, but we prefer to avoid in this
tutorial such dependencies for now.</P><P>We therefore adopt here a slightly different approach, by specifying extensional subsets, that
is subset whose content can be analysed systematically.</P><!--TOC subsubsection Inclusion-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc14">5.2.1</A>&#XA0;&#XA0;Inclusion</H4><!--SEC END --><P>
<A NAME="specsubset_extensional_inclusion"></A></P><P>Extensional subsets being subsets, we use the inheritance mechanism: we create a new species

<CODE>#1</CODE> parametrised by a collection 
<CODE>#1</CODE>, which inherits of

<CODE>#1</CODE>, that is of all its methods and properties. Of course, we intend to enrich
this specification with new methods and properties.</P><P>The new requirement in 
<CODE>#1</CODE> is to have a method checking whether or not a subset
is included in another, denoted 
<CODE>#1</CODE> in our code.
Taking benefit
from the specification of
the (yet undefined) inclusion method, it is already possible to prove that inclusion is
reflexive and transitive:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>ExtSubset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Subset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> ( &lt;: ) : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> &lt;-&gt; </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_refl</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_tran</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s3</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s3</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s3</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I>;;</I></FONT></TD></TR>
</TABLE><P>Any collection implementing 
<CODE>#1</CODE> will therefore have to provide code for the
method 
<CODE>#1</CODE> as well as a proof that this code indeed represents inclusion; provided this
proof reflexivity and transitivity will be ensured as well without further work.</P><DIV CLASS="theorem"><B>Tip&#XA0;7</B>&#XA0;<B>(Inheritance)</B>&#XA0;&#XA0;<EM> The </EM><EM>
</EM><CODE><EM>#1</EM></CODE><EM> clause has to be the first one in a species; it
indicates that the current species includes all the signatures, definitions, properties and
proofs on the inherited species.
</EM></DIV><!--TOC subsubsection Extensional Equality-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc15">5.2.2</A>&#XA0;&#XA0;Extensional Equality</H4><!--SEC END --><P>
<A NAME="specsubset_extensional_equal"></A></P><P>An evident enrichment is to define the equality of two finite subsets as the reciprocal
inclusion. This should however ring a bell: if the species 
<CODE>#1</CODE> offers an
equality, then it can probably also inherits from the species 
<CODE>#1</CODE>. That&#X2019;s our
design choice here, using the multiple inheritance feature provided by <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>. We therefore
modify and extends the species 
<CODE>#1</CODE> as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>ExtSubset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Subset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> ( &lt;: ) : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> &lt;-&gt; </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_refl</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_tran</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s3</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s3</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s3</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( = ) (</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> (</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> (</I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I>;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I>;;</I></FONT></TD></TR>
</TABLE><P>
<CODE>#1</CODE> is now a species combining the interface of 
<CODE>#1</CODE> and

<CODE>#1</CODE>: equality (of subsets), membership, insertion, removal, as well as the
associated properties<SUP><A NAME="text6" HREF="#note6">6</A></SUP>. Equality is also defined using
inclusion<SUP><A NAME="text7" HREF="#note7">7</A></SUP>.
Using these properties and the definition of 
<CODE>#1</CODE>, we can discharge the proof obligations
inherited from 
<CODE>#1</CODE>:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_refl</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( = ) </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_refl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_symm</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( = ) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_tran</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( = ) </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_tran</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><P>Defining 
<CODE>#1</CODE> using 
<CODE>#1</CODE> is apparently relevant, and allows us to discharge the
associated proof obligations. This is not constraining, as we know that thanks to
late binding it is possible to later change the definition of 
<CODE>#1</CODE>, for example for
optimisation. But of course such a redefinition would erase the proofs depending upon the
current definition, here 
<CODE>#1</CODE>, 
<CODE>#1</CODE> and 
<CODE>#1</CODE>.</P><P>Now, we can already consider that such a redefinition is more than likely to happen. For
example, if we implement subsets as lists, checking equality will require checking twice
inclusion between lists, while comparing directly the two lists is more efficient. So it is
indeed pleasant to be able to discharge so soon the proof obligations, but it is probably
useless &#X2013; at least in the current form of the species. Therefore, exactly as we have done
when dealing with the definition of 
<CODE>#1</CODE> of the species 
<CODE>#1</CODE> in Sub.
<A HREF="#specsuperset_definition">4.3</A>, instead of defining 
<CODE>#1</CODE> using 
<CODE>#1</CODE>, we capture the
meaning of the definition in a property, which is used to discharge the proof obligations:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> &lt;-&gt; </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> /\ </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_refl</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>incl_refl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_symm</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_tran</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>incl_tran</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_eq</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> &lt;-&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  (</I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;-&gt; </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><P>Note that here we can delete the definition of 
<CODE>#1</CODE>. It is trivial to show that

<CODE>#1</CODE> indeed satisfies 
<CODE>#1</CODE>, if we decide to use such a
definition; on the other hand, if we provide a more efficient algorithm for 
<CODE>#1</CODE>, we have
just to check its validity by proving 
<CODE>#1</CODE>, never having to prove again

<CODE>#1</CODE>, 
<CODE>#1</CODE> and 
<CODE>#1</CODE>.</P><!--TOC subsubsection A Few Trivial Properties-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc16">5.2.3</A>&#XA0;&#XA0;A Few Trivial Properties</H4><!--SEC END --><P>
<A NAME="specsubset_extensional_trivial"></A></P><P>Having proposed a definition of extensional subsets by enforcing a signature containing
inclusion with some standard properties, we now complete our species with additional facts
that we consider relevant and useful for later uses. We add the following properties and
proofs in the species 
<CODE>#1</CODE>:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_empty</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_empty</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_insert</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_remove</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_insert_mem</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                           </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><P>Compiling this new version, <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> is able to derive a proof for 
<CODE>#1</CODE>,

<CODE>#1</CODE> and 
<CODE>#1</CODE>, but not for 
<CODE>#1</CODE>. Before blaming
<SPAN STYLE="font-variant:small-caps">Zenon</SPAN>, let&#X2019;s produce by hand a derivation tree of the property 
<CODE>#1</CODE>, giving
a hierarchical vision of the deductive proof. In such a tree the goal is at the bottom, and
using deduction rules we progress toward trivial subgoals at the top of the tree, possibly
branching (for example, to prove <I>A</I>&#X2227;<I>B</I> one may provide a proof of <I>A</I> and a proof of
<I>B</I>). We got something like:

</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>?</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>s</I>:<I>Self</I>,&#XA0;<I>v</I>&#XA0;<I>w</I>:<EM>Val</EM>,&#XA0;<I>v</I>&#X2208;<I>s</I>,&#XA0;<I>v</I>=<I>w</I>&#X22A2;&#XA0;<I>w</I>&#X2208;<I>s</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;
</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>Trivial, by assumption</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>s</I>:<I>Self</I>,&#XA0;<I>v</I>&#XA0;<I>w</I>:<EM>Val</EM>,&#XA0;<I>v</I>&#X2208;<I>s</I>,&#XA0;<I>w</I>&#X2208;<I>s</I>&#X22A2;&#XA0;<I>w</I>&#X2208;<I>s</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>s</I>:<I>Self</I>,&#XA0;<I>v</I>&#XA0;<I>w</I>:<EM>Val</EM>,&#XA0;<I>v</I>&#X2208;<I>s</I>,&#XA0;<I>w</I>=<I>v</I>&#XA0;&#X2228;&#XA0;<I>w</I>&#X2208;<I>s</I>&#X22A2;&#XA0;<I>w</I>&#X2208;<I>s</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>s</I>:<I>Self</I>,&#XA0;<I>v</I>&#XA0;<I>w</I>:<EM>Val</EM>,&#XA0;<I>v</I>&#X2208;<I>s</I>,&#XA0;<I>w</I>&#X2208;<I>s</I>+<I>v</I>&#X22A2;&#XA0;<I>w</I>&#X2208;<I>s</I></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>s</I>:<I>Self</I>,&#XA0;<I>v</I>:<EM>Val</EM>,&#XA0;<I>v</I>&#X2208;<I>s</I>&#X22A2;
&#X2200;&#XA0;<I>w</I>:<EM>Val</EM>,&#XA0;<I>w</I>&#X2208;<I>s</I>+<I>v</I>&#X21D2;&#XA0;<I>w</I>&#X2208;<I>s</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X22A2;
&#X2200;&#XA0;<I>s</I>:<I>Self</I>,&#XA0;<I>v</I>:<EM>Val</EM>,&#XA0;
<I>v</I>&#X2208;<I>s</I>&#X21D2;&#XA0;<I>s</I>+<I>v</I>&#X2286;<I>s</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>

This identifies the difficulty preventing the derivation of the proof by <SPAN STYLE="font-variant:small-caps">Zenon</SPAN>, as something
is missing in the left branch, the subgoal denoted by the interrogation mark. Indeed, this
subgoal has no reason to be valid: 
<CODE>#1</CODE> is an equivalence relation, but nothing enforces
it to be a congruence w.r.t. membership, that is we have never required
<I>v</I>&#X2208;<I>s</I>, <I>v</I>=<I>w</I>&#X22A2; <I>w</I>&#X2208;<I>s</I>. To understand why this may not be the case even in
perfectly legitimate cases, remember the comment in Sub. <A HREF="#specsuperset_species">4.1</A>, about the
encoding of natural values as strings.</P><P>Of course, using the symbol 
<CODE>#1</CODE> it is clear that our intention was to capture a form of
equality; so we can emphasise this interpretation by adding the congruence property at the
beginning of the species 
<CODE>#1</CODE>:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_congr</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      (</I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, (</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) &lt;-&gt; (</I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>)) ;</I></FONT></TD></TR>
</TABLE><P>Given this property as an additional tip, <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> indeed succeeds:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_insert_mem</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                           </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_congr</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><!--TOC subsubsection Proving Non Trivial Properties-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc17">5.2.4</A>&#XA0;&#XA0;Proving Non Trivial Properties</H4><!--SEC END --><P>
<A NAME="specsubset_extensional_nontrivial"></A></P><P>We can also try to prove the following property:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_remove_mem</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                           ~(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_congr</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><P><SPAN STYLE="font-variant:small-caps">Zenon</SPAN> does not succeeds<SUP><A NAME="text8" HREF="#note8">8</A></SUP>, but in this case it is apparently not because of missing
information as a proof by hand appears possible:

</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>Assuming <I>w</I>=<I>v</I> is absurd</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>s</I>:<I>Self</I>,&#XA0;<I>v</I>&#XA0;<I>w</I>:<EM>Val</EM>,&#XA0;<I>v</I>&#X2209;<I>s</I>,&#XA0;<I>w</I>&#X2208;<I>s</I>&#X22A2;&#XA0;<I>w</I>&#X2260;<I>v</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;
</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>Trivial, by assumption</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>s</I>:<I>Self</I>,&#XA0;<I>v</I>&#XA0;<I>w</I>:<EM>Val</EM>,&#XA0;<I>v</I>&#X2209;<I>s</I>,&#XA0;<I>w</I>&#X2208;<I>s</I>&#X22A2;&#XA0;<I>w</I>&#X2208;<I>s</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>s</I>:<I>Self</I>,&#XA0;<I>v</I>&#XA0;<I>w</I>:<EM>Val</EM>,&#XA0;<I>v</I>&#X2209;<I>s</I>,&#XA0;<I>w</I>&#X2208;<I>s</I>&#X22A2;
<I>w</I>&#X2260;<I>v</I>&#XA0;&#X2227;&#XA0;<I>w</I>&#X2208;<I>s</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>s</I>:<I>Self</I>,&#XA0;<I>v</I>&#XA0;<I>w</I>:<EM>Val</EM>,&#XA0;<I>v</I>&#X2209;<I>s</I>,&#XA0;<I>w</I>&#X2208;<I>s</I>&#X22A2;&#XA0;<I>w</I>&#X2208;<I>s</I>&#X2212;<I>v</I></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>s</I>:<I>Self</I>,&#XA0;<I>v</I>:<EM>Val</EM>,&#XA0;<I>v</I>&#X2209;<I>s</I>&#X22A2;
&#X2200;&#XA0;<I>w</I>:<EM>Val</EM>,&#XA0;<I>w</I>&#X2208;<I>s</I>&#X21D2;&#XA0;<I>w</I>&#X2208;<I>s</I>&#X2212;<I>v</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X22A2;
&#X2200;&#XA0;<I>s</I>:<I>Self</I>,&#XA0;<I>v</I>:<EM>Val</EM>,&#XA0;
<I>v</I>&#X2209;<I>s</I>&#X21D2;&#XA0;<I>s</I>&#X2286;<I>s</I>&#X2212;<I>v</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>

It is likely to be a problem of complexity, and human guidance is required.</P><P>Two main approaches are possible in <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> to prove non-trivial properties using <SPAN STYLE="font-variant:small-caps">Zenon</SPAN>. The
first one consists into introducing progressively lemmas, easier to prove, then to use these
lemmas to derive the complex results. Unfortunately, this
makes the signature of the species more complex with numerous uninteresting results; in other word, the documentation of the species
can quickly becomes clumsy. The second approach requires user-guided proof using the <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> Proof Language (<SPAN STYLE="font-variant:small-caps">Fpl</SPAN>). We adopt the latter, detailing the important steps of the proof and
expecting <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> to complete it, as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_remove_mem</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                           ~(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hv</I></FONT><FONT SIZE=2><I> : ~(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>)) /\ </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_congr</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hv</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;3&gt;1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><P>This script details the proof structure to be followed by <SPAN STYLE="font-variant:small-caps">Zenon</SPAN>. The label 
<CODE>#1</CODE>
indicates the level 
<CODE>#1</CODE> and the step 
<CODE>#1</CODE> in this level; levels have to be managed
consistently, while steps are just names. In essence, to prove a result labelled 
<CODE>#1</CODE>,
one can introduce a few lemmas labelled 
<CODE>#1</CODE>, &#X2026;, 
<CODE>#1</CODE> and conclude
with a command 
<CODE>#1</CODE> (and additional hypotheses
and properties if required). Note that the step 
<CODE>#1</CODE> here is the user notation for the
final step for a given level, but that the compiler does not care about the value specifying
the step as long as it is a unique identifier for the current level. Similarly, the label

<CODE>#1</CODE> does not mark the proof of the statement 
<CODE>#1</CODE> but use this statement to
prove the theorem 
<CODE>#1</CODE>. Take care to use different step identifiers for a
given level, as repeating an identifier will not cause an error but will mask the associated
results and prevent <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> to conclude.</P><P>A goal step is associated with assumptions (keyword 
<CODE>#1</CODE> or 
<CODE>#1</CODE>), a
goal (keyword 
<CODE>#1</CODE>), and possibly the tips to solve the goal (keyword 
<CODE>#1</CODE>
completed with 
<CODE>#1</CODE>, 
<CODE>#1</CODE>, 
<CODE>#1</CODE>, 
<CODE>#1</CODE> and

<CODE>#1</CODE>). If the goal 
<CODE>#1</CODE> is not provided with tips, then the next steps (at level

<CODE>#1</CODE>) provide a strategy to solve it, the last step of the level 
<CODE>#1</CODE> being
expected to be a 
<CODE>#1</CODE> with tips (or a 
<CODE>#1</CODE>, which is equivalent to a

<CODE>#1</CODE>).</P><P>Writing such a script is better done incrementally and interactively. The first attempt is
generally a fully automated proof by <SPAN STYLE="font-variant:small-caps">Zenon</SPAN>, levels being introduced gradually to give
additional tips and guidances for tricky parts. Let&#X2019;s develop such a proof for a new theorem
in our species 
<CODE>#1</CODE> that describes a way to split a subset, first attempting an
automated proof:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>remove_insert</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                         </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> = (</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      </I></FONT><FONT SIZE=2><I>mem_congr</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>diff_eq</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><P><SPAN STYLE="font-variant:small-caps">Zenon</SPAN> is however unlikely to derive the proof, so we have to give more details:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>remove_insert</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                         </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> = (</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hv</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> = (</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; (</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;2 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; (</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_congr</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                   </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>diff_eq</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1, &lt;2&gt;2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;1&gt;1 ;</I></FONT></TD></TR>
</TABLE><P>The level 
<CODE>#1</CODE> is associated to the theorem we want to prove, and the level 
<CODE>#1</CODE>
indicates that to prove the equality, we have to prove the mutual inclusion. Invoking the
compiler, we got a message indicating that no proof has been found for 
<CODE>#1</CODE> and

<CODE>#1</CODE>; on the other hand the absence of error messages for 
<CODE>#1</CODE> also indicates
that provided a proof for 
<CODE>#1</CODE> and 
<CODE>#1</CODE> <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> will indeed conclude. So we
provide more details, but only for the failing steps, first 
<CODE>#1</CODE>:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>           &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; (</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>)) -&gt; </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;3&gt;1</I></FONT></TD></TR>
</TABLE><P>The important indication given in step 
<CODE>#1</CODE> is to consider the case <I>w</I>&#X2260;<I>v</I>;
<SPAN STYLE="font-variant:small-caps">Zenon</SPAN> is then able to conclude (by also considering the case <I>w</I>=<I>v</I>, for which the
property 
<CODE>#1</CODE> apply) and prove the subgoal 
<CODE>#1</CODE>.</P><P>Given the same amount of details for 
<CODE>#1</CODE>, the proof is finally derived:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>           &lt;2&gt;2 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; (</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_congr</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hv</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                        </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;3&gt;1, &lt;3&gt;2</I></FONT></TD></TR>
</TABLE><P><SPAN STYLE="font-variant:small-caps">Zenon</SPAN> provides various indications when failing or succeeding, for example:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
When succeeding, the message <B>unused hypothesis</B> (alternatively
<B>unused variable</B>) indicates that some of the tips or variables are useless; note
however that useless tips are not always be detected as there is no guarantee that <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> will
find the most &#X201C;efficient&#X201D; proof<SUP><A NAME="text9" HREF="#note9">9</A></SUP>.
</LI><LI CLASS="li-itemize">When failing, the message <B>exhausted search space without finding a proof</B>
indicates that it is impossible to prove the goal, at least with just the provided tips. The
goal is not derivable from the provided assumptions,
or may be false.
</LI><LI CLASS="li-itemize">When failing, the message <B>could not find a proof within the time limit</B>
(alternatively <B>within the memory size limit</B> or
<B>within the inference steps limit</B>) indicates that <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> has reached the fixed limits
passed as parameters; there may be a proof or not. It is then possible either to modify the
parameters used when invoking <SPAN STYLE="font-variant:small-caps">Zenon</SPAN>, or to reduce the number of tips, or to use the <SPAN STYLE="font-variant:small-caps">Fpl</SPAN> to
split the proof in subproofs.
</LI></UL><P>To avoid error messages, an alternative solution is to incrementally develop the proof using
the keyword 
<CODE>#1</CODE>. For example, to prove a goal, you may consider 3 subgoals and
start your proof as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> ...</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subgoal1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>         &lt;1&gt;2 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> ...</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subgoal2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>         &lt;1&gt;3 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> ...</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subgoal3</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>         &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><P>The compiler can be invoked to check that indeed the goal can be proved using the three
subgoals. It is then possible to focus for example on the proof of step 
<CODE>#1</CODE>, etc.</P><DIV CLASS="theorem"><B>Tip&#XA0;8</B>&#XA0;<B>(Proofs)</B>&#XA0;&#XA0;<EM> Complex proofs are better developed incrementally, from the general levels
to the more detailed ones, and invoking regularly </EM><EM><SPAN STYLE="font-variant:small-caps">Zenon</SPAN></EM><EM> to check the validity of the
currently developed steps.
</EM></DIV><!--TOC subsection Finite Subsets-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc18">5.3</A>&#XA0;&#XA0;Finite Subsets</H3><!--SEC END --><P>
<A NAME="specsubset_finite"></A></P><P>We have used inheritance and parametrisation as composition operators between specifications,
describing a species 
<CODE>#1</CODE>, a species 
<CODE>#1</CODE> and a species 
<CODE>#1</CODE>.</P><P>Our aim is to define additional species inheriting from 
<CODE>#1</CODE>, to provide more and
more details, for example indicating that the representation (the concrete datatype of the
elements of the species) is based on lists and providing the associated algorithms for the
methods. In such a case the inheritance acts as a refinement operator &#X2013; that is progress
toward an implementation, with concrete datatypes and algorithms.</P><P>The most straightforward approach would be to embed the definition of the type and operations
for lists in the species inheriting from 
<CODE>#1</CODE>. Yet we choose here to first specify
and implement lists in an independent hierarchy of species, and then to use this hierarchy to
refine 
<CODE>#1</CODE>. Beyond the illustration provided in this tutorial, this approach is
also fully justifiable, ensuring reusability of lists in other contexts.</P><!--TOC section Specifying Lists-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc19">6</A>&#XA0;&#XA0;Specifying Lists</H2><!--SEC END --><P>
<A NAME="speclist"></A></P><P>We edit a new file, named <B>mylist.fcl</B><SUP><A NAME="text10" HREF="#note10">10</A></SUP>, to describe lists, with two directives:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>use</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>open</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>superset</I></FONT><FONT SIZE=2><I>" ;;</I></FONT></TD></TR>
</TABLE><!--TOC subsection Co-Lists-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc20">6.1</A>&#XA0;&#XA0;Co-Lists</H3><!--SEC END --><P>
<A NAME="speclist_co"></A></P><P>We start with a species 
<CODE>#1</CODE> that represents a very abstract form of lists, possibly
infinite. As for 
<CODE>#1</CODE>, 
<CODE>#1</CODE> needs to be parametrised by a 
<CODE>#1</CODE>,
representing the values that are put in a list. We also specify various methods, as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>CoList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_nil</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) &lt;-&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                       ~ </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>list_dec</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     ~ </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>))) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><P>The 
<CODE>#1</CODE> and 
<CODE>#1</CODE> methods are used to build

<CODE>#1</CODE>s,
while the 
<CODE>#1</CODE>,

<CODE>#1</CODE> and 
<CODE>#1</CODE> methods are used to analyse and destruct them. In the properties,

<CODE>#1</CODE> represents the structural equality, that is the standard equality in both
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> and <SPAN STYLE="font-variant:small-caps">OCaml</SPAN>. The combination of the properties 
<CODE>#1</CODE> and 
<CODE>#1</CODE> is
very strong, indicating that the concrete implementation of any

<CODE>#1</CODE>
is either 
<CODE>#1</CODE> or

<CODE>#1</CODE>, a form of surjectivity of these methods w.r.t. the species.</P><P>Note that whereas subsets are things with a decidable membership,

<CODE>#1</CODE>s
are things defining
a succession of values: membership is not specified<SUP><A NAME="text11" HREF="#note11">11</A></SUP> but we have a function returning the head
element of a

<CODE>#1</CODE>
. Another characteristic of

<CODE>#1</CODE>s
is that values may appear several time
&#X2013; that is it is possible for example to have <EM>head</EM>(<I>l</I>)=<I>head</I>(<I>tail</I>(<I>l</I>)). This
illustrates the difference of point of view: (finite) subsets and (finite) lists can appear
pretty similar once implemented, but the intentions are different
(with the only difference being the number of occurrences of a same element).</P><P>The properties listed in 
<CODE>#1</CODE> are sufficient to prove other expected results, such as
for example the injectivity of 
<CODE>#1</CODE>:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>cons_left</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>t1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>t2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Heq</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t1</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                                             </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t2</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t1</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                                   </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t2</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Heq</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t2</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;2 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;1&gt;1 ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>cons_right</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Heq</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                                             </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                                   </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Heq</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;2 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;1&gt;1 ;</I></FONT></TD></TR>
</TABLE><P>As a final point, one can remark that the 
<CODE>#1</CODE> function is specified only for non-empty
list. For an empty list, it has to return a value from 
<CODE>#1</CODE><SUP><A NAME="text12" HREF="#note12">12</A></SUP>, but which one? Remember that 
<CODE>#1</CODE>, which represents a collection
implementing the interface of 
<CODE>#1</CODE>, can be empty; in such a case, the list species
still contains the empty list (and only the empty list), and implementing the 
<CODE>#1</CODE>
function can be &#X201C;difficult&#X201D;.</P><!--TOC subsection Finite Lists-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc21">6.2</A>&#XA0;&#XA0;Finite Lists</H3><!--SEC END --><P>
<A NAME="speclist_finite"></A></P><P>An abstract entity such as 
<CODE>#1</CODE> is not very interesting. We aim at representing
standard lists, as they are defined in <SPAN STYLE="font-variant:small-caps">OCaml</SPAN> and <SPAN STYLE="font-variant:small-caps">Coq</SPAN> for example, which are in particular
finite (well-founded), even if the species of all lists is infinite.</P><P>Finiteness is a tricky concept to capture. Similarly to what is mentioned in Sub.
<A HREF="#specsubset_extensional">5.2</A>, a possible approach is for example to specify a function in
<EM>Self</EM>&#X2192;&#X2115; computing the length of the list provided as a parameter. The
existence of such a function, that has to be total, indeed ensures finiteness of any value of
the species. But how do we specify that natural values are themselves finite? We are just
pushing back the problem to another species.</P><P>Another possible approach is to provide a concrete representation which is itself finite and
encodes only finite values. This would correspond, in our case, into using the inductive
definition of lists of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> or <SPAN STYLE="font-variant:small-caps">OCaml</SPAN>, knowing that such a definition only describes finite
constructions.</P><P>But it is also possible indeed to specify finiteness, as illustrated here by introducing a
new species 
<CODE>#1</CODE>:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>FiniteList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>CoList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>finite</I></FONT><FONT SIZE=2><I> :</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> : (</I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  (</I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>))) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><P>The property 
<CODE>#1</CODE> requires the standard induction principle for lists to be valid:
to prove that a boolean function <I>f</I> is true for any list, it is sufficient to prove that
it is true for the empty list and that if it is true for a list <I>t</I> then it is also true for
the list <EM>cons</EM>(<I>h</I>, <I>t</I>).</P><P>It indeed provides a strategy to prove e.g.
<I>f</I>(<EM>cons</EM>(<I>a</I>,<EM>cons</EM>(<I>b</I>,<EM>cons</EM>(<I>c</I>,<EM>nil</EM>)))): from <I>f</I>(<I>nil</I>) and
<I>f</I>(<I>t</I>)&#X21D2;<I>f</I>(<I>cons</I>(<I>h</I>, <I>t</I>)), one can prove <I>f</I>(<EM>cons</EM>(<I>c</I>, <I>nil</I>)), using again
<I>f</I>(<I>t</I>)&#X21D2;<I>f</I>(<I>cons</I>(<I>h</I>, <I>t</I>)) he derives <I>f</I>(<EM>cons</EM>(<I>b</I>, <EM>cons</EM>(<I>c</I>, <I>nil</I>))), etc.</P><P>The property 
<CODE>#1</CODE> is higher-order: it quantifies over all possible decidable
predicates that can be applied to 
<CODE>#1</CODE> &#X2013; that is in fact over all the methods
of the species acting over 
<CODE>#1</CODE>, as encapsulation prevents manipulations from outside
the species. Note that higher-order properties can be expressed in <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>, but are not
manageable by <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> ; in such a case, a proof in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> is required, as illustrated later.</P><P>Why does the property 
<CODE>#1</CODE> prove that lists are finite? Let&#X2019;s first define the
finiteness predicate <EM>finite</EM> by two axioms:

</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><EM>finite</EM>(<EM>nil</EM>)&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;
&#X2200;&#XA0;<I>t</I>,&#XA0;<EM>finite</EM>(<I>t</I>)&#X21D2;&#XA0;&#X2200;&#XA0;<I>h</I>,&#XA0;<EM>finite</EM>(<EM>cons</EM>(<I>h</I>,<I>t</I>))</TD></TR>
</TABLE></TD></TR>
</TABLE><P>

The first claims that the empty list is finite, and the second that if a list is finite, then
it is still finite after having added an element to it. It is then possible to prove the
theorem &#X2200; <I>l</I>, <EM>finite</EM>(<I>l</I>) by applying 
<CODE>#1</CODE>.</P><P>Having ensured that 
<CODE>#1</CODE> only describes finite lists, we may also add the
specification of two methods, membership 
<CODE>#1</CODE> and deletion 
<CODE>#1</CODE>, whose
implementation is likely to have to browse all the elements of a list:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_nil</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, ~ </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)) &lt;-&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>) \/ </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)) &lt;-&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>) /\ </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) ;</I></FONT></TD></TR>
</TABLE><P>Note that the property 
<CODE>#1</CODE> states that the method 
<CODE>#1</CODE> has to remove all
occurrences of values which are equal to its second parameter.</P><!--TOC section Refining Lists-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc22">7</A>&#XA0;&#XA0;Refining Lists</H2><!--SEC END --><P>
<A NAME="reflist"></A></P><P>Intuitively, we have specified in the previous section what we need: 
<CODE>#1</CODE>
describes structures to collect finitely many values, with methods to build and analyse such
structures.</P><P>In this section, we continue the development by inheritance, but having in mind a
<EM>refinement</EM> approach: we do not specify anymore the structure itself, but instead we
provide an implementation. Still favouring a very progressive approach in this tutorial, we
<EM>refine</EM> the species 
<CODE>#1</CODE> by a species 
<CODE>#1</CODE>, with a few
algorithms, before providing a complete species 
<CODE>#1</CODE> in which the
<EM>representation</EM>, that is the concrete datatype used to encode the specified structures,
is defined.</P><!--TOC subsection Enumerable Lists-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc23">7.1</A>&#XA0;&#XA0;Enumerable Lists</H3><!--SEC END --><P>
<A NAME="reflist_enumerable"></A></P><P>We create first a new species 
<CODE>#1</CODE> describing intuitively lists whose elements can
be enumerated. Editing the file <B>mylist.fcl</B>, we start 
<CODE>#1</CODE> as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>EnumList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>FiniteList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><!--TOC subsubsection Recursive Membership-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc24">7.1.1</A>&#XA0;&#XA0;Recursive Membership</H4><!--SEC END --><P>
<A NAME="reflist_enumerable_mem"></A></P><P>The first definition that we provide in 
<CODE>#1</CODE> is the membership. Knowing that any
list in <EM>Self</EM> is finite, we browse the structure using the dedicated methods to look
for a specific value:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>rec</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> (</I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)) </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>true</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>))) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Termination</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Proof</I></FONT><FONT SIZE=2><I> *)</I></FONT></TD></TR>
</TABLE><P>The definition for the method 
<CODE>#1</CODE> is recursive, as computing 
<CODE>#1</CODE> requires
in some cases to compute 
<CODE>#1</CODE>. In a formal development, one has to prove
that recursive functions always terminate to avoid logical inconsistency<SUP><A NAME="text13" HREF="#note13">13</A></SUP>. In its current version, <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> offers two ways to deal with such a
function:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The keyword 
<CODE>#1</CODE> indicates that the function is recursive, and that any
recursive call is done on a parameter which is structurally &#X201C;smaller&#X201D; than the initial one.
It is illustrated later in this tutorial.
</LI><LI CLASS="li-itemize">The keyword 
<CODE>#1</CODE> indicates that the function is recursive. In this case a
termination proof is normally added after the definition, for example:<P>
<CODE>#1</CODE>.
</P></LI></UL><P>
With regard to the second case, the full support in <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> of recursive functions, with proofs
of termination based on measures, orders and so on is still in development and is not further
detailed here. For this reason, the termination proof is for now admitted and is not required
in the code. The <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> compiler however warns that the species is potentially unsafe
and will generate a pseudo-termination proof instead, in order to have the whole program
however accepted by <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. In some sense, we afford lying to <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, being optimistic about the
part of the consistency of our program involved by the termination of this function.</P><P>We adopt here the second version, noting that if the property 
<CODE>#1</CODE> is valid, the
function 
<CODE>#1</CODE> terminates. Indeed, a possible interpretation of 
<CODE>#1</CODE> is that it
enforces any list to be build-able (accessible) starting from the list 
<CODE>#1</CODE> and using
only the function 
<CODE>#1</CODE>; reciprocally, because of the properties stated in 
<CODE>#1</CODE>
we know that 
<CODE>#1</CODE> and 
<CODE>#1</CODE> act as decomposition operators and allow for a
systematic enumeration of the values of the list.</P><P>Having defined 
<CODE>#1</CODE> (and admitted termination), we can prove that this function has the
expected properties as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_nil</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_nil</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>        </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;2 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>        </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;3 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>) \/ </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> : ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>        </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>        </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><!--TOC subsubsection Recursive Deletion-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc25">7.1.2</A>&#XA0;&#XA0;Recursive Deletion</H4><!--SEC END --><P>
<A NAME="list_enumerable_del"></A></P><P>We can add a second definition in our species, for the deletion method:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>rec</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) , </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>)) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Termination</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Proof</I></FONT><FONT SIZE=2><I> *)</I></FONT></TD></TR>
</TABLE><P>Again, termination is admitted in this case.</P><P>This second method is very illustrative. Indeed, provided this recursive definition, it is
possible to prove the property 
<CODE>#1</CODE>, yet we need to use the induction principle.
That is, as indicated by the property 
<CODE>#1</CODE><SUP><A NAME="text14" HREF="#note14">14</A></SUP> to prove &#X2200; <I>l</I>, <I>P</I>(<I>l</I>)
(any list satisfies a property <I>P</I>), it is sufficient to prove <I>P</I>(<EM>nil</EM>) (the property is
true for the empty list) and that for any list <I>t</I>, assuming <I>P</I>(<I>t</I>) (the property is true for
<I>t</I>), then for any <I>h</I>, <I>P</I>(<I>cons</I>(<I>h</I>, <I>t</I>)) is provable as well (the property is still true when
adding an element to <I>t</I>).</P><P>We can foresee a rather complex proof, as 
<CODE>#1</CODE> is a composite statement and because
we have to use 
<CODE>#1</CODE>. To avoid a very long proof we suggest here a decomposition of

<CODE>#1</CODE> into three subgoals, and further to use the 
<CODE>#1</CODE> feature to
improve the readability of the proof. Let&#X2019;s start with a first subgoal:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>logical</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)) -&gt; </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del_mem</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)</I></FONT></TD></TR>
</TABLE><P>We first define a statement 
<CODE>#1</CODE>, using the keyword 
<CODE>#1</CODE> to introduce a
parametrised statement. Note that we do not claim that such a statement is valid: we just
introduce a name for a complex
<B>logical expression</B>.
The theorem 
<CODE>#1</CODE>, on the
contrary, claims that 
<CODE>#1</CODE> is always valid.</P><P>The first level of the proof of 
<CODE>#1</CODE> is as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;2 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hind</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;3 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>)-&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     (</I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>Standard</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>induction</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>principle</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><P>Thanks to the use of the 
<CODE>#1</CODE> name, we can see clearly that the step 
<CODE>#1</CODE> is of
the form <I>P</I>(<EM>nil</EM>), and the step 
<CODE>#1</CODE> of the the form
<I>P</I>(<I>t</I>)&#X21D2;<I>P</I>(<EM>cons</EM>(<I>h</I>,<I>t</I>)). They have to be proved but for the current stage we
just assume these results.</P><P>The label 
<CODE>#1</CODE> states very clearly the induction principle, instantiated for the
property we are trying to prove, that is 
<CODE>#1</CODE>. We also assume this result, but in this
case because the current version of <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> is not able to manage higher-order declarations
such as 
<CODE>#1</CODE> &#X2013; a <SPAN STYLE="font-variant:small-caps">Coq</SPAN> proof is still possible, but here we decide to just accept
this result as a fact
to prevent running in too complex notions out of the scope of this tutorial
. The step 
<CODE>#1</CODE> concludes.</P><P>We can check that this proof structure is valid by invoking the compiler, before pursuing the
development. For the step 
<CODE>#1</CODE>, it is straightforward:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_nil</I></FONT></TD></TR>
</TABLE><P>Note that we need to make visible the definition of the statement 
<CODE>#1</CODE>.</P><P>For the step 
<CODE>#1</CODE>, it is a little longer. The idea is that the definition of the

<CODE>#1</CODE> function is visible, and can be analysed by case reasoning &#X2013; for example, an

<CODE>#1</CODE> construct is dealt with by assuming that the condition is true in a first case, and
false in a second case. The resulting proof is as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>          &lt;1&gt;2 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hind</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;2 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> : ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                            </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;3 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;1, &lt;4&gt;2 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;4 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;3 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;4 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hind</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                         </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;3 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> : ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                            </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I> : ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;3 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                                    </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;1, &lt;4&gt;2 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;4 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;3 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;5 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;4 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;5 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hind</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                         </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT></TD></TR>
</TABLE><P>This proof is simple but rather long, essentially because we have to explicit a lot of
transformations such as
<EM>cons</EM>(<EM>head</EM>(<EM>cons</EM>(<I>h</I>,<I>t</I>)),<EM>tail</EM>(<EM>cons</EM>(<I>h</I>,<I>t</I>)))=<EM>cons</EM>(<I>h</I>,<I>t</I>).
Remember indeed that 
<CODE>#1</CODE>, 
<CODE>#1</CODE> and 
<CODE>#1</CODE> are not yet defined, but are
just described by properties. Once these functions implemented, those simplifications can be
the result of computations, with shorter proofs; yet having only an axiomatised form of these
functions for now, we have to provide some guidance. In this case, a more straightforward
approach (jumping directly to an implementation by inductive lists) is likely to be simpler.</P><P>A similar approach is chosen for the second subgoal:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>logical</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)) -&gt; ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del_eq</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_nil</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_nil</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>         &lt;1&gt;2 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hind</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;3&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;4&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;3 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;5&gt;1, &lt;5&gt;2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;5&gt;3 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;4&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hind</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;3&gt;2 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> : ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;4&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>eq_symm</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>eq_tran</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;4&gt;2 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I> : ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;3 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                                    </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;5&gt;1, &lt;5&gt;2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;4 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;5&gt;3 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;5 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;5&gt;4 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;5&gt;5 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hind</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;4&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;3&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>         &lt;1&gt;3 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    (</I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>Standard</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>induction</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>principle</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>         &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><P>The third subgoal is left as an exercise to the reader; note that we have slightly adapted the
statement of 
<CODE>#1</CODE> to ease the proof by induction:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del_inv</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                       </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT></TD></TR>
</TABLE><P>Finally we prove the global result

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del_mem</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_del_eq</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_del_inv</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                       </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><!--TOC subsection Inductive Lists-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc26">7.2</A>&#XA0;&#XA0;Inductive Lists</H3><!--SEC END --><P>
<A NAME="reflist_inductive"></A></P><P>It is now time to define the species 
<CODE>#1</CODE> which refines, or more precisely
implements, the species 
<CODE>#1</CODE> and therefore the species 
<CODE>#1</CODE> and

<CODE>#1</CODE>.</P><!--TOC subsubsection Non Empty Supersets-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc27">7.2.1</A>&#XA0;&#XA0;Non Empty Supersets</H4><!--SEC END --><P>
<A NAME="reflist_inductive_supersetwitness"></A></P><P>First, taking into account the comment at the end of Sub. <A HREF="#speclist_co">6.1</A>, we append to
the file <B>superset.fcl</B> the definition of a new species 
<CODE>#1</CODE> as
follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>SupersetWitness</I></FONT><FONT SIZE=2><I>  =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>witness</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><P>The 
<CODE>#1</CODE> constant ensures that a 
<CODE>#1</CODE> is never empty. More
specifically, it is used in our case as the default value returned e.g. when the 
<CODE>#1</CODE>
function is applied to the empty list. Do not forget to recompile <B>superset.fcl</B> once
edited.</P><!--TOC subsubsection A Type for Lists-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc28">7.2.2</A>&#XA0;&#XA0;A Type for Lists</H4><!--SEC END --><P>Back to the file <B>mylist.fcl</B>, we now define the representation of the species as being
a list
; yet rather than using the predefined 
<CODE>#1</CODE> type provided in <B>basics.fcl</B>,
we introduce our own definition for the sake of illustration. Type definitions are allowed in
<SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>, but only at top level, that is outside a species:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>type</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mylist</I></FONT><FONT SIZE=2><I>('</I></FONT><FONT SIZE=2><I>a</I></FONT><FONT SIZE=2><I>) = | </I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I> | </I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I> ('</I></FONT><FONT SIZE=2><I>a</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mylist</I></FONT><FONT SIZE=2><I>('</I></FONT><FONT SIZE=2><I>a</I></FONT><FONT SIZE=2><I>)) ;;</I></FONT></TD></TR>
</TABLE><P>Such an inductive definition
, called a &#X201C;sum type&#X201D;,
claims that the type only contains values build from the
constructors (surjectivity), and that two values of this type are equal
if and only if
they are
structurally equal (injectivity);
well-foundation
(finiteness of the constructs) is also
ensured.</P><DIV CLASS="theorem"><B>Tip&#XA0;9</B>&#XA0;&#XA0;<EM>[Syntax] Type definitions are only authorised at top-level.
</EM></DIV><P>This is also a polymorphic type: 
<CODE>#1</CODE> represents a type variable parametrisation our
definition, 
<CODE>#1</CODE> or 
<CODE>#1</CODE> being examples of types obtained by
instantiating this variable. Note that the <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> syntax requires
sum type constructor
identifiers to
start by an uppercase character.</P><DIV CLASS="theorem"><B>Tip&#XA0;10</B>&#XA0;&#XA0;<EM>[Syntax] Sum type constructor identifiers have to start with an uppercase character.
</EM></DIV><!--TOC subsubsection Inductive Lists-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc29">7.2.3</A>&#XA0;&#XA0;Inductive Lists</H4><!--SEC END --><P>Provided this type, it is possible to introduce associated top level definitions and theorems
(but not declarations and properties, in the absence of inheritance mechanism). In this
tutorial, however, we stick to the species vision and include all the definitions and theorems
in a new species. Starting with trivial definitions, the 
<CODE>#1</CODE> species, to be
inserted in the file <B>mylist.fcl</B>, is as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IndList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>SupersetWitness</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>FiniteList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>representation</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>mylist</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I> = #</I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = #</I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>match</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>with</I></FONT><FONT SIZE=2><I> | #</I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>true</I></FONT><FONT SIZE=2><I> | </I></FONT><FONT SIZE=2><I>_</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>match</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>with</I></FONT><FONT SIZE=2><I> | #</I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>_</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> | </I></FONT><FONT SIZE=2><I>_</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>witness</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>match</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>with</I></FONT><FONT SIZE=2><I> | #</I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>_</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> | </I></FONT><FONT SIZE=2><I>_</I></FONT><FONT SIZE=2><I> -&gt; #</I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><P>The keyword 
<CODE>#1</CODE> is used to associate a concrete datatype to the species;
once the representation is defined it cannot be changed at inheritance. Note that we
parametrise 
<CODE>#1</CODE> with 
<CODE>#1</CODE> (that is its representation).</P><P>For the functions 
<CODE>#1</CODE>, 
<CODE>#1</CODE> and 
<CODE>#1</CODE> we use pattern matching (as in
<SPAN STYLE="font-variant:small-caps">OCaml</SPAN> and <SPAN STYLE="font-variant:small-caps">Coq</SPAN>). In <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> pattern matching has to be complete and without redundancy; in other
words, all cases should be addressed, and patterns included in previous patterns are not
allowed.</P><!--TOC subsubsection Higher-Order Proofs-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc30">7.2.4</A>&#XA0;&#XA0;Higher-Order Proofs</H4><!--SEC END --><P>We have now a definition for all the declared methods, but we are still lacking the proofs of
the properties. Let&#X2019;s first address the higher-order 
<CODE>#1</CODE> property; as mentioned,
<SPAN STYLE="font-variant:small-caps">Zenon</SPAN> is not able to tackle it. The most simple approach is to admit this property as an
axiom:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>finite</I></FONT><FONT SIZE=2><I> =  </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>Requires</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>a</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Coq</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> *) ;</I></FONT></TD></TR>
</TABLE><P>The keyword 
<CODE>#1</CODE> is the logical backdoor in <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>: the proof is not provided, but the
property is accepted as true. It is recommended to associate, in such a case, a comment
justifying why no proof is given. That is, it is possible to introduce axioms in a <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> development, but those axioms are traced and documented.</P><P>The alternative approach is to provide the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> proof. It is beyond the scope of this tutorial
to describe how to build such a proof; ideally the use of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> scripts should be limited to
the standard library of <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>, and only expert users should try to use <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. We just provide
in the rest of this paragraph a sketch of the process, that can be skipped by most readers.</P><P>The first step is to identify the relevant properties and definitions to derive the proof &#X2013;
exactly as when <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> is used. This is required to make these definitions and properties
visible from the proof context. It is then possible to build a template for the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> proof, as
follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>finite</I></FONT><FONT SIZE=2><I> =  </I></FONT><FONT SIZE=2><I>coq</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    {* *} ;</I></FONT></TD></TR>
</TABLE><P>The keywords 
<CODE>#1</CODE> indicates that the proof is attached and has to be checked
directly by <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, without assistance of <SPAN STYLE="font-variant:small-caps">Zenon</SPAN>. It is followed by the tips, in this case we
need to make sure that the definition of the methods 
<CODE>#1</CODE> and 
<CODE>#1</CODE> are visible,
as we will in fact reason on the inductive definition of 
<CODE>#1</CODE> and on the constructors

<CODE>#1</CODE> and 
<CODE>#1</CODE>.
These tips will not be used by <SPAN STYLE="font-variant:small-caps">Coq</SPAN> but serves <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> to be aware that the following proof
(that it cannot analyse) will depend on the listed functions, properties and theorems. During
dependencies computation, this allows to invalidate the proof in children species who will have
redefined some of these listed dependencies (or inductively, dependencies on these dependencies).
The <SPAN STYLE="font-variant:small-caps">Coq</SPAN> script is then expected to follow, between 
<CODE>#1</CODE> and

<CODE>#1</CODE>; here it is empty, just marking a hole that we will fill later using <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.</P><P>It is then possible to compile the file with the command <B>focalizec mylist.fcl</B>; the
compilation of course fails when <SPAN STYLE="font-variant:small-caps">Coq</SPAN> checks the proof file <B>mylist.v</B>. Using <SPAN STYLE="font-variant:small-caps">Coq</SPAN> (and
providing the path to the <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> and <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> libraries, that are prompted at compilation time)
the proof can then be completed by hand, and copied into the <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> source file:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>finite</I></FONT><FONT SIZE=2><I> =  </I></FONT><FONT SIZE=2><I>coq</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    {* </I></FONT><FONT SIZE=2><I>Proof</I></FONT><FONT SIZE=2><I>.</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                        </I></FONT><FONT SIZE=2><I>intros</I></FONT><FONT SIZE=2><I>.</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                        </I></FONT><FONT SIZE=2><I>unfold</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>abst_cons</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>abst_nil</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> *.</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                        </I></FONT><FONT SIZE=2><I>induction</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>.</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                         </I></FONT><FONT SIZE=2><I>trivial</I></FONT><FONT SIZE=2><I>.</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                        </I></FONT><FONT SIZE=2><I>apply</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H0</I></FONT><FONT SIZE=2><I>; </I></FONT><FONT SIZE=2><I>apply</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IHl</I></FONT><FONT SIZE=2><I>.</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                       </I></FONT><FONT SIZE=2><I>Qed</I></FONT><FONT SIZE=2><I>. *} ;</I></FONT></TD></TR>
</TABLE><P>A new compilation of <B>mylist.fcl</B> now succeeds.</P><!--TOC subsubsection Proofs on Inductive Types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc31">7.2.5</A>&#XA0;&#XA0;Proofs on Inductive Types</H4><!--SEC END --><P>Other properties related to inductive definitions can be done in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, or can be assumed. We
choose for this tutorial the second option:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_nil</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>list_dec</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT></TD></TR>
</TABLE><P>Note however that <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> is currently evolving to provide some support for such results, by
allowing for a new form of tip, 
<CODE>#1</CODE>, when the very definition of a type provides the
required information. The expected use is as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_nil</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>type</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mylist</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I> ;</I></FONT></TD></TR>
</TABLE><P>It can be experimentally tested, but only at top level for now.</P><!--TOC subsubsection Structural Recursion-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc32">7.2.6</A>&#XA0;&#XA0;Structural Recursion</H4><!--SEC END --><P>In the species 
<CODE>#1</CODE>, we redefine the methods 
<CODE>#1</CODE> and 
<CODE>#1</CODE> as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>recstruct</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   </I></FONT><FONT SIZE=2><I>match</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>with</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   | #</I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   | #</I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>true</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_nil</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>recstruct</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>match</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>with</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  | #</I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I> -&gt; #</I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  | #</I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> #</I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>)) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del</I></FONT><FONT SIZE=2><I> =  </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT></TD></TR>
</TABLE><P>In this case, we are using the keyword 
<CODE>#1</CODE> to indicate a structurally recursive
function, that is recursive calls on subterms of the parameter &#X2013; termination then being
trivially true. For such functions, however, the decreasing parameter has to be the first one;
that&#X2019;s why we are using a 
<CODE>#1</CODE> construct, as the declaration of 
<CODE>#1</CODE> puts the
list as the second parameter.</P><P>Such redefinitions, of course, cause the deletion of the associated proofs for 
<CODE>#1</CODE>,

<CODE>#1</CODE>, 
<CODE>#1</CODE>. Yet the use of pattern matching on an inductive type leads to
simpler proofs of these properties. For this tutorial, we just admit these properties.</P><P>Note that the keyword 
<CODE>#1</CODE> may become deprecated in future versions of <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>, as it
is an <EM>ad hoc</EM> adaptation to deal with a simple form of recursion.</P><!--TOC section A Complete Implementation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc33">8</A>&#XA0;&#XA0;A Complete Implementation</H2><!--SEC END --><P>
<A NAME="implem"></A></P><P>We are now at the final stage of the development, in which we will define collections. A
<EM>collection</EM> is a frozen implementation obtained by abstracting the concrete
representation of a <EM>complete species</EM>, that is a species which has a concrete datatype
representation, a definition for every signature and a proof for every property.</P><P>Provided what has been developed up to now, there are still two approaches to implement
subsets as lists. In both case, we need a collection implementing a complete species, but
this species can either:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
inherits from both 
<CODE>#1</CODE> and 
<CODE>#1</CODE>.
</LI><LI CLASS="li-itemize">inherits from 
<CODE>#1</CODE> and be parametrised by 
<CODE>#1</CODE>.
</LI></UL><P>
These two approaches have similarities &#X2013; for example, in both cases the membership method

<CODE>#1</CODE> of subsets is implemented as the membership method 
<CODE>#1</CODE> of lists &#X2013; but they
represent very different intentions.</P><P>In the first case, using multiple inheritance, we claim that any subset is also a list. So the
methods of both interfaces can be used to manipulate these values; a set can be created with
two elements, then it can be considered as a list in which we exchange the position of these
elements.</P><P>In the second case, using parametrisation, we use lists to represent subsets, but emphasising
that lists and subsets are different in nature: manipulating a subset can only be done using
the methods of the subset interface &#X2013; and it is possible to ensure that some &#X201C;dangerous&#X201D;
methods defined for lists are not used when dealing with subsets.</P><P>We discuss in the rest of this section of the strategy to build an executable program using
the implementation of subsets with the second approach, parametrisation by lists. As a
collection is never parametrised, and always implement one and only one complete species
whose parameters are instantiated by collections, we have to follow a strict discipline: to
create a collection from a given species, we have to create a collection for its parameters.
That is creating a subset collection requires creating a list collection, which itself
requires creating a superset collection.</P><P>We edit a new file, named <B>main.fcl</B>, and include the required information with the

<CODE>#1</CODE> and 
<CODE>#1</CODE> directives:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>use</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>open</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>superset</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>open</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>subset</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>open</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>mylist</I></FONT><FONT SIZE=2><I>" ;;</I></FONT></TD></TR>
</TABLE><P>The rest of the section deals with a superset collection, a list collection and a subset
collection, that are implementing complete species.</P><!--TOC subsection Integers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc34">8.1</A>&#XA0;&#XA0;Integers</H3><!--SEC END --><P>
<A NAME="implem_integer"></A></P><!--TOC subsubsection Adding Inputs and Outputs to Supersets-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc35">8.1.1</A>&#XA0;&#XA0;Adding Inputs and Outputs to Supersets</H4><!--SEC END --><P>
<A NAME="implem_integer_hmi"></A></P><P>We can implement collections with the currently defined interfaces, unfortunately this would
not be very demonstrative in the absence of HMI. As a first mandatory step toward a program we
therefore create a new species with methods to import or export values:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>PrintParseSuperset</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>SupersetWitness</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>unit</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>string</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><P>Of course, it is possible to add, at any point of the development, a 
<CODE>#1</CODE> and a

<CODE>#1</CODE> methods to any species &#X2013; as illustrated later in this section for subsets. But
the definition of a 
<CODE>#1</CODE> interface is required. Indeed, to implement for
example the 
<CODE>#1</CODE> method for a subset, one has to be able to rely on the 
<CODE>#1</CODE>
method of its superset parameter, that is to ensure that such method exists in the interface.</P><!--TOC subsubsection A Complete Integer Species-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc36">8.1.2</A>&#XA0;&#XA0;A Complete Integer Species</H4><!--SEC END --><P>
<A NAME="implem_integer_complete"></A></P><P>Provided the specification 
<CODE>#1</CODE>, we develop a complete species
representing machine integers:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Int</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>PrintParseSuperset</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>representation</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>int</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( = )(</I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_refl</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( = ) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_symm</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( = ) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_tran</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( = ) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>witness</I></FONT><FONT SIZE=2><I> = 0 ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_int</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>string</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>int_of_string</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><P>In this species, the representation is defined, all the declared methods are
defined<SUP><A NAME="text15" HREF="#note15">15</A></SUP> and all the properties are proved.</P><!--TOC subsubsection An Integer Collection-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc37">8.1.3</A>&#XA0;&#XA0;An Integer Collection</H4><!--SEC END --><P>
<A NAME="implem_integer_collection"></A></P><P>The species 
<CODE>#1</CODE> being complete, it can be transformed into a collection:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>collection</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>implement</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Int</I></FONT><FONT SIZE=2><I>; </I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><P>
<CODE>#1</CODE> now denotes a form of abstract data type, whose representation is hidden. It is not
possible to inherit from 
<CODE>#1</CODE>, or to modify otherwise its structure; of course, it is
still possible to use 
<CODE>#1</CODE> as a parameter.</P><DIV CLASS="theorem"><B>Tip&#XA0;11</B>&#XA0;<B>(Implementation)</B>&#XA0;&#XA0;<EM> Collections are the final entities of </EM><EM><SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN></EM><EM> developments and
represent executable implementations. They cannot be parametrised or inherited from, but they
can be used as parameters for other species.
</EM></DIV><!--TOC subsection Lists if Integers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc38">8.2</A>&#XA0;&#XA0;Lists if Integers</H3><!--SEC END --><P>
<A NAME="implem_lists"></A></P><P>As we want to create a collection from the parametrised species 
<CODE>#1</CODE>, we need
first to create a collection for the parameter itself, that is a collection representing the
species 
<CODE>#1</CODE>:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>collection</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IntList_Coll</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>implement</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IndList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>) ; </I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><P>Remember that a collection cannot be parametrised, and that it has to implement a species
whose all formal parameters are instantiated by a collection, as it is the case here.</P><DIV CLASS="theorem"><B>Tip&#XA0;12</B>&#XA0;<B>(Implementation)</B>&#XA0;&#XA0;<EM> A collection can only implements a complete species whose
parameters are instantiated by collections.
</EM></DIV><!--TOC subsection Subsets-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc39">8.3</A>&#XA0;&#XA0;Subsets</H3><!--SEC END --><P>
<A NAME="implem_subset"></A></P><!--TOC subsubsection A Complete Subset Species-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc40">8.3.1</A>&#XA0;&#XA0;A Complete Subset Species</H4><!--SEC END --><P>
<A NAME="implem_subset_complete"></A></P><P>Having chosen to implement subsets as a species parametrised by lists, it is straightforward
to complete 
<CODE>#1</CODE> in a new species 
<CODE>#1</CODE>. We just provide some proofs,
assuming most of the properties, and we add a 
<CODE>#1</CODE> method for subsets:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>ListSubset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>PrintParseSuperset</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IndList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>)) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>ExtSubset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>representation</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( &lt;&lt; )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_empty</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( &lt;&lt; ), </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                         </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>mem_nil</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( + )(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> + </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>) \/ </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( &lt;&lt; ), ( + )</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;2 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> + </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;3 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> + </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( - )(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_congr</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>rec</I></FONT><FONT SIZE=2><I> ( &lt;: )(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>true</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>) &lt;&lt; </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>) &lt;: </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Termination</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Proof</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>rec</I></FONT><FONT SIZE=2><I> ( = )(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>and</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( &amp;&amp; )(</I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> ((</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I>) - </I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I>) = ((</I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I>) - </I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Termination</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Proof</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("{") </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>rec</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>print_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>)=</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("}")</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>)) </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>print_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>print_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><!--TOC subsubsection A Subset Collection-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc41">8.3.2</A>&#XA0;&#XA0;A Subset Collection</H4><!--SEC END --><P>
<A NAME="implem_subset_collection"></A></P><P>We can finally implement 
<CODE>#1</CODE> in a collection 
<CODE>#1</CODE> as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>collection</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>implement</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>ListSubset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>IntList_Coll</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><!--TOC subsection Using Subsets-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc42">8.4</A>&#XA0;&#XA0;Using Subsets</H3><!--SEC END --><P>
<A NAME="implem_program"></A></P><!--TOC subsubsection Top Level Use-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc43">8.4.1</A>&#XA0;&#XA0;Top Level Use</H4><!--SEC END --><P>
<A NAME="implem_program_use"></A></P><P>We have now an implementation of finite subsets of integers, whose concrete representation is
hidden. To use this implementation, we can for example use the <SPAN STYLE="font-variant:small-caps">OCaml</SPAN> files produced by <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> as
proved
libraries for <SPAN STYLE="font-variant:small-caps">OCaml</SPAN> programs. But it is also possible to use directly the various
methods of any collection from the <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> top level, as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Subsets</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Integers</I></FONT><FONT SIZE=2><I> :\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("---------------------\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset1</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Creating</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>set</I></FONT><FONT SIZE=2><I> : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset1</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset2</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( + )(</I></FONT><FONT SIZE=2><I>subset1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("1")) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Inserting</I></FONT><FONT SIZE=2><I> 1 : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset2</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset3</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( + )(</I></FONT><FONT SIZE=2><I>subset2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("2")) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Inserting</I></FONT><FONT SIZE=2><I> 2 : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset3</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset4</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( + )(</I></FONT><FONT SIZE=2><I>subset3</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("3")) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Inserting</I></FONT><FONT SIZE=2><I> 3 : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset4</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset5</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( + )(</I></FONT><FONT SIZE=2><I>subset4</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("2")) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Inserting</I></FONT><FONT SIZE=2><I> 2 : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset5</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset6</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( - )(</I></FONT><FONT SIZE=2><I>subset5</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("2")) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Removing</I></FONT><FONT SIZE=2><I> 2 : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset6</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset7</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( - )(</I></FONT><FONT SIZE=2><I>subset6</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("3")) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Removing</I></FONT><FONT SIZE=2><I> 3 : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset7</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT></TD></TR>
</TABLE><!--TOC subsubsection Producing an Executable-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc44">8.4.2</A>&#XA0;&#XA0;Producing an Executable</H4><!--SEC END --><P>
<A NAME="implem_program_compile"></A></P><P>Once all <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> files have been compiled by <B>focalizec</B>, there is still a final stage of
compilation required to produce an executable, an <SPAN STYLE="font-variant:small-caps">OCaml</SPAN> compilation, with the following
command<SUP><A NAME="text16" HREF="#note16">16</A></SUP>:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><B>ocamlc -I &#XA0;/focalize/focalizec/src/stdlib/</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<B>-o main</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<B>ml_builtins.cmo basics.cmo</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<B>superset.cmo subset.cmo mylist.cmo main.cmo</B></TD></TR>
</TABLE><P>This produces an executable file named <B>main</B>, which can be executed:
</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><B>Creating empty set: {}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Inserting 1: {1}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Inserting 2: {21}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Inserting 3: {321}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Inserting 2: {321}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Removing 2: {31}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Removing 3: {1}</B></TD></TR>
</TABLE><!--TOC section Some Remarks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc45">9</A>&#XA0;&#XA0;Some Remarks</H2><!--SEC END --><P>
<A NAME="remark"></A></P><P>We discuss here more theoretical aspects, considering extensions and alternatives to our
development and their consequences.</P><!--TOC subsection Over-specifications-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc46">9.1</A>&#XA0;&#XA0;Over-specifications</H3><!--SEC END --><P>
<A NAME="remark_over"></A></P><P>We have considered, at the end of Sub. <A HREF="#specsubset_generic">5.1</A>, the opportunity to declare
additional methods and properties for the species 
<CODE>#1</CODE>. Our concern was not to enrich
the specification of 
<CODE>#1</CODE> to enforces inhabitants of the species to be finite, but to
provide more features &#X2013; recognising that it may causes unnecessary burden for the developer
if these features are not used.</P><P>For example, one could ask for the union, the intersection or the complement operations. If
the two formers seems to be straightforward, the situation of the latter if more complex.
Indeed the complement, for any subset <I>S</I>, returns the subset of elements of the superset not
belonging to <I>S</I>. This is a perfectly valid requirement, and as we will see later in this
section, we can even implement directly the species 
<CODE>#1</CODE> enriched with this
operation. Yet the complement operation would also be part of all the other inheriting
species, including 
<CODE>#1</CODE>, 
<CODE>#1</CODE>. This would clearly cause some
difficulties, preventing the parameter 
<CODE>#1</CODE> to be infinite, as in such a case for
<I>S</I> a finite subset, the complement of <I>S</I> would not be finite. In other words, provided an
infinite superset, complement would not be an internal operation on finite subsets.</P><P>It is not always easy to identify well in advance this type of traps, and a re-engineering of
the inheritance tree can be required when facing similar problems during development. Yet to
make such difficulties less likely to happen as well as to ease possible modifications of the
species structure, a good recommendation is to multiply the inheritance steps and branches,
introducing very gradually new methods and properties. Remember that early branching is not a 
problem in a system such as <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>, as it supports multiple inheritance: having for example
species 
<CODE>#1</CODE> and 
<CODE>#1</CODE> (inheriting from 
<CODE>#1</CODE> and
enriched with the complement operation) does not prevent a later definition of a species

<CODE>#1</CODE> inheriting from both if we are able to define an appropriate concrete
representation.
Although deep and multiple inheritance can seem difficult to understand, we must not forget
that the compiler is able to provide traces of methods provenance which greatly help
understanding in case of a complex development.</P><!--TOC subsection Closure Reasoning&#X2019;s-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc47">9.2</A>&#XA0;&#XA0;Closure Reasoning&#X2019;s</H3><!--SEC END --><P>
<A NAME="remark_closure"></A></P><P>It is worth mentioning that a species defines an interface which can be completed later,
therefore closure reasoning does not apply for such an interface.</P><P>Taking the example of the species 
<CODE>#1</CODE>, we only provide a few methods to build
subsets: the empty subset, the insertion and the removal of an element. Using only these
methods it is not possible to build an infinite subset. But that does not mean that the
species 
<CODE>#1</CODE> only describes finite subsets &#X2013; nothing prevent the developer to
introduce through inheritance more powerful methods such as a complement operation. The fact
that the species 
<CODE>#1</CODE> only requires methods building finite subsets actually ensures
that it is indeed valid as an ancestor for the species representing finite subsets.</P><P>For the same reason, species invariants have to be handled with care. It is possible to write
a fully defined species, with methods such that all returned values of the species are of a
specific form (for example sorted lists). It is however important to note that inheritance
may, either by creation of new functions or by redefinition of existing ones, break such
invariants. The only mechanism provided in <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> for preventing such modification is to
freeze a complete species by transforming it into a collection.</P><!--TOC subsection Observability Considerations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc48">9.3</A>&#XA0;&#XA0;Observability Considerations</H3><!--SEC END --><P>
<A NAME="remark_observability"></A></P><P>We consider here the creation of a new species inheriting from 
<CODE>#1</CODE>,
providing a choice operator. This is a standard notion in set theory: the choice operator
returns a value belonging to a subset, provided this subset is not empty. One of the interest
of such an operator in our development is to define a method for enumerating all elements of
a subset, as indicated by the theorem 
<CODE>#1</CODE>:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>ExtSubsetChc</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>ExtSubset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>chc</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_chc</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, ~(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>chc</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>enumerate</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> \/ </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> = (</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>chc</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>)) + </I></FONT><FONT SIZE=2><I>chc</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_choice</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>remove_insert</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I>;;</I></FONT></TD></TR>
</TABLE><P>The choice operator has interesting properties. Indeed, it is able to extract a value from any
non empty subset, but we have no indication about which value will be returned provided the
subset passed as a parameter contains at least two of them. In fact, whereas the choice
operator has to be implemented as a <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> function at some point in the development, it may
not be a function in the sense of set theory. Indeed, provided <I>S</I><SUB>1</SUB> and <I>S</I><SUB>2</SUB> two sets that
are extensionally equal, <EM>i.e.</EM> containing the same elements, nothing enforces to have
<EM>chc</EM>(<I>S</I><SUB>1</SUB>)=<EM>chc</EM>(<I>S</I><SUB>2</SUB>). Of course, we can prevent those strange behaviours by
adding a property requiring extensional equality to be a congruence w.r.t. 
<CODE>#1</CODE>:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>chc_congr</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>chc</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>chc</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>)) ;</I></FONT></TD></TR>
</TABLE><P>But this deserves additional consideration, as it may be inadequate. Indeed, any
implementation of our subset species has to be parametrised by a collection having an
interface compatible with 
<CODE>#1</CODE>. That is, values in our subsets can be of any sort,
as soon as we can define an equivalence relation (representing a form of equality). The point
is that even if other operations are available for the provided collection, such as for
example a comparison, they will not be visible (usable) from the species 
<CODE>#1</CODE>;
as a consequence, it may not be possible to satisfy the property 
<CODE>#1</CODE>.</P><P>Consider an implementation of 
<CODE>#1</CODE> using lists: thanks to 
<CODE>#1</CODE>, it is
possible to build injective lists (no repetition of elements), but without a comparison
operator there is no way to sort such lists. So for example the set {1,2} has two possible
implementations, <EM>cons</EM>(1,<EM>cons</EM>(2,<EM>nil</EM>)) and
<EM>cons</EM>(2,<EM>cons</EM>(1,<EM>nil</EM>)). Whereas we can distinguish them using the structural
equality 
<CODE>#1</CODE>, there is no way to characterise a good one and a bad one. If we
now try to implement 
<CODE>#1</CODE>, we have to exhibit a function that provided a non-empty list,
returns an element of this list. Remember that beyond an equality, we have no
operation
on
values, that is for example we cannot code 
<CODE>#1</CODE> such that it always
returns the smallest element of the list. The only criteria which is available is the position
of the value in the list, and 
<CODE>#1</CODE> can for example return the head value. This
definition complies with 
<CODE>#1</CODE> but not with 
<CODE>#1</CODE>.</P><P>It is possible to provide an implementation of 
<CODE>#1</CODE> with the property

<CODE>#1</CODE>, but we need to slightly
make our inheritance tree more complex.
For example, we can
define a species 
<CODE>#1</CODE> inheriting from 
<CODE>#1</CODE>, with a total order
between values, and a species 
<CODE>#1</CODE> as follows:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>NormalisedSubset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>OrderedSuperset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherits</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>ExtSubsetChc</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_congr</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><P>With this approach, any collection implementing 
<CODE>#1</CODE> of course implements

<CODE>#1</CODE> as well, but is parametrised by a collection providing a total order;
using this order, a normal form for subsets as well as a 
<CODE>#1</CODE> operator can be defined,
ensuring that the property 
<CODE>#1</CODE> is indeed satisfied, for example returning the
smallest element of the subset.</P><!--TOC subsection Functional Representations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc49">9.4</A>&#XA0;&#XA0;Functional Representations</H3><!--SEC END --><P>
<A NAME="remark_functional"></A></P><P>For the sake of illustration, we consider in this subsection a totally different
implementation of subsets based on a functional representation. Our intent is not to advice to
use such type of code &#X2013; which is generally considered as inefficient &#X2013; but rather to
emphasise the freedom offered to a developer facing an abstract specification, provided this
specification is appropriate.</P><P>As mentioned in Sub. <A HREF="#specsubset_generic">5.1</A>, a subset is characterised by the values it
contains, in other words a subset is characterised by its membership function. It is therefore
possible to represent a subset by this very function, <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> being a functional (higher order)
language. One of the interest of this representation is that we can represent infinite
subsets: the function deciding if a natural value is even or not defines the subset of even
values. The complement operation is also naturally supported, the difficulties identified in
Sub. <A HREF="#remark_over">9.1</A> being irrelevant here. The description is straightforward:

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>SubsetFun</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Subset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>representation</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( &lt;&lt; )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>empty_in</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>empty_in</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_empty</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( + )(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inner</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>true</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inner</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( - )(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inner</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inner</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>comp</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inner</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( ~~ )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inner</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><P>Being higher order this encoding is not supported by <SPAN STYLE="font-variant:small-caps">Zenon</SPAN>, so the properties have to be
assumed or proved in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> ; yet this is just a technical concern. More fundamentally,

<CODE>#1</CODE> is not an extensional representation &#X2013; it is clearly not compatible with the
interface of 
<CODE>#1</CODE>. Inclusion or equality between subsets cannot be implemented in
the general case. It is also interesting to note that the 
<CODE>#1</CODE> operator, described in
Sub. <A HREF="#remark_observability">9.3</A>, is not implementable as well. Finally, a property such as

<CODE>#1</CODE>, defined in Par. <A HREF="#specsubset_extensional_trivial">5.2.3</A>, is true but not
provable because once we have represented a subset by a function, we cannot later analyse this
function to check its structure.</P><!--TOC section Inheritance Graph-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc50">A</A>&#XA0;&#XA0;Inheritance Graph</H2><!--SEC END --><P>Inheritance in our development is as follows:

</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
<EM>CoList</EM>=&gt;[<I>d</I>]<EM>Superset</EM>=&gt;[<I>d</I>]<EM>Subset</EM>=&gt;[<I>d</I>]=&gt;[<I>dr</I>]<EM>FiniteList</EM>=&gt;[<I>d</I>]<EM>SupersetWitness</EM>=&gt;[<I>d</I>]=&gt;[<I>r</I>]<EM>ExtSubset</EM>=&gt;[<I>d</I>]<EM><U>FunSubset</U></EM>&#XA0;<EM>EnumList</EM>=&gt;[<I>d</I>]<EM>PrintParseSuperset</EM>=&gt;[<I>d</I>]=&gt;[<I>r</I>]<EM><U>ListSubset</U></EM>=&gt;[<I>d</I>]<EM><U>IndList</U></EM>=&gt;[<I>d</I>]<EM><U>Int</U></EM>=&gt;[<I>d</I>]<EM><SPAN CLASS="textboxed">IntSubset_Coll</SPAN></EM>&#XA0;<EM><SPAN CLASS="textboxed">IntList_Coll</SPAN></EM><EM><SPAN CLASS="textboxed">Int_Coll</SPAN></EM></TD></TR>
</TABLE><P>

If <I>B</I> inherits of <I>A</I> then an arrow is drawn from <I>A</I> to <I>B</I>. Complete species are
underlined, and collections are boxed. Note that parametrisation is not represented here to
avoid over-complexification.</P><P>We have slightly amended the inheritance relation, compared to what is described in this
tutorial. For example, the species 
<CODE>#1</CODE> inherits not from the species

<CODE>#1</CODE> as in Par. <A HREF="#specsubset_extensional_equal">5.2.2</A>, but from the species

<CODE>#1</CODE> introduced in Par. <A HREF="#reflist_inductive_supersetwitness">7.2.1</A>. Indeed,
we have noted that whatever his parameters is, the species 
<CODE>#1</CODE> is never empty,
something characteristic of the species 
<CODE>#1</CODE>. This requires of course to add
the definition 
<CODE>#1</CODE>. Similarly, the species 
<CODE>#1</CODE> now
inherits from the species 
<CODE>#1</CODE>; it indeed offers a 
<CODE>#1</CODE> method,
and the 
<CODE>#1</CODE> method can be implemented for example by the stub

<CODE>#1</CODE>.</P><P>Once fine tuned, our development is more consistent and allows for easy extensions. This is
illustrated in the final code given at annex <A HREF="#source">B</A>. It includes a new collection
implementing subsets of subsets of integers at a minimal cost (2 collections, 6 lines of
code); executing this program, we get:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><B><U>Subsets of Integers :</U></B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Creating empty set : {}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Inserting 1 : {1}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Inserting 2 : {21}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Inserting 3 : {321}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Inserting 2 : {321}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Removing 2 : {31}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Removing 3 : {1}</B></TD></TR>
</TABLE></TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><B><U>Subsets of Subsets of Integers :</U></B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Creating empty set : {}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Inserting {} : {{}}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Inserting {1} : {{1}{}}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Inserting {21} : {{21}{1}{}}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Removing {1} : {{21}{}}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Creating {12} : {12}</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><B>Inserting {12} : {{21}{}}</B></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC section Full Sources-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc51">B</A>&#XA0;&#XA0;Full Sources</H2><!--SEC END --><P>
<A NAME="source"></A></P><!--TOC subsection superset.fcl-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc52">B.1</A>&#XA0;&#XA0;superset.fcl</H3><!--SEC END --><P>
<A NAME="source_superset"></A></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>use</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> ( = ) : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_refl</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_symm</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_tran</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>z</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>z</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>z</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>SupersetWitness</I></FONT><FONT SIZE=2><I>  =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>witness</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>PrintParseSuperset</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>SupersetWitness</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>unit</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>string</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><!--TOC subsection subset.fcl-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc53">B.2</A>&#XA0;&#XA0;subset.fcl</H3><!--SEC END --><P>
<A NAME="source_subset"></A></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>use</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>open</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>superset</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Subset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> ( &lt;&lt; ) : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_empty</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, ~(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> ( + ) : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                       </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> + </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> &lt;-&gt; (</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>) \/ </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> ( - ) : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                       </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> &lt;-&gt; (~(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>)) /\ </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>ExtSubset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>SupersetWitness</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Subset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>);</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_congr</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      (</I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, (</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) &lt;-&gt; (</I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>)) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> ( &lt;: ) : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> &lt;-&gt; </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_refl</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_tran</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s3</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s3</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s3</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> &lt;-&gt; </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> /\ </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_refl</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>incl_refl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_symm</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_tran</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>incl_tran</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_eq</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> &lt;-&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  (</I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> &lt;-&gt; </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_empty</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_empty</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_insert</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_remove</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_insert_mem</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                           </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_congr</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>incl_remove_mem</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                           ~(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hv</I></FONT><FONT SIZE=2><I> : ~(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> &lt;: </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>)) /\ </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_congr</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hv</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;3&gt;1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>remove_insert</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                         </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> = (</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hv</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> = (</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; (</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>)) -&gt; </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;3&gt;1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;2 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; (</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) + </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_congr</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hv</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hw</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;3&gt;1, &lt;3&gt;2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1, &lt;2&gt;2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;1&gt;1 ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>witness</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I>;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>SubsetFun</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Subset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>representation</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( &lt;&lt; )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>empty_in</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>empty_in</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_empty</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( + )(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inner</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>true</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inner</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( - )(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inner</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inner</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>comp</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inner</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( ~~ )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inner</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><!--TOC subsection mylist.fcl-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc54">B.3</A>&#XA0;&#XA0;mylist.fcl</H3><!--SEC END --><P>
<A NAME="source_mylist"></A></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>use</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>open</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>superset</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>CoList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_nil</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) &lt;-&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, ~ </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>list_dec</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     ~ </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>))) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>cons_left</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>t1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>t2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Heq</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t1</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t2</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t1</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t2</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Heq</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t2</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;2 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;1&gt;1 ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>cons_right</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Heq</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Heq</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>l1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l2</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;2 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;1&gt;1 ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>FiniteList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>CoList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>finite</I></FONT><FONT SIZE=2><I> :</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> : (</I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  (</I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>))) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>bool</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_nil</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, ~ </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)) &lt;-&gt; </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>) \/ </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>signature</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)) &lt;-&gt; ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>) /\ </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>EnumList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Superset</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>FiniteList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>rec</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> (</I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)) </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>true</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>))) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Termination</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Proof</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_nil</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_nil</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>        </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;2 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>        </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;3 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>) \/ </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> : ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>        </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>        </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>rec</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) , </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>)) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Termination</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Proof</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>logical</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)) -&gt; </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del_mem</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_nil</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;2 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hind</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;2 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> : ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;3 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;1, &lt;4&gt;2 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;4 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;3 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;4 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hind</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                         </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;3 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> : ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I> : ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;3 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                                    </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;1, &lt;4&gt;2 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;4 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;3 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;5 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;4 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;4&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;5 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hind</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                         </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;3&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;3 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>)-&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     (</I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                      </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>Standard</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>induction</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>principle</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>logical</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)) -&gt; ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del_eq</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_nil</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_nil</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>         &lt;1&gt;2 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hind</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;2&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>               </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;3&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;4&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;3 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;5&gt;1, &lt;5&gt;2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;5&gt;3 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;4&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;4&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hind</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;3&gt;2 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I> : ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;4&gt;1 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>eq_symm</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>eq_tran</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;4&gt;2 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I> : ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;1 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;2 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;3 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                                    </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)), </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;5&gt;1, &lt;5&gt;2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;4 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>)))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;5&gt;3 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;5 </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                  </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;5&gt;4 </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H3</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>             &lt;5&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;5&gt;5 </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Hind</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>            &lt;4&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>           &lt;3&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          &lt;2&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>qed</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>step</I></FONT><FONT SIZE=2><I> &lt;2&gt;1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>         &lt;1&gt;3 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    (</I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                     </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>))) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>              </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>Standard</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>induction</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>principle</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>         &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>theorem</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del_inv</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, ~ </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>) -&gt;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                       </I></FONT><FONT SIZE=2><I>all</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>w</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del_mem</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_del_eq</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mem_del_inv</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                       </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mdm_</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mde_</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>type</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mylist</I></FONT><FONT SIZE=2><I>('</I></FONT><FONT SIZE=2><I>a</I></FONT><FONT SIZE=2><I>) = | </I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I> | </I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I> ('</I></FONT><FONT SIZE=2><I>a</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>mylist</I></FONT><FONT SIZE=2><I>('</I></FONT><FONT SIZE=2><I>a</I></FONT><FONT SIZE=2><I>)) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IndList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>SupersetWitness</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>FiniteList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>representation</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>mylist</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I> = #</I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = #</I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>match</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>with</I></FONT><FONT SIZE=2><I> | #</I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>true</I></FONT><FONT SIZE=2><I> | </I></FONT><FONT SIZE=2><I>_</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>match</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>with</I></FONT><FONT SIZE=2><I> | #</I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>_</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I> | </I></FONT><FONT SIZE=2><I>_</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>witness</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>match</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>with</I></FONT><FONT SIZE=2><I> | #</I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>_</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I> | </I></FONT><FONT SIZE=2><I>_</I></FONT><FONT SIZE=2><I> -&gt; #</I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>finite</I></FONT><FONT SIZE=2><I> =  </I></FONT><FONT SIZE=2><I>coq</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    {* </I></FONT><FONT SIZE=2><I>Proof</I></FONT><FONT SIZE=2><I>.</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                        </I></FONT><FONT SIZE=2><I>intros</I></FONT><FONT SIZE=2><I>.</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                        </I></FONT><FONT SIZE=2><I>unfold</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>abst_cons</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>abst_nil</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> *.</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                        </I></FONT><FONT SIZE=2><I>induction</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>.</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                         </I></FONT><FONT SIZE=2><I>trivial</I></FONT><FONT SIZE=2><I>.</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                        </I></FONT><FONT SIZE=2><I>apply</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H0</I></FONT><FONT SIZE=2><I>; </I></FONT><FONT SIZE=2><I>apply</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IHl</I></FONT><FONT SIZE=2><I>.</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                       </I></FONT><FONT SIZE=2><I>Qed</I></FONT><FONT SIZE=2><I>. *} ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_nil</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>isnil_cons</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>head_cons</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>tail_cons</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>list_dec</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>recstruct</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   </I></FONT><FONT SIZE=2><I>match</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>with</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   | #</I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I> -&gt; </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   | #</I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>true</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_nil</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>recstruct</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>match</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>l</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>with</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  | #</I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I> -&gt; #</I></FONT><FONT SIZE=2><I>FNil</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  | #</I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>) -&gt; </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>                    </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> #</I></FONT><FONT SIZE=2><I>FCons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>h</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>t</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>)) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_del</I></FONT><FONT SIZE=2><I> =  </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT></TD></TR>
</TABLE><!--TOC subsection main.fcl-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc55">B.4</A>&#XA0;&#XA0;main.fcl</H3><!--SEC END --><P>
<A NAME="source_main"></A></P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT SIZE=2><I>use</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>open</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>superset</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>open</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>subset</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>open</I></FONT><FONT SIZE=2><I> "</I></FONT><FONT SIZE=2><I>mylist</I></FONT><FONT SIZE=2><I>" ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Int</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>PrintParseSuperset</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>representation</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>int</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( = )(</I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( = )(</I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_refl</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( = ) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_symm</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( = ) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_tran</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( = ) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>witness</I></FONT><FONT SIZE=2><I> = 0 ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_int</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>string</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>int_of_string</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>collection</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>implement</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Int</I></FONT><FONT SIZE=2><I>; </I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>collection</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IntList_Coll</I></FONT><FONT SIZE=2><I> =  </I></FONT><FONT SIZE=2><I>implement</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IndList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>) ; </I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>species</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>ListSubset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>PrintParseSuperset</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>is</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IndList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>)) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>inherit</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>ExtSubset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>), </I></FONT><FONT SIZE=2><I>PrintParseSuperset</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>representation</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( &lt;&lt; )(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>mem</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>nil</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_empty</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( &lt;&lt; ), </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>mem_nil</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( + )(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>cons</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_insert</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;1 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> + </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>) \/ </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>by</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>definition</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> ( &lt;&lt; ), ( + )</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>          </I></FONT><FONT SIZE=2><I>property</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>mem_cons</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;2 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!( = )(</I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> + </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;3 </I></FONT><FONT SIZE=2><I>assume</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>hypothesis</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>H1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>,</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>prove</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>v1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> + </I></FONT><FONT SIZE=2><I>v2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  &lt;1&gt;</I></FONT><FONT SIZE=2><I>f</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>conclude</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> ( - )(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>del</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>v</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_remove</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_congr</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>rec</I></FONT><FONT SIZE=2><I> ( &lt;: )(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>true</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>) &lt;&lt; </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>tail</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>) &lt;: </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Termination</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Proof</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>mem_incl</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>rec</I></FONT><FONT SIZE=2><I> ( = )(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>and</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>) </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#( &amp;&amp; )(</I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I> &lt;&lt; </I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> ((</I></FONT><FONT SIZE=2><I>s1</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I>) - </I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I>) = ((</I></FONT><FONT SIZE=2><I>s2</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>h1</I></FONT><FONT SIZE=2><I>) - </I></FONT><FONT SIZE=2><I>h2</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>       </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>false</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Termination</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Proof</I></FONT><FONT SIZE=2><I> *)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>proof</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>eq_incl</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>assumed</I></FONT><FONT SIZE=2><I> (* </I></FONT><FONT SIZE=2><I>TODO</I></FONT><FONT SIZE=2><I> *) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>) =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>x</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("{") </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>rec</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>print_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>Self</I></FONT><FONT SIZE=2><I>)=</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   </I></FONT><FONT SIZE=2><I>if</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>isnil</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>)</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   </I></FONT><FONT SIZE=2><I>then</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("}")</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   </I></FONT><FONT SIZE=2><I>else</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>y</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>Val</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>)) </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>print_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> - </I></FONT><FONT SIZE=2><I>Sup</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>head</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>))</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  </I></FONT><FONT SIZE=2><I>in</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>print_</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>s</I></FONT><FONT SIZE=2><I> : </I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>string</I></FONT><FONT SIZE=2><I>) = </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I>;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>witness</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>collection</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>implement</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>ListSubset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>IntList_Coll</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>collection</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IntSubsetList_Coll</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>implement</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IndList</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>) ; </I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>collection</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IntSubset2_Coll</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>implement</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>ListSubset</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>IntSubsetList_Coll</I></FONT><FONT SIZE=2><I>) ;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>end</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Subsets</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Integers</I></FONT><FONT SIZE=2><I> :\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("---------------------\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset1</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Creating</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>set</I></FONT><FONT SIZE=2><I> : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset1</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset2</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( + )(</I></FONT><FONT SIZE=2><I>subset1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("1")) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Inserting</I></FONT><FONT SIZE=2><I> 1 : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset2</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset3</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( + )(</I></FONT><FONT SIZE=2><I>subset2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("2")) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Inserting</I></FONT><FONT SIZE=2><I> 2 : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset3</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset4</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( + )(</I></FONT><FONT SIZE=2><I>subset3</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("3")) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Inserting</I></FONT><FONT SIZE=2><I> 3 : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset4</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset5</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( + )(</I></FONT><FONT SIZE=2><I>subset4</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("2")) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Inserting</I></FONT><FONT SIZE=2><I> 2 : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset5</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset6</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( - )(</I></FONT><FONT SIZE=2><I>subset5</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("2")) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Removing</I></FONT><FONT SIZE=2><I> 2 : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset6</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset7</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( - )(</I></FONT><FONT SIZE=2><I>subset6</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("3")) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Removing</I></FONT><FONT SIZE=2><I> 3 : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset7</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Subsets</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Subsets</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>of</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>Integers</I></FONT><FONT SIZE=2><I> :\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("--------------------------------\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>power1</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset2_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Creating</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>set</I></FONT><FONT SIZE=2><I> : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset2_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>power1</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>power2</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset2_Coll</I></FONT><FONT SIZE=2><I>!( + )(</I></FONT><FONT SIZE=2><I>power1</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>subset1</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Inserting</I></FONT><FONT SIZE=2><I> {} : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset2_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>power2</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>power3</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset2_Coll</I></FONT><FONT SIZE=2><I>!( + )(</I></FONT><FONT SIZE=2><I>power2</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>subset2</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Inserting</I></FONT><FONT SIZE=2><I> {1} : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset2_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>power3</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>power4</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset2_Coll</I></FONT><FONT SIZE=2><I>!( + )(</I></FONT><FONT SIZE=2><I>power3</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>subset3</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Inserting</I></FONT><FONT SIZE=2><I> {21} : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset2_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>power4</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>power5</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset2_Coll</I></FONT><FONT SIZE=2><I>!( - )(</I></FONT><FONT SIZE=2><I>power4</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>subset2</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Removing</I></FONT><FONT SIZE=2><I> {1} : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset2_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>power5</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>subset8</I></FONT><FONT SIZE=2><I> =</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( + )</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>  (</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!( + )(</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>empty</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("2")),</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>   </I></FONT><FONT SIZE=2><I>Int_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>parse</I></FONT><FONT SIZE=2><I>("1"));;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Creating</I></FONT><FONT SIZE=2><I> {12} : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>subset8</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>let</I></FONT><FONT SIZE=2><I> </I></FONT><FONT SIZE=2><I>power6</I></FONT><FONT SIZE=2><I> = </I></FONT><FONT SIZE=2><I>IntSubset2_Coll</I></FONT><FONT SIZE=2><I>!( + )(</I></FONT><FONT SIZE=2><I>power5</I></FONT><FONT SIZE=2><I>, </I></FONT><FONT SIZE=2><I>subset8</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("</I></FONT><FONT SIZE=2><I>Inserting</I></FONT><FONT SIZE=2><I> {12} : ") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>IntSubset2_Coll</I></FONT><FONT SIZE=2><I>!</I></FONT><FONT SIZE=2><I>print</I></FONT><FONT SIZE=2><I>(</I></FONT><FONT SIZE=2><I>power6</I></FONT><FONT SIZE=2><I>) ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>
</I></FONT><FONT SIZE=2><I>basics</I></FONT><FONT SIZE=2><I>#</I></FONT><FONT SIZE=2><I>print_string</I></FONT><FONT SIZE=2><I>("\</I></FONT><FONT SIZE=2><I>n</I></FONT><FONT SIZE=2><I>") ;;</I></FONT></TD></TR>
</TABLE><!--BEGIN NOTES document-->
<HR CLASS="ffootnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes"><SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> can be downloaded from <EM>http://focalize.inria.fr</EM>.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note2" HREF="#text2">2</A></DT><DD CLASS="dd-thefootnotes">That is, lists in which a given value appears at most once.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note3" HREF="#text3">3</A></DT><DD CLASS="dd-thefootnotes">More precisely, 
<CODE>#1</CODE> expects two values of
the concrete type used as the support for the collection implementing the species.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note4" HREF="#text4">4</A></DT><DD CLASS="dd-thefootnotes">The
success of <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> for complex proofs depends upon the computer architecture and the parameters
used for its invocation.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note5" HREF="#text5">5</A></DT><DD CLASS="dd-thefootnotes">Note that we describe in fact subsets for which membership is decidable.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note6" HREF="#text6">6</A></DT><DD CLASS="dd-thefootnotes">As 
<CODE>#1</CODE> inherits from 
<CODE>#1</CODE>, it can
parametrise 
<CODE>#1</CODE>, that is it is possible to consider subsets of a superset, but also
subsets of subsets of a superset, and so on.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note7" HREF="#text7">7</A></DT><DD CLASS="dd-thefootnotes">
<CODE>#1</CODE> is defined with an 
<CODE>#1</CODE>, which is primitive in <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN> ; it is
also possible to use the boolean and, denoted 
<CODE>#1</CODE> and provided in <B>basics.fcl</B>.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note8" HREF="#text8">8</A></DT><DD CLASS="dd-thefootnotes">Remember that actual results depend upon the computer and
the parameters of <SPAN STYLE="font-variant:small-caps">Zenon</SPAN>.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note9" HREF="#text9">9</A></DT><DD CLASS="dd-thefootnotes">In exceptional cases, it may also happen that
<SPAN STYLE="font-variant:small-caps">Zenon</SPAN> indicates that a tip is useless, yet is not able to find a proof without it.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note10" HREF="#text10">10</A></DT><DD CLASS="dd-thefootnotes">The file name <B>list.fcl</B> cannot
be used because of name clashes with <SPAN STYLE="font-variant:small-caps">Coq</SPAN> library.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note11" HREF="#text11">11</A></DT><DD CLASS="dd-thefootnotes">It may not be possible to browse
all elements in a

<CODE>#1</CODE>
to find a specific value.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note12" HREF="#text12">12</A></DT><DD CLASS="dd-thefootnotes">Unless an
exception is raised.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note13" HREF="#text13">13</A></DT><DD CLASS="dd-thefootnotes">Consider for
example the function 
<CODE>#1</CODE>: should it be a valid definition, it
could have any return type &#X2013; and in particular it could be used as a trick to build a value
from an empty type.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note14" HREF="#text14">14</A></DT><DD CLASS="dd-thefootnotes">In fact, we need a slightly
more generic form as we need to quantify over all predicates.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note15" HREF="#text15">15</A></DT><DD CLASS="dd-thefootnotes">For 
<CODE>#1</CODE> it is possible to use the 
<CODE>#1</CODE> equality, denoted

<CODE>#1</CODE> in <SPAN STYLE="font-variant:small-caps">FoCaLiZe</SPAN>, but <SPAN STYLE="font-variant:small-caps">Zenon</SPAN> does not know much about it and cannot prove 
<CODE>#1</CODE>,

<CODE>#1</CODE> and 
<CODE>#1</CODE>.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note16" HREF="#text16">16</A></DT><DD CLASS="dd-thefootnotes">Modulo the path for the <B>stdlib</B>, and the use of the correct version
of the <SPAN STYLE="font-variant:small-caps">OCaml</SPAN> compiler.
</DD></DL>
<!--END NOTES-->
<!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
