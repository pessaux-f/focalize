\documentclass[11pt,a4paper,twoside,onecolumn,fullpage]{article}
\pagenumbering{arabic}
\pagestyle{headings}

\input{init.tex}


\author{Fran\c{c}ois Pessaux\\
  ENSTA ParisTech\\
  \url{francois.pessaux@ensta-paristech.fr}}
\title{Another Tutorial for {F}o{C}a{L}ize:\\
  Playing with Proofs}
\date{December 2012}

\begin{document}

\maketitle

\input{intro.tex}
\input{first_order_logic.tex}

\section{Playing with programs}
Let's now introduce more material than simple first-order logic
formulae. In this section we will first introduce functions, then
inductive types in stated properties. Finally we will see that
such previously stated properties can be used as lemmas to prove further
theorems.

\subsection{Introducing functions}
One may want to prove that logical or ($\logor$) is commutative,
i.e. that $(a \logor b) \Rightarrow (b \logor a)$. But, on atomic
properties, this would again be trivial for \zenon\ as it is for
\coq. Instead, of making again explicit trivial proof steps, we will
now extend this formula with the (trivial again) identity
function. Hence we want to prove that if \verb"id" is defined as
$\lambda x.x$, then
$\forall a, b, c, d : int, (id (a) = b \logor id (c) = d) \Rightarrow (c = id (d) \logor a = id (b))$.
We write this in \focal\ like:

{\scriptsize
\lstinputlisting[numbers=left,caption=or\_id\_com.fcl]{or_id_com.fcl}}

As shown in the previous code snippet, we optimistically asked \zenon\ to
automatically handle the proof. So, let's invoke the compilation
command: \textbf{focalizec or\_id\_com.fcl} and we get:

{\scriptsize
\begin{verbatim}
Invoking ocamlc...
>> /usr/local/bin/ocamlc -I /usr/local/lib/focalize -c or_id_com.ml
Invoking zvtov...
>> /usr/local/bin/zvtov -zenon /usr/local/bin/zenon -new or_id_com.zv
File "or_id_com.fcl", line 7, characters 8-16:
Zenon error: exhausted search space without finding a proof
### proof failed
\end{verbatim}}

We should have not been so optimistic: line 7, where we invoked \lstinline"conclude",
\zenon\ did not find any proof despite it natively knows equality and
basic logic. We will investigate this point incrementally, and once
understood, we will see that we could have fixed the proof more
quickly (and more lazily). The aim here is to make again hierarchical
proof steps explicit to train splitting proofs in intermediate cases
(which will quickly become mandatory with realistic proofs).

\medskip
What is the sketch of the proof ? We basically want to assume that
$id (a) = b \logor id (c) = d$ then prove $c = id (d) \logor a = id
(b)$. We will now build the structure of the proof incrementally,
adding steps from our intuition, but leaving temporarily them
unproved. By this mean, we do not yet focus on each sub-goal, rather
on the global scheme of the proof. In some sense, we add intermediate
lemmas and want to ensure that (obviously provided they will be proven)
\zenon\ can find a proof of the global theorem combining these
lemmas. So, let's simply add a step assuming $id (a) = b \logor id (c) = d$
and ``fake-prove'' that $c = id (d) \logor a = id (b)$. Then, we ask
\zenon\ to conclude the whole theorem by this step.

{\scriptsize
\lstinputlisting[numbers=left,caption=or\_id\_com.fcl (2)]{or_id_com1.fcl}}

We remark the apparition of the keyword \lstinline"assumed" whose aim
is to loosely make a ``fake'' proof. In a sense, this allows stating
the related goal as being an axiom. Obviously, this is cheating since
the proof gets admitted, hence do not reflect anymore a really holding
property. Decent \focal\ developments should not have such ``proofs''
remaining. However, this can be the only solution when dealing with
properties that can't be proved because relying of third-party code,
not available in \focal, or when properties deal with higher-order
(\zenon\ doesn't handle this aspect). In the present case, we
only use it as a temporary placeholder to help us refining our proof
from the general idea to the fine-grain sequence of steps.

At this point the source file can be compiled invoking
\textbf{focalizec or\_id\_com.fcl} which hopefully gives not
error. It is pretty satisfactory that from the only step of the proof,
having lifted the left part of the implication as hypothesis, the
whole theorem can be proved !

\medskip
It remains now to really prove that $c = id (d) \logor a = id(b)$ under
our hypothesis. This is achieved by proving it in both cases where we
have the left and the right parts of our disjunctive hypothesis. We
can then add these new steps, still assuming their proofs, just to
ensure that our intuition of the scheme is consistent.

{\scriptsize
\lstinputlisting[numbers=left,caption=or\_id\_com.fcl (3)]{or_id_com2.fcl}}

We introduced steps \verb"<2>1" and \verb"<2>2" and said that they
should be sufficient for \zenon\ to prove the enclosing goal.
To conclude
step \lstinline"<2>3" , we must make explicit that the 2 steps
\lstinline"<2>1" and \lstinline"<2>2" are performed under assumptions
being the two parts of the disjunction we had in hypothesis
\lstinline"h1", otherwise these 2 cases are not relevant (in other
words, why did we state and prove them). Hence, step
\lstinline"<2>3" is only missing this information:
\lstinline"by ... hypothesis h1" !
We again
compile the program and get pretty happy to see that, provided these
two steps, \zenon\ really succeeds.

\medskip
So, we now need to continue our incremental process and really prove
that on one side \lstinline"c = id (d)" and on the other
\lstinline"a = id (b)". Since \zenon\ looks smart, why not asking him
to \lstinline"conclude" ? Let's try\ldots

{\scriptsize
\lstinputlisting[numbers=left,caption=or\_id\_com.fcl (4)]{or_id_com3.fcl}}

It is now time to compile the program, again with the command
\textbf{focalizec or\_id\_com.fcl} and we get:

{\scriptsize
\begin{verbatim}
Invoking ocamlc...
>> /usr/local/bin/ocamlc -I /usr/local/lib/focalize -c or_id_com3.ml
Invoking zvtov...
>> /usr/local/bin/zvtov -zenon /usr/local/bin/zenon -new or_id_com3.zv
File "or_id_com3.fcl", line 14, characters 12-20:
Zenon error: exhausted search space without finding a proof
### proof failed
\end{verbatim}}

\noindent clearly stating that \zenon\ didn't find any proof. Let's
just inspect the proof tree we tried to build:

$$
\inferrule* [Right=($\Rightarrow$-intro)]
  {\inferrule* [Right=($\logor$-elim)]
    { {\inferrule*
         {
           \inferrule* [Left=($\logor$-introl)]
           { {\begin{tabular}[b]{l}
          How to know id (a) is equal to a ? \\     How to know b is equal to id (b) ?
         \end{tabular}}}
           {\green{id (a) = b} \vdash \blue{a = id (b)}}
        }
        { \green{id (a) = b} \vdash \blue{c = id (d) \logor a = id (b)} }} \\
      {\inferrule*
         {
          \inferrule* [Right=($\logor$-intror)]
           { {\begin{tabular}[b]{l}
          How to know id (c) is equal to c ? \\   How to know d is equal to id (d) ?
         \end{tabular}}}
          {\green{id (c) = d} \vdash \blue{c = id (d)}}
        }
        { \green{id (c) = d} \vdash \blue{c = id (d) \logor a = id (b)} }}
    }
    { \green{id (a) = b \logor id (c) = d} \vdash \blue{c = id (d) \logor a = id (b)} }}
  { \vdash \blue{(id (a) = b \logor id (c) = d) \Rightarrow (c = id (d) \logor a = id (b))}}
$$

The blocking point is that the proof strongly rely on the fact that
\lstinline"id" being the identity, $id(a) = a, id(b) = b, id(c) = c$ and
$id(d) = d$, but \zenon\ is not aware of this. What \zenon\ needs is
to know about the {\em definition} of the function \lstinline"id".

Here comes
a new fact (in addition to the already seen \lstinline"conclude",
\lstinline"hypothesis" and \lstinline"step"): the
\lstinline"definition of" stating that \zenon\ must consider a whole
function (i.e. including its body -- its {\em definition}) to try
finding a proof. Hence, our proof of each intermediate steps
\lstinline"<2>1" and \lstinline"<2>2" will be done
\lstinline"by definition of id". Moreover, as shown in our above proof
tree, both goals (\lstinline"<2>1" and \lstinline"<2>2") rely on their
related hypothesis (\lstinline"h2" and \lstinline"h3").

{\scriptsize
\lstinputlisting[numbers=left,caption=or\_id\_com.fcl (5)]{or_id_com_good.fcl}}

We now compile our whole and definitive program and get proofs finally
done and accepted by \coq:

{\scriptsize
\begin{verbatim}
Invoking ocamlc...
>> /usr/local/bin/ocamlc -I /usr/local/lib/focalize -c or_id_com.ml
Invoking zvtov...
>> /usr/local/bin/zvtov -zenon /usr/local/bin/zenon -new or_id_com.zv
Invoking coqc...                                                
>> /usr/local/bin/coqc  -I /usr/local/lib/focalize  -I /usr/local/lib/zenon or_id_com.v
\end{verbatim}}

Now we suffered enough, splitting the proof of this theorem in several
parts and learnt the \lstinline{by definition of} fact, let's just
discover that all the intermediate steps we did, dealing with {\em basic
logic combinations} \ldots could again be automatically done by
\zenon\ and that, only telling it that it should use the definition of
\lstinline{id} would have been sufficient !

{\scriptsize
\lstinputlisting[numbers=left,caption=or\_id\_com\_shortest.fcl]{or_id_com_shortest.fcl}}

We can invoke the compiler on this shortened version of our program
(assuming the source file is \textbf{or\_id\_com\_shortest.fcl}):
\textbf{focalizec or\_id\_com\_shortest.fcl} and get the same successful
happy end:

{\scriptsize
\begin{verbatim}
Invoking ocamlc...
>> /usr/local/bin/ocamlc -I /usr/local/lib/focalize -c or_id_com_shortest.ml
Invoking zvtov...
>> /usr/local/bin/zvtov -zenon /usr/local/bin/zenon -new or_id_com_shortest.zv
Invoking coqc...                                               
>> /usr/local/bin/coqc  -I /usr/local/lib/focalize  -I /usr/local/lib/zenon or_id_com_shortest.v
\end{verbatim}}


\subsection{Introducing pairs}

\focal\ natively provides the type of tuples. \zenon\ knows only about
{\em pairs} (i.e. 2-components tuples). However, until enhancements of
\focal\ and/or \zenon, it is possible to encode general tuples as
nested pairs. For instance, instead of manipulating the type
\lstinline"(int * bool * string)", one will manipulate
\lstinline"(int * (bool * string))" even if it is a bit cumbersome.

\medskip
We will now study some proofs dealing with pairs, see what \zenon\ is
able to handle and how we can explicitly write such proofs. We first
start by the initial type definition, aliasing pairs of
\lstinline"int"s to a type \lstinline"int_pair_t". Such a definition
is written:

{\scriptsize
\begin{lstlisting}
type int_pair_t = alias (int * int) ;;
\end{lstlisting}}

\noindent and simply declares a new type constructor compatible with
\lstinline "(int * int)".

\zenon\ natively knows about \lstinline"fst : ('a * 'b) -> 'a" and
\lstinline"snd : ('a * 'b) -> 'b" functions, extracting the first and
second component of a pair. For instance, it will be able to prove
that extracting components of one pair with 2 equal components will lead
to 2 equal values:

{\scriptsize
\lstinputlisting[numbers=left,caption=same\_comps.fcl]{same_comps.fcl}}



\subsection{Playing with pairs}

We will now prove another simple property to continue using the hierarchical way
to write proofs, hence train to make explicit steps for later, when
such splits will be mandatory. We want to prove the property:
$$
\forall v_1, v_2 : {\tt int}, \forall v : {\tt int\_pair\_t},
\ v = (v1, v2) \Rightarrow\ \sim (v1 = v2) \Rightarrow ~ ({\tt fst} (v) = {\tt snd} (v))
$$

This obviously can be proven by \zenon\ as shows the following
formulation in \focal:

{\scriptsize
\lstinputlisting[numbers=left,caption=diff\_comps.fcl]{diff_comps.fcl}}

However, we want to prove it ourselves (nearly, \zenon\ will finally still
provide the glue between our steps)! We first need to expose
the sketch of the proof: first assume the 2 implications, then prove
$\sim ({\tt fst} (v) = {\tt snd} (v))$. To do so, we will demonstrate that in fact
${\tt fst} (v) = v_1$, that ${\tt snd} (v) = v_2$, and conclude by the hypothesis
that $v_1 \not = v_2$.

{\scriptsize
\lstinputlisting[numbers=left,caption=diff\_comps.fcl (2)]{diff_comps2.fcl}}

In lines 10 and 11, we lift the implications premises as hypotheses,
then the re\-mai\-ning goal is \lstinline"prove ~ (fst (v) = snd (v))".
Then we prove in step \lstinline"<2>1" that \lstinline"fst (v) = v1"
which is obtained from the fact that \lstinline"v" is a pair (hypothesis
\lstinline"h1") and \zenon's knowledge about \lstinline"fst". We prove
that \lstinline"snd (v) = v2" by the same means. And finally from
these 2 intermediate steps and the hypothesis that $v_1 \not = v_2$
(\lstinline"h2") we achieve demonstration of the goal \lstinline"<1>1".


\subsection{Introducing inductive types}

Realistic programs usually do not only involve integers and pairs:
inductive type de\-fi\-ni\-tions are a powerful mean to model
data-structures. \focal\ doesn't escape this rule and \zenon\ makes
possible to reason on such type definitions to automate
proofs.
An inductive type definition introduces several {\em value constructors} for a type.
For instance:

{\scriptsize
\begin{lstlisting}
type signal_t = | Red | Orange | Green ;;
\end{lstlisting}}

\noindent declares the {\bf new} type \lstinline"signal_t" as containing the
{\bf only} 3 values \lstinline"Red", \lstinline"Orange" and
\lstinline"Green". These values are all different from each other.

Moreover, an inductive type definition can introduce parametrised
constructors, possibly by values of the type itself: we have a recursive
type definition:

{\scriptsize
\begin{lstlisting}
type peano_t = | Z | S (peano_t) ;;
\end{lstlisting}}

\noindent declares the {\bf new} type \lstinline"peano_t" as containing the
{\bf only} 2 values \lstinline"Z" and \lstinline"S", this latter
embedding a value of type \lstinline"peano_t" itself. We recognize
here the usual definition of Peano's integers.

\medskip
As a summary, inductive definitions natively introduce 2 important
concepts used all over proofs:
\begin{itemize}
\item {\em The injectivity of value constructors}: a value of such a type is
  one of its cons\-truc\-tors and nothing else, constructors being all
  different from each other.
\item {\em The induction principle}: assuming a property holding on constant
  value constructors, if this property holds for any parametrised
  value constructor, then it holds for any values of this type. This is
  indeed a generalization of the well-known recurrence principle on
  natural numbers.
\end{itemize}

\medskip
We will first show that \zenon\ greatly helps by knowing injectivity
of constructors. The aim will be to demonstrate that any value of type
\lstinline"signal_t" is equal to either \lstinline"Red", or \lstinline"Orange"
or \lstinline"Green". Hence we state the theorem:

{\scriptsize
\lstinputlisting[numbers=left,caption=signal.fcl]{signal1.fcl}}

\noindent and invoke the compiler to get:

{\scriptsize
\begin{verbatim}
Invoking ocamlc...
>> /usr/local/bin/ocamlc -I /usr/local/lib/focalize -c signal.ml
Invoking zvtov...
>> /usr/local/bin/zvtov -zenon /usr/local/bin/zenon -new signal.zv
File "signal.fcl", line 7, characters 10-18:
Zenon error: exhausted search space without finding a proof
### proof failed
\end{verbatim}}

\zenon\ didn't find any proof despite we promised it knew how to
reason on inductive types! In fact, it was given no fact, no clue, so
how could it guess that this property was induced by the underlying
type definition? It it important to keep in mind that \zenon\ only implicitly uses
basic logic combinations: it will never use all the material
available in a program! So, we just need to tell him that this proof
can be deduced from the type definition of \lstinline"signal_t".

Here comes a new fact  (in addition to the already seen \lstinline"conclude",
\lstinline"hypothesis", \lstinline"step" and \lstinline"definition of"): the
\lstinline"type" fact stating that the definition of the following
type must be used. We modify our program just inserting this new fact
and get:

{\scriptsize
\lstinputlisting[numbers=left,caption=signal.fcl (2)]{signal2.fcl}}

\noindent which is perfectly proven now. This could seem not so
wonderful, but to prove such a property directly in \coq, a little more
work would be required, applying the \verb"destruct" tactic and
enumerating all the possible cases (hopefully shortened thanks to
\coq\ ability to repeat attempts to a tactic on individual
goals). Let's illustrate this point:

{\scriptsize
\begin{lstlisting}[language=MyCoq]
Coq < Inductive signal_t : Set :=
Coq <  | Red : signal_t
Coq <  | Orange : signal_t
Coq <  | Green : signal_t.
signal_t is defined
signal_t_rect is defined
signal_t_ind is defined
signal_t_rec is defined

Coq < Goal forall s : signal_t, (s = Red) \/ (s = Orange) \/ (s = Green).
1 subgoal
  
  ============================
   forall s : signal_t, s = Red \/ s = Orange \/ s = Green

Unnamed_thm < intro ty.
1 subgoal
  
  ty : signal_t
  ============================
   ty = Red \/ ty = Orange \/ ty = Green

Unnamed_thm < auto.
1 subgoal
  
  ty : signal_t
  ============================
   ty = Red \/ ty = Orange \/ ty = Green

(* Humm, below shows that auto tactic is not sufficient: this property
   is not trivial for Coq. We need to be just a little more explicit. *)

Unnamed_thm < destruct ty; auto.
No more subgoals.
\end{lstlisting}}

Hence, using \zenon, such intrinsic property of inductive type
definitions is natively understood, as long as \zenon\ is told to use
it by the fact \lstinline"by ... type ...".

\medskip
We can also show that mutual exclusion of value constructors are
native for \zenon: let prove that if a value of type
\lstinline"signal_t" is equal to \lstinline"Red", then it is different
of \lstinline"Green". This can appear more than trivial, but we will
see that this property, often used while reasoning by cases, it not so
trivial in \coq. Let's first state and prove this property in \focal:

{\scriptsize
\lstinputlisting[numbers=left,caption=signal2.fcl]{signal3.fcl}}

Proving the same property in \coq\ is more complex, and not having to
deal with this during proofs is really appreciable. Let's have a look
to an equivalent proof in \coq:

{\scriptsize
\begin{lstlisting}[language=MyCoq]
Coq < Inductive signal_t : Set :=
Coq <  | Red : signal_t
Coq <  | Orange : signal_t
Coq <  | Green : signal_t.
signal_t is defined
signal_t_rect is defined
signal_t_ind is defined
signal_t_rec is defined

Coq < Goal forall s : signal_t, s = Red -> ~ (s = Green).
1 subgoal
  
  ============================
   forall s : signal_t, s = Red -> s <> Green


Unnamed_thm < intros ty h.
1 subgoal
  
  ty : signal_t
  h : ty = Red
  ============================
   ty <> Green

(* Humm, below shows that auto tactic is not sufficient: this property
   is not trivial for Coq. We need to be just a little more explicit. *)

Unnamed_thm < auto.
1 subgoal
  
  ty : signal_t
  h : ty = Red
  ============================
   ty <> Green

Unnamed_thm < induction ty.
3 subgoals
  
  h : Red = Red
  ============================
   Red <> Green

subgoal 2 is:
 Orange <> Green
subgoal 3 is:
 Green <> Green
Unnamed_thm < discriminate.
2 subgoals
  
  h : Orange = Red
  ============================
   Orange <> Green

subgoal 2 is:
 Green <> Green
Unnamed_thm < discriminate.
1 subgoal
  
  h : Green = Red
  ============================
   Green <> Green

Unnamed_thm < inversion h.
No more subgoals.
\end{lstlisting}}

\subsection{Introducing lemmas}
Until now we stated properties and demonstrated them writing
``all-in-one'' proofs, i.e. using intermediate (hence nested) steps,
hypotheses, types and functions definitions. However, depending on the
complexity of the property to prove, it may be easier to define
intermediate lemmas, or even involve previously demonstrated
theorems. This answers a need for modularity (intermediate lemmas can
be used for other proofs) and readability (intermediate lemmas can
make proofs more numerous but smaller) when writing proofs.

\medskip
Still addressing proofs on programs, we now want to prove that the
absolute value of a difference is always \ldots positive. The only
thing is, we won't write the program computing such a value using a
predefined {\tt abs} function bringing its property stating it always
returns a positive value. Instead, we write this function using a test
and a subtraction:

{\scriptsize
\begin{lstlisting}[caption=lemmas.fcl]
open "basics" ;;

let abs_diff (x, y) = if x >0x y then x - y else y - x ;;
\end{lstlisting}}

In this program and the following, relational operators on integers
are written suffixed by \lstinline{0x}. These are the \focal\
operators on \lstinline{int} ( \lstinline{>0x}, \lstinline{<0x},
\lstinline{>=0x} \ldots). We now state the property we want to
demonstrate, and as always we initially state it as \lstinline{assumed}:

{\scriptsize
\lstinputlisting[numbers=left,caption=lemmas.fcl (2)]{lemmas1.fcl}}

We must now elaborate the sketch of the proof to introduce
intermediate steps. From the definition of our function
\lstinline"abs_diff", it is clear that we must reason by cases, one if
$x > y$ and one if $\sim (x > y)$, i.e. $x \le y$. Hence, we will
introduce 2 steps for these cases, and an ending one using the former
to conclude the goal.

{\scriptsize
\lstinputlisting[numbers=left,caption=lemmas.fcl (3)]{lemmas2.fcl}}

In both intermediate steps \lstinline"<2>1" and \lstinline"<2>2" the
goal is the same than the global one: we did not yet split it, changed
it by any refinement. However, we introduced 2 differents (and
complementary) hypotheses.
Having in mind that having covered cases $x > y$
and  $x \le y$ we covered all the cases of integers, we run the
compiler and get:

{\scriptsize
\begin{verbatim}
Invoking ocamlc...
>> /usr/local/bin/ocamlc -I /usr/local/lib/focalize -c lemmas.ml
Invoking zvtov...
>> /usr/local/bin/zvtov -zenon /usr/local/bin/zenon -new lemmas.zv
File "lemmas2.fcl", line 16, characters 16-34:
Zenon error: exhausted search space without finding a proof
\end{verbatim}}

Oops, it goes wrong, \zenon\ didn't find any proof! So what? So why ?
As naively said in the above paragraph, ``{\em Having in mind that having
covered cases $x > y$ and  $x \le y$ we covered all the cases of
integers}'', we assume that it is obvious that 2 integers are either
greater or lower-or-equal together. But, this fact is {\bf not}
obvious: \zenon\ does not known arithmetic! So we need to give it
such a property as a fact to hope it will finally find a proof.

\medskip
We are currently trying to make a proof, and now we need to prove
another property. So, first we don't want to spread our effort in
several directions. We need to have this other property: why not state
it, not prove it yet, and check that our current proof pass with this
new property ? We just need a lemma to make our proof, so we will
introduce some. We then write the theorem
\lstinline"two_ints_are_gt_or_le"
stating that $\forall x, y : int,\ x \le y \logor x > y$ and give it
as a new fact to \zenon.

Here comes a new fact  (in addition to the
already seen \lstinline"conclude", \lstinline"hypothesis",
\lstinline"step", \lstinline"definition of" and \lstinline"type": the
\lstinline"property" fact, stating that \zenon\ should use the given
property (i.e. logical statement) to find a proof.

{\scriptsize
\lstinputlisting[numbers=left,caption=lemmas.fcl (4)]{lemmas2_1.fcl}}

We now compile again our development and see that with this new fact,
\zenon\ finally succeeded.

{\scriptsize
\begin{verbatim}
Invoking ocamlc...
>> /usr/local/bin/ocamlc -I /usr/local/lib/focalize -c lemmas.ml
Invoking zvtov...
>> /usr/local/bin/zvtov -zenon /usr/local/bin/zenon -new lemmas.zv
Invoking coqc...                                                
>> /usr/local/bin/coqc  -I /usr/local/lib/focalize  -I /usr/local/lib/zenon lemmas.v
\end{verbatim}}

Obviously, we get one more theorem to demonstrate. However, we know
that provided this theorem holds, the proof of our main program
property also holds. We can now go on further on it, leaving the new
lemma for later.

But\ldots by a wonderful coincidence, \focal\ comes with a ``standard
library''! And looking among available theorems (in
\textbf{basics.fcl}) we find a theorem:

{\scriptsize
\begin{lstlisting}
theorem int_gt_or_le : all x y : int, (x >0x y) \/ (x <=0x y)
\end{lstlisting}}

\noindent exactly fitting what we need! So, proof of our lemma will be
trivial since it will simply be done \lstinline"by property basics.int_gt_or_le".
But, we can make even simpler: in our proof, let's just use this
theorem from the library instead of aliasing it by our lemma! Hence,
in our proof, we change \lstinline"<2>3 qed" by adding
\lstinline"by ... int_gt_or_le" instead of 
\lstinline"by ... two_ints_are_gt_or_le" and remove this latter from
our source code.

\medskip
Now, let's going on with our proof. We need to really prove the 2
steps \lstinline"<2>1" and \lstinline"<2>2". For \lstinline"<2>1", we
can prove that ${\tt abs\_diff} (x, y) = x - y$ and that
$x - y \ge 0$. This way, we will really have proved that
${\tt abs\_diff} (x, y) \ge 0$: our sub-proof will then be conclude ``by
these 2 steps'' as show below in step \lstinline"<3>2"

Similarly, for \lstinline"<2>2" we will prove something like that
${\tt abs\_diff} (x, y) = y - x$ and $y - x \ge 0$. We let this second case
aside for the moment (i.e. \lstinline"assumed"), only dealing with the
first one.

{\scriptsize
\lstinputlisting[numbers=left,caption=lemmas.fcl (5)]{lemmas3.fcl}}

Compiling our program, we will see that the proof continues passing:
our idea of sub-proofs was correct. So, we now want to really prove
the new intermediate steps \lstinline"<3>1" and \lstinline"<3>2". The
sketch of the proof is to prove that ${\tt abs\_diff} (x, y) = x - y$ and
that $x - y \ge 0$ knowing we are in the context of hypothesis
\lstinline"h1" stating that $x > y$.

Lets start by step \lstinline"<3>1". We want to prove that
${\tt abs\_diff} (x, y) = x - y$.
This is a direct consequence of the definition of the function
\lstinline"abs_diff" since we are in the case of hypothesis
\lstinline"h1". Hence, this proof is simply done
\lstinline"by definition of abs_diff hypothesis h1".

We now address step \lstinline"<3>2".  What do we have as material? We
know by hypothesis \lstinline"h1" that $x>y$. From this point, it looks
obvious to us that in effect,  $x - y \ge 0$. However, like above for
the ``trivial'' lemma on arithmetic, it won't probably be so for
\zenon. We can again introduce a new lemma, or \ldots have a look to
see if there would not already be a suitable theorem in the \focal\
standard library! And hopefully, we find in \textbf{basics.fcl} the
theorem:

{\scriptsize
\begin{lstlisting}
theorem int_diff_ge_is_pos : all x y : int, x >=0x y -> x - y >=0x 0
\end{lstlisting}}

It is pretty won, but not yet. In effect having a deeper look at our
hypothesis \lstinline"h1", we see that it states that $x > y$ although
the theorem \lstinline"int_diff_ge_is_pos" requires as hypothesis that
$x \ge y$. However, our intuition immediately makes us thinking that if
$x > y$ then it is inevitable that $x \ge y$. Again, a new lemma to
introduce or a look to have in the standard library\ldots

Fortunately, we again discover a theorem fitting our expectations in
\textbf{basics.fcl}:

{\scriptsize
\begin{lstlisting}
theorem int_gt_implies_ge : all x y : int, x >0x y -> x >=0x y
\end{lstlisting}}

Note that in ``real life'', it will happen that the library do not already
contains the theorem you need: in this case, you will really state it
as a new theorem (lemma) and finally will need to prove it!

Now we found the 2 former theorems, our goal should be solved by
\zenon\ \lstinline"by property ..." of them and the hypothesis
\lstinline"h1".

{\scriptsize
\lstinputlisting[numbers=left,caption=lemmas.fcl (6)]{lemmas4.fcl}}

As planned, the proof is accepted and we go on, trying to prove the
remaining step \lstinline"<2>2". We will proceed in the same way,
proving that assuming hypothesis \lstinline"h2" we have
${\tt abs\_diff} (x, y) = y - x$ and $y - x \ge 0$.

However, we can note that the theorem \lstinline"int_diff_ge_is_pos"
we used above states  $(a \ge b) \Rightarrow (a - b \ge 0)$.
But, our hypothesis \lstinline"h2" states that $x \le y$ and we need
to prove that $y -x \ge 0$. But in fact, in our hypothesis, if we swap $x$ and
$y$ and replace $\le$ by $\ge$ we get into the right hypothesis of the
theorem. Again, we will need a theorem stating that
$x \le y \Rightarrow y \ge x$ which already exists as
\lstinline"int_le_ge_swap". We then have one more step than in the
previous case, to demonstrate that $y \ge x$
\lstinline"by property int_le_ge_swap hypothesis h2".

\medskip
We finally show the new form of the proof, skiping the ({\em a priori}
obvious) proof that {\tt abs\_diff (x, y) = y - x}. Although it seems
it is only a consequence of the definition of \lstinline{abs_diff}, we
will see later that it requires something more.

{\scriptsize
\lstinputlisting[numbers=left,caption=lemmas.fcl (7)]{lemmas5.fcl}}

Finally, it only remains to inspect step \lstinline"<3>1". As
previously mentioned, it looks trivial that it only depends on the
fact we are in hypothesis \lstinline"h2", i.e. $x \le y$ and the
definition of \lstinline"abs_diff" falling in the ``else-case''. Let
simply make the proof with these 2 facts:

{\scriptsize
\begin{lstlisting}
...
       <2>2 hypothesis h2: x <=0x y,
                 prove abs_diff (x, y) >=0x 0
            <3>1 prove abs_diff (x, y) = y - x
                      by definition of abs_diff hypothesis h2
...
\end{lstlisting}}

We compile and get:

{\scriptsize
\begin{verbatim}
Invoking ocamlc...
>> /usr/local/bin/ocamlc -I /usr/local/lib/focalize -c lemmas.ml
Invoking zvtov...
>> /usr/local/bin/zvtov -zenon /usr/local/bin/zenon -new lemmas.zv
File "lemmas.fcl", line 21, characters 17-56:                
Zenon error: exhausted search space without finding a proof
### proof failed
\end{verbatim}}

Having closer look at our hypothesis \lstinline"h2: x <=0x y" and the
way \lstinline"abs_diff" has its conditional written
\lstinline"if x >0x y", we see that the \lstinline"if" tests $x >y$,
hence in the ``else-case'' we have $\sim (x >y)$ and not $x \le y$ as
stated in the hypothesis! In effect, in a ``else-branch'' the holding
property is ``{\bf not}-the-tested-condition''. And again, for \zenon,
it is not obvious that $\sim (x >y)$ is the same thing than $x \le y$.
Again, we need to guide \zenon\ with such a theorem which hopefully
exists in \focal\ standard library:

{\scriptsize
\begin{lstlisting}
theorem int_le_not_gt : all x y : int, (x <=0x y) -> ~ (x >0x y)
\end{lstlisting}}

At this point, adding the fact \lstinline"int_le_not_gt" to the proof
of our step \lstinline"<3>1" will finally conclude the whole proof:

{\scriptsize
\lstinputlisting[numbers=left,caption=lemmas.fcl (8)]{lemmas.fcl}}

\input{program.tex}
\input{conclusion.tex}
\end{document}

