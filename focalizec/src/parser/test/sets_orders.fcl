(**
 @title FoC Project. Basic algebra.
 @author The FoC project

Basic sets operations, orderings and lattices.
*)

-- This is a file in new syntax!

uses "../../../basics";;
open "../basics";;

(** In a setoid, we can test the equality (note for logicians: this is
   a congruence). The setoid can not be empty. *)
species setoid inherits basic_object =

  (** @mathml <eq/> *)
  sig ( = ) : self -> self -> bool
  ;
  property ``equal is reflexive'' : all x y in self,
    self!( = ) (x, x) and
    x = x
  ;
  property equal_symmetric : all x y in self,
    self!equal(x, y) -> !equal(y, x)
  ;
  property equal_transitive : all x y z in self,
    !equal(x, y) -> !equal(y, z) -> !equal(x, z)
  ;
  (** element returns some element of our non empty setoid *)
  sig element : self
  ;
  (** @mathml <neq/> *)
  let different (x, y) = basics#not_b(!equal(x, y))
  ;
  theorem same_is_not_different : all x y in self,
     !different(x, y) <-> ( !equal(x, y))
  proof:
    by definition of different
;
(*   theorem same_is_not_different : all x y in self, *)
(*      !equal(x,y) -> not(!different(x,y))  *)
(*   proof:  *)
(*     DEF !different *)
(*   ; *)

(*   theorem different_is_not_same : all x y in self, *)
(*      !different(x,y) -> not(!equal(x,y))  *)
(*   proof:  *)
(*     DEF !different *)
(*   ; *)

end
;;

(**
  This is a first attempt to specify representations.
  We define two functions and two properties relating 
  concrete values of rep and abstract values of self
*)
species represented_by(s is basic_object)

inherits setoid =

  rep = s;

  (** an element of self is encoded by an element of s *)
  let to_rep (x in self) in s = x;

  (** One should be able to describe which values of s
     correspond to some abstract self
   *)
  sig represents_some_self : s -> prop;

  (** A way to abstract concrete values,
     not intended to be used by the programmer
   *)
  sig from_rep : s -> self;

  (** This property enables to state theorems about abstract self *)
  logical correct_representation(x) =
    !represents_some_self(!to_rep(x))
  ;

  theorem correct_rep_spec: all x in self,
     !correct_representation(x) <-> !represents_some_self(!to_rep(x))
     proof: by definition of !correct_representation
  ;

  (** combining to_rep and from_rep gives identity *)
  property to_rep_reverses: all x in self, !equal(!from_rep(!to_rep(x)), x);

  (** since we provide an injection to s from_rep is a surjection *)
  theorem from_rep_is_surjective: all x in self, ex y in s,
    !equal(!from_rep(y), x)
  proof:
   <1>1 assume x in self,
        prove !equal(!from_rep(x), x)
        by property !to_rep_reverses
           definition of !to_rep
   <1>f qed.
  ;

  (** every element of self should verify an invariant *)
  property correct_invariant: all x in self, !correct_representation(x);

  (** by default we print the concrete data *)
  let print(x) = s!print(!to_rep(x));
  (** by default we parse concrete data and abstract it*)
  let parse(p) = !from_rep(s!parse(p));

end
;;

(** 
   Here we state that in some cases we may view partial operations
   as total operations.
   This requires to include some form of predicate for failing operations.

 *)
species partial_set inherits setoid =

  (** this is intended to model failure*)
  let failed in (string -> self) =
    let ifailed (r in string, elt in self) in self =
       external
       | caml -> "i_failed"
       | coq -> "i_failed"
       end
    in function reason -> ifailed(reason, !element);

end
;;

(** pre orderings are sometimes called quasi orderings *)
species pre_order inherits setoid =
  (** leq(x,y) is x &le; y
      @mathml <leq/> *)
  sig leq : self -> self -> bool;

  property leq_reflexive: all x y in self,
    !equal(x, y) -> !leq(x, y);
  property leq_transitive: all x y  z in self,
    !leq(x, y) -> !leq(y, z) -> !leq(x, z) ;

   (** we may reverse inequalities by simply changing notations
    @mathml <geq/> *)
  let geq(x, y)= !leq(y, x);

  (** a characteristic property *)
  theorem geq_is_leq: all x y in self,
    (!geq(x, y) -> !leq(y, x)) and  (!leq(x, y) -> !geq(y, x))
    proof: 
      by definition of !geq
  ;

  theorem geq_reflexive: all x y in self, !equal(x, y) -> !geq(x, y)
  proof: by definition of !leq_reflexive, !equal_symmetric, !geq_is_leq
  ;

  theorem geq_transitive: all x y z in self,
    !geq(x, y) -> !geq(y, z) -> !geq(x, z)
    proof: by definition of !leq_transitive, !geq_is_leq
  ;


  (** strict inequality
     @mathml <lt/> *)
  let lt(x, y) = basics#and_b(!leq(x, y), basics#not_b(!equal(x, y)));

  (** some results about strict and large inequalities *)
  theorem lt_is_not_leq : all x y in self,
    ((!lt(x, y) -> (!leq(x, y) and !different(x, y)))
  and
     (!leq(x, y) -> (!lt(x, y) or !equal(x, y))))
    proof:
      by definition of !lt, !different
  ;



  (** @mathml <gt/> *)
  let gt(x, y) = !lt(y, x);

  theorem gt_is_lt: all x y in self,
    (!gt(x, y) -> (!geq(x, y) and !different(x, y)))
      and
    (!geq(x, y) -> (!gt(x, y) or !equal(x, y)))
    proof:
      by property !lt_is_not_leq, !equal_symmetric
         definition of !gt, !geq, !different
  ;

end
;;

(** In a set an ordering is often called a partial order *)
species partial_order inherits pre_order =
  property leq_antisymmetric:  all x y in self,
    !leq(x, y) -> !leq(y, x) -> !equal(x, y)
  ;


  theorem geq_antisymmetric: all x y in self,
    !geq(x, y) -> !geq(y, x) -> !equal(x, y)
    proof: by definition of !leq_antisymmetric, !geq_is_leq
  ;

end
;;

(** in a meet semi lattice we have an operation inducing an ordering (&lt;=)*)
species meet_semi_lattice inherits setoid =
  (** the infimum of two elements *)
  (* [rr]: need a mathml symbol for that, 
     we don't want to use <min/> nor <intersect/>
  *)
  sig inf : self -> self -> self ;
  (** compatibility with equality *)
  property inf_left_substitution_rule : all x y z in self,
    !equal (x, y) -> !equal (!inf (x, z), !inf (y, z))
  ;
  (** inf is a commutative law*)
  property inf_commutes : all x y in self,
    !equal(!inf(x, y), !inf(y, x));
  (** 
     for a  commutative law right congruence is a consequence 
      of left congruence
   *)
  theorem inf_right_substitution_rule : all x y z in self,
     !equal(y, z) -> !equal(!inf(x, y), !inf(x, z))
     proof: 
       by property
          !inf_left_substitution_rule,
          !inf_commutes, 
          (*!equal_reflexive,*)
          !equal_transitive
     ;
  (** users should use global congruence when possible *)
  theorem inf_substitution_rule: all x y z t in self,
    !equal(x, y) -> !equal(z, t) -> !equal(!inf(x, z), !inf(y, t))
(*    !equal(x, y) -> !equal(y, t) -> !equal(!inf(x, y), !inf(y, t)) *)
    proof:
      by property
         !inf_left_substitution_rule, !inf_right_substitution_rule,
         (* [rr]: if not given reflexivity Zenon fails *)
         (* [dd]: now it works *)
         (* [pw]: now it breaks again! *)
         !equal_transitive(*, !equal_reflexive*)
    ;
  (* inf is an associative law *)
  property inf_is_associative : all x y z in self,
    !equal(!inf(!inf(x, y), z), !inf(x, !inf(y, z)));
  (* inf is an idempotent law  *)
  property inf_idempotent : all x y in self,
    !equal(x, y) -> !equal(x, !inf(x, y));

  (** order_inf is the least defined ordering compatible with inf *)
  (* [rr]: need a mathml symbol for that, 
     we don't want to use <leq/>
  *)
  let order_inf(x, y) = !equal(x, !inf(x, y));
  theorem order_inf_is_reflexive : all x y in self,
     !equal(x, y) -> !order_inf(x, y)
     proof : 
       by property !inf_idempotent
       definition of !order_inf
     ;

  theorem order_inf_is_antisymmetric : all x y in self,
     !order_inf(x, y) -> !order_inf(y, x) -> !equal(x, y)
     (* x=inf(x, y) et y=inf(x, y) *)
     proof:
       by
        property !inf_commutes, !equal_transitive, !equal_symmetric
        definition of !order_inf
     ;
  theorem order_inf_is_transitive : all x y z in self,
     !order_inf(x, y) -> !order_inf(y, z) -> !order_inf(x, z)
     (* x=inf(x, y) et y=inf(y, z) x=inf(x, inf(y, z))=inf(inf(x, y), z)=inf(x, z)*)
     proof:
       <1>1 assume x in self,
            assume y in self,
            assume z in self,
            assume H1: !order_inf (x, y),
            assume H2: !order_inf (y, z),
            prove !order_inf (x, z)
         <2>0 prove !equal (x, !inf (x, y))
           by
             hypothesis H1
             definition of !order_inf
         <2>1 prove !equal (x, !inf (x, !inf (y, z)))
           by
              step <2>0
              hypothesis H2
              property !inf_right_substitution_rule, !equal_transitive
              definition of !order_inf
         <2>2 prove !equal (x, !inf (!inf (x, y), z))
           by
              step <2>1
              property !inf_is_associative, !equal_transitive, !equal_symmetric
         <2>3 prove !equal (x, !inf (x, z))
              by step <2>2, <2>0
	         property !equal_symmetric, !equal_transitive,
	           !inf_left_substitution_rule
         <2>4 qed
              by step <2>3
                 definition of !order_inf
       <1>2 qed.
     ;
  (** any element smaller than x and y is smaller than their infimum *)
  theorem order_inf_is_infimum: all x y i in self,
    !order_inf(i, x) -> !order_inf(i, y) ->
      !order_inf(i, !inf(x, y))
    proof:
      <1>1 assume x in self,
           assume y in self,
           assume i in self,
           assume H1: !order_inf(i, x),
           assume H2: !order_inf(i, y),
           prove !order_inf(i, !inf(x, y))
        <2>1 prove !equal(i, !inf(!inf(i, x), y))
          by hypothesis H1, H2
             property !inf_left_substitution_rule,
             !equal_symmetric, !equal_transitive
             definition of !order_inf
        <2>9 qed
          by step <2>1
             property !inf_is_associative, !equal_transitive
             definition of !order_inf
      <1>2 qed.
    ;

end
;;

(** in a join semi lattice we have an operation inducing an ordering (&gt;=) *)
species join_semi_lattice inherits setoid =

  (** the supremum of two elements *)
  (* [rr]: need a mathml symbol for that, 
     we don't want to use <max/> nor <union/>
  *)
  sig sup : self -> self -> self ;
  (** compatibility with equality *)
  property sup_left_substitution_rule : all x y z in self,
    !equal (x, y) -> !equal (!sup (x, z), !sup (y, z))
  ;
  property sup_commutes : all x y in self,
    !equal(!sup(x, y), !sup(y, x));

  (** 
     for a  commutative law right congruence is a consequence 
      of left congruence
   *)
  theorem sup_right_substitution_rule : all x y z in self,
     !equal(y, z) -> !equal(!sup(x, y), !sup(x, z))
     proof: 
       by
        property !sup_left_substitution_rule, !sup_commutes, !equal_transitive
     ;
  (** users should use global congruence when possible *)
  theorem sup_substitution_rule: all x y z t in self,
    !equal(x, y) -> !equal(z, t) -> !equal(!sup(x, z), !sup(y, t))
(*    !equal(x, y) -> !equal(y, t) -> !equal(!sup(x, y), !sup(y, t)) *)
    proof:
      by
        property !sup_left_substitution_rule, !sup_right_substitution_rule,
           (* [rr]: if not given reflexivity Zenon fails *)
           !equal_transitive(*, !equal_reflexive*)
    ;
  (* sup is an associative law *)
  property sup_is_associative : all x y z in self,
    !equal(!sup(!sup(x, y), z), !sup(x, !sup(y, z)));
  (* sup is an idempotent law  *)
  property sup_idempotent : all x y in self,
    !equal(x, y) -> !equal(x, !sup(x, y));

  (** order_sup is the least defined ordering compatible with sup *)
  (* [rr]: need a mathml symbol for that, 
     we don't want to use <geq/>
  *)
  let order_sup(x, y) = !equal(x, !sup(x, y));

  theorem order_sup_is_reflexive : all x y in self,
     !equal(x, y) -> !order_sup(x, y)
     proof:
       by property !sup_idempotent
          definition of !order_sup
  ;

  theorem order_sup_is_antisymmetric : all x y in self,
     !order_sup(x, y) -> !order_sup(y, x) -> !equal(x, y)
     proof:
       by property !sup_commutes, !equal_symmetric, !equal_transitive
          definition of !order_sup
     ;

  theorem order_sup_is_transitive : all x y z in self,
     !order_sup(x, y) -> !order_sup(y, z) -> !order_sup(x, z)
     (* x=inf(x, y) et y=inf(y, z) x=inf(x, inf(y, z)=inf(inf(x, y), z)=inf(x, z)*)
     proof:
       <1>1 assume x in self,
            assume y in self,
            assume z in self,
            assume xLTy : !order_sup (x, y),
            assume yLTz : !order_sup (y, z),
            prove !order_sup (x, z)
         <2>1 prove !equal (x, !sup (x, !sup (y, z)))
           by
             hypothesis xLTy, yLTz
             property !sup_right_substitution_rule, !equal_transitive
             definition of !order_sup
         <2>2 prove !equal (x, !sup (!sup (x, y), z))
           by step <2>1
              property !sup_is_associative, !equal_transitive, !equal_symmetric
         <2>9 qed
           by step <2>2
              hypothesis xLTy
               property !equal_symmetric, !equal_transitive,
                        !sup_left_substitution_rule
               definition of !order_sup
       <1>2 qed.
     ;

  (** any element bigger than two elements is bigger than their supremum *)
  theorem order_sup_is_supremum: all x y i in self,
    !order_sup(i, x) -> !order_sup(i, y) ->
      !order_sup(i, !sup(x, y))
    proof:
      <1>1 assume x in self,
           assume y in self,
           assume i in self,
           assume H1: !order_sup(i, x),
           assume H2: !order_sup(i, y),
           prove !order_sup(i, !sup(x, y))
        <2>1 prove !equal(i, !sup(!sup(i, x), y))
          by
           hypothesis H1, H2
           property !sup_left_substitution_rule,
                    !equal_symmetric, !equal_transitive
          definition of !order_sup
        <2>9 qed
          by step <2>1
             property !sup_is_associative, !equal_transitive
             definition of !order_sup
      <1>2 qed.
    ;

end
;;

(** lattices have an inf and sup operation which induce a partial order *)

species lattice inherits meet_semi_lattice, join_semi_lattice = 

  (** the first absorbtion law *)
   property inf_absorbes_sup: all x y in self,
     !equal(x, !sup(x, !inf(x, y)));

   (** the second absorbtion law *)
   property sup_absorbes_inf: all x y in self,
     !equal(x, !inf(x, !sup(x, y)));

   (** in a lattice there is only one ordering *)
   theorem order_inf_refines_order_sup: all x y in self,
     !order_sup(y, x) -> !order_inf(x, y)
     proof:
       (* x = x v y ; x ^ y = x ^ (x v y) = x *)
       <1>1 assume x in self,
            assume y in self,
            assume H: !order_sup(y, x),
            notation s = !sup (x, y),
            prove !order_inf(x, y)
            <2>1 prove !equal(!inf(x, y), x)
                 <3>1 prove !equal(y, !sup(x, y))
                      by hypothesis H
                         property !sup_commutes, !equal_transitive
                         definition of !order_sup
                 <3>2 prove !equal(!inf(x, !sup(x, y)), x)
                      by property !sup_absorbes_inf, !equal_symmetric
                 <3>3 prove !equal(!inf(x, y), !inf(x, !sup(x, y)))
                      by step <3>1
                      property !inf_right_substitution_rule
                 <3>f qed by step <3>3, <3>2
                          property !equal_transitive
            <2>z qed by step <2>1
                        property !equal_symmetric
                        definition of !order_inf
       <1>2 qed.
     ;

(*
     proof:
       (* [rr]: Wow! I couldn't guess this until I performed the latter *)
       (* forget it if you have a small computer ! *)
       by property
            !inf_commutes, !inf_absorbes_sup, !sup_right_substitution_rule,
            !equal_symmetric, !equal_transitive
          definition of !order_inf, !order_sup
     ;
*)

end
;;

(** Modular lattices *)
species modular_lattice inherits lattice =

(** a generalization of ditributivity  *)
property modular_law: all x y z in self,
  !order_inf(x, y) -> !equal(!inf(!sup(x, y), !sup(x, z)),
			    !inf(y, !sup(!inf(x, y), z)));

end
;;

-- The doc ``Every distribute lattice is modular'' was
-- just before the inherits keyword: need to insert it into the species
-- documentation instead.

(** Distributive lattices
    Every distribute lattice is modular.
 *)
species distributive_lattice
  
  inherits lattice,
            modular_lattice =
  property sup_left_distributes : all x y z in self,
    !equal(!sup(x, !inf(y, z)), !inf(!sup(x, y), !sup(x, z)));

  theorem sup_right_distributes : all x y z in self,
    !equal(!sup(!inf(x, y), z), !inf(!sup(x, z), !sup(y, z)))
    proof: 
      (* [rr]: Wow my second proof *)
      <1>1 assume x in self,
           assume y in self,
           assume z in self,
           prove      !equal(!sup(!inf(x, y), z), !inf(!sup(x, z), !sup(y, z)))
           <2>1 prove !equal(!sup(z, !inf(x, y)), !inf(!sup(z, x), !sup(z, y)))
                by property !sup_left_distributes
           <2>2 prove !equal(!sup(!inf(x, y), z), !sup(z, !inf(x, y))) 
                by property !sup_commutes 
           <2>3 prove !equal(!sup(x, z), !sup(z, x)) by property !sup_commutes
           <2>4 prove !equal(!sup(y, z), !sup(z, y)) by property !sup_commutes
           <2>5 prove !equal(!inf(!sup(x, z), !sup(y, z)), 
                             !inf(!sup(z, x), !sup(y, z))) 
                by step <2>3
                   property !inf_left_substitution_rule
           <2>6 prove !equal(!inf(!sup(z, x), !sup(y, z)), 
                             !inf(!sup(z, x), !sup(z, y))) 
                by step <2>4
                   property !inf_right_substitution_rule
           <2>7 prove !equal(!inf(!sup(x, z), !sup(y, z)), 
                             !inf(!sup(z, x), !sup(z, y)))
                by step <2>5, <2>6
                   property !equal_transitive
           <2>9 qed by step <2>1, <2>2, <2>7
                       property !equal_transitive, !equal_symmetric

      <1>2 qed.
    ;

  property inf_left_distributes : all x y z in self, 
    !equal(!inf(x, !sup(y, z)), !sup(!inf(x, y), !inf(x, z)));
  theorem inf_right_distributes : all x y z in self, 
    !equal(!inf(!sup(x, y), z), !sup(!inf(x, z), !inf(y, z)))
    proof:
      (* [rr]: see sup_right_distributes above *)
      (* should be easy but still fails on time limit !
       by !inf_left_distributes, !inf_commutes, 
          !sup_left_substitution_rule, !sup_right_substitution_rule, 
          !equal_transitive, !equal_symmetric;
       *)
-- ??? What is this decl stuff ???
--      decl: inf_left_distributes inf_commutes
--            sup_left_substitution_rule sup_right_substitution_rule
--            equal_transitive equal_symmetric;
      assumed;

  (** a distributive lattice is always modular *)
  (* [rr]: shouldn't this be simplified ? *)
  proof of modular_law =
    <1>1 assume x in self,
         assume y in self,
         assume z in self,
         assume H: !order_inf(x, y),
         prove !equal(!inf(y, !sup(!inf(x, y), z)),
		      !sup(x, !inf(y, z)))
         <2>0 prove !equal(x, !inf(x, y))
              by step <1>1 definition of !order_inf
         <2>1 prove !equal(!inf(y, !sup(!inf(x, y), z)), 
			   !sup(!inf(y, !inf(x, y)), !inf(y, z)))
              by property !inf_left_distributes
         <2>2 prove !equal(!inf(y, !inf(x, y)), !inf(y, x))
	      by step <2>0
                 property !inf_right_substitution_rule, !equal_symmetric
         <2>3 prove !equal(!sup(!inf(y, !inf(x, y)), !inf(y, z)), 
			   !sup(!inf(y, x), !inf(y, z)))
              by step <2>2
                 property !sup_left_substitution_rule
         <2>4 prove !equal(!sup(!inf(y, x), !inf(y, z)), 
			   !sup(x, !inf(y, z)))
              <3>0 prove !equal(!inf(y, x), x)
                   by step <2>0
                      property !inf_commutes,
                               !equal_symmetric, !equal_transitive
              <3>2 qed by step <3>0
                          property !sup_left_substitution_rule
         <2>f qed by step <2>1, <2>3, <2>4 property !equal_transitive
    <1>2 qed by
           step <1>1
           property !sup_left_distributes, !equal_transitive, !equal_symmetric
  ;

end
;;

(** 
A meet semi lattice with an upper bound as neutral element for infimum.
That is a meet semi lattice with a monoid structure.
*)
species meet_semi_lattice_with_max inherits meet_semi_lattice =
  sig max : self;
  property max_is_right_neutral: all x in self, 
    !equal(!inf(x, !max), x);
  theorem max_is_left_neutral: all x in self, 
    !equal(!inf(!max, x), x)
    proof:
    by property !max_is_right_neutral, !inf_commutes, !equal_transitive
    ;
  let is_max(x) = !equal(x, !max);
end
;;

(**
A meet semi lattice with a lower bound.
That is a meet semi lattice with an absorbant element
*)
species meet_semi_lattice_with_min inherits meet_semi_lattice =
  sig min : self;
  property min_right_absorbes: all x in self, 
    !equal(!inf(x, !min), !min);
  theorem min_left_absorbes: all x in self, 
    !equal(!inf(!min, x), !min)
    proof:
    by property !min_right_absorbes, !inf_commutes, !equal_transitive
    ;

end
;;

(**
A join semi lattice with a lower bound as neutral element for supremum.
That is a join semi lattice with a monoid structure.
*)
species join_semi_lattice_with_min inherits join_semi_lattice =
  sig min : self;
  property min_is_right_neutral: all x in self,
    !equal(!sup(x, !min), x);
  theorem min_is_left_neutral: all x in self, 
    !equal(!sup(!min, x), x)
    proof:
      by property !min_is_right_neutral, !sup_commutes, !equal_transitive
  ;

  let is_min(x) = self!equal(x, self!min)
  ;

end
;;

(**
A join semi lattice with an upper bound.
That is a join semi lattice with an absorbant element
*)
species join_semi_lattice_with_max inherits join_semi_lattice =
  sig max : self;
  property max_right_absorbes: all x in self, 
    !equal(!sup(x, !max), !max);
  theorem max_left_absorbes: all x in self, 
    !equal(!sup(!max, x), !max)
    proof:
    by property !max_right_absorbes, !sup_commutes, !equal_transitive
    ;

end
;;

(** These are commonly named lattices *)
species bounded_lattice 
  inherits lattice, 
           meet_semi_lattice_with_min, 
           meet_semi_lattice_with_max, 
           join_semi_lattice_with_min, 
           join_semi_lattice_with_max =

  (** absorption laws enable to prove that being absorbant for one law 
      is being neutral for the other *)
  proof of max_right_absorbes =
    <1>1 assume x in self ,
         prove !equal(!sup(x, !max), !max)
         <2>1 prove !equal(!max, !inf(!max, !sup(!max, x)))
              by property !sup_absorbes_inf
         <2>2 prove !equal(!inf(!max, !sup(!max, x)), !sup(!max, x))
              by property !max_is_left_neutral
         <2>3 prove !equal(!max, !sup(!max, x))
              by step <2>1, <2>2
                 property !equal_transitive
         <2>f qed
            by step <2>3
               property !sup_commutes, !equal_symmetric, !equal_transitive
    <1>2 qed.
   ;
  (** absorption laws enable to prove that being absorbant for one law 
      is being neutral for the other *)
  proof of min_right_absorbes =
-- ???
--    decl: min_is_left_neutral 
--         inf_absorbes_sup
--         inf_commutes
--         equal_reflexive equal_transitive;
    assumed
    (* [rr]: fails on size limit !
       Should be the same than max_right_absorbes which looks trivial.
       Did I forgot something ?
    by !min_is_left_neutral, 
       !inf_absorbes_sup, 
       !inf_commutes, 
       !equal_reflexive, !equal_transitive
    *)
  ;
end
;;

(** An ordering is total whenever two elements are always comparable *)
species ordered_set inherits partial_order =

  property total_order: all x y in self, self!leq(x, y) or self!leq(y, x);

  let equal(x, y) = #and_b(self!leq(x, y), self!leq(y, x));
  
  proof of equal_reflexive = 
    by property !total_order
       definition of !equal
  ;

  proof of equal_symmetric = 
    by definition of !equal
  ;

  proof of equal_transitive = 
    by property !leq_transitive definition of !equal
  ;

  let lt(x, y) = #not_b(self!leq(y, x));
  proof of lt_is_not_leq =
    by property !total_order
       definition of !lt, !different, !equal;

end
;;

(**
   Sometimes it is convenient to define lattices from partial ordering
*)
species partially_ordered_set_as_meet_semi_lattice
  inherits meet_semi_lattice, 
           (* partial ordering takes precedence *)
           partial_order =

  (** we define lattice ordering from normal ordering *)
  let order_inf(x, y) = !leq(x, y);

  proof of order_inf_is_reflexive =
    by property !leq_reflexive
       definition of !order_inf;

  proof of order_inf_is_antisymmetric =
    by property !leq_antisymmetric
    definition of !order_inf;

  proof of order_inf_is_transitive =
    by property !leq_transitive
       definition of !order_inf;

  property inf_is_smaller: all x y in self, 
    !leq(!inf(x, y), x) and !leq(!inf(x, y), y) ;

  property leq_defines_infimum: all x y i in self, 
    !leq(i, x) -> !leq(i, y) -> !leq(i, !inf(x, y));

  proof of order_inf_is_infimum =
    by property !leq_defines_infimum
       definition of !order_inf
  ;

  proof of inf_idempotent =
    <1>1 assume x in self,
         assume y in self,
         assume H: !equal(x, y),
         prove !equal(x, !inf(x, y))
         <2>1 prove !leq(x, y) by hypothesis H property !leq_reflexive
         <2>2 prove !leq(x, x) by property !leq_reflexive, !equal_reflexive
         <2>3 prove !leq(x, !inf(x, y))
              by step <2>2, <2>1 property !leq_defines_infimum
         <2>4 prove !leq(!inf(x, y), x) by property !inf_is_smaller
         <2>f qed by step <2>4, <2>3 property !leq_antisymmetric
    <1>f qed.
  ;

  (** details left as exercice for the reader *)
  proof of inf_commutes =
    by property !leq_defines_infimum, !leq_antisymmetric, !inf_is_smaller
  ;

  (** associativity is always tricky *)
  proof of inf_is_associative =
    <1>1 assume x in self,
         assume y in self,
         assume z in self,
         prove !equal(!inf(x, !inf(y, z)), !inf(!inf(x, y), z))
         <2>1 prove !leq(!inf(!inf(x, y), z), !inf(x, !inf(y, z)))
              <3>1 prove !leq(!inf(!inf(x, y), z), x)
                   by property !inf_is_smaller, !leq_transitive
              <3>2 prove !leq(!inf(!inf(x, y), z), !inf(y, z))
                   <4>1 prove !leq(!inf(!inf(x, y), z), y)
                        by property !inf_is_smaller, !leq_transitive
                   <4>2 prove !leq(!inf(!inf(x, y), z), z)
                        by property !inf_is_smaller
                   <4>f qed by step <4>1, <4>2 property !leq_defines_infimum
              <3>f qed by step <3>1, <3>2 property !leq_defines_infimum
         <2>2 prove !leq(!inf(x, !inf(y, z)), !inf(!inf(x, y), z))
              (* [rr]: this is the same as <2>1, should work ?*)
              (* by !inf_is_smaller, !leq_transitive, !leq_defines_infimum *)
              assumed
         <2>f qed by step <2>1, <2>2 property !leq_antisymmetric
    <1>f qed by step <1>1 property !equal_symmetric
  ;

end
;;

species partially_ordered_set_as_join_semi_lattice
  inherits join_semi_lattice, 
           (* partial ordering takes precedence *)
           partial_order =

  (** we define lattice ordering from normal ordering *)
  let order_sup(x, y) = !geq(x, y);

  proof of order_sup_is_reflexive =
    by property !geq_reflexive
       definition of !order_sup;

  proof of order_sup_is_antisymmetric =
    by property !geq_antisymmetric definition of !order_sup;

  proof of order_sup_is_transitive =
    by property !geq_transitive definition of !order_sup;

  (**  a supremum should be bigger than its arguments *)
  property sup_is_bigger: all x y in self, 
    !geq(!sup(x, y), x) and !geq(!sup(x, y), y)  ;

  (** Anything bigger than a supremum is bigger than the supremum  *)
  property geq_defines_supremum: all x y s in self, 
    !geq(s, x) -> !geq(s, y) -> !geq(s, !sup(x, y));

  (**  We relate to lattice notions *)
  proof of order_sup_is_supremum =
    by property !geq_defines_supremum definition of !order_sup;

  proof of sup_idempotent =
    <1>1 assume x in self,
         assume y in self,
         assume H: !equal(x, y),
         prove !equal(x, !sup(x, y))
         <2>1 prove !geq(x, y)
                by hypothesis H property !geq_reflexive
         <2>2 prove !geq(x, x)
                by property !geq_reflexive, !equal_reflexive
         <2>3 prove !geq(x, !sup(x, y))
                by step <2>2, <2>1 property !geq_defines_supremum
         <2>4 prove !geq(!sup(x, y), x)
                by property !sup_is_bigger
         <2>f qed
            by step <2>4, <2>3 property !geq_antisymmetric
    <1>f qed.
  ;

  (** details left as exercice for the reader *)
  proof of sup_commutes =
    by property !geq_defines_supremum, !geq_antisymmetric, !sup_is_bigger
  ;

  (** associativity is always tricky *)
  proof of sup_is_associative =
    <1>1 assume x in self,
         assume y in self,
         assume z in self,
         prove !equal(!sup(x, !sup(y, z)), !sup(!sup(x, y), z))
         <2>1 prove !geq(!sup(!sup(x, y), z), !sup(x, !sup(y, z)))
              <3>1 prove !geq(!sup(!sup(x, y), z), x)
                   by property !sup_is_bigger, !geq_transitive
              <3>2 prove !geq(!sup(!sup(x, y), z), !sup(y, z))
                   <4>1 prove !geq(!sup(!sup(x, y), z), y)
                        by property !sup_is_bigger, !geq_transitive
                   <4>2 prove !geq(!sup(!sup(x, y), z), z)
                        by property !sup_is_bigger
                   <4>f qed by step <4>1, <4>2 property !geq_defines_supremum
              <3>f qed by step <3>1, <3>2 property !geq_defines_supremum
         <2>2 prove !geq(!sup(x, !sup(y, z)), !sup(!sup(x, y), z))
              (* [rr]: this is the same as <2>1, should work ?*)
              (* by !sup_is_bigger, !geq_transitive, !geq_defines_supremum *)
              assumed
         <2>f qed by step <2>1, <2>2 property !geq_antisymmetric
    <1>f qed by step <1>1 property !equal_symmetric
  ;

end
;;

species partially_ordered_set_as_lattice
  inherits lattice, 
           partially_ordered_set_as_meet_semi_lattice, 
           partially_ordered_set_as_join_semi_lattice =

  proof of order_inf_refines_order_sup =
    by definition of !order_inf, !order_sup, !geq
  ;

  proof of order_sup_refines_order_inf =
    by definition of !order_inf, !order_sup, !geq
  ;

  proof of sup_absorbes_inf =
    <1>1 assume x in self,
         assume y in self,
         prove !equal(!inf(x, !sup(x, y)), x)
         <2>1 prove !leq(!inf(x, !sup(x, y)), x)
              by property !inf_is_smaller
         <2>2 prove !leq(x, !inf(x, !sup(x, y))) 
              <3>1 prove !leq(x, !sup(x, y))
                   by property !sup_is_bigger
                      definition of !geq
              <3>f qed
                   by step <3>1
                      property !leq_reflexive, !leq_defines_infimum,
                               !equal_reflexive
         <2>f qed
            by step <2>1, <2>2 property !leq_antisymmetric
    <1>f qed
       by step <1>1 property !equal_symmetric
  ;

  proof of inf_absorbes_sup =
    (* [rr]: damned prover this should work !
    by !inf_is_smaller, !sup_is_bigger, !geq_reflexive, !equal_reflexive, 
       !geq_defines_supremum def !geq ;
     *)
    <1>1 assume x in self,
         assume y in self,
         prove !equal(!sup(x, !inf(x, y)), x)
         <2>1 prove !geq(!sup(x, !inf(x, y)), x)
              by property !sup_is_bigger
         <2>2 prove !geq(x, !sup(x, !inf(x, y)))
              <3>1 prove !geq(x, !inf(x, y))
                   by property !inf_is_smaller
                      definition of !geq
              <3>f qed
                 by step <3>1
                    property !geq_reflexive, !geq_defines_supremum,
                             !equal_reflexive
         <2>f qed
            by step <2>1, <2>2
               property !geq_antisymmetric
    <1>f qed
       by step <1>1
          property !equal_symmetric
  ;

end
;;

(**
   Ordered meet semi lattices have a complete ordering which refines that 
   of the semi lattice structure.
 *)
species ordered_meet_semi_lattice inherits meet_semi_lattice, ordered_set =

  property leq_refines_order_inf : all x y in self, 
    !order_inf(x, y) -> !leq(x, y);

end
;;

(**
 We view an ordered set as a meet semi lattice
*)
species ordered_set_as_meet_semi_lattice
  inherits ordered_meet_semi_lattice =

  let inf(x, y) = if !leq(x, y) then x else y ;

  proof of leq_refines_order_inf =
   by property !leq_reflexive
      definition of !inf, !order_inf
  ;

  proof of inf_left_substitution_rule = 
    by property !equal_reflexive, !equal_symmetric, 
                !leq_reflexive, !leq_transitive
       definition of !inf
  ;

  proof of inf_idempotent =
    by property !equal_reflexive
       definition of !inf
  ;

  proof of inf_is_associative = 
    by property !equal_reflexive, !leq_transitive, !total_order
       definition of !inf
  ;

  theorem order_inf_refines_leq: all x y in self, 
    !leq(x, y) -> !order_inf(x, y)
    proof:
      by property !total_order, !total_order, !leq_antisymmetric
         definition of !inf, !order_inf
  ;

  proof of inf_commutes = 
   <1>1 assume x in self,
        assume y in self,
        prove !equal(!inf(x, y), !inf(y, x))
        <2>1 assume Hxy: !leq(x, y),
             prove !equal(!inf(x, y), !inf(y, x))
             <3>1 prove !equal(x, !inf(x, y)) 
                  by hypothesis Hxy
                     property !equal_reflexive
                     definition of !inf
             <3>2 prove !equal(x, !inf(y, x))
                  <4>1 assume Hyx: !leq(y, x),
                       prove !equal(x, !inf(y, x))
                       <5>1 prove !equal(x, y) 
                            by hypothesis Hxy, Hyx
                               property !leq_antisymmetric
                        <5>2 prove !equal(y, !inf(y, x))
                             by hypothesis Hyx
                                property !equal_reflexive
                                definition of !inf
                        <5>f qed 
                             by step <5>1, <5>2
                                property !equal_transitive
                  <4>2 assume H: not(!leq(y, x)),
                        prove !equal(x, !inf(y, x))
                        by hypothesis H
                           property !equal_reflexive
                           definition of !inf
                  <4>f qed by step <4>1, <4>2
             <3>f qed
                by step <3>1, <3>2
                   property !equal_symmetric, !equal_transitive
        <2>2 assume Hyx: !leq(y, x),
             prove !equal(!inf(x, y), !inf(y, x))
             (* [rr]: could do as <2>1 above, but zenon is wiser *)
             by hypothesis Hyx
                property !equal_reflexive, !leq_antisymmetric
                definition of !inf
        <2>f qed
           by step <2>1, <2>2
              property !total_order
   <1>2 qed.
  ;

end
;;


(**
   Ordered join semi lattices have a complete ordering which refines that 
   of the join semi lattice structure.
 *)
species ordered_join_semi_lattice inherits join_semi_lattice, ordered_set =

  property geq_refines_order_sup : all x y in self, 
    !order_sup(x, y) -> !geq(x, y)
  ;

end
;;

(**
 We view an ordered set as a join semi lattice
*)

species ordered_set_as_join_semi_lattice inherits ordered_join_semi_lattice =

  let sup(x, y) = if !geq(x, y) then x else y ;

  proof of sup_idempotent = 
    by property !equal_reflexive
       definition of !sup
  ;

  proof of geq_refines_order_sup =
    by property !geq_reflexive
       definition of !sup, !order_sup
  ;

  proof of sup_commutes = 
    by property !equal_reflexive, !leq_antisymmetric, !total_order
       definition of !sup, !geq
  ;

  proof of sup_is_associative = 
    by property !equal_reflexive, !leq_transitive, !total_order
       definition of !sup, !geq
  ;

  proof of sup_left_substitution_rule = 
    by property !equal_reflexive, !equal_symmetric, 
       !leq_reflexive, !leq_transitive
       definition of !sup, !geq
  ;

end
;;

(** here we complete the partial ordering of the lattice *)
species ordered_lattice
  inherits ordered_meet_semi_lattice, 
           ordered_join_semi_lattice, 
           lattice =

end
;;

(** a toitally ordered set may be viewed as a lattice *)
species ordered_set_as_lattice
  inherits ordered_set_as_meet_semi_lattice, 
           ordered_set_as_join_semi_lattice, 
           ordered_lattice =
  
  (** absorption laws are a mess !*)
  proof of sup_absorbes_inf =
    <1>1 assume x in self,
         assume y in self,
         prove !equal(x, !inf(x, !sup(x, y)))
         <2>1 assume H: !leq(x, y),
              prove !equal(x, !inf(x, !sup(x, y)))
              <3>1 prove !equal(y, !sup(x, y))
                   <4>1 prove !geq(y, x)
                        by hypothesis H
                           definition of !geq
                   <4>2 prove !equal(!sup(y, x), y)
		        by step <4>1
                           property !equal_reflexive
                           definition of !sup
                   <4>f qed
                      by step <4>2
                         property !sup_commutes, 
		                  !equal_symmetric, !equal_transitive
              <3>2 prove !equal(x, !inf(x, y))
                   by hypothesis H
                      property !equal_reflexive
                      definition of !inf
              <3>3 prove !equal(!inf(x, !sup(x, y)), 
				!inf(x, y))
(* [rr]: loops?    by step <3>1 property !inf_substitution_rule, !equal_symmetric *)
		   by step <3>1
                      property !inf_right_substitution_rule, !equal_symmetric
              <3>f qed
                 by step <3>3, <3>2
                    property !equal_symmetric, !equal_transitive
         <2>2 assume H: !leq(y, x),
              prove !equal(x, !inf(x, !sup(x, y)))
              <3>1 prove !geq(x, y)
                   by hypothesis H
                      definition of !geq
              <3>2 prove !equal(x, !sup(x, y))
                   by step <3>1
                      property !equal_reflexive
                      definition of !sup
              <3>3 prove !equal(!inf(x, !sup(x, y)), 
				!inf(x, x))
		   by step <3>2
                      property !inf_right_substitution_rule, !equal_symmetric
              <3>f qed
                 by step <3>2, <3>3
                    property !inf_idempotent,
                             !equal_symmetric, !equal_transitive
         <2>f qed
            by step <2>1, <2>2
               property !total_order
    <1>f qed.

   ;

   (* [rr]: see above *)
   proof of inf_absorbes_sup = assumed;

end
;;


