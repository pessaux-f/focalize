(**
 @title FoC Project. Basic algebra.
 @author The FoC project

Basic sets operations, orderings and lattices.
*)

uses "../../../basics";;
open "../basics";;

(** In a setoid, we can test the equality (note for logicians: this is
   a congruence). The setoid can not be empty. *)
species setoid inherits basic_object =

  (** @mathml <eq/> *)
  sig equal : self -> self -> bool

  property equal_reflexive = all x y in self,
    !equal (x, x)

  property equal_symmetric = all x y in self,
    !equal(x, y) -> !equal(y, x)

  property equal_transitive = all x y z in self,
    !equal(x, y) -> !equal(y, z) -> !equal(x, z)

  (** element returns some element of our non empty setoid *)
  sig element : self

  (** @mathml <neq/> *)
  let different (x, y) = basics#not_b(!equal(x, y))

  theorem same_is_not_different : all x y in self,
     !different(x, y) <-> (not ( !equal(x, y)) )
%%  proof:
%%    DEF !different
%%  ;



(*   theorem same_is_not_different : all x y in self,  *)
(*      !equal(x,y) -> not(!different(x,y))  *)
(*   proof:  *)
(*     DEF !different *)
(*   ; *)

(*   theorem different_is_not_same : all x y in self,  *)
(*      !different(x,y) -> not(!equal(x,y))  *)
(*   proof:  *)
(*     DEF !different *)
(*   ; *)


end

(**
  This is a first attempt to specify representations.
  We define two functions and two properties relating 
  concrete values of rep and abstract values of self
*)
species represented_by(s is basic_object)

inherits setoid =

  rep = s;

  (** an element of self is encoded by an element of s *)
  let to_rep (x in self) in s = x;

  (** One should be able to describe which values of s
     correspond to some abstract self
   *)
  sig represents_some_self in s -> Prop;

  (** A way to abstract concrete values,
     not intended to be used by the programmer
   *)
  sig from_rep in s -> self;

  (** This property enables to state theorems about abstract self *)
  letprop correct_representation(x) =
    !represents_some_self(!to_rep(x))
    ;

  theorem correct_rep_spec: all x in self,
     !correct_representation(x) <-> !represents_some_self(!to_rep(x))
     proof: by def !correct_representation
  ;

  (** combining to_rep and from_rep gives identity *)
  property to_rep_reverses: all x in self, !equal(!from_rep(!to_rep(x)), x);

  (** since we provide an injection to s from_rep is a surjection *)
  theorem from_rep_is_surjective: all x in self, ex y in s,
    !equal(!from_rep(y),x)
  proof: 
   <1>1 assume x in self
        prove !equal(!from_rep(x),x)
        by !to_rep_reverses def !to_rep
   <1>f qed
  ;

  (** every element of self should verify an invariant *)
  property correct_invariant: all x in self, !correct_representation(x);

  (** by default we print the concrete data *)
  let print(x) = s!print(!to_rep(x));
  (** by default we parse concrete data and abstract it*)
  let parse(p) = !from_rep(s!parse(p));

end

(** 
   Here we state that in some cases we may view partial operations
   as total operations.
   This requires to include some form of predicate for failing operations.

 *)
species partial_set inherits setoid =

  (** this is intended to model failure*)
  let failed in (string -> self) =
    let ifailed( r in string, elt in self) in self =
       caml i_failed with coqdef i_failed
    in fun reason -> ifailed(reason, !element);

end

(** pre orderings are sometimes called quasi orderings *)
species pre_order inherits setoid =
  (** leq(x,y) is x &le; y *)
  (** @mathml <leq/> *)
  sig leq in self->self->bool;

  property leq_reflexive: all x y in self,
    !equal(x,y) -> !leq(x,y);
  property leq_transitive: all x y  z in self,
    !leq(x,y) -> !leq(y,z) -> !leq(x,z) ;

   (** we may reverse inequalities by simply changing notations
    @mathml <geq/> *)
  let geq(x,y)= !leq(y,x);

  (** a characteristic property *)
  theorem geq_is_leq: all x y in self,
    (!geq(x,y) -> !leq(y,x)) and  (!leq(x,y) -> !geq(y,x))
    proof: 
      def !geq
  ;

  theorem geq_reflexive: all x y in self, !equal(x,y) -> !geq(x,y)
  proof: by !leq_reflexive, !equal_symmetric, !geq_is_leq;

  theorem geq_transitive: all x y z in self,
    !geq(x,y) -> !geq(y,z) -> !geq(x,z)
    proof: by !leq_transitive, !geq_is_leq;


  (** strict inequality
     @mathml <lt/> *)
  let lt(x,y) = basics#and_b(!leq(x,y),basics#not_b(!equal(x,y)));

  (** some results about strict and large inequalities *)
  theorem lt_is_not_leq : all x y in self,
    ((!lt(x,y) -> (!leq(x,y) and !different(x,y)))
  and
     (!leq(x,y) -> (!lt(x,y) or !equal(x,y))))
    proof: 
      def !lt, !different
      ;



(** @mathml <gt/> *)
let gt(x,y)= !lt(y,x);

theorem gt_is_lt: all x y in self,
  (!gt(x,y) -> (!geq(x,y) and !different(x,y)))
    and
  (!geq(x,y) -> (!gt(x,y) or !equal(x,y)))
  proof:
    by !lt_is_not_leq, !equal_symmetric
    def !gt, !geq, !different
  ;

end

(** In a set an ordering is often called a partial order *)
species partial_order inherits pre_order =
  property leq_antisymmetric:  all x y in self,
    !leq(x,y) -> !leq(y,x) -> !equal(x,y) ;


  theorem geq_antisymmetric: all x y in self,
    !geq(x,y) -> !geq(y,x) -> !equal(x,y)
    proof: by !leq_antisymmetric, !geq_is_leq;

end

(** in a meet semi lattice we have an operation inducing an ordering (&lt;=)*)
species meet_semi_lattice inherits setoid =
  (** the infimum of two elements *)
  (* [rr]: need a mathml symbol for that, 
     we don't want to use <min/> nor <intersect/>
  *)
  sig inf in self -> self -> self ;
  (** compatibility with equality *)
  property inf_left_substitution_rule : all x y z in self,
    !equal (x, y) -> !equal (!inf (x, z), !inf (y, z))
  ;
  (** inf is a commutative law*)
  property inf_commutes : all x y in self,
    !equal(!inf(x,y), !inf(y,x));
  (** 
     for a  commutative law right congruence is a consequence 
      of left congruence
   *)
  theorem inf_right_substitution_rule : all x y z in self,
     !equal(y,z) -> !equal(!inf(x,y),!inf(x,z))
     proof: 
       by !inf_left_substitution_rule ,
          !inf_commutes, 
          (*!equal_reflexive,*)
          !equal_transitive
     ;
  (** users should use global congruence when possible *)
  theorem inf_substitution_rule: all x y z t in self,
    !equal(x,y) -> !equal(z,t) -> !equal(!inf(x,z),!inf(y,t))
(*    !equal(x,y) -> !equal(y,t) -> !equal(!inf(x,y),!inf(y,t)) *)
    proof:
      by !inf_left_substitution_rule, !inf_right_substitution_rule,
         (* [rr]: if not given reflexivity Zenon fails *)
         (* [dd]: now it works *)
         !equal_transitive(*, !equal_reflexive*)
    ;
  (* inf is an associative law *)
  property inf_is_associative : all x y z in self,
    !equal(!inf(!inf(x,y),z), !inf(x, !inf(y, z)));
  (* inf is an idempotent law  *)
  property inf_idempotent : all x y in self,
    !equal(x,y) -> !equal(x,!inf(x,y));

  (** order_inf is the least defined ordering compatible with inf *)
  (* [rr]: need a mathml symbol for that, 
     we don't want to use <leq/>
  *)
  let order_inf(x,y) = !equal(x, !inf(x, y));
  theorem order_inf_is_reflexive : all x y in self,
     !equal(x,y) -> !order_inf(x,y)
     proof : 
       BY !inf_idempotent DEF !order_inf
     ;

  theorem order_inf_is_antisymmetric : all x y in self,
     !order_inf(x,y) -> !order_inf(y,x) -> !equal(x,y)
     (* x=inf(x,y) et y=inf(x,y) *)
     proof:
       BY !inf_commutes, !equal_transitive, !equal_symmetric DEF !order_inf
     ;
  theorem order_inf_is_transitive : all x y z in self,
     !order_inf(x,y) -> !order_inf(y,z) -> !order_inf(x,z)
     (* x=inf(x,y) et y=inf(y,z) x=inf(x,inf(y,z))=inf(inf(x,y),z)=inf(x,z)*)
     proof:
       <1>1 assume x y z in self
                   H1: !order_inf (x, y)
                   H2: !order_inf (y, z)
            prove !order_inf (x, z)
         <2>0 prove !equal (x, !inf (x, y))
           BY <1>:H1   DEF !order_inf
         <2>1 prove !equal (x, !inf (x, !inf (y, z)))
           by <2>0, <1>:H2, 
              !inf_right_substitution_rule, 
              !equal_transitive
           def !order_inf
         <2>2 prove !equal (x, !inf (!inf (x, y), z))
           by <2>1, !inf_is_associative, !equal_transitive, !equal_symmetric
         <2>3 prove !equal (x, !inf (x, z))
           by <2>2, <2>0,
	      !equal_symmetric, !equal_transitive,
	      !inf_left_substitution_rule
         <2>4 qed
           by <2>3 BY DEF !order_inf
       <1>2 qed
     ;
  (** any element smaller than x and y is smaller than their infimum *)
  theorem order_inf_is_infimum: all x y i in self,
    !order_inf(i,x) -> !order_inf(i,y) ->
      !order_inf(i,!inf(x,y))
    proof:
      <1>1 assume x y i in self
                  H1: !order_inf(i,x)
                  H2: !order_inf(i,y)
           prove !order_inf(i, !inf(x,y))
        <2>1 prove !equal(i, !inf(!inf(i,x), y))
          by <1>:H1, <1>:H2, !inf_left_substitution_rule,
             !equal_symmetric, !equal_transitive
          def !order_inf
        <2>9 qed
          by <2>1, !inf_is_associative, !equal_transitive
          def !order_inf
      <1>2 qed
    ;

end

(** in a join semi lattice we have an operation inducing an ordering (&gt;=) *)
species join_semi_lattice inherits setoid =

  (** the supremum of two elements *)
  (* [rr]: need a mathml symbol for that, 
     we don't want to use <max/> nor <union/>
  *)
  sig sup in self -> self -> self ;
  (** compatibility with equality *)
  property sup_left_substitution_rule : all x y z in self,
    !equal (x, y) -> !equal (!sup (x, z), !sup (y, z))
  ;
  property sup_commutes : all x y in self,
    !equal(!sup(x,y), !sup(y,x));

  (** 
     for a  commutative law right congruence is a consequence 
      of left congruence
   *)
  theorem sup_right_substitution_rule : all x y z in self,
     !equal(y,z) -> !equal(!sup(x,y),!sup(x,z))
     proof: 
       by !sup_left_substitution_rule, !sup_commutes, !equal_transitive
     ;
  (** users should use global congruence when possible *)
  theorem sup_substitution_rule: all x y z t in self,
    !equal(x,y) -> !equal(z,t) -> !equal(!sup(x,z),!sup(y,t))
(*    !equal(x,y) -> !equal(y,t) -> !equal(!sup(x,y),!sup(y,t)) *)
    proof:
      by !sup_left_substitution_rule, !sup_right_substitution_rule,
         (* [rr]: if not given reflexivity Zenon fails *)
         !equal_transitive(*, !equal_reflexive*)
    ;
  (* sup is an associative law *)
  property sup_is_associative : all x y z in self,
    !equal(!sup(!sup(x,y),z), !sup(x, !sup(y, z)));
  (* sup is an idempotent law  *)
  property sup_idempotent : all x y in self,
    !equal(x,y) -> !equal(x,!sup(x,y));

  (** order_sup is the least defined ordering compatible with sup *)
  (* [rr]: need a mathml symbol for that, 
     we don't want to use <geq/>
  *)
  let order_sup(x,y) = !equal(x, !sup(x, y));

  theorem order_sup_is_reflexive : all x y in self,
     !equal(x,y) -> !order_sup(x,y)
     proof: by !sup_idempotent by def !order_sup;

  theorem order_sup_is_antisymmetric : all x y in self,
     !order_sup(x,y) -> !order_sup(y,x) -> !equal(x,y)
     proof: by !sup_commutes, !equal_symmetric, !equal_transitive
            def !order_sup
     ;

  theorem order_sup_is_transitive : all x y z in self,
     !order_sup(x,y) -> !order_sup(y,z) -> !order_sup(x,z)
     (* x=inf(x,y) et y=inf(y,z) x=inf(x,inf(y,z)=inf(inf(x,y),z)=inf(x,z)*)
     proof:
       <1>1 assume x y z in self
                   xLTy: !order_sup (x, y)
                   yLTz: !order_sup (y, z)
            prove !order_sup (x, z)
         <2>1 prove !equal (x, !sup (x, !sup (y, z)))
           by <1>:xLTy, <1>:yLTz, !sup_right_substitution_rule, !equal_transitive
           def !order_sup
         <2>2 prove !equal (x, !sup (!sup (x, y), z))
           by <2>1, !sup_is_associative, !equal_transitive, !equal_symmetric
         <2>9 qed
           by <2>2, <1>:xLTy, !equal_symmetric, !equal_transitive,
              !sup_left_substitution_rule
           def !order_sup
       <1>2 qed
     ;

  (** any element bigger than two elements is bigger than their supremum *)
  theorem order_sup_is_supremum: all x y i in self,
    !order_sup(i,x) -> !order_sup(i,y) ->
      !order_sup(i,!sup(x,y))
    proof:
      <1>1 assume x y i in self
                  H1: !order_sup(i,x)
                  H2: !order_sup(i,y)
           prove !order_sup(i, !sup(x,y))
        <2>1 prove !equal(i, !sup(!sup(i,x), y))
          by <1>:H1, <1>:H2, !sup_left_substitution_rule,
             !equal_symmetric, !equal_transitive
          def !order_sup
        <2>9 qed
          by <2>1, !sup_is_associative, !equal_transitive
          def !order_sup
      <1>2 qed
    ;

end

(** lattices have an inf and sup operation which induce a partial order *)

species lattice inherits meet_semi_lattice, join_semi_lattice = 

  (** the first absorbtion law *)
   property inf_absorbes_sup: all x y in self,
     !equal(x,!sup(x,!inf(x,y)));

   (** the second absorbtion law *)
   property sup_absorbes_inf: all x y in self,
     !equal(x,!inf(x,!sup(x,y)));


   (** in a lattice there is only one ordering *)
   theorem order_inf_refines_order_sup: all x y in self,
     !order_sup(y,x) -> !order_inf(x,y)
     proof:
       (* x = x v y ; x ^ y = x ^ (x v y) = x *) 
       <1>1 assume x y in self
                H: !order_sup(y,x)
            prove !order_inf(x,y)
            <2>1 prove !equal(!inf(x,y),x)
                 <3>1 prove !equal(y,!sup(x,y)) 
                      by <1>:H, !sup_commutes, !equal_transitive
                      def !order_sup
                 <3>2 prove !equal(!inf(x,!sup(x,y)),x)
                      by !sup_absorbes_inf, !equal_symmetric
                 <3>3 prove !equal(!inf(x,y),!inf(x,!sup(x,y)))
                      by <3>1, !inf_right_substitution_rule
                 <3>f qed by <3>3, <3>2,!equal_transitive 
            <2>z qed by <2>1, !equal_symmetric def !order_inf
       <1>2 qed 
     ;

   (** in a lattice there is only one ordering *)
   theorem order_sup_refines_order_inf: all x y in self,
     (* x = x ^ y ; x v y = (x ^ y) v x = x v (x ^ y) = x *) 
     !order_inf(y,x) -> !order_sup(x,y)
     proof:
       <1>1 assume x y in self
                   H: !order_inf (y, x)
            prove !order_sup (x, y)
         <2>1 prove !equal (!sup(x,y), !sup(x,!inf(x,y)))
           by <1>:H, !inf_commutes, !equal_transitive, !sup_right_substitution_rule
           def !order_inf
         <2>2 qed
           by <2>1, !equal_transitive, !equal_symmetric, !inf_absorbes_sup
           def !order_sup
       <1>2 qed
     ;
(*
     proof:
       (* [rr]: Wow! I couldn't guess this until I performed the latter *)
       (* forget it if you have a small computer ! *)
       by !inf_commutes, !inf_absorbes_sup, !sup_right_substitution_rule,
          !equal_symmetric, !equal_transitive
       def !order_inf, !order_sup
     ;
*)

end

(** Modular lattices *)
species modular_lattice inherits lattice =

(** a generalization of ditributivity  *)
property modular_law: all x y z in self,
  !order_inf(x,y) -> !equal(!inf(!sup(x,y),!sup(x,z)),
			    !inf(y,!sup(!inf(x,y),z)));

end

(** Distributive lattices *)
species distributive_lattice
  inherits lattice,
            (** every distribute lattice is modular *)
            modular_lattice =
  property sup_left_distributes : all x y z in self,
    !equal(!sup(x,!inf(y,z)), !inf(!sup(x,y), !sup(x,z)));

  theorem sup_right_distributes : all x y z in self,
    !equal(!sup(!inf(x,y),z), !inf(!sup(x,z), !sup(y,z)))
    proof: 
      (* [rr]: Wow my second proof *)
      <1>1 assume x y z in self
           prove      !equal(!sup(!inf(x,y),z), !inf(!sup(x,z),!sup(y,z)))
           <2>1 prove !equal(!sup(z, !inf(x,y)),!inf(!sup(z,x),!sup(z,y)))
                by !sup_left_distributes
           <2>2 prove !equal(!sup(!inf(x,y),z),!sup(z,!inf(x,y))) 
                by !sup_commutes 
           <2>3 prove !equal(!sup(x,z),!sup(z,x)) by !sup_commutes
           <2>4 prove !equal(!sup(y,z),!sup(z,y)) by !sup_commutes
           <2>5 prove !equal(!inf(!sup(x,z),!sup(y,z)),
                             !inf(!sup(z,x),!sup(y,z))) 
                by <2>3, !inf_left_substitution_rule
           <2>6 prove !equal(!inf(!sup(z,x),!sup(y,z)),
                             !inf(!sup(z,x),!sup(z,y))) 
                by <2>4, !inf_right_substitution_rule
           <2>7 prove !equal(!inf(!sup(x,z),!sup(y,z)),
                             !inf(!sup(z,x),!sup(z,y)))
                by <2>5, <2>6, !equal_transitive
           <2>9 qed by <2>1, <2>2, <2>7, !equal_transitive, !equal_symmetric

      <1>2 qed
    ;

  property inf_left_distributes : all x y z in self,
    !equal(!inf(x,!sup(y,z)), !sup(!inf(x,y), !inf(x,z)));
  theorem inf_right_distributes : all x y z in self,
    !equal(!inf(!sup(x,y),z), !sup(!inf(x,z), !inf(y,z)))
    proof:
      (* [rr]: see sup_right_distributes above *)
      (* should be easy but still fails on time limit !
       by !inf_left_distributes, !inf_commutes,
          !sup_left_substitution_rule, !sup_right_substitution_rule,
          !equal_transitive, !equal_symmetric;
       *)
      decl: inf_left_distributes inf_commutes
            sup_left_substitution_rule sup_right_substitution_rule
            equal_transitive equal_symmetric;
      assumed;

  (** a distributive lattice is always modular *)
  (* [rr]: shouldn't this be simplified ? *)
  proof of modular_law =
    <1>1 assume x y z in self
             H: !order_inf(x,y)
         prove !equal(!inf(y,!sup(!inf(x,y),z)),
		      !sup(x,!inf(y,z)))
         <2>0 prove !equal(x,!inf(x,y)) by <1>:H def !order_inf
         <2>1 prove !equal(!inf(y,!sup(!inf(x,y),z)),
			   !sup(!inf(y,!inf(x,y)),!inf(y,z)))
              by !inf_left_distributes
         <2>2 prove !equal(!inf(y,!inf(x,y)), !inf(y,x))
	      by <2>0, !inf_right_substitution_rule,
	         !equal_symmetric
         <2>3 prove !equal(!sup(!inf(y,!inf(x,y)),!inf(y,z)),
			   !sup(!inf(y,x),!inf(y,z)))
              by <2>2, !sup_left_substitution_rule
         <2>4 prove !equal(!sup(!inf(y,x),!inf(y,z)),
			   !sup(x,!inf(y,z)))
              <3>0 prove !equal(!inf(y,x),x)
                   by <2>0, !inf_commutes,
	              !equal_symmetric, !equal_transitive
              <3>2 qed by <3>0, !sup_left_substitution_rule
         <2>f qed by <2>1, <2>3, <2>4, !equal_transitive
    <1>2 qed by <1>1, !sup_left_distributes,
                !equal_transitive, !equal_symmetric
  ;

end

(** 
A meet semi lattice with an upper bound as neutral element for infimum.
That is a meet semi lattice with a monoid structure.
*)
species meet_semi_lattice_with_max inherits meet_semi_lattice =
  sig max in self;
  property max_is_right_neutral: all x in self,
    !equal(!inf(x,!max),x);
  theorem max_is_left_neutral: all x in self,
    !equal(!inf(!max,x),x)
    proof:
    by !max_is_right_neutral, !inf_commutes, !equal_transitive
    ;
  let is_max(x) = !equal(x,!max);
end

(**
A meet semi lattice with a lower bound.
That is a meet semi lattice with an absorbant element
*)
species meet_semi_lattice_with_min inherits meet_semi_lattice =
  sig min in self;
  property min_right_absorbes: all x in self,
    !equal(!inf(x,!min),!min);
  theorem min_left_absorbes: all x in self,
    !equal(!inf(!min,x),!min)
    proof:
    by !min_right_absorbes, !inf_commutes, !equal_transitive
    ;

end

(**
A join semi lattice with a lower bound as neutral element for supremum.
That is a join semi lattice with a monoid structure.
*)
species join_semi_lattice_with_min inherits join_semi_lattice =
  sig min in self;
  property min_is_right_neutral: all x in self,
    !equal(!sup(x,!min),x);
  theorem min_is_left_neutral: all x in self,
    !equal(!sup(!min,x),x)
    proof:
    by !min_is_right_neutral, !sup_commutes, !equal_transitive
  ;

  let is_min(x) = self!equal(x,self!min);
end

(**
A join semi lattice with an upper bound.
That is a join semi lattice with an absorbant element
*)
species join_semi_lattice_with_max inherits join_semi_lattice =
  sig max in self;
  property max_right_absorbes: all x in self,
    !equal(!sup(x,!max),!max);
  theorem max_left_absorbes: all x in self,
    !equal(!sup(!max,x),!max)
    proof:
    by !max_right_absorbes, !sup_commutes, !equal_transitive
    ;

end

(** These are comonly named lattices *)
species bounded_lattice 
  inherits lattice,
           meet_semi_lattice_with_min,
           meet_semi_lattice_with_max,
           join_semi_lattice_with_min,
           join_semi_lattice_with_max =

  (** absorption laws enable to prove that being absorbant for one law 
      is being neutral for the other *)
  proof of max_right_absorbes =
    <1>1 assume x in self 
         prove !equal(!sup(x,!max),!max)
         <2>1 prove !equal(!max,!inf(!max,!sup(!max,x)))
              by !sup_absorbes_inf
         <2>2 prove !equal(!inf(!max,!sup(!max,x)),!sup(!max,x))
              by !max_is_left_neutral
         <2>3 prove !equal(!max,!sup(!max,x))
              by <2>1, <2>2, !equal_transitive
         <2>f qed by <2>3, !sup_commutes, !equal_symmetric, !equal_transitive
    <1>2 qed;
  (** absorption laws enable to prove that being absorbant for one law 
      is being neutral for the other *)
  proof of min_right_absorbes =
    decl: min_is_left_neutral 
         inf_absorbes_sup
         inf_commutes
         equal_reflexive equal_transitive;
    assumed
    (* [rr]: fails on size limit !
       Should be the same than max_right_absorbes which looks trivial.
       Did I forgot something ?
    by !min_is_left_neutral,
       !inf_absorbes_sup,
       !inf_commutes,
       !equal_reflexive, !equal_transitive
    *)
  ;
end
(** An ordering is total whenever two elements are always comparable *)
species ordered_set inherits partial_order =

  property total_order: all x y in self, self!leq(x,y) or self!leq(y,x);

  let equal(x,y) = #and_b(self!leq(x,y),self!leq(y,x));
  
  proof of equal_reflexive = 
    by !total_order def !equal
  ;

  proof of equal_symmetric = 
    by def !equal
  ;

  proof of equal_transitive = 
    by !leq_transitive def !equal
  ;

  let lt(x,y) = #not_b(self!leq(y,x));
  proof of lt_is_not_leq = by !total_order def !lt, !different, !equal;

end

(**
   Sometimes it is convenient to define lattices from partial ordering
*)
species partially_ordered_set_as_meet_semi_lattice
  inherits meet_semi_lattice,
           (* partial ordering takes precedence *)
           partial_order =

  (** we define lattice ordering from normal ordering *)
  let order_inf(x,y) = !leq(x,y);

  proof of order_inf_is_reflexive = by !leq_reflexive def !order_inf;

  proof of order_inf_is_antisymmetric = by !leq_antisymmetric def !order_inf;

  proof of order_inf_is_transitive = by !leq_transitive def !order_inf;

  property inf_is_smaller: all x y in self,
    !leq(!inf(x,y),x) and !leq(!inf(x,y),y) ;

  property leq_defines_infimum: all x y i in self,
    !leq(i,x) -> !leq(i,y) -> !leq(i,!inf(x,y));

  proof of order_inf_is_infimum = by !leq_defines_infimum def !order_inf;

  proof of inf_idempotent =
    <1>1 assume x y in self
             H: !equal(x,y)
         prove !equal(x,!inf(x,y))
         <2>1 prove !leq(x,y) by <1>:H, !leq_reflexive
         <2>2 prove !leq(x,x) by !leq_reflexive, !equal_reflexive
         <2>3 prove !leq(x,!inf(x,y)) by <2>2, <2>1, !leq_defines_infimum
         <2>4 prove !leq(!inf(x,y),x) by !inf_is_smaller
         <2>f qed by <2>4, <2>3, !leq_antisymmetric
    <1>f qed;

  (** details left as exercice for the reader *)
  proof of inf_commutes =
    by !leq_defines_infimum, !leq_antisymmetric, !inf_is_smaller
    ;

  (** associativity is always tricky *)
  proof of inf_is_associative =
    <1>1 assume x y z in self
         prove !equal(!inf(x,!inf(y,z)),!inf(!inf(x,y),z))
         <2>1 prove !leq(!inf(!inf(x,y),z),!inf(x,!inf(y,z)))
              <3>1 prove !leq(!inf(!inf(x,y),z),x)
                   by !inf_is_smaller, !leq_transitive
              <3>2 prove !leq(!inf(!inf(x,y),z),!inf(y,z))
                   <4>1 prove !leq(!inf(!inf(x,y),z),y)
                        by !inf_is_smaller, !leq_transitive
                   <4>2 prove !leq(!inf(!inf(x,y),z),z)
                        by !inf_is_smaller
                   <4>f qed by <4>1, <4>2, !leq_defines_infimum
              <3>f qed by <3>1, <3>2, !leq_defines_infimum
         <2>2 prove !leq(!inf(x,!inf(y,z)),!inf(!inf(x,y),z))
              (* [rr]: this is the same as <2>1, should work ?*)
              (* by !inf_is_smaller, !leq_transitive, !leq_defines_infimum *)
              assumed
         <2>f qed by <2>1, <2>2, !leq_antisymmetric
    <1>f qed by <1>1, !equal_symmetric
    ;

end


species partially_ordered_set_as_join_semi_lattice
  inherits join_semi_lattice,
           (* partial ordering takes precedence *)
           partial_order =

  (** we define lattice ordering from normal ordering *)
  let order_sup(x,y) = !geq(x,y);

  proof of order_sup_is_reflexive = by !geq_reflexive def !order_sup;

  proof of order_sup_is_antisymmetric = by !geq_antisymmetric def !order_sup;

  proof of order_sup_is_transitive = by !geq_transitive def !order_sup;

  (**  a supremum should be bigger than its arguments *)
  property sup_is_bigger: all x y in self,
    !geq(!sup(x,y),x) and !geq(!sup(x,y),y)  ;

  (** Anything bigger than a supremum is bigger than the supremum  *)
  property geq_defines_supremum: all x y s in self,
    !geq(s,x) -> !geq(s,y) -> !geq(s,!sup(x,y));

  (**  We relate to lattice notions *)
  proof of order_sup_is_supremum = by !geq_defines_supremum def !order_sup;

  proof of sup_idempotent =
    <1>1 assume x y in self
             H: !equal(x,y)
         prove !equal(x,!sup(x,y))
         <2>1 prove !geq(x,y) by <1>:H, !geq_reflexive
         <2>2 prove !geq(x,x) by !geq_reflexive, !equal_reflexive
         <2>3 prove !geq(x,!sup(x,y)) by <2>2, <2>1, !geq_defines_supremum
         <2>4 prove !geq(!sup(x,y),x) by !sup_is_bigger
         <2>f qed by <2>4, <2>3, !geq_antisymmetric
    <1>f qed;


  (** details left as exercice for the reader *)
  proof of sup_commutes =
    by !geq_defines_supremum, !geq_antisymmetric, !sup_is_bigger
    ;

  (** associativity is always tricky *)
  proof of sup_is_associative =
    <1>1 assume x y z in self
         prove !equal(!sup(x,!sup(y,z)),!sup(!sup(x,y),z))
         <2>1 prove !geq(!sup(!sup(x,y),z),!sup(x,!sup(y,z)))
              <3>1 prove !geq(!sup(!sup(x,y),z),x)
                   by !sup_is_bigger, !geq_transitive
              <3>2 prove !geq(!sup(!sup(x,y),z),!sup(y,z))
                   <4>1 prove !geq(!sup(!sup(x,y),z),y)
                        by !sup_is_bigger, !geq_transitive
                   <4>2 prove !geq(!sup(!sup(x,y),z),z)
                        by !sup_is_bigger
                   <4>f qed by <4>1, <4>2, !geq_defines_supremum
              <3>f qed by <3>1, <3>2, !geq_defines_supremum
         <2>2 prove !geq(!sup(x,!sup(y,z)),!sup(!sup(x,y),z))
              (* [rr]: this is the same as <2>1, should work ?*)
              (* by !sup_is_bigger, !geq_transitive, !geq_defines_supremum *)
              assumed
         <2>f qed by <2>1, <2>2, !geq_antisymmetric
    <1>f qed by <1>1, !equal_symmetric
    ;


end

species partially_ordered_set_as_lattice
  inherits lattice,
           partially_ordered_set_as_meet_semi_lattice,
           partially_ordered_set_as_join_semi_lattice =

  proof of order_inf_refines_order_sup = by def !order_inf, !order_sup, !geq;

  proof of order_sup_refines_order_inf = by def !order_inf, !order_sup, !geq;

  proof of sup_absorbes_inf =
    <1>1 assume x y in self
         prove !equal(!inf(x,!sup(x,y)),x)
         <2>1 prove !leq(!inf(x,!sup(x,y)),x) by !inf_is_smaller
         <2>2 prove !leq(x,!inf(x,!sup(x,y))) 
              <3>1 prove !leq(x,!sup(x,y)) by !sup_is_bigger def !geq
              <3>f qed by
		   <3>1, !leq_reflexive,
		   !leq_defines_infimum, !equal_reflexive
         <2>f qed by <2>1, <2>2, !leq_antisymmetric
    <1>f qed by <1>1, !equal_symmetric;

  proof of inf_absorbes_sup =
    (* [rr]: damned prover this should work !
    by !inf_is_smaller, !sup_is_bigger, !geq_reflexive, !equal_reflexive,
       !geq_defines_supremum def !geq ;
     *)
    <1>1 assume x y in self
         prove !equal(!sup(x,!inf(x,y)),x)
         <2>1 prove !geq(!sup(x,!inf(x,y)),x) by !sup_is_bigger
         <2>2 prove !geq(x,!sup(x,!inf(x,y)))
              <3>1 prove !geq(x,!inf(x,y)) by !inf_is_smaller def !geq
              <3>f qed by <3>1, !geq_reflexive, !
                          geq_defines_supremum, !equal_reflexive
         <2>f qed by <2>1, <2>2, !geq_antisymmetric
    <1>f qed by <1>1, !equal_symmetric;


end


(**
   Ordered meet semi lattices have a complete ordering which refines that 
   of the semi lattice structure.
 *)
species ordered_meet_semi_lattice inherits meet_semi_lattice, ordered_set =

  property leq_refines_order_inf : all x y in self,
    !order_inf(x,y) -> !leq(x,y);

end

(**
 We view an ordered set as a meet semi lattice
*)

species ordered_set_as_meet_semi_lattice
  inherits ordered_meet_semi_lattice =

  let inf(x,y) = if !leq(x,y) then x else y ;

  proof of leq_refines_order_inf =
   by !leq_reflexive
      def !inf, !order_inf
   ;

  proof of inf_left_substitution_rule = 
    by !equal_reflexive, !equal_symmetric,
       !leq_reflexive, !leq_transitive
       def !inf
    ;

  proof of inf_idempotent = by !equal_reflexive def !inf;

  proof of inf_is_associative = 
    by !equal_reflexive, !leq_transitive, !total_order
       def !inf;

  theorem order_inf_refines_leq: all x y in self,
    !leq(x,y) -> !order_inf(x,y)
    proof: by  !total_order, !total_order, !leq_antisymmetric
           def !inf, !order_inf
    ;

  proof of inf_commutes = 
   <1>1 assume x y in self
         prove !equal(!inf(x,y),!inf(y,x))
        <2>1 assume Hxy: !leq(x,y)
             prove !equal(!inf(x,y),!inf(y,x))
             <3>1 prove !equal(x,!inf(x,y)) 
                  by <2>:Hxy, !equal_reflexive def !inf
             <3>2 prove !equal(x,!inf(y,x))
                  <4>1 assume Hyx: !leq(y,x)
                        prove !equal(x,!inf(y,x))
                        <5>1 prove !equal(x,y) 
                             by <2>:Hxy, <4>:Hyx, !leq_antisymmetric
                        <5>2 prove !equal(y,!inf(y,x))
                             by <4>:Hyx, !equal_reflexive
                             def !inf
                        <5>f qed 
                             by <5>1, <5>2, !equal_transitive
                  <4>2 assume H: not(!leq(y,x))
                        prove !equal(x,!inf(y,x))
                        by <4>:H, !equal_reflexive def !inf
                  <4>f qed by <4>1, <4>2
             <3>f qed by <3>1, <3>2, !equal_symmetric, !equal_transitive
        <2>2 assume Hyx: !leq(y,x)
             prove !equal(!inf(x,y),!inf(y,x))
             (* [rr]: could do as <2>1 above, but zenon is wiser *)
             by <2>:Hyx, !equal_reflexive,
                !leq_antisymmetric
                def !inf
        <2>f qed by <2>1, <2>2, !total_order
   <1>2 qed
   ;
end


(**
   Ordered join semi lattices have a complete ordering which refines that 
   of the join semi lattice structure.
 *)
species ordered_join_semi_lattice inherits join_semi_lattice, ordered_set =

  property geq_refines_order_sup : all x y in self,
    !order_sup(x,y) -> !geq(x,y);

end

(**
 We view an ordered set as a join semi lattice
*)

species ordered_set_as_join_semi_lattice inherits ordered_join_semi_lattice =

  let sup(x,y) = if !geq(x,y) then x else y ;

  proof of sup_idempotent = 
    by !equal_reflexive def !sup;

  proof of geq_refines_order_sup = by !geq_reflexive def !sup, !order_sup;

  proof of sup_commutes = 
   by !equal_reflexive, !leq_antisymmetric, !total_order
      def !sup, !geq
   ;

  proof of sup_is_associative = 
    by !equal_reflexive, !leq_transitive, !total_order
       def !sup, !geq;

  proof of sup_left_substitution_rule = 
    by !equal_reflexive, !equal_symmetric,
       !leq_reflexive, !leq_transitive
       def !sup, !geq
    ;


end

(** here we complete the partial ordering of the lattice *)
species ordered_lattice
  inherits ordered_meet_semi_lattice,
           ordered_join_semi_lattice,
           lattice =

end

(** a toitally ordered set may be viewed as a lattice *)
species ordered_set_as_lattice
  inherits ordered_set_as_meet_semi_lattice,
           ordered_set_as_join_semi_lattice,
           ordered_lattice =
  
  (** absorption laws are a mess !*)
  proof of sup_absorbes_inf =
    <1>1 assume x y in self
         prove !equal(x,!inf(x,!sup(x,y)))
         <2>1 assume H: !leq(x,y)
              prove !equal(x,!inf(x,!sup(x,y)))
              <3>1 prove !equal(y,!sup(x,y))
                   <4>1 prove !geq(y,x) by <2>:H def !geq
                   <4>2 prove !equal(!sup(y,x),y)
		        by <4>1, !equal_reflexive def !sup
                   <4>f qed by <4>2, !sup_commutes,
		            !equal_symmetric, !equal_transitive
              <3>2 prove !equal(x,!inf(x,y))
                   by <2>:H, !equal_reflexive def !inf
              <3>3 prove !equal(!inf(x,!sup(x,y)),
				!inf(x,y))
(* [rr]: loops?    by <3>1, !inf_substitution_rule, !equal_symmetric *)
		   by <3>1, !inf_right_substitution_rule, !equal_symmetric
              <3>f qed by <3>3, <3>2, !equal_symmetric, !equal_transitive
         <2>2 assume H: !leq(y,x)
              prove !equal(x,!inf(x,!sup(x,y)))
              <3>1 prove !geq(x,y) by <2>:H def !geq
              <3>2 prove !equal(x,!sup(x,y))
                   by <3>1, !equal_reflexive def !sup
              <3>3 prove !equal(!inf(x,!sup(x,y)),
				!inf(x,x))
		   by <3>2, !inf_right_substitution_rule, !equal_symmetric
              <3>f qed by <3>2, <3>3, !inf_idempotent,
			  !equal_symmetric, !equal_transitive
         <2>f qed by <2>1, <2>2, !total_order
    <1>f qed
    ;

   (* [rr]: see above *)
   proof of inf_absorbes_sup = assumed;

end


