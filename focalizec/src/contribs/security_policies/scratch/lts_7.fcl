(** Labelled transition system *)

open "basics";;
open "sets";;


species State =

    inherit Setoid;

    signature is_initial : Self -> bool;

end;;


species Label = inherit Setoid; end;;


species System (S is State, L is Label) =

    inherit Basic_object;

    (** transition relation *)
    signature delta : S -> L -> S -> bool;

    property determinist :
      all x y z : S, all l : L,
      ( delta (x, l, y) /\ delta (x, l, z) ) -> S!equal (y, z);

    property left_total :
      all x : S, all l : L,
      ex y : S, delta (x, l, y);

    (* logical let rec is_descendant (y, x) = *)
    (*   S!equal (y, x) \/ *)
    (*   ex z : S, ex l : L, delta (x, l, z) /\ is_descendant (y, z); *)

    (* logical let is_reachable (x) = *)
    (*   ex y : S, S!is_initial (y) /\ is_descendant (x, y); *)

    (** The list represents the sequence of transitions of the path in
        reverse. *)
    let rec is_path_from_init_to (p : list (S * L * S), x : S) =
      match p with
        | [] -> S!is_initial (x)
        | (y, l, z) :: q ->
            S!equal (z, x) && delta (y, l, z) && is_path_from_init_to (q, y);
    (* TODO : termination proof *)
    (* /!\ Unexpected error: "Failure("todo 123")" *)
    (* termination proof = structural p; *)

    logical let is_reachable (x) =
      ex p : list (S * L * S), is_path_from_init_to (p, x);

end;;



(* Tests *)

(* Parity automate *)

type parity = | Even | Odd;;

species Parity_State =

    inherit State;

    representation = parity;

    let even : Self = Even;
    let odd : Self = Odd;

    let to_int (x : Self) = match x with | Even -> 0 | Odd -> 1;

    let is_initial (x) = x = Even;
    let element = Even;
    let equal (x, y) = x = y;
    let print (x) = match x with | Even -> "even" | Odd -> "odd";

    proof of equal_reflexive = by definition of equal;
    proof of equal_symmetric = by definition of equal;
    proof of equal_transitive = by definition of equal;

end;;

collection Parity_State_Coll = implement Parity_State; end;;


species Parity_Label =

    inherit Label;

    representation = int;

    let value (l : Self) : int = l;

    let element = 0;
    let equal = ( =0x );
    let print = string_of_int;
    let parse = int_of_string;

    proof of equal_reflexive = assumed; (* by definition of equal; *)
    proof of equal_symmetric = assumed; (* by definition of equal; *)
    proof of equal_transitive = assumed; (* by definition of equal; *)

end;;

collection Parity_Label_Coll = implement Parity_Label; end;;


species Parity_System (S is Parity_State, L is Parity_Label) =

    inherit System (S, L);

    representation = S * L;

    let delta (x, l, y) = (S!to_int (x) + L!value (l)) % 2 = S!to_int (y);

    proof of determinist = assumed; (* by definition of delta; *)
    proof of left_total = assumed; (* by definition of delta; *)

end;;

collection Parity_System_Coll =
    implement Parity_System (Parity_State_Coll, Parity_Label_Coll); end;;
