open "basics";;
open "sets";;
open "listes";;

species Finite_set =

  inherit Setoid;

  (** Number of members of the species *)
  signature cardinal : int;

  (** All the members of the species. *)
  signature all_to_list : list (Self);

(* should use List_util *)
  let rec in_list (l, x) =
      match l with
        | [] -> false
        | h :: q -> (equal (h, x) || in_list (q, x))
      termination proof = structural l;

  property all_in_all_to_list :
    all x : Self, in_list (all_to_list, x);

end;;

species Finite_parts(S is Setoid) =

  inherit Setoid ;

  signature cardinal: Self -> int;
  signature empty : Self;
  signature is_empty : Self -> bool;
  signature add : Self -> S -> Self;
  signature belongs: S -> Self -> bool;
  signature release : Self -> S -> Self;
  signature to_list : Self -> list(S) ;
  signature is_contained : Self -> Self -> bool;

(*
  property inductive_scheme_part: all p: (Self -> prop),
      p(empty) 
   -> (all s: S, all x:Self, p(x) -> p(add(x, s)))
   -> all x: Self, p(x); 
*)

  (* pourquoi ca s'appelle pas belongs_equal_compat ? *)
  property belongs_left_substitution_rule: all s_1 s_2: S, all r: Self,
       S!equal(s_1, s_2) -> belongs(s_1, r) -> belongs(s_2, r);

  property empty_spec :
    all t: S, ~ belongs(t, empty);

  property is_empty_empty : 
     is_empty (empty); 

  property add_spec :
    all x : Self, all t_1 t_2 : S,
    belongs(t_1, add (x, t_2)) <->
      (S!equal(t_1, t_2) \/ belongs(t_1, x));

  theorem add_contains1: 
    all c: Self, all e : S, belongs (e, (add (c, e))) 
    proof = assumed;
  
  theorem add_contains2: 
    all c: Self, all e : S, all x : S, ~ (S!equal(e, x)) -> 
       belongs (x, (add (c, e))) <-> belongs (x, c)
  proof = assumed;

  property release_spec :
    all x : Self, all t_1 t_2 : S,
    belongs(t_1, release(x, t_2)) <-> (S!different (t_1, t_2) /\ belongs(t_1, x));

  property release_contains: 
    all c: Self, all e : S, all x : S, ~~(S!equal (e, x)) -> 
       (belongs (x, (release (c, e))) <-> belongs (x, c));

  property is_contained_spec :
    all x y : Self,
    is_contained (x, y) <-> ( all t : S,
                              belongs(t, x) -> belongs(t, y) );

  theorem is_contained_reflexive : all x : Self, is_contained (x, x)
  proof = by property is_contained_spec;

  theorem is_contained_transitive :
    all x y z : Self,
    (is_contained (x, y) /\ is_contained (y, z)) -> is_contained (x, z)
  proof = by property is_contained_spec;

  let equal(x, y) = is_contained(x, y) && is_contained(y, x);

  proof of equal_reflexive = by definition of equal 
                                property is_contained_reflexive;
  proof of equal_transitive = by definition of equal  
                                property is_contained_transitive;
  proof of equal_symmetric = by definition of equal;

  property to_list_empty : 
    all l : Self, is_empty(l) <-> to_list(l) = []
; 
  
  property unique_belongs : all c : Self, all e : S, 
   ~~ (belongs (e, release (c, e))) ;
    
end;;


(* ne serait il pas plus judicieux de programmer un finite_set by_lists avec par exemple des belongs et compagnie puis de faire hériter finite parts by lists ? *)

species Finite_parts_by_lists(S is Setoid, L is List_util(S)) =

  inherit Finite_parts(S);

  representation = list(S);


  (* y a pas un moyen de dire à zenon de regarder la rep plutot que ca ? *)  
  let to_list(e: Self): list(S) = e;

  let from_list(l: list(S)): Self = l;

  theorem from_list_valid : 
    (all e: Self,
      equal(from_list(to_list(e)), e))
    /\
    (all l: list(S),
      (to_list(from_list(l)) = l))
  proof = by definition of to_list, from_list property equal_reflexive ;    
    

  let empty = [];

  let element = empty;

  (* l'inversion s e est franchement moche faudrait changer list_utils... *)

  let belongs(s, e) = L!belongs(e, s);

  proof of empty_spec = by definition of empty, belongs 
                        property L!belongs_empty_spec
  ;

  let add(e, s) =
    if belongs(s, e)
    then e
    else s::e;


  (* theorem belongs_right_substitution_rule: all s: S, all l_1 l_2: Self, *)
  (*   equal(l_1, l_2) -> belongs(s, l_1) -> belongs(s, l_2) *)
  (*   proof =  *)
  (*     by property equal_reflexive *)
  (*   ; *)

  proof of belongs_left_substitution_rule = 
   <1>1 prove all s_1 s_2 : S, all l : list(S),
         S!equal(s_1, s_2) -> belongs(s_1, l) -> belongs(s_2, l)
    <2>1 prove all s_1 s_2 : S, 
           S!equal(s_1, s_2) -> belongs(s_1, []) -> belongs(s_2, [])
         by property L!belongs_empty_spec definition of belongs
    <2>2 prove all s_1 s_2 h : S, all t : list(S),
             (S!equal(s_1, s_2) -> belongs(s_1, t) -> belongs(s_2, t))
           ->
             (S!equal(s_1, s_2) -> belongs(s_1, h::t) -> belongs(s_2, h::t))
     <3>1 assume s_1 s_2 : S,
          hypothesis H : S!equal(s_1, s_2),
          prove all h : S, all t : list(S),
            (belongs(s_1, t) -> belongs(s_2, t))
         -> (belongs(s_1, h::t) -> belongs(s_2, h::t))
      <4>1 assume h : S, assume t : list(S),
           hypothesis H1 : belongs(s_1, t) -> belongs(s_2, t),
           hypothesis H2 : belongs(s_1, h::t),
           prove belongs(s_2, h::t)
       <5>1 prove L!belongs(t, s_1) -> L!belongs(t, s_2)
            by hypothesis H1 definition of belongs
       <5>2 prove L!belongs(h::t, s_1)
            by hypothesis H2 definition of belongs
       <5>3 prove L!belongs(h::t, s_2)
        <6>1 hypothesis HH1 : ~~ S!equal(h, s_2),
             prove L!belongs(t, s_2)
         <7>1 prove ~~ S!equal(s_1, h)
              by hypothesis HH1, H
                 property S!equal_transitive, S!equal_symmetric
         <7>2 prove L!belongs(t, s_1)
              by property L!belongs_spec, S!equal_symmetric step <7>1, <5>2
         <7>f qed by step <7>1, <7>2, <5>1
        <6>f qed by step <6>1 property L!belongs_spec
       <5>f qed by step <5>3 definition of belongs
      <4>f conclude
     <3>f conclude
    <2>f conclude
   <1>2 prove all s_1 s_2 : S, all r: Self,
          S!equal(s_1, s_2) -> belongs(s_1, r) -> belongs(s_2, r)
        by step <1>1 property from_list_valid
   <1>f conclude
  ;

  proof of is_contained_spec = assumed;

  let rec cardinal(e) = match e with
  | [] -> 0
  | _h::t -> 1 + cardinal(t)
  ;


  proof of add_spec =
   <1>1 assume x: Self, assume t_1 t_2: S,
        hypothesis H: belongs(t_1, add (x, t_2)),
        prove S!equal(t_1, t_2) \/ belongs(t_1, x)
        assumed
   <1>2 assume x: Self, assume t_1 t_2: S,
        hypothesis H: S!equal(t_1, t_2),
        prove belongs(t_1, add(x, t_2))
        assumed
   <1>3 assume x: Self, assume t_1 t_2: S,
        hypothesis H: belongs(t_1, x),
        prove belongs(t_1, add(x, t_2))
        assumed
   <1>f conclude
   ;

  let rec release(e, s) = match e with
  | [] -> []
  | h::t -> 
    if S!equal(s, h)
    then t
    else h::release(t, s)        
    ;

  proof of release_spec = assumed;

  let rec is_contained(l_1, l_2) = match l_1 with
  | [] -> true
  | h::t -> 
    if belongs(h, l_2) 
    then is_contained(t, l_2)
    else false
  ;

  (* proof of is_contained_spec = *)
  (*  by definition of is_contained,  *)

  property to_list_belongs :
    all c: Self, all e : S, belongs (e, c) <-> L!belongs(to_list(c), e);



end;;

