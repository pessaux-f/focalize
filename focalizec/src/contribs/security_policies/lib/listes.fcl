open "sets";;
open "basics";;

species Basic_list_util(A is Basic_object) =
  inherit Basic_object;
  
  representation = unit;
  
  let rec mem (l, x: A) =
    match l with
    | [] -> false
    | h :: q ->  h = x || (mem (q, x))
    termination proof = structural l
  ;

  theorem mem_cons_head: all x: A, all l: list(A), 
    mem(x::l, x)
  proof = by definition of mem;
  
  theorem mem_cons_tail: all x y: A, all l: list(A),
    mem(l, x) -> mem(y::l, x)
  proof = by definition of mem;

  theorem mem_empty_spec: all x: A, ~~(mem([], x))
  proof = by definition of mem;
  
  theorem mem_contains: all l: list(A),
    ~~( l = [] ) <-> (ex x: A, mem(l, x))
  proof = 
  <1>1 assume l: list(A),
       prove (l = []) -> all x: A, ~~(mem(l, x))
       by property mem_empty_spec
  <1>2 prove all l: list(A), ~~(l = []) -> ex x: A, mem(l, x)
       <2>1 prove ~~([] = []) -> ex x: A, mem([], x)
            conclude
       <2>2 assume l: list(A), assume a: A ,
            hypothesis I: ~~(l = []) -> ex x: A, mem(l, x),
            prove ex x: A, mem(a::l, x)
            <3>1 prove mem(a::l, a) by property mem_cons_head
            <3>f conclude
       <2>f conclude
  <1>f conclude;

theorem mem_spec: all l : list(A), all e h : A,  
 (mem (l, e) \/ (e = h)) <-> mem (h :: l, e)
proof = by definition of mem
; 
  

let rec rm (l, x : A) =
      match l with
        | [] -> []
        | h :: q ->  if h = x then q else h :: (rm (q, x)) 
termination proof = structural l
;

let rec length (l : list(A)) = 
      match l with
        | [] -> 0
        | h :: q ->  1 + (length (q)) 
termination proof = structural l
;
     
let rec append (l1 : list(A), l2) =
      match l1 with
        | [] -> l2
        | h :: q ->  h::(append (q, l2))
termination proof = structural l1
;

theorem append_def: 
 all l2: list(A),
   (append([], l2) = l2)
/\ (all h: A, all t: list(A),
     append(h::t, l2) = (h::append(t, l2)))
 proof = by definition of append
 ;


theorem append_def_nil: 
 all l2: list(A), append([], l2) = l2
 proof = by definition of append;

theorem append_def_cons : 
 all l2: list(A),
 all h: A, all t: list(A),
     append(h::t, l2) = (h::append(t, l2))
 proof = by definition of append
 ;


theorem append_right_neutral:
  all l : list(A), append(l,  []) = l
proof = 
  <1>1 prove append([], []) = []
       by definition of append
  <1>2 assume l: list(A), assume a: A,
       hypothesis I: append(l, []) = l,
       prove append(a::l, []) = a::l
       <2>1 prove append(a::l, []) = a::append(l, [])
            by definition of append
       <2>f qed by step <2>1 hypothesis I
  <1>f conclude
;

theorem append_left_neutral: all l: list(A),
  append([], l) = l
proof = by definition of append;

logical let append_neutral(n: list(A)) = 
  all l: list(A), (append(l, n) = l) /\ (append(n, l) = l);

theorem nil_neutral: append_neutral([])
proof = by property append_left_neutral, append_right_neutral
           definition of append_neutral;

theorem nil_unique: all n: list(A),
  append_neutral(n) -> n = []
proof = 
  <1>1 assume n: list(A),
       hypothesis N: append_neutral(n),
       prove n = []
       <2>1 prove append([], n) = []
            by hypothesis N definition of append_neutral
       <2>2 prove append([], n) = n
            by property append_left_neutral
       <2>f conclude
  <1>f conclude;


end
;;   


species List_util(A is Setoid) =
  inherit Basic_list_util(A);
  
  let rec belongs(l, x: A) =
    match l with
    | [] -> false
    | h :: q ->  A!equal(h, x) || (belongs (q, x))
    termination proof = structural l
  ;
  
  theorem mem_implies_belongs : all x: A, all l: list(A),
    mem(l, x) -> belongs(l, x)
  proof = 
   <1>1 assume x: A,
        prove mem([], x) -> belongs([], x)
        by definition of mem, belongs
   <1>2 assume x h : A,
        assume t: list(A),
        prove (mem(t, x) -> belongs(t, x))
           -> (mem(h::t, x) -> belongs(h::t, x))
        <2>1 hypothesis HI: (mem(t, x) -> belongs(t, x)),
             hypothesis H1: mem(h::t, x),
             prove belongs(h::t, x)
	     by definition of mem, belongs property A!equal_reflexive
                hypothesis HI, H1  
        <2>f conclude
   <1>f conclude
  ;

  theorem belongs_spec: all t: list(A), all h x: A,
    (belongs(t, x) \/ A!equal(h, x)) <-> belongs(h::t, x)
  proof = by definition of belongs;

  theorem belongs_cons_head: all x: A, all l: list(A), 
    belongs(x::l, x)
  proof = by property belongs_spec, A!equal_reflexive;
  
  theorem belongs_cons_tail: all x y: A, all l: list(A),
    belongs(l, x) -> belongs(y::l, x)
  proof = by property belongs_spec;

  theorem belongs_empty_spec: all x: A, ~~(belongs([], x))
  proof = by definition of belongs;

end
;;   
