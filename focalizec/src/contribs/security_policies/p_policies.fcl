open "basics";;
open "sets";;
open "utils";;


(** Property-based security policies *)

(** A property-based policy is a characterization of secure elements of a set
    according to some security information. *)


species Target = inherit Setoid; end;;

species Configuration = inherit Setoid; end;;


species P_policy (A is Target, C is Configuration) =

  (** Relation specifying secure targets according to configurations *)
  inherit Relation (A, C);

  signature secure: A -> C -> bool;

  let relation(a, c) = secure(a, c);

end;;

(** And-Composition of two policies defined over the same targets and configurations *)

species And_P_policy (A is Target, C is Configuration,
                      P1 is P_policy(A, C), P2 is P_policy(A, C)) =

 inherit P_policy(A, C);

 let secure(a, c) = P1!secure(a, c) && P2!secure(a, c);

 theorem secure_is_secure : all a:A, all c:C, secure(a, c) <-> (P1!secure(a, c) /\ P2!secure(a, c))
   proof = by definition of secure;

end;;