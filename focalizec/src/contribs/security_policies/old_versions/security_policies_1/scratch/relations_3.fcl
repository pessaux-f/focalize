(** Binary relation *)

open "basics";;
open "sets";;
open "products";;
open "ensembles_finis";;


(** A : domain, B : codomain *)
species Relation (A is Setoid, B is Setoid) =

    inherit Setoid;

    signature relation : Self -> A -> B -> bool;

    signature empty : Self;
    signature add : Self -> A -> B -> Self;
    signature remove : Self -> A -> B -> Self;

    signature union : Self -> Self -> Self;
    signature inter : Self -> Self -> Self;

    let element = empty;

    property equal_spec :
      all r1 r2 : Self,
      equal (r1, r2) <-> all a : A, all b : B,
                         relation (r1, a, b) = relation (r2, a, b);

    proof of equal_reflexive = by property equal_spec;
    proof of equal_symmetric = by property equal_spec;
    proof of equal_transitive = by property equal_spec;

    property add_spec :
      all r : Self, all a1 a2 : A, all b1 b2 : B,
      relation (add (r, a1, b1), a2, b2) <->
      ( (A!equal (a1, a2) /\ B!equal (b1, b2)) \/ relation (r, a2, b2) );

    property remove_spec :
      all r : Self, all a : A, all b : B,
      ~ relation (remove (r, a, b), a, b);    

    property union_rel_spec :
      all r1 r2 : Self, all a : A, all b : B,
      relation (union (r1, r2), a, b) <->
      ( relation (r1, a, b) \/ relation (r2, a, b) );

    property inter_rel_spec :
      all r1 r2 : Self, all a : A, all b : B,
      relation (inter (r1, r2), a, b) <->
      ( relation (r1, a, b) /\ relation (r2, a, b) );

    logical let is_left_unique (r) =
      all a1 a2 : A, all b : B,
      ( relation (r, a1, b) /\ relation (r, a2, b) ) -> A!equal (a1, a2);

    logical let is_right_unique (r) =
      all a : A, all b1 b2 : B,
      ( relation (r, a, b1) /\ relation (r, a, b2) ) -> B!equal (b1, b2);

    logical let is_left_total (r) =
      all a : A, ex b : B, relation (r, a, b);

    logical let is_right_total (r) =
      all b : B, ex a : A, relation (r, a, b);

end;;

(* Injective *)
species Determinist_relation (A is Setoid, B is Setoid) =
    inherit Relation (A, B);
    property right_unique : all r : Self, is_right_unique (r);
end;;

species Left_total_relation (A is Setoid, B is Setoid) =
    inherit Relation (A, B);
    property left_total : all r : Self, is_left_total (r);
end;;

species Function (A is Setoid, B is Setoid) =
    inherit Determinist_relation (A, B), Left_total_relation (A, B);
end;;

(* Determinist *)
species Injective_relation (A is Setoid, B is Setoid) =
    inherit Relation (A, B);
    property left_unique : all r : Self, is_left_unique (r);
end;;

species Surjective_relation (A is Setoid, B is Setoid) =
    inherit Relation (A, B);
    property right_total : all r : Self, is_right_total (r);
end;;

species Injective_function (A is Setoid, B is Setoid) =
    inherit Function (A, B), Injective_relation (A, B);
end;;

species Surjective_function (A is Setoid, B is Setoid) =
    inherit Function (A, B), Surjective_relation (A, B);
end;;

species Bijection (A is Setoid, B is Setoid) =
    inherit Injective_function (A, B), Surjective_function (A, B);
end;;



species Finite_relation (A is Setoid, B is Setoid, P is Product_set (A, B)) =

    inherit Relation (A, B), Ensembles_finis (P);

    let relation (r, a, b) = est_element (P!pair (a, b), r);
    let empty = vide;
    let add (r, a, b) = ajoute_element (P!pair (a, b), r);
    let remove (r, a, b) = diff (r, singleton (P!pair (a, b)));

    proof of equal_spec = assumed;       (* TODO *)
    (* proof of equal_spec = by definition of equal, relation *)
    (*                         property sous_ensemble_spec; *)

    proof of add_spec = assumed;        (* TODO *)
    (* proof of add_spec = by definition of add, ajoute_element *)
    (*                        property ajoute_spec, P!equal_spec; *)

    proof of remove_spec = assumed;     (* TODO *)
    (* proof of remove_spec = by definition of remove *)
    (*                           property diff_spec, singleton_spec; *)

    proof of union_rel_spec = by definition of relation
                                 property union_spec;

    proof of inter_rel_spec = by definition of relation
                                 property inter_spec;

end;;


species Finite_determinist_relation (A is Setoid, B is Setoid,
                                     P is Product_set (A, B)) =
    inherit Determinist_relation (A, B), Finite_relation (A, B, P);
end;;

species Finite_left_total_relation (A is Setoid, B is Setoid,
                                    P is Product_set (A, B)) =
    inherit Left_total_relation (A, B), Finite_relation (A, B, P);
end;;

species Finite_function (A is Setoid, B is Setoid, P is Product_set (A, B)) =
    inherit Function (A, B), Finite_relation (A, B, P);
end;;

species Finite_injective_relation (A is Setoid, B is Setoid,
                                   P is Product_set (A, B)) =
    inherit Injective_relation (A, B), Finite_relation (A, B, P);
end;;

species Finite_surjective_relation (A is Setoid, B is Setoid,
                                    P is Product_set (A, B)) =
    inherit Surjective_relation (A, B), Finite_relation (A, B, P);
end;;

species Finite_injective_function (A is Setoid, B is Setoid,
                                   P is Product_set (A, B)) =
    inherit Injective_function (A, B), Finite_relation (A, B, P);
end;;

species Finite_surjective_function (A is Setoid, B is Setoid,
                                    P is Product_set (A, B)) =
    inherit Surjective_function (A, B), Finite_relation (A, B, P);
end;;

species Finite_bijection (A is Setoid, B is Setoid, P is Product_set (A, B)) =
    inherit Bijection (A, B), Finite_relation (A, B, P);
end;;



species Finite_relation_by_list (A is Setoid, B is Setoid,
                                 P is Product_set (A, B)) =
    
    inherit Finite_relation (A, B, P), Liste (P);

end;;


(* TODO : Others relations by list with proofs (change add...) *)




(* Tests *)

species A_Spec =

  inherit Setoid;

  representation = int;

  let zero : Self = 0;
  let one : Self = 1;
  let two : Self = 2;

  let element = zero;
  let equal = ( =0x );
  let print = string_of_int;

  proof of equal_reflexive = assumed;
  proof of equal_symmetric = assumed;
  proof of equal_transitive = assumed;

end;;

type b_type = | A | B | C;;

species B_Spec =

  inherit Setoid;

  representation = b_type;

  let a : Self = A;
  let b : Self = B;
  let c : Self = C;

  let element = A;
  let equal (x, y) = x = y;
  let print (x : Self) = match x with | A -> "a" | B -> "b" | C -> "c";

  proof of equal_reflexive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_transitive = by definition of equal;

end;;

species Cartesian_product_Print (A is Setoid, B is Setoid) =

    inherit Cartesian_product (A, B);

    let print (x) =
      "(" ^ A!print (first (x)) ^ ", " ^ B!print (second (x)) ^ ")";

end;;


collection A = implement A_Spec; end;;
collection B = implement B_Spec; end;;
collection P = implement Cartesian_product_Print (A, B); end;;
collection R = implement Finite_relation_by_list (A, B, P); end;;

let r = R!add (R!add (R!empty, A!zero, B!a), A!one, B!a);;

print_string (R!print (r) ^ "\n");;
