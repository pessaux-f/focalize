use "basics";;
use "sets_orders";;
use "ensembles_finis";;
open "basics";;
open "sets_orders";;
open "ensembles_finis";;


species Labelled_Transition (State is Setoid, Label is Setoid) =

    inherit Setoid;

    representation = State * Label * State;

    let transition (p, l, q) : Self = (p, l, q);

    let source (t : Self) = match t with | (p, _, _) -> p;
    let destination (t : Self) = match t with | (_, _, q) -> q;
    let label (t : Self) = match t with | (_, l, _) -> l;

    (* property transition_preserves_source : *)
    (*   all p q : State, all l : Label, *)
    (*   State!equal (source (transition (p, l, q)), p); *)

    (* property transition_preserves_destination : *)
    (*   all p q : State, all l : Label, *)
    (*   State!equal (destination (transition (p, l, q)), q); *)
    
    (* property transition_preserves_label : *)
    (*   all p q : State, all l : Label, *)
    (*   Label!equal (label (transition (p, l, q)), l); *)

    let equal (t1, t2) =
      State!equal (source (t1), source (t2)) &&
      State!equal (destination(t1), destination (t2)) &&
      Label!equal (label(t1), label(t2));

    let element = transition (State!element, Label!element, State!element);

    theorem equal_spec:
      all x y : Self,
      equal (x, y) <->
        ( State!equal (source (x), source (y)) /\
          State!equal (destination (x), destination (y)) /\
          Label!equal (label (x), label (y)) )
    proof = by definition of equal;

    proof of equal_reflexive =
      by property State!equal_reflexive, Label!equal_reflexive
         definition of equal;

    proof of equal_symmetric =
      by property State!equal_symmetric, Label!equal_symmetric
         definition of equal;

    proof of equal_transitive =
      by property State!equal_transitive, Label!equal_transitive
         definition of equal;

end;;


species System (State is Setoid,
                States is Ensembles_finis (State),
                Label is Setoid,
                Labels is Ensembles_finis (Label),
                Transition is Labelled_Transition (State, Label),
                Transitions is Ensembles_finis (Transition)) =

    inherit Basic_object;

    signature system : States -> States -> Labels -> Transitions -> Self;

    signature states : States;
    signature initial_states : States;
    signature labels : Labels;
    signature transitions : Transitions;

    logical let in_s (x : State) = States!est_element (x, states);
    logical let in_i (x : State) = States!est_element (x, initial_states);
    logical let in_l (x : Label) = Labels!est_element (x, labels);
    logical let in_t (x : Transition) = Transitions!est_element (x, transitions);
    logical let trans (p, l, q) = in_t (Transition!transition (p, l, q));

    property initials_in_states :
      States!sous_ensemble (initial_states, states);

    property transitions_in_states_and_labels :
      all p q : State, all l : Label,
      trans (p, l, q) -> ( in_s (p) /\ in_l (l) /\ in_s (q) );

    (* property transitions_in_states_and_labels_1 : *)
    (*   all t : Transition, *)
    (*   in_t (t) -> ( in_s (Labelled_Transition!source (t)) /\ *)
    (*                 in_l (Labelled_Transition!label (t)) /\ *)
    (*                 in_s (Labelled_Transition!destination (t)) ); *)

    property determinist :
      all x y z : State, all l : Label,
      in_s (x) -> in_s (y) -> in_s (z) -> in_l (l) ->
      ( trans (x, l, y) /\ trans (x, l, z) ) -> State!equal (y, z);

    property left_total :
      all x : State, all l : Label,
      in_s (x) -> in_l (l) ->
      ex y : State, in_s (y) /\ trans (x, l, y);

end;;




(* Tests *)

collection Transition_Coll =

    implement Labelled_Transition (Entiers, Entiers);

end;;

let t = Transition_Coll!transition (Entiers!parse ("1"), Entiers!parse ("8"), Entiers!parse ("2"));;
print_string (Entiers!print (Transition_Coll!source (t)));;
print_string (Entiers!print (Transition_Coll!label (t)));;
print_string (Entiers!print (Transition_Coll!destination (t)));;
print_string ("\n");;
