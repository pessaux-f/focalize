(** The HRU security model (Harrison, Ruzzo, Ullman model) *)

open "basics";;
open "sets";;
open "finite_sets";;
open "products";;
open "lts";;

(** We define a system allowing to add or to release accesses
    done by active entities, the subjects, over passive entities, the objects,
    according to access modes (for exemple, read, write, etc). *)


species Subject = inherit Finite_set; end;;

species Object = inherit Finite_set; end;;

species Access_mode = inherit Finite_set; end;;



species State_ac (S is Subject, O is Object, A is Access_mode) =

  inherit State;

  (** alpha (x, s, o, a) means that s has an access over o
      according to the access mode a in the state x of the system. *)
  signature alpha : Self -> S -> O -> A -> bool;

  signature initial : Self;
  signature add : Self -> S -> O -> A -> Self;
  signature remove : Self -> S -> O -> A -> Self;

  property is_initial_spec :
    all x : Self,
    is_initial (x) <-> all s : S, all o : O, all a : A, ~ alpha (x, s, o, a);

  property add_spec :
    all x : Self, all s s2 : S, all o : O, all a : A,
    if S!equal (s, s2)
    then alpha (add (x, s, o, a), s2, o, a)
    else alpha (add (x, s, o, a), s2, o, a) = alpha (x, s2, o, a);

  property remove_spec :
    all x : Self, all s s2 : S, all o : O, all a : A,
    if S!equal (s, s2)
    then ~~ alpha (remove (x, s, o, a), s2, o, a)
    else alpha (remove (x, s, o, a), s2, o, a) = alpha (x, s2, o, a);

  property initial_is_initial :
    all x : Self,
    equal (x, initial) <-> is_initial (x);

  property equal_spec :
    all x y : Self,
    equal (x, y) <-> all s : S, all o : O, all a : A,
                     alpha (x, s, o, a) = alpha (y, s, o, a);

  proof of equal_reflexive = by property equal_spec;
  proof of equal_symmetric = by property equal_spec;
  proof of equal_transitive = by property equal_spec;

end;;


type list_soa ('s, 'o, 'a) =
  | Empty
  | Cons ('s, 'o, 'a, list_soa ('s, 'o, 'a));;

species State_ac_as_list (S is Subject, O is Object, A is Access_mode) =

  inherit State_ac (S, O, A);

  representation = list_soa (S, O, A);

  local let ( =S ) = S!equal;
  local let ( =O ) = O!equal;
  local let ( =A ) = A!equal;

  let alpha (x, s, o, a) =
    let rec aux (x) =
      match x with
        | Empty -> false
        | Cons (s2, o2, a2, l) -> (s2 =S s && o2 =O o && a2 =A a) || aux (l) in
    aux (x);

  let initial = Empty;

  let add (x, s, o, a) = Cons (s, o, a, x);

  let remove (x, s, o, a) =
    let rec aux (x) =
      match x with
        | Empty -> Empty
        | Cons (s2, o2, a2, l) ->
            if (s2 =S s && o2 =O o && a2 =A a) then aux (l)
            else Cons (s2, o2, a2, aux (l)) in
    aux (x);

  let is_initial (x) = x = Empty;

  (* TODO : doublons dans x *)
  (* TODO : double inclusion *)
  let equal (x, y) =
    let rec aux (x, y) =
      match x with
        | Empty -> y = Empty
        | Cons (s, o, a, l) ->
            alpha (y, s, o, a) && aux (l, remove (y, s, o, a)) in
    aux (x, y);

  let element = Empty;

  let print (x) =
    let rec aux (x) =
      match x with
        | Empty -> ""
        | Cons (s, o, a, l) ->
            let soa = "(" ^ S!print (s) ^ ", " ^ O!print (o) ^ ", " ^
                      A!print (a) ^ ")" in
            if l = Empty then soa else soa ^ "; " ^ aux (l) in
    "[" ^ aux (x) ^ "]";

  proof of is_initial_spec = assumed; (* TODO *)
  proof of add_spec = assumed;
  proof of remove_spec = assumed;
  proof of initial_is_initial = assumed;
  proof of equal_spec = assumed;

end;;


species Action =

  inherit Setoid;

  representation = bool;

  let add : Self = true;
  let release : Self = false;

  let element = add;
  let equal (a1 : Self, a2 : Self) = a1 = a2;
  let print (a) = if a then "+" else "-";
  let parse (s) = if s = "+" then add else release;

  theorem is_add_or_release : all x : Self, equal (x, add) \/ equal (x, release)
    proof = by definition of add, release, equal;

  theorem add_is_not_release : ~ equal (add, release)
    proof = by definition of add, release, equal;

  proof of equal_reflexive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_transitive = by definition of equal;

end;;


species Label_ac (X is Action, S is Subject, O is Object, A is Access_mode) =

  inherit Label;

  representation = X * S * O * A;

  let label (x, s, o, a) : Self = (x, s, o, a);

  let action (l : Self) = match l with | (x, _, _, _) -> x;
  let subject (l : Self) = match l with | (_, s, _, _) -> s;
  let object_ac (l : Self) = match l with | (_, _, o, _) -> o;
  let access_mode (l : Self) = match l with | (_, _, _, a) -> a;

  local let ( =X ) = X!equal;
  local let ( =S ) = S!equal;
  local let ( =O ) = O!equal;
  local let ( =A ) = A!equal;

  let element = (X!element, S!element, O!element, A!element);

  let equal (l1 : Self, l2 : Self) =
    action (l1) =X action (l2) && subject (l1) =S subject (l2) &&
    object_ac (l1) =O object_ac (l2) && access_mode (l1) =A access_mode (l2);

  let print (l) = "<" ^ X!print (action (l)) ^ ", " ^ S!print (subject (l)) ^
                  ", " ^ O!print (object_ac (l)) ^ ", " ^
                  A!print (access_mode (l)) ^ ">";

  theorem label_spec :
    all x : X, all s : S, all o : O, all a : A,
    action (label (x, s, o, a)) =X x && subject (label (x, s, o, a)) =S s &&
    object_ac (label (x, s, o, a)) =O o && access_mode (label (x, s, o, a)) =A a
  proof = assumed;              (* TODO *)
          (* by definition of label, action, subject, object_ac, access_mode; *)

  theorem equal_spec :
    all l1 l2 : Self,
    equal (l1, l2) <->
    action (l1) =X action (l2) && subject (l1) =S subject (l2) &&
    object_ac (l1) =O object_ac (l2) && access_mode (l1) =A access_mode (l2)
  proof = by definition of equal;

  proof of equal_reflexive = by property equal_spec,
                                         X!equal_reflexive, S!equal_reflexive,
                                         O!equal_reflexive, A!equal_reflexive
                                definition of ( =X ), ( =S ), ( =O ), ( =A );
  proof of equal_symmetric = by property equal_spec,
                                         X!equal_symmetric, S!equal_symmetric,
                                         O!equal_symmetric, A!equal_symmetric
                                definition of ( =X ), ( =S ), ( =O ), ( =A );
  proof of equal_transitive = by property equal_spec,
                                          X!equal_transitive, S!equal_transitive,
                                          O!equal_transitive, A!equal_transitive
                                 definition of ( =X ), ( =S ), ( =O ), ( =A );

end;;


species Transition_system_ac
  (X is Action, S is Subject, O is Object, A is Access_mode,
   St is State_ac (S, O, A), L is Label_ac (X, S, O, A)) =

  inherit Transition_system (St, L);

  (** There is a unique system in the species. *)
  representation = unit;

  let delta_ac (x, l, y) = delta ((), x, l, y);

  let delta (s : Self, x, l, y) =
    ( ( X!equal (L!action (l), X!add) &&
        St!equal (y, St!add (x, L!subject (l),
                                L!object_ac (l),
                                L!access_mode (l))) ) ||
      ( X!equal (L!action (l), X!release) &&
        St!equal (y, St!remove (x, L!subject (l),
                                   L!object_ac (l),
                                   L!access_mode (l))) ) );

  theorem delta_spec :
    all s : Self, all x y : St, all l : L,
    delta (s, x, l, y) <->
    ( ( X!equal (L!action (l), X!add) /\
        St!equal (y, St!add (x, L!subject (l),
                                L!object_ac (l),
                                L!access_mode (l))) ) \/
      ( X!equal (L!action (l), X!release) /\
        St!equal (y, St!remove (x, L!subject (l),
                                   L!object_ac (l),
                                   L!access_mode (l))) ) )
  proof = by definition of delta;

  theorem delta_ac_is_delta :
    all s : Self, all x y : St, all l : L,
    delta_ac (x, l, y) <-> delta (s, x, l, y)
  proof = by definition of delta_ac, delta;

end;;




(** System with requests for transitions *)

species Request_ac (X is Action, S is Subject, O is Object, A is Access_mode) =

  inherit Label_ac (X, S, O, A);

end;;


species Answer_ac =

  inherit Setoid;

  representation = bool;

  let yes : Self = true;
  let no : Self = false;

  let element = no;
  let equal (a1 : Self, a2 : Self) = a1 = a2;
  let print (a) = if a = yes then "yes" else "no";
  let parse (s) = if s = "yes" then yes else no;

  theorem is_yes_or_no : all x : Self, equal (x, yes) \/ equal (x, no)
    proof = by definition of yes, no, equal;

  theorem yes_is_not_not : ~ equal (yes, no)
    proof = by definition of yes, no, equal;

  proof of equal_reflexive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_transitive = by definition of equal;

end;;


species Label_request_ac
  (X is Action, S is Subject, O is Object, A is Access_mode,
   R is Request_ac (X, S, O, A), D is Answer_ac) =

  inherit Label, Cartesian_product (R, D);

  let request (l : Self) = first (l);
  let answer (l : Self) = second (l);

  let action (l) = R!action (request (l));
  let subject (l) = R!subject (request (l));
  let object_ac (l) = R!object_ac (request (l));
  let access_mode (l) = R!access_mode (request (l));

  let print (l) =
    "(" ^ R!print (request (l)) ^ ", " ^ D!print (answer (l)) ^ ")";

end;;



species Transition_system_request_ac
  (X is Action, S is Subject, O is Object, A is Access_mode,
   R is Request_ac (X, S, O, A), D is Answer_ac,
   St is State_ac (S, O, A), L is Label_request_ac (X, S, O, A, R, D)) =

  inherit Transition_system (St, L);

  representation = unit;

  let delta_ac (x, l, y) = delta ((), x, l, y);

  let delta (s : Self, x, l, y) =
    ( ( D!equal (L!answer (l), D!yes) && X!equal (L!action (l), X!add) &&
        St!equal (y, St!add (x, L!subject (l),
                                L!object_ac (l),
                                L!access_mode (l))) ) ||
      ( D!equal (L!answer (l), D!yes) && X!equal (L!action (l), X!release) &&
        St!equal (y, St!remove (x, L!subject (l),
                                   L!object_ac (l),
                                   L!access_mode (l))) ) ||
      ( D!equal (L!answer (l), D!no) && St!equal (y, x) ) );

  theorem delta_spec :
    all s : Self, all x y : St, all l : L,
    delta (s, x, l, y) <->
    ( ( D!equal (L!answer (l), D!yes) /\ X!equal (L!action (l), X!add) /\
        St!equal (y, St!add (x, L!subject (l),
                                L!object_ac (l),
                                L!access_mode (l))) ) \/
      ( D!equal (L!answer (l), D!yes) /\ X!equal (L!action (l), X!release) /\
        St!equal (y, St!remove (x, L!subject (l),
                                   L!object_ac (l),
                                   L!access_mode (l))) ) \/
      ( D!equal (L!answer (l), D!no) /\ St!equal (y, x) ) )
  proof = by definition of delta;

  theorem delta_ac_is_delta :
    all s : Self, all x y : St, all l : L,
    delta_ac (x, l, y) <-> delta (s, x, l, y)
  proof = by definition of delta_ac, delta;

end;;




    (* Tests *)


species Subject_test =

  inherit Subject;

  representation = int;

  let s0 : Self = 0;
  let s1 : Self = 1;
  let s2 : Self = 2;
  let s3 : Self = 3;
  let s4 : Self = 4;
  let s5 : Self = 5;
  let s6 : Self = 6;
  let s7 : Self = 7;

  let element = s0;
  let equal (s_1, s_2) = s_1 = s_2;
  let print (s) = "s" ^ string_of_int (s);

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

end;;

collection S = implement Subject_test; end;;


species Object_test =

  inherit Object;

  representation = int;

  let o0 : Self = 0;
  let o1 : Self = 1;
  let o2 : Self = 2;
  let o3 : Self = 3;
  let o4 : Self = 4;
  let o5 : Self = 5;
  let o6 : Self = 6;
  let o7 : Self = 7;

  let element = o0;
  let equal (o_1, o_2) = o_1 = o_2;
  let print (o) = "o" ^ string_of_int (o);

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

end;;

collection O = implement Object_test; end;;


species Access_mode_test =

  inherit Access_mode;

  representation = int;

  let a0 : Self = 0;
  let a1 : Self = 1;
  let a2 : Self = 2;
  let a3 : Self = 3;
  let a4 : Self = 4;
  let a5 : Self = 5;
  let a6 : Self = 6;
  let a7 : Self = 7;

  let element = a0;
  let equal (a_1, a_2) = a_1 = a_2;
  let print (a) = "a" ^ string_of_int (a);

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

end;;

collection A = implement Access_mode_test; end;;

collection St = implement State_ac_as_list (S, O, A); end;;

collection X = implement Action; end;;

collection L = implement Label_ac (X, S, O, A); end;;

collection LTS = implement Transition_system_ac (X, S, O, A, St, L); end;;

let rec fold_left (l, f, z) =
  match l with
    | [] -> z
    | h :: q -> f (h, fold_left (q, f, z));;

let test (x, l, y) =
  let transition = St!print (x) ^ " --" ^ L!print (l) ^ "--> " ^ St!print (y) in
  if LTS!delta_ac (x, l, y)
  then print_string (transition ^ "   OK\n")
  else print_string (transition ^ "   KO\n");;

let state_0 = St!initial;;
let state_1 = St!initial;;
let state_2 = St!add (state_1, S!s3, O!o5, A!a2);;
let state_3 = St!add (state_2, S!s3, O!o5, A!a7);;

let label_0 = L!label (X!add, S!s3, O!o5, A!a2);;
let label_1 = L!label (X!release, S!s3, O!o5, A!a2);;
let label_2 = L!label (X!add, S!s3, O!o5, A!a7);;
let label_3 = L!label (X!release, S!s3, O!o5, A!a7);;


test (state_0, label_0, state_1);;
test (state_0, label_0, state_2);;
test (state_0, label_0, state_3);;
test (state_2, label_1, state_0);;
test (state_3, label_1, state_2);;
test (state_3, label_3, state_2);;
test (state_2, label_2, state_3);;
