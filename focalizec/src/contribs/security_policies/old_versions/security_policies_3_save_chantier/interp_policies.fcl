open "basics";;
(* open "sets";;*)
open "finite_sets_f";;
(* open "utils";;*)
open "p_policies";;




species Target_Interpretation(A is Target, B is Target) =
  signature interpretation : A -> B;
end;;




(*
species Interpreted_Target(A is Target) =
  inherit Target;
  signature interpretation : A -> Self;
end;;
*)

species Target_Identity(A is Target) =
  inherit Target_Interpretation(A, A);
  let interpretation(a) = a;
  theorem spec_identity_interp : all a : A, A!equal(a, interpretation(a))
  proof = by definition of interpretation
             property A!equal_reflexive;
 end;;





species Interpreted_configurations(C is Configuration) =
  inherit Configuration;
  signature interpretation : C -> Self;
end;;

species Interpreted_configurations_by_parts
        (C is Configuration, 
         D is Target, FD is Finite_parts(D)) =
  inherit Interpreted_configurations(C);

  signature as_part : Self -> FD;

  signature belongs : Self -> D -> bool;
  (* for d in D and p in Self, belongs(p,d) should be true iff d belongs to the part p *)
  (* belongs(p) provides the characteristic function of p *)

  property belongs_spec : all p : Self, all d : D, 
                          belongs(p, d) <-> FD!belongs(d, as_part(p));
end;;


species Interpreted_P_policy 
        (A is Target, C is Configuration, 
         P is P_policy(A, C), 
         D is Target, AD is Target_Interpretation(A, D),
         FD is Finite_parts(D),
         IC is Interpreted_configurations_by_parts(C, D, FD)) =

  inherit P_policy(D, IC);

  let secure(d, ic) = IC!belongs(ic, d);

  theorem spec_secure :  all c: IC, all t: D, 
   FD!belongs(t, IC!as_part(c)) <-> secure(t, c)
  proof = by definition of secure
             property IC!belongs_spec;

  property spec_IC : all c : C, all t : A, 
                     P!secure(t, c) <-> IC!belongs(IC!interpretation(c), AD!interpretation(t));
  
end;;




species Extensional_p_policy(A is Target, C is Configuration, P is P_policy(A, C),
                             AA is Target_Identity(A),
                             FA is Finite_parts(A),
                             IC is Interpreted_configurations_by_parts(C, A, FA)) =
  inherit Interpreted_P_policy(A, C, P, A, AA, FA, IC); 
end;;
