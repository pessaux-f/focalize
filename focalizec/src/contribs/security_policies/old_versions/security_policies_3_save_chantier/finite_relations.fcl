open "basics";;
open "sets";;
open "finite_sets_f";;
open "listes";;
open "products";;
open "relations_mutable";;



(** Finites relations *)


species Finite_relation (A is Finite_set, B is Finite_set) =
  inherit Relation (A, B), Finite_set; end;;


species Finite_injective_relation (A is Finite_set, B is Finite_set) =
  inherit Injective_relation (A, B), Finite_set; end;;


species Finite_determinist_relation (A is Finite_set, B is Finite_set) =
  inherit Determinist_relation (A, B), Finite_set; end;;


species Finite_left_total_relation (A is Finite_set, B is Finite_set) =
  inherit Left_total_relation (A, B), Finite_set; end;;


species Finite_surjective_relation (A is Finite_set, B is Finite_set) =
  inherit Surjective_relation (A, B), Finite_set; end;;


species Finite_function (A is Finite_set, B is Finite_set) =
  inherit Function (A, B), Finite_set; end;;


species Finite_injective_function (A is Finite_set, B is Finite_set) =
  inherit Injective_function (A, B), Finite_set;

  (** The species must be non empty *)
  property card_A_leq_card_B : A!cardinal <=0x B!cardinal;

end;;


species Finite_surjective_function (A is Finite_set, B is Finite_set) =
  inherit Surjective_function (A, B), Finite_set; end;;


species Finite_bijection (A is Finite_set, B is Finite_set) =
  inherit Bijection (A, B), Finite_set;

  (** The species must be non empty *)
  property card_A_eq_card_B : A!cardinal = B!cardinal;

end;;



species Finite_relation_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_relation (A, B);

  representation = list (A * B);

  let relation =
    let rec aux (r, a, b) =
      match r with
        | [] -> false
        | (a1, b1) :: t -> (A!equal (a1, a) && B!equal (b1, b)) ||
                           aux (t, a, b) in
    function r -> function a -> function b -> aux (r, a, b);


  local let empty_belongs_impl = true;
  local let full_belongs_impl = true;
  local let singleton_belongs_impl (_a : A, _b : B) = true;
  local let union_is_internal_impl (_r1 : Self, _r2 : Self) = true;
  local let inter_is_internal_impl (_r1 : Self, _r2 : Self) = true;
  local let diff_is_internal_impl (_r1 : Self, _r2 : Self) = true;

  theorem empty_belongs_impl_correct :
    empty_belongs_impl <-> empty_belongs
  proof = by definition of empty_belongs, empty_belongs_impl;

  theorem full_belongs_impl_correct :
    full_belongs_impl <-> full_belongs
  proof = by definition of full_belongs, full_belongs_impl;
  
  theorem singleton_belongs_impl_correct :
    all a : A, all b : B,
    singleton_belongs_impl (a, b) <-> singleton_belongs (a, b)
  proof = by definition of singleton_belongs, singleton_belongs_impl;
  
  theorem union_is_internal_impl_correct :
    all r1 r2 : Self,
    union_is_internal_impl (r1, r2) <-> union_is_internal (r1, r2)
  proof = by definition of union_is_internal, union_is_internal_impl;
  
  theorem inter_is_internal_impl_correct :
    all r1 r2 : Self,
    inter_is_internal_impl (r1, r2) <-> inter_is_internal (r1, r2)
  proof = by definition of inter_is_internal, inter_is_internal_impl;
  
  theorem diff_is_internal_impl_correct :
    all r1 r2 : Self,
    diff_is_internal_impl (r1, r2) <-> diff_is_internal (r1, r2)
  proof = by definition of diff_is_internal, diff_is_internal_impl;


  local let rev_append =
    let rec aux (l1, l2) =
      match l1 with
        | [] -> l2
        | h :: t -> aux (t, h :: l2) in
    function l1 -> function l2 -> aux (l1, l2);

  (* /!\ Must be redifined first with a valid representation ! (for failed) *)
  let element = [];

  let empty (_u) =
    if empty_belongs_impl then [] else failed ("empty not belongs");

  local let full_forced =
    let rec aux_B (l_b : list (B), a : A, acc) =
      match l_b with
        | [] -> acc
        | h :: t -> aux_B (t, a, (a, h) :: acc) in
    let rec aux_A (l_a : list (A), l_b : list (B), acc) =
      match l_a with
        | [] -> acc
        | h :: t -> aux_A (t, l_b, rev_append (aux_B (l_b, h, []), acc)) in
    aux_A (A!all_to_list, B!all_to_list, []);

  let full (_u) =
    if full_belongs_impl then full_forced
    else failed ("full not belongs");

  let singleton (a, b) =
    if singleton_belongs_impl (a, b) then [(a, b)]
    else failed ("singleton not belongs");

  let union =
    let rec aux (r1, r2) =
      match r1 with
        | [] -> r2
        | (a, b) :: t -> if relation (r2, a, b)
                         then aux (t, r2)
                         else aux (t, (a, b) :: r2) in
    function r1 -> function r2 ->
      if union_is_internal_impl (r1, r2) then aux (r1, r2)
      else failed ("union not internal");

  let inter =
    let rec aux (r1, r2, acc) =
      match r1 with
        | [] -> acc
        | (a, b) :: t -> if relation (r2, a, b)
                         then aux (t, r2, (a, b) :: acc)
                         else aux (t, r2, acc) in
    function r1 -> function r2 ->
      if inter_is_internal_impl (r1, r2) then aux (r1, r2, [])
      else failed ("inter not internal");

  let diff =
    let rec aux (r1, r2, acc) =
      match r1 with
        | [] -> acc
        | (a, b) :: t -> if relation (r2, a, b)
                         then aux (t, r2, acc)
                         else aux (t, r2, (a, b) :: acc) in
    function r1 -> function r2 ->
      if diff_is_internal_impl (r1, r2) then aux (r1, r2, [])
      else failed ("diff not internal");

  local let contains =
    let rec aux (r2 : Self, r1 : Self) =
      match r2 with
        | [] -> true
        | (a, b) :: t -> relation (r2, a, b) && aux (t, r1) in
    function r1 -> function r2 -> aux (r2, r1);

  let equal (r1, r2) = contains (r1, r2) && contains (r2, r1);

  local let rec pow_aux (n, x, acc) =
    if n <=0x 0 then acc else pow_aux (n - 1, x, x * acc);

  local let ( ^0x ) (x, n) = pow_aux (n, x, 1);

  let cardinal = 2 ^0x (A!cardinal * B!cardinal);

  (* Pas de fonctions generiques *)
  local let rev_append_2 =
    let rec aux (l1, l2) =
      match l1 with
        | [] -> l2
        | h :: t -> aux (t, h :: l2) in
    function l1 -> function l2 -> aux (l1, l2);

  let all_to_list : list (Self) =
    (* List of lists with elements of l2 and some of l1 *)
    let rec aux (l1 : list (A * B), l2 : list (A * B)) =
      match l1 with
        | [] -> [l2]
        | h :: t -> rev_append_2 (aux (t, l2), aux (t, h :: l2)) in
    aux (full_forced, []);

  local let is_A_singleton_impl =
    match A!all_to_list with | [_] -> true | _ -> false;

  theorem is_A_singleton_impl_correct : is_A_singleton_impl <-> is_A_singleton
    proof = assumed;            (* TODO *)

  local let is_B_singleton_impl =
    match B!all_to_list with | [_] -> true | _ -> false;

  theorem is_B_singleton_impl_correct : is_B_singleton_impl <-> is_B_singleton
    proof = assumed;            (* TODO *)

  local let print_relation =
    let rec aux (r) =
      match r with
        | [] -> "]"
        | [(a, b)] ->  "(" ^ A!print (a) ^ ", " ^ B!print (b) ^ ")]"
        | (a, b) :: t -> "(" ^ A!print (a) ^ ", " ^ B!print (b) ^ "); " ^
                         aux (t) in
    function r -> "[" ^ aux (r);

  let print = print_relation;

  proof of empty_spec = assumed; (* TODO *)
  proof of full_spec = assumed;
  proof of singleton_spec = assumed;
  proof of union_spec = assumed;
  proof of inter_spec = assumed;
  proof of diff_spec = assumed;
  proof of equal_spec = assumed;
  proof of all_in_all_to_list = assumed;

end;;


species Finite_injective_relation_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_relation_by_list (A, B), Finite_injective_relation (A, B);

  local let full_belongs_impl = is_A_singleton_impl;

  local let union_is_internal_aux_A =
    let rec aux_A_bis (l_a : list (A), b : B, a : A, r2) =
      match l_a with
        | [] -> true
        | h :: t -> if relation (r2, h, b)
                    then A!equal (h, a) && aux_A_bis (t, b, a, r2)
                    else aux_A_bis (t, b, a, r2) in
    let rec aux_A (l_a_r : list (A), l_a : list (A), b : B, r1, r2) =
      match l_a_r with
        | [] -> true
        | h :: t -> if relation (r1, h, b)
                    then aux_A_bis (l_a, b, h, r2) && aux_A (t, l_a, b, r1, r2)
                    else aux_A (t, l_a, b, r1, r2) in
    let rec aux_B (l_b : list (B), l_a : list (A), r1, r2) =
      match l_b with
        | [] -> true
        | h :: t -> aux_A (l_a, l_a, h, r1, r2) && aux_B (t, l_a, r1, r2) in
    function r1 -> function r2 ->
      aux_B (B!all_to_list, A!all_to_list, r1, r2);

  local let union_is_internal_impl = union_is_internal_aux_A;

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;


  proof of full_belongs_impl_correct =
    by property is_A_singleton_impl_correct
       definition of full_belongs, full_belongs_impl;

  proof of union_is_internal_impl_correct = assumed; (* TODO *)

  proof of left_unique = assumed; (* ??? *)

end;;


species Finite_determinist_relation_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_relation_by_list (A, B), Finite_determinist_relation (A, B);

  local let full_belongs_impl = is_B_singleton_impl;

  local let union_is_internal_aux_B =
    let rec aux_B_bis (l_b : list (B), a : A, b : B, r2) =
      match l_b with
        | [] -> true
        | h :: t -> if relation (r2, a, h)
                    then B!equal (h, b) && aux_B_bis (t, a, b, r2)
                    else aux_B_bis (t, a, b, r2) in
    let rec aux_B (l_b_r : list (B), l_b : list (B), a : A, r1, r2) =
      match l_b_r with
        | [] -> true
        | h :: t -> if relation (r1, a, h)
                    then aux_B_bis (l_b, a, h, r2) && aux_B (t, l_b, a, r1, r2)
                    else aux_B (t, l_b, a, r1, r2) in
    let rec aux_A (l_a : list (A), l_b : list (B), r1, r2) =
      match l_a with
        | [] -> true
        | h :: t -> aux_B (l_b, l_b, h, r1, r2) && aux_A (t, l_b, r1, r2) in
    function r1 -> function r2 ->
      aux_A (A!all_to_list, B!all_to_list, r1, r2);

  local let union_is_internal_impl = union_is_internal_aux_B;

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;


  proof of full_belongs_impl_correct =
    by property is_B_singleton_impl_correct
       definition of full_belongs, full_belongs_impl;

  proof of union_is_internal_impl_correct = assumed; (* TODO *)

  proof of right_unique = assumed; (* ??? *)

end;;


species Finite_left_total_relation_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_relation_by_list (A, B), Finite_left_total_relation (A, B);

  let element = full_forced;

  local let empty_belongs_impl = false;

  local let singleton_belongs_impl (_a, _b) = is_A_singleton_impl;

  local let inter_is_internal_aux_A =
    let rec aux_B (l_b, a, r1, r2) =
      match l_b with
        | [] -> false
        | h :: t -> ( relation (r1, a, h) && relation (r2, a, h) ) ||
                    aux_B (t, a, r1, r2) in
    let rec aux_A (l_a, l_b, r1, r2) =
      match l_a with
        | [] -> true
        | h :: t -> aux_B (l_b, h, r1, r2) && aux_A (t, l_b, r1, r2) in
    function r1 -> function r2 -> aux_A (A!all_to_list, B!all_to_list, r1, r2);

  local let inter_is_internal_impl = inter_is_internal_aux_A;

  local let diff_is_internal_aux_A =
    let rec aux_B (l_b, a, r1, r2) =
      match l_b with
        | [] -> false
        | h :: t -> ( relation (r1, a, h) && ~~ relation (r2, a, h) ) ||
                    aux_B (t, a, r1, r2) in
    let rec aux_A (l_a, l_b, r1, r2) =
      match l_a with
        | [] -> true
        | h :: t -> aux_B (l_b, h, r1, r2) && aux_A (t, l_b, r1, r2) in
    function r1 -> function r2 -> aux_A (A!all_to_list, B!all_to_list, r1, r2);

  local let diff_is_internal_impl = diff_is_internal_aux_A;

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;


  proof of empty_belongs_impl_correct =
    by definition of empty_belongs, empty_belongs_impl;

  proof of singleton_belongs_impl_correct =
    by property is_A_singleton_impl_correct
       definition of singleton_belongs, singleton_belongs_impl;

  proof of inter_is_internal_impl_correct = assumed; (* TODO *)
  proof of diff_is_internal_impl_correct = assumed;

  proof of left_total = assumed; (* ??? *)

end;;


species Finite_surjective_relation_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_relation_by_list (A, B), Finite_surjective_relation (A, B);

  let element = full_forced;

  local let empty_belongs_impl = false;

  local let singleton_belongs_impl (_a, _b) = is_B_singleton_impl;

  local let inter_is_internal_aux_B =
    let rec aux_A (l_a, b, r1, r2) =
      match l_a with
        | [] -> false
        | h :: t -> ( relation (r1, h, b) && relation (r2, h, b) ) ||
                    aux_A (t, b, r1, r2) in
    let rec aux_B (l_b, l_a, r1, r2) =
      match l_b with
        | [] -> true
        | h :: t -> aux_A (l_a, h, r1, r2) && aux_B (t, l_a, r1, r2) in
    function r1 -> function r2 -> aux_B (B!all_to_list, A!all_to_list, r1, r2);

  local let inter_is_internal_impl = inter_is_internal_aux_B;

  local let diff_is_internal_aux_B =
    let rec aux_A (l_a, b, r1, r2) =
      match l_a with
        | [] -> false
        | h :: t -> ( relation (r1, h, b) && ~~ relation (r2, h, b) ) ||
                    aux_A (t, b, r1, r2) in
    let rec aux_B (l_b, l_a, r1, r2) =
      match l_b with
        | [] -> true
        | h :: t -> aux_A (l_a, h, r1, r2) && aux_B (t, l_a, r1, r2) in
    function r1 -> function r2 -> aux_B (B!all_to_list, A!all_to_list, r1, r2);

  local let diff_is_internal_impl = diff_is_internal_aux_B;

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;


  proof of empty_belongs_impl_correct =
    by definition of empty_belongs, empty_belongs_impl;

  proof of singleton_belongs_impl_correct =
    by property is_B_singleton_impl_correct
       definition of singleton_belongs, singleton_belongs_impl;

  proof of inter_is_internal_impl_correct = assumed; (* TODO *)
  proof of diff_is_internal_impl_correct = assumed;

  proof of right_total = assumed; (* ??? *)

end;;


species Finite_function_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_determinist_relation_by_list (A, B),
          Finite_left_total_relation_by_list (A, B),
          Finite_function (A, B);

  let element =
    let rec aux (l : list (A), acc) =
      match l with
        | [] -> acc
        | h :: t -> aux (t, (h, B!element) :: acc) in
    aux (A!all_to_list, []);

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;

end;;


species Finite_injective_function_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_function_by_list (A, B),
          Finite_injective_relation_by_list (A, B),
          Finite_injective_function (A, B);

  let element =
    let rec aux (l_a : list (A), l_b : list (B), acc) =
      match l_a with
        | [] -> acc
        | a :: t_a ->
            match l_b with
              | [] -> focalize_error ("B!cardinal must be >= A!cardinal")
              | b :: t_b -> aux (t_a, t_b, (a, b) :: acc) in
    aux (A!all_to_list, B!all_to_list, []);

  local let full_belongs_impl = is_A_singleton_impl && is_B_singleton_impl;

  local let union_is_internal_impl (r1, r2) =
    union_is_internal_aux_A (r1, r2) && union_is_internal_aux_B (r1, r2);

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;


  proof of full_belongs_impl_correct =
    by property is_A_singleton_impl_correct, is_B_singleton_impl_correct
       definition of full_belongs, full_belongs_impl;

  proof of union_is_internal_impl_correct = assumed;

end;;


species Finite_surjective_function_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_function_by_list (A, B),
          Finite_surjective_relation_by_list (A, B),
          Finite_surjective_function (A, B);

  let element =
    let rec aux_A (l_a : list (A), b : B, acc) =
      match l_a with
        | [] -> acc
        | h :: t -> aux_A (t, b, (h, b) :: acc) in
    let rec aux_B (l_b : list (B), l_a : list (A)) =
      match l_b with
        | [] -> focalize_error ("B should not be empty")
        | [b] -> aux_A (l_a, b, [])
        | h :: t -> (A!element, h) :: aux_B (t, l_a) in
    aux_B (B!all_to_list, A!all_to_list);

  local let singleton_belongs_impl (_a, _b) =
    is_A_singleton_impl && is_B_singleton_impl;

  local let inter_is_internal_impl (r1, r2) =
    inter_is_internal_aux_A (r1, r2) && inter_is_internal_aux_B (r1, r2);

  local let diff_is_internal_impl (r1, r2) =
    diff_is_internal_aux_A (r1, r2) && diff_is_internal_aux_B (r1, r2);

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;


  proof of singleton_belongs_impl_correct =
    by property is_A_singleton_impl_correct, is_B_singleton_impl_correct
       definition of singleton_belongs, singleton_belongs_impl;

  proof of inter_is_internal_impl_correct = assumed; (* TODO *)
  proof of diff_is_internal_impl_correct = assumed;

end;;


species Finite_bijection_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_injective_function_by_list (A, B),
          Finite_surjective_function_by_list (A, B),
          Finite_bijection (A, B);

  let element =
    let rec aux (l_a : list (A), l_b : list (B), acc) =
      match l_a with
        | [] -> acc
        | a :: t_a ->
            match l_b with
              | [] -> focalize_error ("B!cardinal must be equal to A!cardinal")
              | b :: t_b -> aux (t_a, t_b, (a, b) :: acc) in
    aux (A!all_to_list, B!all_to_list, []);

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;

end;;







  (* Tests *)


type subject = | S0 | S1 | S2;;

species Subject_test =

  inherit Finite_set;

  representation = subject;

  let s0 : Self = S0;
  let s1 : Self = S1;
  let s2 : Self = S2;

  let cardinal = 3;
  let all_to_list = [S0; S1; S2];

  let element = s0;
  let equal (s_1, s_2) = s_1 = s_2;
  let print (s) =
    match s with
      | S0 -> "s0" | S1 -> "s1" | S2 -> "s2";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

