open "basics";;
open "sets";;
open "finite_sets_f";;


(** an entity of Relation is one relation between A and B *)
species Relation(A is Setoid, B is Setoid) =
  inherit Basic_object;
  signature relation: A -> B -> bool;
end;;

(** entities of Binary_relations are binary relations *)

species Binary_relations(A is Setoid, B is Setoid) =

  inherit Basic_object ;

  signature relation: Self -> A -> B -> bool;
  
  signature is_contained: Self -> Self -> bool ;

  property is_contained_spec: all r_1 r_2: Self, 
        is_contained(r_1, r_2) 
   <->  all a: A, all b: B, 
         relation(r_1, a, b) -> relation(r_2, a, b);

end;;

species Composition_relations(A is Setoid, B is Setoid, C is Setoid, 
                              R_AB is Binary_relations(A, B),
                              R_BC is Binary_relations(B, C)) =
 inherit Binary_relations(A, C);

 signature compose_rel : R_AB -> R_BC -> Self;

(* There is an incredible (ununderstandable) typing bug ! 
 property compose_rel_spec : 
    all r1: R_AB, all r2: R_BC, all a: A, all c: C, 
         relation(compose_rel(r1, r2), a, c)
     <-> (ex b: B, (R_AB!relation(r1, a, b) /\ R_BC!relation(r2, b, c))) 
 ;
*)

end;;

species Binary_rel_over(A is Setoid)=
inherit Binary_relations(A, A);
signature rt_closure : Self -> Self;

property rt_closure_spec : all r: Self, all a1 a2: A,
                        relation(rt_closure(r), a1, a2) 
                        <-> ( A!equal(a1, a2) \/
                              (ex a3: A, (relation(r, a1, a3) /\ relation(rt_closure(r), a3, a2))));

(* theorem closure_is_reflexive : recuper les  def de reflexive, teransitve  et les utiliser pour ecrire les theoremes
qui disent que la closure est reflexive et transitive *)

end;;

species Abstract_pairs(A is Setoid, B is Setoid) =

  inherit Setoid;

  signature first: Self -> A;
  signature second: Self -> B;

  signature make: A -> B -> Self;

  property is_first : all a: A, all b: B,
    A!equal(first(make(a, b)), a);

  property is_second : all a: A, all b: B, 
    B!equal(second(make(a, b)), b);

  let equal(x, y) = A!equal(first(x), first(y)) &&
                    B!equal(second(x), second(y)) ;

  theorem equal_spec: all x y: Self,
        !equal(x, y) 
   <-> ( A!equal(first(x), first(y)) /\
         B!equal(second(x), second(y)) )
     proof = by definition of equal;

  proof of equal_reflexive =
    by property equal_spec,
	        A!equal_reflexive, B!equal_reflexive
  ;

  proof of equal_symmetric =
   by property equal_spec,
               A!equal_symmetric, B!equal_symmetric
  ;

  proof of equal_transitive =
      by property equal_spec,
	          A!equal_transitive, B!equal_transitive
  ;

end;;

species Relations_by_sets_of_pairs(A is Setoid, B is Setoid,
                                     T is Abstract_pairs(A, B),
                                     P is Finite_parts(T)) =

  inherit Binary_relations(A, B);

  representation = P;

  let set_as_relation(s: P): Self = s;

  let relation(r, a, b) = P!belongs(T!make(a, b), r);

  let is_contained(r_1, r_2) = P!is_contained(r_1, r_2);

  proof of is_contained_spec = 
    <1>1 assume r_1 r_2: Self, 
         prove is_contained(r_1, r_2) <-> 
           (all a: A, all b: B, 
              P!belongs(T!make(a, b), r_1) -> 
                   P!belongs(T!make(a, b), r_2))
         <2>1 hypothesis C: is_contained(r_1, r_2),
              prove all a: A, all b: B,
                P!belongs(T!make(a, b), r_1) ->
                  P!belongs(T!make(a, b), r_2)
              <3>1 assume a: A, assume b: B, 
                   hypothesis H: P!belongs(T!make(a, b), r_1),
                   prove P!belongs(T!make(a, b), r_2)
                   by hypothesis H, C 
                      definition of is_contained, relation
                      property P!is_contained_spec
              <3>f conclude
         <2>2 hypothesis I: all a: A, all b: B, 
                  (P!belongs(T!make(a, b), r_1) -> 
                           P!belongs(T!make(a, b), r_2)),
              prove is_contained(r_1, r_2)
              <3>1 prove all a: A, all b: B, 
                    P!belongs(T!make(a, b), r_1) -> 
                       P!belongs(T!make(a, b), r_2)
                   by hypothesis I
              <3>2 prove all t: T, P!belongs(t, r_1) -> P!belongs(t, r_2)
                   <4>1 assume t: T,
                        hypothesis H: P!belongs(t, r_1),
                        prove P!belongs(t, r_2)
                        <5>0 prove T!equal(t, T!make(T!first(t),
                                                     T!second(t)))
                             by property T!is_first, T!is_second, 
                                         T!equal_spec, 
                                         A!equal_reflexive,
                                         A!equal_symmetric,
                                         A!equal_transitive,
                                         B!equal_reflexive,
                                         B!equal_symmetric,
                                         B!equal_transitive
                        <5>1 prove P!belongs(T!make(T!first(t),
                                                    T!second(t)),
                                             r_1)
                             by hypothesis H 
                                step <5>0 
                                property P!belongs_left_substitution_rule
                        <5>2 prove P!belongs(T!make(T!first(t),
                                                    T!second(t)),
                                             r_2)
                             by step <5>1 hypothesis I
                        <5>f qed by step <5>0, <5>2
                                    property P!belongs_left_substitution_rule,
                                             T!equal_symmetric,
                                             T!equal_transitive

                   <4>f conclude
              <3>f qed by step <3>2 
                          property P!is_contained_spec
                          definition of relation, is_contained 
                   
         <2>f conclude
    <1>f qed by step <1>1 definition of relation, is_contained
    ;

end;;

species Composition_relations_sets_of_pair(A is Setoid, 
                                           B is Setoid,
                                           T_AB is Abstract_pairs(A, B),
                                           P_AB is Finite_parts(T_AB), 
                                           C is Setoid,
                                           T_BC is Abstract_pairs(B, C),
                                           P_BC is Finite_parts(T_BC),
                                           R_AB is Relations_by_sets_of_pairs(A, B, T_AB, P_AB),
                                           R_BC is Relations_by_sets_of_pairs(B, C, T_BC, P_BC),
                                           T_AC is Abstract_pairs(A, C),
                                           P_AC is Finite_parts(T_AC)) =
inherit Relations_by_sets_of_pairs(A, C, T_AC, P_AC), Composition_relations(A, B, C, R_AB, R_BC);

(* Theo ... c est comme le code caml de li214 *)

end;;








species Pairs_by_pairs(A is Setoid, B is Setoid) =
 inherit Abstract_pairs(A, B) ;
 representation = A * B ;
 let first (t: Self) = fst(t) ;  
 let second (t: Self) = snd(t);
 let make(a, b):Self = pair(a, b);

 let element = pair(A!element, B!element);

 proof of is_first = assumed;
 proof of is_second = assumed;

end;;


(** entities of Ternary_relations are ternary relations *)

species Ternary_relations(A is Setoid, B is Setoid, C is Setoid) =

  inherit Basic_object ;

  signature relation: Self -> A -> B -> C -> bool;

  signature is_contained: Self -> Self -> bool ;

  property is_contained_spec: all r_1 r_2: Self, 
        is_contained(r_1, r_2) 
   <->  all a: A, all b: B, all c: C, 
         relation(r_1, a, b, c) -> relation(r_2, a, b, c);

end;;

species Abstract_triple(A is Setoid, B is Setoid, C is Setoid) =

  inherit Setoid;

  signature first: Self -> A;
  signature second: Self -> B;
  signature third: Self -> C;

  signature make: A -> B -> C -> Self;

  property is_first : all a: A, all b: B, all c: C,
    A!equal(first(make(a, b, c)), a);

  property is_second : all a: A, all b: B, all c: C,
    B!equal(second(make(a, b, c)), b);

  property is_third : all a: A, all b: B, all c: C,
    C!equal(third(make(a, b, c)), c);

  let equal(x, y) = A!equal(first(x), first(y)) &&
                    B!equal(second(x), second(y)) &&
                    C!equal(third(x), third(y));

  theorem equal_spec: all x y: Self,
        !equal(x, y) 
   <-> ( A!equal(first(x), first(y)) /\
         B!equal(second(x), second(y)) /\
         C!equal(third(x), third(y)) )
     proof = by definition of equal;

  proof of equal_reflexive =
    by property equal_spec,
	        A!equal_reflexive, B!equal_reflexive, C!equal_reflexive	
  ;

  proof of equal_symmetric =
   by property equal_spec,
               A!equal_symmetric, B!equal_symmetric, C!equal_symmetric
  ;

  proof of equal_transitive =
      by property equal_spec,
	          A!equal_transitive, B!equal_transitive, C!equal_transitive
  ;

end;;

species Relations_by_sets_of_triples(A is Setoid, B is Setoid, C is Setoid,
                                     T is Abstract_triple(A, B, C),
                                     P is Finite_parts(T)) =

  inherit Ternary_relations(A, B, C);

  representation = P;

  let set_as_relation(s: P): Self = s;

  let relation(r, a, b, c) = P!belongs(T!make(a, b, c), r);

  let is_contained(r_1, r_2) = P!is_contained(r_1, r_2);

  proof of is_contained_spec = 
    <1>1 assume r_1 r_2: Self, 
         prove is_contained(r_1, r_2) <-> 
           (all a: A, all b: B, all c: C,
              P!belongs(T!make(a, b, c), r_1) -> 
                   P!belongs(T!make(a, b, c), r_2))
         <2>1 hypothesis C: is_contained(r_1, r_2),
              prove all a: A, all b: B, all  c: C,
                P!belongs(T!make(a, b, c), r_1) ->
                  P!belongs(T!make(a, b, c), r_2)
              <3>1 assume a: A, assume b: B, assume c: C,
                   hypothesis H: P!belongs(T!make(a, b, c), r_1),
                   prove P!belongs(T!make(a, b, c), r_2)
                   by hypothesis H, C
                      definition of is_contained, relation
                      property P!is_contained_spec
              <3>f conclude
         <2>2 hypothesis I: all a: A, all b: B, all c: C,
                  (P!belongs(T!make(a, b, c), r_1) -> 
                           P!belongs(T!make(a, b, c), r_2)),
              prove is_contained(r_1, r_2)
              <3>1 prove all a: A, all b: B, all c: C,
                    P!belongs(T!make(a, b, c), r_1) -> 
                       P!belongs(T!make(a, b, c), r_2)
                   by hypothesis I
              <3>2 prove all t: T, P!belongs(t, r_1) -> P!belongs(t, r_2)
                   <4>1 assume t: T,
                        hypothesis H: P!belongs(t, r_1),
                        prove P!belongs(t, r_2)
                        <5>0 prove T!equal(t, T!make(T!first(t),
                                                     T!second(t),
                                                     T!third(t)))
                             by property T!is_first, T!is_second, T!is_third,
                                         T!equal_spec, 
                                         A!equal_reflexive,
                                         A!equal_symmetric,
                                         A!equal_transitive,
                                         B!equal_reflexive,
                                         B!equal_symmetric,
                                         B!equal_transitive,
                                         C!equal_reflexive,
                                         C!equal_symmetric,
                                         C!equal_transitive
                        <5>1 prove P!belongs(T!make(T!first(t),
                                                    T!second(t),
                                                    T!third(t)),
                                             r_1)
                             by hypothesis H 
                                step <5>0 
                                property P!belongs_left_substitution_rule
                        <5>2 prove P!belongs(T!make(T!first(t),
                                                    T!second(t),
                                                    T!third(t)),
                                             r_2)
                             by step <5>1 hypothesis I
                        <5>f qed by step <5>0, <5>2
                                    property P!belongs_left_substitution_rule,
                                             T!equal_symmetric,
                                             T!equal_transitive

                   <4>f conclude
              <3>f qed by step <3>2 
                          property P!is_contained_spec
                          definition of relation, is_contained 
                   
         <2>f conclude
    <1>f qed by step <1>1 definition of relation, is_contained
    ;

end;;


species Triples_by_pairs(A is Setoid, B is Setoid, C is Setoid) =
 inherit Abstract_triple(A, B, C) ;
 representation = (A * B) * C ;
 let first (t: Self) = fst(fst(t)) ;  
 let second (t: Self) = snd(fst(t));
 let third (t:Self) = snd(t);
 let make(a, b, c):Self = pair(pair(a, b), c);

 let element = pair(pair(A!element, B!element), C!element);

 proof of is_first = assumed;
 proof of is_second = assumed;
 proof of is_third = assumed;


end;;

