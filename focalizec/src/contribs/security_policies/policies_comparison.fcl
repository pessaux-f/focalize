open "finite_sets";;
open "p_policies";;
open "interp_policies";;

species Policy_order(A1 is Target, C1 is Configuration, P1 is P_policy(A1, C1),
                     A2 is Target, C2 is Configuration, P2 is P_policy(A2, C2),
                     I is Target_Interpretation(A1,A2),
                     F2 is Finite_parts(A2),
                     C is Interpreted_configurations_by_parts(C1, A2, F2), 
                     IP1 is Interpreted_P_policy(A1, C1, P1, A2, I, F2, C)) =

  logical let equiv_config(c:C, c2:C2) = all t : A2, IP1!secure(t, c) <-> P2!secure(t, c2);

  theorem equiv_config_spec : all c:C, all c2:C2,  
                              equiv_config(c, c2) <-> (all t : A2, IP1!secure(t, c) <-> P2!secure(t, c2))
  proof = by definition of equiv_config;

(*  logical let leq = all c : C, ex c2 : C2, equiv_config(c, c2); *)

end;;


species Policy_order_is_leq(A1 is Target, C1 is Configuration, P1 is P_policy(A1, C1),
                            A2 is Target, C2 is Configuration, P2 is P_policy(A2, C2),
                            I is Target_Interpretation(A1,A2),
                            F2 is Finite_parts(A2),
                            C is Interpreted_configurations_by_parts(C1, A2, F2), 
                            IP1 is Interpreted_P_policy(A1, C1, P1, A2, I, F2, C)) =
  inherit Policy_order(A1, C1, P1, A2, C2, P2, I, F2, C, IP1);

  property leq : all c : C, ex c2 : C2, equiv_config(c, c2); 

end;;


species Policy_order_not_leq(A1 is Target, C1 is Configuration, P1 is P_policy(A1, C1),
                             A2 is Target, C2 is Configuration, P2 is P_policy(A2, C2),
                             I is Target_Interpretation(A1,A2),
                             F2 is Finite_parts(A2),
                             C is Interpreted_configurations_by_parts(C1, A2, F2), 
                             IP1 is Interpreted_P_policy(A1, C1, P1, A2, I, F2, C)) =
  inherit Policy_order(A1, C1, P1, A2, C2, P2, I, F2, C, IP1);

  property not_leq : ex c : C, all c2 : C2, ~ (equiv_config(c, c2)); 

end;;