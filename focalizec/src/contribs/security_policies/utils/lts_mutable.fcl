open "basics";;
open "sets";;


(** Mutable labelled transition system *)


species State =

  inherit Setoid;

  signature is_initial : Self -> bool;

end;;


species Label = inherit Setoid; end;;


(** Species of transition systems in all states S and labels L *)
species Transition_system (S is State, L is Label) =

  inherit Basic_object;

  (** transition relation *)
  signature delta : Self -> S -> L -> S -> bool;

  signature add_trans : Self -> S -> L -> S -> Self;
  signature remove_trans : Self -> S -> L -> S -> Self;

  local let ( =S ) = S!equal;
  local let ( =L ) = L!equal;

  property add_trans_spec :
    all s : Self, all x1 x2 y1 y2 : S, all l1 l2 : L,
    delta (add_trans (s, x1, l1, y1), x2, l2, y2) ->
    ( (x1 =S x2 /\ l1 =L l2 /\ y1 =S y2) \/ delta (s, x2, l2, y2) );

  property remove_trans_spec :
    all s : Self, all x1 x2 y1 y2 : S, all l1 l2 : L,
    delta (remove_trans (s, x1, l1, y1), x2, l2, y2) ->
    ( ~(x1 =S x2 /\ l1 =L l2 /\ y1 =S y2) /\ delta (s, x2, l2, y2) );

  logical let is_determinist (s) =
    all x y z : S, all l : L,
    ( delta (s, x, l, y) /\ delta (s, x, l, z) ) -> y =S z;

  logical let is_complete (s) =
    all x : S, all l : L,
    ex y : S, delta (s, x, l, y);

  (* intuitive definition *)

  (* logical let rec is_descendant (s, y, x) = *)
  (*   y =S x \/ *)
  (*   ex z : S, ex l : L, delta (s, x, l, z) /\ is_descendant (s, y, z); *)

  (* logical let is_reachable (s, x) = *)
  (*   ex y : S, S!is_initial (y) /\ is_descendant (s, x, y); *)

  (** The list represents the sequence of transitions of the path in
      reverse. *)
  let is_path_from_init_to =
    let rec aux (p, x, s) =
      match p with
        | [] -> S!is_initial (x)
        | (y, l, z) :: q -> z =S x && delta (s, y, l, z) && aux (q, y, s) in
    function s -> function p -> function x -> aux (p, x, s);

  logical let is_reachable (s, x) =
    ex p : list (S * L * S), is_path_from_init_to (s, p, x);

end;;



species Transition_system_by_fun (S is State, L is Label) =

  inherit Transition_system (S, L);

  representation = S -> L -> S -> bool;

  (** constructor *)
  let make (d : S -> L -> S -> bool) : Self = d;
  let delta (s : Self) : S -> L -> S -> bool = s;
  let add_trans (s, x1, l1, y1, x2, l2, y2) =
    ( x2 =S x1 && l2 =L l1 && y2 =S y1 ) || delta (s, x2, l2, y2);
  let remove_trans (s, x1, l1, y1, x2, l2, y2) =
    ~~( x2 =S x1 && l2 =L l1 && y2 =S y1 ) && delta (s, x2, l2, y2);

  theorem make_spec :
    all d : S -> L -> S -> bool, all x y : S, all l : L,
    delta (make (d), x, l, y) = d (x, l, y)
  proof = assumed;                    (* TODO *)

  proof of add_trans_spec = assumed;  (* TODO *)
  proof of remove_trans_spec = assumed;

end;;




(* (\* Tests *\) *)

(* (\* Parity automate *\) *)

(* type parity = | Even | Odd;; *)

(* species Parity_State = *)

(*   inherit State; *)

(*   representation = parity; *)

(*   let even : Self = Even; *)
(*   let odd : Self = Odd; *)

(*   let to_int (x : Self) = match x with | Even -> 0 | Odd -> 1; *)

(*   let is_initial (x) = x = Even; *)
(*   let element = Even; *)
(*   let equal (x, y) = x = y; *)
(*   let print (x) = match x with | Even -> "even" | Odd -> "odd"; *)

(*   proof of equal_reflexive = by definition of equal; *)
(*   proof of equal_symmetric = by definition of equal; *)
(*   proof of equal_transitive = by definition of equal; *)

(* end;; *)

(* collection S = implement Parity_State; end;; *)


(* species Parity_Label = *)

(*   inherit Label; *)

(*   representation = int; *)

(*   let value (l : Self) : int = l; *)

(*   let element = 0; *)
(*   let equal = ( = ); *)
(*   let print = string_of_int; *)
(*   let parse = int_of_string; *)

(*   proof of equal_reflexive = assumed; (\* by definition of equal; *\) *)
(*   proof of equal_symmetric = assumed; (\* by definition of equal; *\) *)
(*   proof of equal_transitive = assumed; (\* by definition of equal; *\) *)

(* end;; *)

(* collection L = implement Parity_Label; end;; *)

(* collection Parity_System = *)
(*   implement Transition_system_by_fun (S, L); end;; *)


(* let delta (x, l, y) = abs0x ((S!to_int (x) + L!value (l)) % 2) = S!to_int (y);; *)

(* let sys = Parity_System!make (delta);; *)


(* let test (s, x, l, y) = *)
(*   let _0 = *)
(*     print_string (S!print (x) ^ " -[" ^ L!print (l) ^ "]-> " ^ S!print (y)) in *)
(*   if Parity_System!delta (s, x, l, y) then print_string (" OK\n") *)
(*   else print_string (" KO\n");; *)


(* test (sys, S!even, L!parse ("42"), S!even);; *)
(* test (sys, S!even, L!parse ("42"), S!odd);; *)
(* test (sys, S!odd, L!parse ("42"), S!odd);; *)
(* test (sys, S!odd, L!parse ("42"), S!even);; *)

(* test (sys, S!even, L!parse ("1337"), S!even);; *)
(* test (sys, S!even, L!parse ("1337"), S!odd);; *)
(* test (sys, S!odd, L!parse ("1337"), S!odd);; *)
(* test (sys, S!odd, L!parse ("1337"), S!even);; *)

(* test (sys, S!even, L!parse ("0"), S!even);; *)
(* test (sys, S!even, L!parse ("0"), S!odd);; *)
(* test (sys, S!odd, L!parse ("0"), S!odd);; *)
(* test (sys, S!odd, L!parse ("0"), S!even);; *)

(* test (sys, S!even, L!parse ("-1"), S!even);; *)
(* test (sys, S!even, L!parse ("-1"), S!odd);; *)
(* test (sys, S!odd, L!parse ("-1"), S!odd);; *)
(* test (sys, S!odd, L!parse ("-1"), S!even);; *)

(* let sys1 = Parity_System!add_trans (sys, S!even, L!parse ("0"), S!odd);; *)
(* let sys2 = Parity_System!remove_trans (sys1, S!odd, L!parse ("0"), S!odd);; *)

(* test (sys2, S!even, L!parse ("0"), S!even);; *)
(* test (sys2, S!even, L!parse ("0"), S!odd);; *)
(* test (sys2, S!odd, L!parse ("0"), S!odd);; *)
(* test (sys2, S!odd, L!parse ("0"), S!even);; *)
