open "basics";;
open "sets";;
open "products";;
open "finite_sets";;


(** Binary relation *)


(** A : domain, B : codomain *)
species Relation (A is Setoid, B is Setoid) =

  inherit Partial_set;

  signature relation : Self -> A -> B -> bool;

  signature empty : unit -> Self;

  (** Statement for the empty relation being element of Self *)
  logical let empty_belongs = true;

  signature complete : unit -> Self;

  (** Statement for the complete relation being element of Self *)
  logical let complete_belongs = true;

  signature singleton : A -> B -> Self;

  (** Statement for the singleton relation being element of Self *)
  logical let singleton_belongs (_a : A, _b : B) = true;

  signature union : Self -> Self -> Self;

  (** Statement describing when union is a composition law *)
  logical let union_is_internal (_r1 : Self, _r2 : Self) = true;

  signature inter : Self -> Self -> Self;

  (** Statement describing when inter is a composition law *)
  logical let inter_is_internal (_r1 : Self, _r2 : Self) = true;

  signature diff : Self -> Self -> Self;

  (** Statement describing when diff is a composition law *)
  logical let diff_is_internal (_r1 : Self, _r2 : Self) = true;


  logical let is_A_singleton = all a : A, A!equal (a, A!element);
  logical let is_B_singleton = all b : B, B!equal (b, B!element);


  property equal_spec :
    all r1 r2 : Self,
    equal (r1, r2) <-> all a : A, all b : B,
                       relation (r1, a, b) = relation (r2, a, b);

  proof of equal_reflexive = by property equal_spec;
  proof of equal_symmetric = by property equal_spec;
  proof of equal_transitive = by property equal_spec;

  property empty_spec :
    empty_belongs ->
      all a : A, all b : B, ~ relation (empty (()), a, b);

  property complete_spec :
    complete_belongs ->
      all a : A, all b : B, relation (complete (()), a, b);

  property singleton_spec :
    all a1 : A, all b1 : B,
    singleton_belongs (a1, b1) ->
      all a2 : A, all b2 : B,
      relation (singleton (a1, b1), a2, b2) <->
      ( A!equal (a1, a2) && B!equal (b1, b2) );

  property union_spec :
    all r1 r2 : Self,
    union_is_internal (r1, r2) ->
      all a : A, all b : B,
      relation (union (r1, r2), a, b) <->
      ( relation (r1, a, b) \/ relation (r2, a, b) );

  property inter_spec :
    all r1 r2 : Self,
    inter_is_internal (r1, r2) ->
      all a : A, all b : B,
      relation (inter (r1, r2), a, b) <->
      ( relation (r1, a, b) /\ relation (r2, a, b) );

  property diff_spec :
    all r1 r2 : Self,
    diff_is_internal (r1, r2) ->
      all a : A, all b : B,
      relation (diff (r1, r2), a, b) <->
      ( relation (r1, a, b) /\ ~ relation (r2, a, b) );


  logical let is_left_unique (r) =
    all a1 a2 : A, all b : B,
    ( relation (r, a1, b) /\ relation (r, a2, b) ) -> A!equal (a1, a2);

  logical let is_right_unique (r) =
    all a : A, all b1 b2 : B,
    ( relation (r, a, b1) /\ relation (r, a, b2) ) -> B!equal (b1, b2);

  logical let is_left_total (r) =
    all a : A, ex b : B, relation (r, a, b);

  logical let is_right_total (r) =
    all b : B, ex a : A, relation (r, a, b);

end;;


species Injective_relation (A is Setoid, B is Setoid) =

  inherit Relation (A, B);

  property left_unique : all r : Self, is_left_unique (r);


  (** A can't be empty *)
  logical let complete_belongs = is_A_singleton;

  logical let union_is_internal (r1, r2) =
    all a1 a2 : A, all b : B,
    ( relation (r1, a1, b) /\ relation (r2, a2, b) ) -> A!equal (a1, a2);


  theorem left_unique_empty :
    empty_belongs -> is_left_unique (empty (()))
  proof = assumed;            (* TODO *)

  theorem left_unique_complete :
    complete_belongs -> is_left_unique (complete (()))
  proof = assumed;            (* TODO *)

  theorem left_unique_singleton :
    all a : A, all b : B,
    singleton_belongs (a, b) -> is_left_unique (singleton (a, b))
  proof = assumed;            (* TODO *)

  theorem left_unique_union :
    all r1 r2 : Self,
    union_is_internal (r1, r2) -> is_left_unique (union (r1, r2))
  proof = assumed;            (* TODO *)

  theorem left_unique_inter :
    all r1 r2 : Self,
    inter_is_internal (r1, r2) -> is_left_unique (inter (r1, r2))
  proof = assumed;            (* TODO *)

  theorem left_unique_diff :
    all r1 r2 : Self,
    diff_is_internal (r1, r2) -> is_left_unique (diff (r1, r2))
  proof = assumed;            (* TODO *)

end;;


species Determinist_relation (A is Setoid, B is Setoid) =

  inherit Relation (A, B);

  property right_unique : all r : Self, is_right_unique (r);


  logical let complete_belongs = is_B_singleton;

  logical let union_is_internal (r1, r2) =
    all a : A, all b1 b2 : B,
    ( relation (r1, a, b1) /\ relation (r2, a, b2) ) -> B!equal (b1, b2);


  theorem right_unique_empty :
    empty_belongs -> is_right_unique (empty (()))
  proof = assumed;            (* TODO *)

  theorem right_unique_complete :
    complete_belongs -> is_right_unique (complete (()))
  proof = assumed;            (* TODO *)

  theorem right_unique_singleton :
    all a : A, all b : B,
    singleton_belongs (a, b) -> is_right_unique (singleton (a, b))
  proof = assumed;            (* TODO *)

  theorem right_unique_union :
    all r1 r2 : Self,
    union_is_internal (r1, r2) -> is_right_unique (union (r1, r2))
  proof = assumed;            (* TODO *)

  theorem right_unique_inter :
    all r1 r2 : Self,
    inter_is_internal (r1, r2) -> is_right_unique (inter (r1, r2))
  proof = assumed;            (* TODO *)

  theorem right_unique_diff :
    all r1 r2 : Self,
    diff_is_internal (r1, r2) -> is_right_unique (diff (r1, r2))
  proof = assumed;            (* TODO *)

end;;


species Left_total_relation (A is Setoid, B is Setoid) =

  inherit Relation (A, B);

  property left_total : all r : Self, is_left_total (r);


  logical let empty_belongs = false;

  logical let singleton_belongs (_a, _b) = is_A_singleton;

  logical let inter_is_internal (r1, r2) =
    all a : A, ex b : B, relation (r1, a, b) /\ relation (r2, a, b);

  logical let diff_is_internal (r1, r2) =
    all a : A, ex b : B, relation (r1, a, b) /\ ~ relation (r2, a, b);


  theorem left_total_empty :
    empty_belongs -> is_left_total (empty (()))
  proof = assumed;            (* TODO *)

  theorem left_total_complete :
    complete_belongs -> is_left_total (complete (()))
  proof = assumed;            (* TODO *)

  theorem left_total_singleton :
    all a : A, all b : B,
    singleton_belongs (a, b) -> is_left_total (singleton (a, b))
  proof = assumed;            (* TODO *)

  theorem left_total_union :
    all r1 r2 : Self,
    union_is_internal (r1, r2) -> is_left_total (union (r1, r2))
  proof = assumed;            (* TODO *)

  theorem left_total_inter :
    all r1 r2 : Self,
    inter_is_internal (r1, r2) -> is_left_total (inter (r1, r2))
  proof = assumed;            (* TODO *)

  theorem left_total_diff :
    all r1 r2 : Self,
    diff_is_internal (r1, r2) -> is_left_total (diff (r1, r2))
  proof = assumed;            (* TODO *)

end;;


species Surjective_relation (A is Setoid, B is Setoid) =

  inherit Relation (A, B);

  property right_total : all r : Self, is_right_total (r);


  logical let empty_belongs = false;

  logical let singleton_belongs (_a, _b) = is_B_singleton;

  logical let inter_is_internal (r1, r2) =
    all b : B, ex a : A, relation (r1, a, b) /\ relation (r2, a, b);

  logical let diff_is_internal (r1, r2) =
    all b : B, ex a : A, relation (r1, a, b) /\ ~ relation (r2, a, b);


  theorem right_total_empty :
    empty_belongs -> is_right_total (empty (()))
  proof = assumed;            (* TODO *)

  theorem right_total_complete :
    complete_belongs -> is_right_total (complete (()))
  proof = assumed;            (* TODO *)

  theorem right_total_singleton :
    all a : A, all b : B,
    singleton_belongs (a, b) -> is_right_total (singleton (a, b))
  proof = assumed;            (* TODO *)

  theorem right_total_union :
    all r1 r2 : Self,
    union_is_internal (r1, r2) -> is_right_total (union (r1, r2))
  proof = assumed;            (* TODO *)

  theorem right_total_inter :
    all r1 r2 : Self,
    inter_is_internal (r1, r2) -> is_right_total (inter (r1, r2))
  proof = assumed;            (* TODO *)

  theorem right_total_diff :
    all r1 r2 : Self,
    diff_is_internal (r1, r2) -> is_right_total (diff (r1, r2))
  proof = assumed;            (* TODO *)

end;;


species Function (A is Setoid, B is Setoid) =

  inherit Determinist_relation (A, B), Left_total_relation (A, B);

end;;


species Injective_function (A is Setoid, B is Setoid) =

  inherit Function (A, B), Injective_relation (A, B);

  logical let complete_belongs = is_A_singleton /\ is_B_singleton;

  logical let union_is_internal (r1, r2) =
    all a1 a2 : A, all b1 b2 : B,
    (( relation (r1, a1, b1) /\ relation (r2, a2, b1) ) -> A!equal (a1, a2)) /\
    (( relation (r1, a1, b1) /\ relation (r2, a1, b2) ) -> B!equal (b1, b2));

  (* Les preuves suivantes devraient etre cassees (??) *)

  (* proof of left_unique_complete = assumed; (\* TODO *\) *)
  (* proof of left_total_complete = assumed; *)
  (* proof of right_total_complete = assumed; *)

  (* proof of left_unique_union = assumed; (\* TODO *\) *)
  (* proof of left_total_union = assumed; *)
  (* proof of right_total_union = assumed; *)

end;;


species Surjective_function (A is Setoid, B is Setoid) =

  inherit Function (A, B), Surjective_relation (A, B);

  logical let singleton_belongs (_a, _b) = is_A_singleton /\ is_B_singleton;

  logical let inter_is_internal (r1, r2) =
    ( all a : A, ex b : B, relation (r1, a, b) /\ relation (r2, a, b) ) /\
    ( all b : B, ex a : A, relation (r1, a, b) /\ relation (r2, a, b) );

  logical let diff_is_internal (r1, r2) =
    ( all a : A, ex b : B, relation (r1, a, b) /\ ~ relation (r2, a, b) ) /\
    ( all b : B, ex a : A, relation (r1, a, b) /\ ~ relation (r2, a, b) );

  (* Les preuves suivantes devraient etre cassees (??) *)

  (* proof of left_unique_singleton = assumed; (\* TODO *\) *)
  (* proof of left_total_singleton = assumed; *)
  (* proof of right_total_singleton = assumed; *)

  (* proof of left_unique_inter = assumed; (\* TODO *\) *)
  (* proof of left_total_inter = assumed; *)
  (* proof of right_total_inter = assumed; *)

  (* proof of left_unique_diff = assumed; (\* TODO *\) *)
  (* proof of left_total_diff = assumed; *)
  (* proof of right_total_diff = assumed; *)

end;;


species Bijection (A is Setoid, B is Setoid) =

  inherit Injective_function (A, B), Surjective_function (A, B);

end;;




(** Finites relations *)


species Finite_relation (A is Finite_set, B is Finite_set) =
  inherit Relation (A, B), Finite_set; end;;


species Finite_injective_relation (A is Finite_set, B is Finite_set) =
  inherit Injective_relation (A, B), Finite_set; end;;


species Finite_determinist_relation (A is Finite_set, B is Finite_set) =
  inherit Determinist_relation (A, B), Finite_set; end;;


species Finite_left_total_relation (A is Finite_set, B is Finite_set) =
  inherit Left_total_relation (A, B), Finite_set; end;;


species Finite_surjective_relation (A is Finite_set, B is Finite_set) =
  inherit Surjective_relation (A, B), Finite_set; end;;


species Finite_function (A is Finite_set, B is Finite_set) =
  inherit Function (A, B), Finite_set; end;;


species Finite_injective_function (A is Finite_set, B is Finite_set) =
  inherit Injective_function (A, B), Finite_set;

  (** The species must be non empty *)
  property card_A_leq_card_B : A!cardinal <=0x B!cardinal;

end;;


species Finite_surjective_function (A is Finite_set, B is Finite_set) =
  inherit Surjective_function (A, B), Finite_set; end;;


species Finite_bijection (A is Finite_set, B is Finite_set) =
  inherit Bijection (A, B), Finite_set;

  (** The species must be non empty *)
  property card_A_eq_card_B : A!cardinal = B!cardinal;

end;;



species Finite_relation_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_relation (A, B);

  representation = list (A * B);

  let relation =
    let rec aux (r, a, b) =
      match r with
        | [] -> false
        | (a1, b1) :: t -> (A!equal (a1, a) && B!equal (b1, b)) ||
                           aux (t, a, b) in
    function r -> function a -> function b -> aux (r, a, b);


  local let empty_belongs_impl = true;
  local let complete_belongs_impl = true;
  local let singleton_belongs_impl (_a : A, _b : B) = true;
  local let union_is_internal_impl (_r1 : Self, _r2 : Self) = true;
  local let inter_is_internal_impl (_r1 : Self, _r2 : Self) = true;
  local let diff_is_internal_impl (_r1 : Self, _r2 : Self) = true;

  theorem empty_belongs_impl_correct :
    empty_belongs_impl <-> empty_belongs
  proof = by definition of empty_belongs, empty_belongs_impl;

  theorem complete_belongs_impl_correct :
    complete_belongs_impl <-> complete_belongs
  proof = by definition of complete_belongs, complete_belongs_impl;
  
  theorem singleton_belongs_impl_correct :
    all a : A, all b : B,
    singleton_belongs_impl (a, b) <-> singleton_belongs (a, b)
  proof = by definition of singleton_belongs, singleton_belongs_impl;
  
  theorem union_is_internal_impl_correct :
    all r1 r2 : Self,
    union_is_internal_impl (r1, r2) <-> union_is_internal (r1, r2)
  proof = by definition of union_is_internal, union_is_internal_impl;
  
  theorem inter_is_internal_impl_correct :
    all r1 r2 : Self,
    inter_is_internal_impl (r1, r2) <-> inter_is_internal (r1, r2)
  proof = by definition of inter_is_internal, inter_is_internal_impl;
  
  theorem diff_is_internal_impl_correct :
    all r1 r2 : Self,
    diff_is_internal_impl (r1, r2) <-> diff_is_internal (r1, r2)
  proof = by definition of diff_is_internal, diff_is_internal_impl;


  local let rev_append =
    let rec aux (l1, l2) =
      match l1 with
        | [] -> l2
        | h :: t -> aux (t, h :: l2) in
    function l1 -> function l2 -> aux (l1, l2);

  (* /!\ Must be redifined first with a valid representation ! (for failed) *)
  let element = [];

  let empty (_u) =
    if empty_belongs_impl then [] else failed ("empty not belongs");

  local let complete_forced =
    let rec aux_B (l_b : list (B), a : A, acc) =
      match l_b with
        | [] -> acc
        | h :: t -> aux_B (t, a, (a, h) :: acc) in
    let rec aux_A (l_a : list (A), l_b : list (B), acc) =
      match l_a with
        | [] -> acc
        | h :: t -> aux_A (t, l_b, rev_append (aux_B (l_b, h, []), acc)) in
    aux_A (A!all_to_list, B!all_to_list, []);

  let complete (_u) =
    if complete_belongs_impl then complete_forced
    else failed ("complete not belongs");

  let singleton (a, b) =
    if singleton_belongs_impl (a, b) then [(a, b)]
    else failed ("singleton not belongs");

  let union =
    let rec aux (r1, r2) =
      match r1 with
        | [] -> r2
        | (a, b) :: t -> if relation (r2, a, b)
                         then aux (t, r2)
                         else aux (t, (a, b) :: r2) in
    function r1 -> function r2 ->
      if union_is_internal_impl (r1, r2) then aux (r1, r2)
      else failed ("union not internal");

  let inter =
    let rec aux (r1, r2, acc) =
      match r1 with
        | [] -> acc
        | (a, b) :: t -> if relation (r2, a, b)
                         then aux (t, r2, (a, b) :: acc)
                         else aux (t, r2, acc) in
    function r1 -> function r2 ->
      if inter_is_internal_impl (r1, r2) then aux (r1, r2, [])
      else failed ("inter not internal");

  let diff =
    let rec aux (r1, r2, acc) =
      match r1 with
        | [] -> acc
        | (a, b) :: t -> if relation (r2, a, b)
                         then aux (t, r2, acc)
                         else aux (t, r2, (a, b) :: acc) in
    function r1 -> function r2 ->
      if diff_is_internal_impl (r1, r2) then aux (r1, r2, [])
      else failed ("diff not internal");

  local let contains =
    let rec aux (r2 : Self, r1 : Self) =
      match r2 with
        | [] -> true
        | (a, b) :: t -> relation (r2, a, b) && aux (t, r1) in
    function r1 -> function r2 -> aux (r2, r1);

  let equal (r1, r2) = contains (r1, r2) && contains (r2, r1);

  local let rec pow_aux (n, x, acc) =
    if n <=0x 0 then acc else pow_aux (n - 1, x, x * acc);

  local let ( ^0x ) (x, n) = pow_aux (n, x, 1);

  let cardinal = 2 ^0x (A!cardinal * B!cardinal);

  (* Pas de fonctions generiques *)
  local let rev_append_2 =
    let rec aux (l1, l2) =
      match l1 with
        | [] -> l2
        | h :: t -> aux (t, h :: l2) in
    function l1 -> function l2 -> aux (l1, l2);

  let all_to_list : list (Self) =
    (* List of lists with elements of l2 and some of l1 *)
    let rec aux (l1 : list (A * B), l2 : list (A * B)) =
      match l1 with
        | [] -> [l2]
        | h :: t -> rev_append_2 (aux (t, l2), aux (t, h :: l2)) in
    aux (complete_forced, []);

  local let is_A_singleton_impl =
    match A!all_to_list with | [_] -> true | _ -> false;

  theorem is_A_singleton_impl_correct : is_A_singleton_impl <-> is_A_singleton
    proof = assumed;            (* TODO *)

  local let is_B_singleton_impl =
    match B!all_to_list with | [_] -> true | _ -> false;

  theorem is_B_singleton_impl_correct : is_B_singleton_impl <-> is_B_singleton
    proof = assumed;            (* TODO *)

  local let print_relation =
    let rec aux (r) =
      match r with
        | [] -> "]"
        | [(a, b)] ->  "(" ^ A!print (a) ^ ", " ^ B!print (b) ^ ")]"
        | (a, b) :: t -> "(" ^ A!print (a) ^ ", " ^ B!print (b) ^ "); " ^
                         aux (t) in
    function r -> "[" ^ aux (r);

  let print = print_relation;

  proof of empty_spec = assumed; (* TODO *)
  proof of complete_spec = assumed;
  proof of singleton_spec = assumed;
  proof of union_spec = assumed;
  proof of inter_spec = assumed;
  proof of diff_spec = assumed;
  proof of equal_spec = assumed;
  proof of all_in_all_to_list = assumed;

end;;


species Finite_injective_relation_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_relation_by_list (A, B), Finite_injective_relation (A, B);

  local let complete_belongs_impl = is_A_singleton_impl;

  local let union_is_internal_aux_A =
    let rec aux_A_bis (l_a : list (A), b : B, a : A, r2) =
      match l_a with
        | [] -> true
        | h :: t -> if relation (r2, h, b)
                    then A!equal (h, a) && aux_A_bis (t, b, a, r2)
                    else aux_A_bis (t, b, a, r2) in
    let rec aux_A (l_a_r : list (A), l_a : list (A), b : B, r1, r2) =
      match l_a_r with
        | [] -> true
        | h :: t -> if relation (r1, h, b)
                    then aux_A_bis (l_a, b, h, r2) && aux_A (t, l_a, b, r1, r2)
                    else aux_A (t, l_a, b, r1, r2) in
    let rec aux_B (l_b : list (B), l_a : list (A), r1, r2) =
      match l_b with
        | [] -> true
        | h :: t -> aux_A (l_a, l_a, h, r1, r2) && aux_B (t, l_a, r1, r2) in
    function r1 -> function r2 ->
      aux_B (B!all_to_list, A!all_to_list, r1, r2);

  local let union_is_internal_impl = union_is_internal_aux_A;

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;


  proof of complete_belongs_impl_correct =
    by property is_A_singleton_impl_correct
       definition of complete_belongs, complete_belongs_impl;

  proof of union_is_internal_impl_correct = assumed; (* TODO *)

  proof of left_unique = assumed; (* ??? *)

end;;


species Finite_determinist_relation_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_relation_by_list (A, B), Finite_determinist_relation (A, B);

  local let complete_belongs_impl = is_B_singleton_impl;

  local let union_is_internal_aux_B =
    let rec aux_B_bis (l_b : list (B), a : A, b : B, r2) =
      match l_b with
        | [] -> true
        | h :: t -> if relation (r2, a, h)
                    then B!equal (h, b) && aux_B_bis (t, a, b, r2)
                    else aux_B_bis (t, a, b, r2) in
    let rec aux_B (l_b_r : list (B), l_b : list (B), a : A, r1, r2) =
      match l_b_r with
        | [] -> true
        | h :: t -> if relation (r1, a, h)
                    then aux_B_bis (l_b, a, h, r2) && aux_B (t, l_b, a, r1, r2)
                    else aux_B (t, l_b, a, r1, r2) in
    let rec aux_A (l_a : list (A), l_b : list (B), r1, r2) =
      match l_a with
        | [] -> true
        | h :: t -> aux_B (l_b, l_b, h, r1, r2) && aux_A (t, l_b, r1, r2) in
    function r1 -> function r2 ->
      aux_A (A!all_to_list, B!all_to_list, r1, r2);

  local let union_is_internal_impl = union_is_internal_aux_B;

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;


  proof of complete_belongs_impl_correct =
    by property is_B_singleton_impl_correct
       definition of complete_belongs, complete_belongs_impl;

  proof of union_is_internal_impl_correct = assumed; (* TODO *)

  proof of right_unique = assumed; (* ??? *)

end;;


species Finite_left_total_relation_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_relation_by_list (A, B), Finite_left_total_relation (A, B);

  let element = complete_forced;

  local let empty_belongs_impl = false;

  local let singleton_belongs_impl (_a, _b) = is_A_singleton_impl;

  local let inter_is_internal_aux_A =
    let rec aux_B (l_b, a, r1, r2) =
      match l_b with
        | [] -> false
        | h :: t -> ( relation (r1, a, h) && relation (r2, a, h) ) ||
                    aux_B (t, a, r1, r2) in
    let rec aux_A (l_a, l_b, r1, r2) =
      match l_a with
        | [] -> true
        | h :: t -> aux_B (l_b, h, r1, r2) && aux_A (t, l_b, r1, r2) in
    function r1 -> function r2 -> aux_A (A!all_to_list, B!all_to_list, r1, r2);

  local let inter_is_internal_impl = inter_is_internal_aux_A;

  local let diff_is_internal_aux_A =
    let rec aux_B (l_b, a, r1, r2) =
      match l_b with
        | [] -> false
        | h :: t -> ( relation (r1, a, h) && ~~ relation (r2, a, h) ) ||
                    aux_B (t, a, r1, r2) in
    let rec aux_A (l_a, l_b, r1, r2) =
      match l_a with
        | [] -> true
        | h :: t -> aux_B (l_b, h, r1, r2) && aux_A (t, l_b, r1, r2) in
    function r1 -> function r2 -> aux_A (A!all_to_list, B!all_to_list, r1, r2);

  local let diff_is_internal_impl = diff_is_internal_aux_A;

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;


  proof of empty_belongs_impl_correct =
    by definition of empty_belongs, empty_belongs_impl;

  proof of singleton_belongs_impl_correct =
    by property is_A_singleton_impl_correct
       definition of singleton_belongs, singleton_belongs_impl;

  proof of inter_is_internal_impl_correct = assumed; (* TODO *)
  proof of diff_is_internal_impl_correct = assumed;

  proof of left_total = assumed; (* ??? *)

end;;


species Finite_surjective_relation_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_relation_by_list (A, B), Finite_surjective_relation (A, B);

  let element = complete_forced;

  local let empty_belongs_impl = false;

  local let singleton_belongs_impl (_a, _b) = is_B_singleton_impl;

  local let inter_is_internal_aux_B =
    let rec aux_A (l_a, b, r1, r2) =
      match l_a with
        | [] -> false
        | h :: t -> ( relation (r1, h, b) && relation (r2, h, b) ) ||
                    aux_A (t, b, r1, r2) in
    let rec aux_B (l_b, l_a, r1, r2) =
      match l_b with
        | [] -> true
        | h :: t -> aux_A (l_a, h, r1, r2) && aux_B (t, l_a, r1, r2) in
    function r1 -> function r2 -> aux_B (B!all_to_list, A!all_to_list, r1, r2);

  local let inter_is_internal_impl = inter_is_internal_aux_B;

  local let diff_is_internal_aux_B =
    let rec aux_A (l_a, b, r1, r2) =
      match l_a with
        | [] -> false
        | h :: t -> ( relation (r1, h, b) && ~~ relation (r2, h, b) ) ||
                    aux_A (t, b, r1, r2) in
    let rec aux_B (l_b, l_a, r1, r2) =
      match l_b with
        | [] -> true
        | h :: t -> aux_A (l_a, h, r1, r2) && aux_B (t, l_a, r1, r2) in
    function r1 -> function r2 -> aux_B (B!all_to_list, A!all_to_list, r1, r2);

  local let diff_is_internal_impl = diff_is_internal_aux_B;

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;


  proof of empty_belongs_impl_correct =
    by definition of empty_belongs, empty_belongs_impl;

  proof of singleton_belongs_impl_correct =
    by property is_B_singleton_impl_correct
       definition of singleton_belongs, singleton_belongs_impl;

  proof of inter_is_internal_impl_correct = assumed; (* TODO *)
  proof of diff_is_internal_impl_correct = assumed;

  proof of right_total = assumed; (* ??? *)

end;;


species Finite_function_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_determinist_relation_by_list (A, B),
          Finite_left_total_relation_by_list (A, B),
          Finite_function (A, B);

  let element =
    let rec aux (l : list (A), acc) =
      match l with
        | [] -> acc
        | h :: t -> aux (t, (h, B!element) :: acc) in
    aux (A!all_to_list, []);

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;

end;;


species Finite_injective_function_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_function_by_list (A, B),
          Finite_injective_relation_by_list (A, B),
          Finite_injective_function (A, B);

  let element =
    let rec aux (l_a : list (A), l_b : list (B), acc) =
      match l_a with
        | [] -> acc
        | a :: t_a ->
            match l_b with
              | [] -> focalize_error ("B!cardinal must be >= A!cardinal")
              | b :: t_b -> aux (t_a, t_b, (a, b) :: acc) in
    aux (A!all_to_list, B!all_to_list, []);

  local let complete_belongs_impl = is_A_singleton_impl && is_B_singleton_impl;

  local let union_is_internal_impl (r1, r2) =
    union_is_internal_aux_A (r1, r2) && union_is_internal_aux_B (r1, r2);

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;


  proof of complete_belongs_impl_correct =
    by property is_A_singleton_impl_correct, is_B_singleton_impl_correct
       definition of complete_belongs, complete_belongs_impl;

  proof of union_is_internal_impl_correct = assumed;

end;;


species Finite_surjective_function_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_function_by_list (A, B),
          Finite_surjective_relation_by_list (A, B),
          Finite_surjective_function (A, B);

  let element =
    let rec aux_A (l_a : list (A), b : B, acc) =
      match l_a with
        | [] -> acc
        | h :: t -> aux_A (t, b, (h, b) :: acc) in
    let rec aux_B (l_b : list (B), l_a : list (A)) =
      match l_b with
        | [] -> focalize_error ("B should not be empty")
        | [b] -> aux_A (l_a, b, [])
        | h :: t -> (A!element, h) :: aux_B (t, l_a) in
    aux_B (B!all_to_list, A!all_to_list);

  local let singleton_belongs_impl (_a, _b) =
    is_A_singleton_impl && is_B_singleton_impl;

  local let inter_is_internal_impl (r1, r2) =
    inter_is_internal_aux_A (r1, r2) && inter_is_internal_aux_B (r1, r2);

  local let diff_is_internal_impl (r1, r2) =
    diff_is_internal_aux_A (r1, r2) && diff_is_internal_aux_B (r1, r2);

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;


  proof of singleton_belongs_impl_correct =
    by property is_A_singleton_impl_correct, is_B_singleton_impl_correct
       definition of singleton_belongs, singleton_belongs_impl;

  proof of inter_is_internal_impl_correct = assumed; (* TODO *)
  proof of diff_is_internal_impl_correct = assumed;

end;;


species Finite_bijection_by_list (A is Finite_set, B is Finite_set) =

  inherit Finite_injective_function_by_list (A, B),
          Finite_surjective_function_by_list (A, B),
          Finite_bijection (A, B);

  let element =
    let rec aux (l_a : list (A), l_b : list (B), acc) =
      match l_a with
        | [] -> acc
        | a :: t_a ->
            match l_b with
              | [] -> focalize_error ("B!cardinal must be equal to A!cardinal")
              | b :: t_b -> aux (t_a, t_b, (a, b) :: acc) in
    aux (A!all_to_list, B!all_to_list, []);

  let cardinal = 1;             (* TODO *)

  let all_to_list = [element];  (* TODO *)

  let print = print_relation;

end;;







  (* Tests *)


type subject = | S0 | S1 | S2;;

species Subject_test =

  inherit Finite_set;

  representation = subject;

  let s0 : Self = S0;
  let s1 : Self = S1;
  let s2 : Self = S2;

  let cardinal = 3;
  let all_to_list = [S0; S1; S2];

  let element = s0;
  let equal (s_1, s_2) = s_1 = s_2;
  let print (s) =
    match s with
      | S0 -> "s0" | S1 -> "s1" | S2 -> "s2";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

collection S = implement Subject_test; end;;


type object = | O0 | O1 | O2;;

species Object_test =

  inherit Finite_set;

  representation = object;

  let o0 : Self = O0;
  let o1 : Self = O1;
  let o2 : Self = O2;

  let cardinal = 3;
  let all_to_list = [O0; O1; O2];

  let element = o0;
  let equal (o_1, o_2) = o_1 = o_2;
  let print (o) =
    match o with
      | O0 -> "o0" | O1 -> "o1" | O2 -> "o2";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

collection O = implement Object_test; end;;

collection R = implement Finite_relation_by_list (S, O); end;;

collection RI = implement Finite_injective_relation_by_list (S, O); end;;

collection RD = implement Finite_determinist_relation_by_list (S, O); end;;

collection RL = implement Finite_left_total_relation_by_list (S, O); end;;

collection RS = implement Finite_surjective_relation_by_list (S, O); end;;

collection F = implement Finite_function_by_list (S, O); end;;

(* proof of card_A_leq_card_B *)
(* collection FI = implement Finite_injective_function_by_list (S, O); end;; *)

collection FS = implement Finite_surjective_function_by_list (S, O); end;;

(* proof of card_A_leq_card_B *)
(* proof of card_A_eq_card_B *)
(* collection FB = implement Finite_bijection_by_list (S, O); end;; *)


let r = R!element;;

let test (r, s, o) =
  let _a = print_string ("(" ^ S!print (s) ^ ", " ^ O!print (o) ^ ")  ") in
  let _b = print_string (R!print (r) ^ "   ") in
  if R!relation (r, s, o)
  then print_string ("OK\n") else print_string ("KO\n");;

test (r, S!s1, O!o0);;
test (r, S!s1, O!o1);;

let r1 = R!complete (());;

test (r1, S!s1, O!o1);;

let r2 = R!singleton (S!s2, O!o2);;

test (r2, S!s1, O!o2);;
test (r2, S!s2, O!o2);;

let r3 = R!singleton (S!s1, O!o2);;

test (r1, S!s1, O!o2);;
test (r1, S!s2, O!o2);;

let r4 = R!union (r2, r1);;

test (r4, S!s1, O!o2);;
test (r4, S!s2, O!o2);;



print_string ("\n");;

let f = F!element;;

let testF (f, s, o) =
  let _a = print_string ("(" ^ S!print (s) ^ ", " ^ O!print (o) ^ ")  ") in
  let _b = print_string (F!print (f) ^ "   ") in
  if F!relation (f, s, o)
  then print_string ("OK\n") else print_string ("KO\n");;

testF (f, S!s1, O!o0);;
testF (f, S!s1, O!o1);;

let f1 = F!complete (());;

testF (f1, S!s1, O!o1);;

let f2 = F!diff (f1, f);;

testF (f2, S!s1, O!o0);;
testF (f2, S!s1, O!o1);;

let f3 = F!inter (f1, f);;

testF (f3, S!s1, O!o0);;
testF (f3, S!s1, O!o1);;

print_string ("element = element inter complete   ");;
  if F!equal (f, f3)
  then print_string ("OK\n") else print_string ("KO\n");;

(* Fatal error *)
(* let f4 = F!inter (f2, f);; *)


let relations_list_to_string =
  let rec aux (l) =
    match l with
      | [] -> "]"
      | [r] -> R!print (r) ^ "]"
      | r :: t -> R!print (r) ^ "; " ^ aux (t) in
  function l -> "[" ^ aux (l);;

let lenght =
  let rec aux (l, cpt) =
    match l with
      | [] -> cpt
      | _h :: t -> aux (t, cpt + 1) in
  function l -> aux (l, 0);;

let l = R!all_to_list;;

print_string (relations_list_to_string (l) ^ "\n");;
print_string (string_of_int (lenght (l)) ^ "\n");;
