open "basics";;
open "finite_sets";;


(** Accesses are done by active entities, the subjects, over passive entities,
    the objects, according to access modes (for exemple, read, write, etc). *)


species Subject = inherit Finite_set; end;;

species Object = inherit Finite_set; end;;

species Access_mode = inherit Finite_set; end;;



species Accesses (S is Subject, O is Object, A is Access_mode) =

  inherit Finite_set;

  (** alpha (x, s, o, a) means that s has an access over o
      according to the access mode a in the state x of the system. *)
  signature alpha : Self -> S -> O -> A -> bool;

  signature empty : Self;
  signature add : Self -> S -> O -> A -> Self;
  signature release : Self -> S -> O -> A -> Self;

  signature is_contained : Self -> Self -> bool;

  signature to_list : Self -> list (S * O * A);
  signature from_list : list (S * O * A) -> Self;

  property empty_spec :
    all s : S, all o : O, all a : A,
    ~ alpha (empty, s, o, a);

  property add_spec :
    all x : Self, all s s2 : S, all o : O, all a : A,
    if S!equal (s, s2)
    then alpha (add (x, s, o, a), s2, o, a)
    else alpha (add (x, s, o, a), s2, o, a) = alpha (x, s2, o, a);

  property release_spec :
    all x : Self, all s s2 : S, all o : O, all a : A,
    if S!equal (s, s2)
    then ~~ alpha (release (x, s, o, a), s2, o, a)
    else alpha (release (x, s, o, a), s2, o, a) = alpha (x, s2, o, a);

  property is_contained_spec :
    all x y : Self,
    is_contained (x, y) <-> ( all s : S, all o : O, all a : A,
                              alpha (x, s, o, a) -> alpha (y, s, o, a) );

  theorem is_contained_reflexive : all x : Self, is_contained (x, x)
  proof = by property is_contained_spec;

  theorem is_contained_antisymetric :
    all x y : Self,
    (is_contained (x, y) /\ is_contained (y, x)) -> equal (x, y)
  proof = assumed;              (* TODO *)
       (* by property is_contained_spec, equal_symmetric, equal_transitive; *)

  theorem is_contained_transitive :
    all x y z : Self,
    (is_contained (x, y) /\ is_contained (y, z)) -> is_contained (x, z)
  proof = by property is_contained_spec;

  local let in_list_ac =
    let rec aux (l, s, o, a) =
      match l with
        | [] -> false
        | (s1, o1, a1) :: t ->
            ( S!equal (s1, s) && O!equal (o1, o) && A!equal (a1, a) ) ||
            aux (t, s, o, a) in
    function s -> function o -> function a -> function l -> aux (l, s, o, a);

  property alpha_to_list :
    all x : Self, all s : S, all o : O, all a : A,
    in_list_ac (s, o, a, to_list (x)) <-> alpha (x, s, o, a);

  property alpha_from_list :
    all l : list (S * O * A), all s : S, all o : O, all a : A,
    in_list_ac (s, o, a, l) <-> alpha (from_list (l), s, o, a); 

  property equal_spec :
    all x y : Self,
    equal (x, y) <-> ( all s : S, all o : O, all a : A,
                       alpha (x, s, o, a) <-> alpha (y, s, o, a) );

  proof of equal_reflexive = by property equal_spec;
  proof of equal_symmetric = by property equal_spec;
  proof of equal_transitive = by property equal_spec;

end;;


type list_soa ('s, 'o, 'a) =
  | Empty
  | Cons ('s, 'o, 'a, list_soa ('s, 'o, 'a));;

species Accesses_by_list (S is Subject, O is Object, A is Access_mode) =

  inherit Accesses (S, O, A);

  representation = list_soa (S, O, A);

  local let ( =S ) = S!equal;
  local let ( =O ) = O!equal;
  local let ( =A ) = A!equal;

  let alpha =
    let rec aux (x, s, o, a) =
      match x with
        | Empty -> false
        | Cons (s2, o2, a2, l) -> (s2 =S s && o2 =O o && a2 =A a) ||
                                  aux (l, s, o, a) in
    function x -> function s -> function o -> function a -> aux (x, s, o, a);

  let empty = Empty;

  (* On permet les doublons. *)
  let add (x, s, o, a) = Cons (s, o, a, x);

  (* On enleve toutes les occurrences. *)
  let release =
    let rec aux (x, s, o, a) =
      match x with
        | Empty -> Empty
        | Cons (s2, o2, a2, l) ->
            if (s2 =S s && o2 =O o && a2 =A a) then aux (l, s, o, a)
            else Cons (s2, o2, a2, aux (l, s, o, a)) in
    function x -> function s -> function o -> function a -> aux (x, s, o, a);

  let is_contained =
    let rec aux (x : Self, y : Self) =
      match x with
        | Empty -> true
        | Cons (s, o, a, l) -> alpha (y, s, o, a) && aux (l, y) in
    function x -> function y -> aux (x, y);

  let to_list =
    let rec aux (x : Self, acc) =
      match x with
        | Empty -> acc
        | Cons (s, o, a, l) -> aux (l, (s, o, a) :: acc) in
    function x -> aux (x, []);

  let from_list =
    let rec aux (l : list (S * O * A), acc : Self) =
      match l with
        | [] -> acc
        | (s, o, a) :: t -> aux (t, Cons (s, o, a, acc)) in
    function l -> aux (l, Empty);
    

  let equal (x, y) = is_contained (x, y) && is_contained (y, x);

  theorem equal_from_is_contained :
    all x y : Self,
    equal (x, y) <-> is_contained (x, y) /\ is_contained (y, x)
  proof = by definition of equal;

  let element = Empty;

  local let rev_append =
    let rec aux (l1, l2) =
      match l1 with
        | [] -> l2
        | h :: t -> aux (t, h :: l2) in
    function l1 -> function l2 -> aux (l1, l2);

  local let rev_append_soa =
    let rec aux (l1 : list_soa (S, O, A), l2 : list_soa (S, O, A)) =
      match l1 with
        | Empty -> l2
        | Cons (s, o, a, t) -> aux (t, Cons (s, o, a, l2)) in
    function l1 -> function l2 -> aux (l1, l2);

  local let accesses_list : Self =
    let rec aux_a (la, s : S, o : O, acc) =
      match la with
        | [] -> acc
        | a :: t -> aux_a (t, s, o, Cons (s, o, a, acc)) in
    let rec aux_o (lo, la, s, acc) =
      match lo with
        | [] -> acc
        | o :: t ->
            aux_o (t, la, s, rev_append_soa (aux_a (la, s, o, Empty), acc)) in
    let rec aux_s (ls, lo, la, acc) =
      match ls with
        | [] -> acc
        | s :: t ->
            aux_s (t, lo, la, rev_append_soa (aux_o (lo, la, s, Empty), acc)) in
    aux_s (S!all_to_list, O!all_to_list, A!all_to_list, Empty);

  let all_to_list : list (Self)=
    (* List of lists with elements of l2 and some of l1 *)
    let rec aux (l1 : list_soa (S, O, A), l2 : list_soa (S, O, A)) =
      match l1 with
        | Empty -> [l2]
        | Cons (s, o, a, t) -> rev_append (aux (t, l2),
                                           aux (t, Cons (s, o, a, l2))) in
    aux (accesses_list, Empty);

  let print (x) =
    let rec aux (x) =
      match x with
        | Empty -> ""
        | Cons (s, o, a, l) ->
            let soa = "(" ^ S!print (s) ^ ", " ^ O!print (o) ^ ", " ^
                      A!print (a) ^ ")" in
            if l = Empty then soa else soa ^ "; " ^ aux (l) in
    "[" ^ aux (x) ^ "]";

  proof of empty_spec = assumed; (* TODO *)
  proof of add_spec = assumed;
  proof of release_spec = assumed;
  proof of is_contained_spec = assumed;
  proof of alpha_to_list = assumed;
  proof of alpha_from_list = assumed;
  proof of equal_spec = by property is_contained_spec, equal_from_is_contained;
  proof of all_in_all_to_list = assumed;

end;;






  (* Tests *)


type subject = | S0 | S1;;

species Subject_test =

  inherit Subject;

  representation = subject;

  let s0 : Self = S0;
  let s1 : Self = S1;

  let all_to_list = [S0; S1];

  let element = s0;
  let equal (s_1, s_2) = s_1 = s_2;
  let print (s) =
    match s with
      | S0 -> "s0" | S1 -> "s1";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

collection S = implement Subject_test; end;;


type object = | O0 | O1;;

species Object_test =

  inherit Object;

  representation = object;

  let o0 : Self = O0;
  let o1 : Self = O1;

  let all_to_list = [O0; O1];

  let element = o0;
  let equal (o_1, o_2) = o_1 = o_2;
  let print (o) =
    match o with
      | O0 -> "o0" | O1 -> "o1";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

collection O = implement Object_test; end;;


type access_mode = | A0 | A1;;

species Access_mode_test =

  inherit Access_mode;

  representation = access_mode;

  let a0 : Self = A0;
  let a1 : Self = A1;

  let all_to_list = [A0; A1];

  let element = a0;
  let equal (a_1, a_2) = a_1 = a_2;
  let print (a) =
    match a with
      | A0 -> "a0" | A1 -> "a1";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

collection A = implement Access_mode_test; end;;


collection Ac = implement Accesses_by_list (S, O, A); end;;

let accesses_list_to_string =
  let rec aux (l) =
    match l with
      | [] -> "]"
      | [ac] -> Ac!print (ac) ^ "]"
      | ac :: t -> Ac!print (ac) ^ "; " ^ aux (t) in
  function l -> "[" ^ aux (l);;

let lenght =
  let rec aux (l, cpt) =
    match l with
      | [] -> cpt
      | _h :: t -> aux (t, cpt + 1) in
  function l -> aux (l, 0);;

let l = Ac!all_to_list;;

(* print_string (accesses_list_to_string (l) ^ "\n");; *)
(* print_string (string_of_int (lenght (l)) ^ "\n");; *)
