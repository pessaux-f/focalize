open "basics";;
open "products";;
open "accesses";;
open "p_policies";;
open "access_p_policies";;
open "access_system";;
open "secure_system";;


(** The HRU security model (Harrison, Ruzzo, Ullman model) *)


(** HRU configuration *)


species Configuration_ac (S is Subject, O is Object, A is Access_mode,
                          Ac is Accesses (S, O, A)) =

  inherit Configuration, Accesses (S, O, A);

  signature accesses : Self -> Ac;

  property accesses_preserves_alpha :
    all c : Self, all s : S, all o : O, all a : A,
    alpha (c, s, o, a) = Ac!alpha (accesses (c), s, o, a);

end;;


species Configuration_ac_by_list (S is Subject, O is Object, A is Access_mode,
                                  Ac is Accesses (S, O, A)) =

  inherit Finite_configuration, Configuration_ac (S, O, A, Ac),
          Accesses_by_list (S, O, A);

  let accesses (c) =
    let rec aux (c) =
      match c with
        | Empty -> Ac!empty
        | Cons (s, o, a, l) -> Ac!add (aux (l), s, o, a) in
    aux (c);

  proof of accesses_preserves_alpha = assumed; (* TODO *)

end;;



(** HRU policy *)


species P_policy_hru (S is Subject, O is Object, A is Access_mode,
                      Ac is Accesses (S, O, A),
                      T is Target_ac (S, O, A, Ac),
                      C is Configuration_ac (S, O, A, Ac)) =

  inherit P_policy_ac (S, O, A, Ac, T, C), Finite_p_policy (T, C);

  representation = unit;

  let relation (t, c) =
    Ac!is_contained (T!accesses (t), C!accesses (c));

  theorem relation_is_is_contained :
    all t : T, all c : C,
    relation (t, c) <-> Ac!is_contained (T!accesses (t), C!accesses (c))
  proof = by definition of relation;

end;;



(** HRU secure system *)


species Secured_state_hru
  (S is Subject, O is Object, A is Access_mode, Ac is Accesses (S, O, A),
   T is Target_ac (S, O, A, Ac), C is Configuration_ac (S, O, A, Ac),
   P is P_policy_hru (S, O, A, Ac, T, C),
   St is State_ac (S, O, A, Ac)) =

  inherit Cartesian_product (St, C), Secured_state (T, C, P, St);

  let interpretation (x) = T!from_accesses (St!accesses (x));

  let print (x) = "(" ^ St!print (state (x)) ^ ", " ^
                        C!print (configuration (x)) ^ ")";

end;;


species Secured_transition_system_hru
  (S is Subject, O is Object, A is Access_mode, Ac is Accesses (S, O, A),
   T is Target_ac (S, O, A, Ac), C is Configuration_ac (S, O, A, Ac),
   P is P_policy_hru (S, O, A, Ac, T, C),
   St is State_ac (S, O, A, Ac), L is Label_ac (S, O, A),
   Sys is Transition_system_ac (S, O, A, Ac, St, L),
   Ss is Secured_state_hru (S, O, A, Ac, T, C, P, St)) =

  inherit Secured_transition_system (St, L, Sys, Ss);

end;;



species Secured_operational_transition_system_hru
  (S is Subject, O is Object, A is Access_mode, Ac is Accesses (S, O, A),
   T is Target_ac (S, O, A, Ac), C is Configuration_ac (S, O, A, Ac),
   P is P_policy_hru (S, O, A, Ac, T, C),
   St is State_ac (S, O, A, Ac), L is Label_ac (S, O, A),
   Sys is Operational_transition_system_ac (S, O, A, Ac, St, L),
   Ss is Secured_state_hru (S, O, A, Ac, T, C, P, St)) =

  inherit Secured_transition_system_hru (S, O, A, Ac, T, C, P, St, L, Sys, Ss),
          Secured_operational_transition_system (St, L, Sys, Ss);

  representation = unit;

end;;





(* Tests *)


type subject = | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7;;

species Subject_test =

  inherit Subject;

  representation = subject;

  let s0 : Self = S0;
  let s1 : Self = S1;
  let s2 : Self = S2;
  let s3 : Self = S3;
  let s4 : Self = S4;
  let s5 : Self = S5;
  let s6 : Self = S6;
  let s7 : Self = S7;

  let cardinal = 8;
  let all_to_list = [S0; S1; S2; S3; S4; S5; S6; S7];

  let element = s0;
  let equal (s_1, s_2) = s_1 = s_2;
  let print (s) =
    match s with
      | S0 -> "s0" | S1 -> "s1" | S2 -> "s2" | S3 -> "s3"
      | S4 -> "s4" | S5 -> "s5" | S6 -> "s6" | S7 -> "s7";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

collection S = implement Subject_test; end;;


type object = | O0 | O1 | O2 | O3 | O4 | O5 | O6 | O7;;

species Object_test =

  inherit Object;

  representation = object;

  let o0 : Self = O0;
  let o1 : Self = O1;
  let o2 : Self = O2;
  let o3 : Self = O3;
  let o4 : Self = O4;
  let o5 : Self = O5;
  let o6 : Self = O6;
  let o7 : Self = O7;

  let cardinal = 8;
  let all_to_list = [O0; O1; O2; O3; O4; O5; O6; O7];

  let element = o0;
  let equal (o_1, o_2) = o_1 = o_2;
  let print (o) =
    match o with
      | O0 -> "o0" | O1 -> "o1" | O2 -> "o2" | O3 -> "o3"
      | O4 -> "o4" | O5 -> "o5" | O6 -> "o6" | O7 -> "o7";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

collection O = implement Object_test; end;;


type access_mode = | A0 | A1 | A2 | A3 | A4 | A5 | A6 | A7;;

species Access_mode_test =

  inherit Access_mode;

  representation = access_mode;

  let a0 : Self = A0;
  let a1 : Self = A1;
  let a2 : Self = A2;
  let a3 : Self = A3;
  let a4 : Self = A4;
  let a5 : Self = A5;
  let a6 : Self = A6;
  let a7 : Self = A7;

  let cardinal = 8;
  let all_to_list = [A0; A1; A2; A3; A4; A5; A6; A7];

  let element = a0;
  let equal (a_1, a_2) = a_1 = a_2;
  let print (a) =
    match a with
      | A0 -> "a0" | A1 -> "a1" | A2 -> "a2" | A3 -> "a3"
      | A4 -> "a4" | A5 -> "a5" | A6 -> "a6" | A7 -> "a7";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

collection A = implement Access_mode_test; end;;

collection Ac = implement Accesses_by_list (S, O, A); end;;

collection T = implement Target_ac_by_list (S, O, A, Ac); end;;

collection C = implement Configuration_ac_by_list (S, O, A, Ac); end;;

collection P = implement P_policy_hru (S, O, A, Ac, T, C); end;;


(* let test_2 (t, c) = *)
(*   let conf = "(" ^ T!print (t) ^ ", " ^ C!print (c) ^ ")" in *)
(*   if P!relation (t, c) *)
(*   then print_string (conf ^ "   OK\n") *)
(*   else print_string (conf ^ "   KO\n");; *)


(* let target_0 = T!empty;; *)
(* let target_1 = T!add (target_0, S!s3, O!o5, A!a2);; *)

(* let configuration_0 = C!empty;; *)
(* let configuration_1 = C!add (configuration_0, S!s3, O!o5, A!a2);; *)

(* test_2 (target_0, configuration_0);; *)
(* test_2 (target_0, configuration_1);; *)
(* test_2 (target_1, configuration_0);; *)
(* test_2 (target_1, configuration_1);; *)



collection St = implement State_ac_by_list (S, O, A, Ac); end;;

collection L = implement Label_ac (S, O, A); end;;

collection Sys_ac =
  implement Operational_transition_system_ac (S, O, A, Ac, St, L); end;;


collection Ss = implement Secured_state_hru (S, O, A, Ac, T, C, P, St); end;;

collection Sys =
  implement Secured_operational_transition_system_hru
    (S, O, A, Ac, T, C, P, St, L, Sys_ac, Ss); end;;


let c = C!add (C!empty, S!s0, O!o0, A!a0);;

let st = Ss!pair (St!empty, c);;

let st1 = Sys!transition (st, L!label (Add, S!s0, O!o0, A!a0));;

let st2 = Sys!transition (st1, L!label (Release, S!s0, O!o0, A!a0));;

let st3 = Sys!transition (st2, L!label (Release, S!s1, O!o1, A!a1));;

let st4 = Sys!transition (st3, L!label (Add, S!s1, O!o1, A!a1));;

print_string (Ss!print (st) ^ "\n");;
print_string (Ss!print (st1) ^ "\n");;
print_string (Ss!print (st2) ^ "\n");;
print_string (Ss!print (st3) ^ "\n");;
print_string (Ss!print (st4) ^ "\n");;
