open "basics";;
open "accesses";;
open "lts";;


(** We define a system allowing to add or to release accesses. *)


species State_ac (S is Subject, O is Object, A is Access_mode,
                  Ac is Accesses (S, O, A)) =

  inherit State, Accesses (S, O, A);

  let is_initial (x) = equal (x, empty);

  theorem initial_is_empty : all x : Self, is_initial (x) <-> equal (x, empty)
  proof = by definition of is_initial;

  signature accesses : Self -> Ac;

  property accesses_preserves_alpha :
    all t : Self, all s : S, all o : O, all a : A,
    alpha (t, s, o, a) = Ac!alpha (accesses (t), s, o, a);

end;;


species State_ac_by_list (S is Subject, O is Object, A is Access_mode,
                          Ac is Accesses (S, O, A)) =

  inherit State_ac (S, O, A, Ac), Accesses_by_list (S, O, A);

  let accesses =
    let rec aux (x) =
      match x with
        | Empty -> Ac!empty
        | Cons (s, o, a, l) -> Ac!add (aux (l), s, o, a) in
    function x -> aux (x);

  proof of accesses_preserves_alpha = assumed; (* TODO *)

end;;


type action = | Add | Release;;

species Label_ac (S is Subject, O is Object, A is Access_mode) =

  inherit Label;

  representation = action * S * O * A;

  let label (x, s, o, a) : Self = (x, s, o, a);

  let action (l : Self) = match l with | (x, _, _, _) -> x;
  let subject (l : Self) = match l with | (_, s, _, _) -> s;
  let object_ac (l : Self) = match l with | (_, _, o, _) -> o;
  let access_mode (l : Self) = match l with | (_, _, _, a) -> a;

  local let ( =S ) = S!equal;
  local let ( =O ) = O!equal;
  local let ( =A ) = A!equal;

  let element = (Add, S!element, O!element, A!element);

  let equal (l1 : Self, l2 : Self) =
    action (l1) = action (l2) && subject (l1) =S subject (l2) &&
    object_ac (l1) =O object_ac (l2) && access_mode (l1) =A access_mode (l2);

  local let print_action (x) = match x with | Add -> "+" | Release -> "-";

  let print (l) = "<" ^ print_action (action (l)) ^ ", " ^
                        S!print (subject (l)) ^ ", " ^
                        O!print (object_ac (l)) ^ ", " ^
                        A!print (access_mode (l)) ^ ">";

  theorem label_spec :
    all x : action, all s : S, all o : O, all a : A,
    action (label (x, s, o, a)) = x && subject (label (x, s, o, a)) =S s &&
    object_ac (label (x, s, o, a)) =O o && access_mode (label (x, s, o, a)) =A a
  proof = assumed;              (* TODO *)
          (* by definition of label, action, subject, object_ac, access_mode; *)

  theorem equal_spec :
    all l1 l2 : Self,
    equal (l1, l2) <->
    action (l1) = action (l2) && subject (l1) =S subject (l2) &&
    object_ac (l1) =O object_ac (l2) && access_mode (l1) =A access_mode (l2)
  proof = by definition of equal;

  proof of equal_reflexive = by property equal_spec, S!equal_reflexive,
                                         O!equal_reflexive, A!equal_reflexive
                                definition of ( =S ), ( =O ), ( =A );
  proof of equal_symmetric = by property equal_spec, S!equal_symmetric,
                                         O!equal_symmetric, A!equal_symmetric
                                definition of ( =S ), ( =O ), ( =A );
  proof of equal_transitive = by property equal_spec, S!equal_transitive,
                                          O!equal_transitive, A!equal_transitive
                                 definition of ( =S ), ( =O ), ( =A );

end;;


species Transition_system_ac (S is Subject, O is Object, A is Access_mode,
                              Ac is Accesses (S, O, A),
                              St is State_ac (S, O, A, Ac),
                              L is Label_ac (S, O, A)) =

  inherit Transition_system (St, L);

  representation = unit;

  let delta (x, l, y) =
    ( ( L!action (l) = Add &&
        St!equal (y, St!add (x, L!subject (l),
                                L!object_ac (l),
                                L!access_mode (l))) ) ||
      ( L!action (l) = Release &&
        St!equal (y, St!release (x, L!subject (l),
                                   L!object_ac (l),
                                   L!access_mode (l))) ) );

  theorem delta_spec :
    all x y : St, all l : L,
    delta (x, l, y) <->
    ( ( L!action (l) = Add /\
        St!equal (y, St!add (x, L!subject (l),
                                L!object_ac (l),
                                L!access_mode (l))) ) \/
      ( L!action (l) = Release /\
        St!equal (y, St!release (x, L!subject (l),
                                   L!object_ac (l),
                                   L!access_mode (l))) ) )
  proof = by definition of delta;

    (* Doit marcher sinon report *)
  theorem determinist : is_determinist
  proof = assumed;            (* TODO *)
  
  theorem complete : is_complete
  proof = assumed;

end;;


species Operational_transition_system_ac
  (S is Subject, O is Object, A is Access_mode, Ac is Accesses (S, O, A),
   St is State_ac (S, O, A, Ac), L is Label_ac (S, O, A)) =

  inherit Transition_system_ac (S, O, A, Ac, St, L),
          Operational_transition_system (St, L);

  let transition (x, l) =
    if L!action (l) = Add
    then St!add (x, L!subject (l), L!object_ac (l), L!access_mode (l))
    else if L!action (l) = Release
    then St!release (x, L!subject (l), L!object_ac (l), L!access_mode (l))
    else focalize_error ("Invalid action");

  proof of transition_is_valid = assumed;
                (* TODO : by property delta_spec definition of transition; *)

end;;




(** Access System with requests for transitions *)


species Request_ac (S is Subject, O is Object, A is Access_mode) =

  inherit Request, Label_ac (S, O, A);

end;;


species Answer_ac =

  inherit Answer;

  representation = bool;

  let yes : Self = true;
  let no : Self = false;

  let element = no;
  let equal (a1 : Self, a2 : Self) = a1 = a2;
  let print (a) = if a = yes then "yes" else "no";
  let parse (s) = if s = "yes" then yes else no;

  theorem is_yes_or_no : all x : Self, equal (x, yes) \/ equal (x, no)
  proof = by definition of yes, no, equal;

  theorem yes_is_not_not : ~ equal (yes, no)
  proof = by definition of yes, no, equal;

  proof of equal_reflexive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_transitive = by definition of equal;

end;;


species Transition_system_request_ac
  (S is Subject, O is Object, A is Access_mode, Ac is Accesses (S, O, A),
   R is Request_ac (S, O, A), D is Answer_ac,
   St is State_ac (S, O, A, Ac), L is Label_request (R, D)) =

  inherit Transition_system_request (R, D, St, L);

  representation = unit;

  local let action (l) = R!action (L!request (l));
  local let subject (l) = R!subject (L!request (l));
  local let object_ac (l) = R!object_ac (L!request (l));
  local let access_mode (l) = R!access_mode (L!request (l));

  let delta (x, l, y) =
    ( ( D!equal (L!answer (l), D!yes) && action (l) = Add &&
        St!equal (y, St!add (x, subject (l),
                                object_ac (l),
                                access_mode (l))) ) ||
      ( D!equal (L!answer (l), D!yes) && action (l) = Release &&
        St!equal (y, St!release (x, subject (l),
                                   object_ac (l),
                                   access_mode (l))) ) ||
      ( D!equal (L!answer (l), D!no) && St!equal (y, x) ) );

  theorem delta_spec :
    all x y : St, all l : L,
    delta (x, l, y) <->
    ( ( D!equal (L!answer (l), D!yes) /\ action (l) = Add /\
        St!equal (y, St!add (x, subject (l),
                                object_ac (l),
                                access_mode (l))) ) \/
      ( D!equal (L!answer (l), D!yes) /\ action (l) = Release /\
        St!equal (y, St!release (x, subject (l),
                                   object_ac (l),
                                   access_mode (l))) ) \/
      ( D!equal (L!answer (l), D!no) /\ St!equal (y, x) ) )
  proof = by definition of delta;

end;;






(* Tests *)


(* ype subject = | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7;; *)

(* species Subject_test = *)

(*   inherit Subject; *)

(*   representation = subject; *)

(*   let s0 : Self = S0; *)
(*   let s1 : Self = S1; *)
(*   let s2 : Self = S2; *)
(*   let s3 : Self = S3; *)
(*   let s4 : Self = S4; *)
(*   let s5 : Self = S5; *)
(*   let s6 : Self = S6; *)
(*   let s7 : Self = S7; *)

(*   let cardinal = 8; *)
(*   let all_to_list = [S0; S1; S2; S3; S4; S5; S6; S7]; *)

(*   let element = s0; *)
(*   let equal (s_1, s_2) = s_1 = s_2; *)
(*   let print (s) = *)
(*     match s with *)
(*       | S0 -> "s0" | S1 -> "s1" | S2 -> "s2" | S3 -> "s3" *)
(*       | S4 -> "s4" | S5 -> "s5" | S6 -> "s6" | S7 -> "s7"; *)

(*   proof of equal_transitive = by definition of equal; *)
(*   proof of equal_symmetric = by definition of equal; *)
(*   proof of equal_reflexive = by definition of equal; *)

(*   proof of all_in_all_to_list = assumed; *)

(* end;; *)

(* collection S = implement Subject_test; end;; *)


(* type object = | O0 | O1 | O2 | O3 | O4 | O5 | O6 | O7;; *)

(* species Object_test = *)

(*   inherit Object; *)

(*   representation = object; *)

(*   let o0 : Self = O0; *)
(*   let o1 : Self = O1; *)
(*   let o2 : Self = O2; *)
(*   let o3 : Self = O3; *)
(*   let o4 : Self = O4; *)
(*   let o5 : Self = O5; *)
(*   let o6 : Self = O6; *)
(*   let o7 : Self = O7; *)

(*   let cardinal = 8; *)
(*   let all_to_list = [O0; O1; O2; O3; O4; O5; O6; O7]; *)

(*   let element = o0; *)
(*   let equal (o_1, o_2) = o_1 = o_2; *)
(*   let print (o) = *)
(*     match o with *)
(*       | O0 -> "o0" | O1 -> "o1" | O2 -> "o2" | O3 -> "o3" *)
(*       | O4 -> "o4" | O5 -> "o5" | O6 -> "o6" | O7 -> "o7"; *)

(*   proof of equal_transitive = by definition of equal; *)
(*   proof of equal_symmetric = by definition of equal; *)
(*   proof of equal_reflexive = by definition of equal; *)

(*   proof of all_in_all_to_list = assumed; *)

(* end;; *)

(* collection O = implement Object_test; end;; *)


(* type access_mode = | A0 | A1 | A2 | A3 | A4 | A5 | A6 | A7;; *)

(* species Access_mode_test = *)

(*   inherit Access_mode; *)

(*   representation = access_mode; *)

(*   let a0 : Self = A0; *)
(*   let a1 : Self = A1; *)
(*   let a2 : Self = A2; *)
(*   let a3 : Self = A3; *)
(*   let a4 : Self = A4; *)
(*   let a5 : Self = A5; *)
(*   let a6 : Self = A6; *)
(*   let a7 : Self = A7; *)

(*   let cardinal = 8; *)
(*   let all_to_list = [A0; A1; A2; A3; A4; A5; A6; A7]; *)

(*   let element = a0; *)
(*   let equal (a_1, a_2) = a_1 = a_2; *)
(*   let print (a) = *)
(*     match a with *)
(*       | A0 -> "a0" | A1 -> "a1" | A2 -> "a2" | A3 -> "a3" *)
(*       | A4 -> "a4" | A5 -> "a5" | A6 -> "a6" | A7 -> "a7"; *)

(*   proof of equal_transitive = by definition of equal; *)
(*   proof of equal_symmetric = by definition of equal; *)
(*   proof of equal_reflexive = by definition of equal; *)

(*   proof of all_in_all_to_list = assumed; *)

(* end;; *)

(* collection A = implement Access_mode_test; end;; *)

(* collection Ac = implement Accesses_by_list (S, O, A); end;; *)

(* collection St = implement State_ac_by_list (S, O, A, Ac); end;; *)

(* collection L = implement Label_ac (S, O, A); end;; *)

(* collection LTS = *)
(*   implement Operational_transition_system_ac (S, O, A, Ac, St, L); end;; *)

(* let rec fold_left (l, f, z) = *)
(*   match l with *)
(*     | [] -> z *)
(*     | h :: t -> f (h, fold_left (t, f, z));; *)

(* let test (x, l, y) = *)
(*   let transition = St!print (x) ^ " *)--" ^ L!print (l) ^ "--> " ^ St!print (y) in
(*   if LTS!delta (x, l, y) && St!equal (LTS!transition (x, l), y) *)
(*   then print_string (transition ^ "   OK\n") *)
(*   else print_string (transition ^ "   KO\n");; *)

(* let state_0 = St!empty;; *)
(* let state_1 = St!empty;; *)
(* let state_2 = St!add (state_1, S!s3, O!o5, A!a2);; *)
(* let state_3 = St!add (state_2, S!s3, O!o5, A!a7);; *)

(* let label_0 = L!label (Add, S!s3, O!o5, A!a2);; *)
(* let label_1 = L!label (Release, S!s3, O!o5, A!a2);; *)
(* let label_2 = L!label (Add, S!s3, O!o5, A!a7);; *)
(* let label_3 = L!label (Release, S!s3, O!o5, A!a7);; *)


(* test (state_0, label_0, state_1);; *)
(* test (state_0, label_0, state_2);; *)
(* test (state_0, label_0, state_3);; *)
(* test (state_2, label_1, state_0);; *)
(* test (state_3, label_1, state_2);; *)
(* test (state_3, label_3, state_2);; *)
(* test (state_2, label_2, state_3);; *)

(* TODO *)
(* LTS!transition (LTS!transition (St!empty, label_2), label_3) *)
