open "basics";;
open "orders";;
open "products";;
open "accesses";;
open "p_policies";;
open "access_p_policies";;
open "access_system";;
open "secure_system";;


(** The BLP security model (Bell, LaPadula) *)


(** BLP configuration *)


species Configuration_blp (S is Subject, O is Object, L is Pre_order) =

  inherit Configuration;

  (* subject security level *)
  signature fs : S -> L;

  (* object security level *)
  signature fo : O -> L;

end;;



(** BLP policy *)


species Access_mode_blp =

  inherit Access_mode;

  signature read : Self;
  signature write : Self;

end;;


species Security_level = inherit Pre_order; end;;


species P_policy_blp (S is Subject, O is Object, A is Access_mode_blp,
                      Ac is Accesses (S, O, A),
                      L is Security_level,
                      T is Target_ac (S, O, A, Ac),
                      C is Configuration_blp (S, O, L)) =

  inherit P_policy_ac (S, O, A, Ac, T, C);

  representation = unit;

  property relation_spec :
    all t : T, all c : C,
    relation (t, c) <->
      all s : S, all o1 o2 : O,
      (Ac!alpha (T!accesses (t), s, o1, A!read) ->
         L!geq (C!fs (s), C!fo (o1))) /\
      ((Ac!alpha (T!accesses (t), s, o1, A!read) /\
        Ac!alpha (T!accesses (t), s, o2, A!write)) ->
         L!geq (C!fo (o2), C!fo (o1)));

  let relation =
    let rec auxO2 (l_o, s, o, t) =
      match l_o with
        | [] -> true
        | o2 :: t_o ->
            if Ac!alpha (T!accesses (t), s, o2, A!write) then
              L!geq (C!fo (o2), C!fo (o)) && auxO2 (t_o, s, o, t)
            else auxO2 (t_o, s, o, t) in
    let rec auxO1 (l_o, s, l_o2, t) =
      match l_o with
        | [] -> true
        | o :: t_o ->
            if Ac!alpha (T!accesses (t), s, o, A!read) then
              L!geq (C!fs (s), C!fo (o)) && auxO2 (l_o2, s, o, t) &&
              auxO1 (t_o, s, l_o2, t)
            else auxO1 (t_o, s, l_o2, t) in
    let rec auxS (l_s, l_o, t) =
      match l_s with
        | [] -> true
        | s :: t_s -> auxO1 (l_o, s, l_o, t) && auxS (t_s, l_o, t) in
    function t -> function c -> auxS (S!all_to_list, O!all_to_list, t);

  proof of relation_spec = assumed; (* TODO *)

end;;



(** BLP secure system *)


species Secured_state_blp
  (S is Subject, O is Object, A is Access_mode_blp, Ac is Accesses (S, O, A),
   L is Security_level,
   T is Target_ac (S, O, A, Ac), C is Configuration_blp (S, O, L),
   P is P_policy_blp (S, O, A, Ac, L, T, C),
   St is State_ac (S, O, A, Ac)) =

  inherit Cartesian_product (St, C), Secured_state (T, C, P, St);

  let interpretation (x) = T!from_accesses (St!accesses (x));

  let print (x) = "(" ^ St!print (state (x)) ^ ", " ^
                        C!print (configuration (x)) ^ ")";

end;;


species Secured_transition_system_blp
  (S is Subject, O is Object, A is Access_mode_blp, Ac is Accesses (S, O, A),
   Lev is Security_level,
   T is Target_ac (S, O, A, Ac), C is Configuration_blp (S, O, Lev),
   P is P_policy_blp (S, O, A, Ac, Lev, T, C),
   St is State_ac (S, O, A, Ac), L is Label_ac (S, O, A),
   Sys is Transition_system_ac (S, O, A, Ac, St, L),
   Ss is Secured_state_blp (S, O, A, Ac, Lev, T, C, P, St)) =

  inherit Secured_transition_system (St, L, Sys, Ss);

end;;



species Secured_operational_transition_system_blp
  (S is Subject, O is Object, A is Access_mode_blp, Ac is Accesses (S, O, A),
   Lev is Security_level,
   T is Target_ac (S, O, A, Ac), C is Configuration_blp (S, O, Lev),
   P is P_policy_blp (S, O, A, Ac, Lev, T, C),
   St is State_ac (S, O, A, Ac), L is Label_ac (S, O, A),
   Sys is Operational_transition_system_ac (S, O, A, Ac, St, L),
   Ss is Secured_state_blp (S, O, A, Ac, Lev, T, C, P, St)) =

  inherit
    Secured_transition_system_blp (S, O, A, Ac, Lev, T, C, P, St, L, Sys, Ss),
    Secured_operational_transition_system (St, L, Sys, Ss);

  representation = unit;

end;;





(* Tests *)


type subject = | S1 | S2 | S3;;

species Subject_test =

  inherit Subject;

  representation = subject;

  let s1 : Self = S1;
  let s2 : Self = S2;
  let s3 : Self = S3;

  let cardinal = 3;
  let all_to_list = [S1; S2; S3];

  let element = s1;
  let equal (s_1, s_2) = s_1 = s_2;
  let print (s) =
    match s with
      | S1 -> "s1" | S2 -> "s2" | S3 -> "s3";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

collection S = implement Subject_test; end;;


type object = | O1 | O2 | O3;;

species Object_test =

  inherit Object;

  representation = object;

  let o1 : Self = O1;
  let o2 : Self = O2;
  let o3 : Self = O3;

  let cardinal = 3;
  let all_to_list = [O1; O2; O3];

  let element = o1;
  let equal (o_1, o_2) = o_1 = o_2;
  let print (o) =
    match o with
      | O1 -> "o1" | O2 -> "o2" | O3 -> "o3";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

collection O = implement Object_test; end;;


species Access_mode_test =

  inherit Access_mode_blp;

  representation = bool;

  let read = true;
  let write = false;

  let cardinal = 2;
  let all_to_list = [read; write];

  let element = read;
  let equal (a_1, a_2) = a_1 = a_2;
  let print (a) = if a then "read" else "write";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

collection A = implement Access_mode_test; end;;

collection Ac = implement Accesses_by_list (S, O, A); end;;

collection T = implement Target_ac_by_list (S, O, A, Ac); end;;


species Security_level_test =

  inherit Security_level;

  representation = int;

  let l1 : Self = 1;
  let l2 : Self = 2;
  let l3 : Self = 3;
  let l4 : Self = 4;
  let l5 : Self = 5;

  theorem only_them :
    all l : Self,
    equal (l, l1) \/ equal (l, l2) \/ equal (l, l3) \/ equal (l, l4) \/
    equal (l, l5)
  proof = assumed;              (* TODO *)

  let leq (l_1 : Self, l_2 : Self) = l_1 <=0x l_2;

  proof of leq_extends_equal = assumed; (* TODO *)
                               (* by property int_le_refl *)
                               (*    definition of leq; *)
  proof of leq_transitive = by property int_le_trans
                               definition of leq;

  let cardinal = 5;
  let all_to_list = [l1; l2; l3; l4; l5];

  let element = l1;
  let equal (l_1, l_2) = l_1 = l_2;
  let print (l) = "l" ^ string_of_int (l);

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

end;;


species Configuration_blp_test (Sub is Subject_test, Obj is Object_test,
                                Lev is Security_level_test) =

  inherit Configuration_blp (Sub, Obj, Lev);

  representation = unit;

  let fs (s : Sub) =
    if      Sub!equal (s, Sub!s1) then Lev!l3
    else if Sub!equal (s, Sub!s2) then Lev!l2
    else if Sub!equal (s, Sub!s3) then Lev!l4
    else Lev!l1;

  let fo (o : Obj) =
    if      Obj!equal (o, Obj!o1) then Lev!l4
    else if Obj!equal (o, Obj!o2) then Lev!l2
    else if Obj!equal (o, Obj!o3) then Lev!l3
    else Lev!l1;

  let element = ();
  let equal (a, b) = a = b;
  let print (_c) = "c";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

end;;

collection Lev = implement Security_level_test; end;;

collection C = implement Configuration_blp_test (S, O, Lev); end;;

collection P = implement P_policy_blp (S, O, A, Ac, Lev, T, C); end;;


let assert_secure (t, c, b) =
  let conf = "(" ^ T!print (t) ^ ", " ^ C!print (c) ^ ")" in
  let ass = if b then "secure" else "not secure" in
  if (b && P!secure (t, c)) || (~~ b && ~~ P!secure (t, c))
  then print_string (conf ^ " " ^ ass ^ "   OK\n")
  else print_string (conf ^ " " ^ ass ^ "   KO\n");;


let target_0 = T!empty;;
let target_1 = T!add (target_0, S!s1, O!o3, A!read);;
let target_2 = T!add (target_1, S!s1, O!o2, A!write);;

let target_3 = T!add (target_1, S!s1, O!o1, A!write);;
let target_4 = T!add (target_3, S!s2, O!o1, A!read);;

let configuration_0 = C!element;;

assert_secure (target_0, configuration_0, true);;
assert_secure (target_1, configuration_0, true);;
assert_secure (target_2, configuration_0, false);;

assert_secure (target_3, configuration_0, true);;
assert_secure (target_4, configuration_0, false);;



collection St = implement State_ac_by_list (S, O, A, Ac); end;;

collection L = implement Label_ac (S, O, A); end;;

collection Sys_ac =
  implement Operational_transition_system_ac (S, O, A, Ac, St, L); end;;


collection Ss =
  implement Secured_state_blp (S, O, A, Ac, Lev, T, C, P, St); end;;

collection Sys =
  implement Secured_operational_transition_system_blp
    (S, O, A, Ac, Lev, T, C, P, St, L, Sys_ac, Ss); end;;


let print_trans (st, l) =
  let st2 = Sys!transition (st, l) in
  let _a = print_string (Ss!print (st) ^ " --[" ^ L!print (l) ^ "]--> " ^
                         Ss!print (st2) ^ "\n") in
  st2;;

let c = C!element;;

let st = Ss!pair (St!empty, c);;

let st1 = print_trans (st, L!label (Add, S!s1, O!o3, A!read));;

let st2 = print_trans (st1, L!label (Add, S!s1, O!o2, A!write));;

let st3 = print_trans (st2, L!label (Add, S!s1, O!o1, A!write));;

let st4 = print_trans (st3, L!label (Add, S!s2, O!o1, A!read));;

