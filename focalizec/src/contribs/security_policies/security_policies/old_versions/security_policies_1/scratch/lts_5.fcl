
open "basics";;
open "my_sets_orders";;
open "products";;
open "ensembles_finis";;

species Simple_transition (State is Setoid) =

    inherit Cartesian_product (State, State);

end;;


species Labelled_transition (State is Setoid,
                             Transition is Simple_transition (State),
                             Label is Setoid) =

    inherit Cartesian_product (Transition, Label);

    let transition (p, l, q) : Self = pair (Transition!pair (p, q), l);

    let source (t) = Transition!first (first (t));
    let destination (t) = Transition!second (first (t));
    let label (t) = second (t);

    let print (t) =
      State!print (source (t)) ^
      " -[" ^ Label!print (label (t)) ^ "]-> " ^
      State!print (destination (t));

    let graphviz_print (t) =
      State!print (source (t)) ^ " -> " ^ State!print (destination (t)) ^
      " [label = " ^ Label!print (label (t)) ^ "]";

end;;


species Ensemble_fini (A is Setoid) =

    inherit Ensembles_finis (A);

    signature un_element : Self -> A;

    (* property un_element_vide : Comment spécifier une erreur ? *)

    property un_element_non_vide :
      all s : Self,
      ~ (equal (s, vide)) -> est_element (un_element (s), s);

end;;


species Ensemble_fini_ordonne (A is Ordered_set) =
    inherit Ensembles_finis_ordonnes (A), Ensemble_fini (A); end;;


species System (State is Setoid,
                States is Ensemble_fini (State),
                Label is Setoid,
                Labels is Ensemble_fini (Label),
                S_transition is Simple_transition (State),
                Transition is Labelled_transition (State, S_transition, Label),
                Transitions is Ensemble_fini (Transition),
                Executions is Ensemble_fini (States) ) =
    (* TODO : il faut un ordre pour diférencier a->b->c de a->c->b *)

    inherit Basic_object;

    signature system : States -> States -> Labels -> Transitions -> Self;
    
    signature states : Self -> States;
    signature initial_states : Self -> States;
    signature labels : Self -> Labels;
    signature transitions : Self -> Transitions;

    signature reachables : Self -> States;
    signature executions : Self -> Executions;

    logical let in_s (x : State, s : Self) =
      States!est_element (x, states (s));
    logical let in_i (x : State, s : Self) =
      States!est_element (x, initial_states (s));
    logical let in_l (x : Label, s : Self) =
      Labels!est_element (x, labels (s));
    logical let in_t (x : Transition, s : Self) =
      Transitions!est_element (x, transitions (s));
    logical let in_r (x : State, s : Self) =
      States!est_element (x, reachables (s));
    logical let in_e (x : States, s : Self) =
      Executions!est_element (x, executions (s));

    logical let trans (p, l, q, s) = in_t (Transition!transition (p, l, q), s);

    property initials_in_states :
      all s : Self, States!sous_ensemble (initial_states (s), states (s));

    property transitions_in_states_and_labels :
      all s : Self, all p q : State, all l : Label,
      trans (p, l, q, s) -> ( in_s (p, s) /\ in_l (l, s) /\ in_s (q, s) );

    
    (* property transitions_in_states_and_labels_1 : *)
    (*   all s : Self, all t : Transition, *)
    (*   in_t (t, s) -> ( in_s (Transition!source (t), s) /\ *)
    (*                    in_l (Transition!label (t), s) /\ *)
    (*                    in_s (Transition!destination (t), s) ); *)

    property determinist :
      all s : Self, all x y z : State, all l : Label,
      in_s (x, s) -> in_s (y, s) -> in_s (z, s) -> in_l (l, s) ->
      ( trans (x, l, y, s) /\ trans (x, l, z, s) ) -> State!equal (y, z);

    property left_total :
      all s : Self, all x : State, all l : Label,
      in_s (x, s) -> in_l (l, s) ->
      ex y : State, in_s (y, s) /\ trans (x, l, y, s);

    property reachables_spec :
      all s : Self, all x : State,
      in_r (x, s) <-> ( in_i (x, s) \/
                        ex y : State, ex l : Label,
                        ( in_r (y, s) /\ trans (y, l, x, s) ) );

    theorem initials_in_reachables :
      all s : Self, States!sous_ensemble (initial_states (s), reachables (s))
    proof = assumed;                    (* TODO *)

    theorem reachables_in_states :
      all s : Self, States!sous_ensemble (reachables (s), states (s))
    proof = assumed;                    (* TODO *)
            (* by property reachables_spec, initials_in_states, *)
            (*             transitions_in_states_and_labels; *)

    theorem reachable_induction :
      all s : Self, all x y : State, all l : Label,
      in_r (x, s) -> trans (x, l, y, s) -> in_r (y, s)
    proof = assumed;                    (* TODO *)

    (* property executions_spec : *)
    (*   all s : Self, all e : States, *)
    (*   in_e (e, s) <-> ( (ex x : State, States!est_element (x, e) /\ in_i (x)) /\ *)
          (* TODO : sequence, ordre important !! *)

end;;


species System_Impl (State is Setoid,
                     States is Ensemble_fini (State),
                     Label is Setoid,
                     Labels is Ensemble_fini (Label),
                     S_transition is Simple_transition (State),
                     Transition is
                       Labelled_transition (State, S_transition, Label),
                     Transitions is Ensemble_fini (Transition),
                     Executions is Ensemble_fini (States) ) =
    (* TODO : il faut un ordre pour diférencier a->b->c de a->c->b *)

    inherit System (State, States, Label, Labels, S_transition, Transition,
                    Transitions, Executions);

    representation = States * States * Labels * Transitions;

    let states (s : Self) =         match s with | (s, _, _, _) -> s;
    let initial_states (s : Self) = match s with | (_, i, _, _) -> i;
    let labels (s : Self) =         match s with | (_, _, l, _) -> l;
    let transitions (s : Self) =    match s with | (_, _, _, t) -> t;

    let rec transitions_in_states_and_labels_predicate (t, s, l) =
      if Transitions!equal (t, Transitions!vide) then true
      else
        let tr = Transitions!un_element (t) in
        States!est_element (Transition!source (tr), s) &&
        States!est_element (Transition!destination (tr), s) &&
        Labels!est_element (Transition!label (tr), l) &&
        transitions_in_states_and_labels_predicate (
          Transitions!diff (t, Transitions!singleton (tr)), s, l);

    let rec determinist_predicate_aux (x, l, y, t) =
      if Transitions!equal (t, Transitions!vide) then true
      else
        let h = Transitions!un_element (t) in
        let q = Transitions!diff (t, Transitions!singleton (h)) in
        if ( State!equal (Transition!source (h), x) &&
             Label!equal (Transition!label (h), l) ) then
          State!equal (Transition!destination (h), y) &&
          determinist_predicate_aux (x, l, y, q)
        else determinist_predicate_aux (x, l, y, q);

    let rec determinist_predicate (t) =
      if Transitions!equal (t, Transitions!vide) then true
      else
        let h = Transitions!un_element (t) in
        let q = Transitions!diff (t, Transitions!singleton (h)) in
        determinist_predicate_aux (Transition!source (h), Transition!label (h),
                                   Transition!destination (h), q) &&
        determinist_predicate (q);

    let rec exist_transition (x, l, t) =
      if Transitions!equal (t, Transitions!vide) then false
      else
        let h = Transitions!un_element (t) in
        let q = Transitions!diff (t, Transitions!singleton (h)) in
        ( State!equal (Transition!source (h), x) &&
          Label!equal (Transition!label (h), l) ) || exist_transition (x, l, q);

    let rec left_total_predicate_aux (l, x, t) =
      if Labels!equal (l, Labels!vide) then true
      else
        let h = Labels!un_element (l) in
        let q = Labels!diff (l, Labels!singleton (h)) in
        exist_transition (x, h, t) && left_total_predicate_aux (q, x, t);

    let rec left_total_predicate (s, l, t) =
      if States!equal (s, States!vide) then true
      else
        let h = States!un_element (s) in
        let q = States!diff (s, States!singleton (h)) in
        left_total_predicate_aux (l, h, t) &&
        left_total_predicate (q, l, t);

    let system (s, i, l, t) : Self =
      if ( States!sous_ensemble (i, s) &&
           transitions_in_states_and_labels_predicate (t, s, l) &&
           determinist_predicate (t) && left_total_predicate (s, l, t) ) then
        (s, i, l, t)
      else
        (* (States!vide, States!vide, Labels!vide, Transitions!vide); *)
        focalize_error ("not correct system");
        (* Erreur ? *)

    let rec reachables_from_state (x, t) =
      if Transitions!equal (t, Transitions!vide) then States!singleton (x)
      else
        let h = Transitions!un_element (t) in
        let q = Transitions!diff (t, Transitions!singleton (h)) in
        if State!equal (Transition!source (h), x) then
          States!ajoute_element (Transition!destination (h),
                                 reachables_from_state (x, q))
        else reachables_from_state (x, q);

    let rec reachables_from_states (i, t) =
      if States!equal (i, States!vide) then States!vide
      else
        let h = States!un_element (i) in
        let q = States!diff (i, States!singleton (h)) in
        States!union (reachables_from_state (h, t),
                      reachables_from_states (q, t));

    let reachables (s) =
      reachables_from_states (initial_states (s), transitions (s));

    let executions (s : Self) = Executions!vide; (* TODO *)

    let rec print_transitions_from_state (x, t, graph) =
      if Transitions!equal (t, Transitions!vide) then ""
      else
        let h = Transitions!un_element (t) in
        let q = Transitions!diff (t, Transitions!singleton (h)) in
        if State!equal (Transition!source (h), x) then
          if graph then
            Transition!graphviz_print (h) ^ "\n" ^
            print_transitions_from_state (x, q, graph)
          else
            Transition!print (h) ^ "\n" ^
            print_transitions_from_state (x, q, graph)
        else
          print_transitions_from_state (x, q, graph);

    let rec print_initial_states (i, t, graph) =
      if States!equal (i, States!vide) then ""
      else
        let h = States!un_element (i) in
        let q = States!diff (i, States!singleton (h)) in
        print_transitions_from_state (h, t, graph) ^ "\n" ^
        print_initial_states (q, t, graph);

    let rec print_other_states (s, i, t, graph) =
      if States!equal (s, States!vide) then ""
      else
        let h = States!un_element (s) in
        let q = States!diff (s, States!singleton (h)) in
        if States!est_element (h, i) then
          print_other_states (q, i, t, graph)
        else
          print_transitions_from_state (h, t, graph) ^ "\n" ^
          print_other_states (q, i, t, graph);

    let print (s) =
      "Initial states :\n\n" ^
      print_initial_states (initial_states (s), transitions (s), false) ^
      "Other states :\n\n" ^
      print_other_states (states (s), initial_states (s), transitions (s),
                          false);

    let rec graphviz_print_header (i, n) =
      if States!equal (i, States!vide) then ""
      else
        let h = States!un_element (i) in
        let q = States!diff (i, States!singleton (h)) in
        "null_" ^ string_of_int (n) ^ " [shape = plaintext label = \"\"]\n" ^
        "null_" ^ string_of_int (n) ^ " -> " ^ State!print (h) ^ "\n" ^
        graphviz_print_header (q, n + 1);

    let graphviz_print (s) =
      "digraph {\n\nnode [shape = circle];\n\n" ^
      graphviz_print_header (initial_states (s), 0) ^ "\n" ^
      "// Initial states :\n\n" ^
      print_initial_states (initial_states (s), transitions (s), true) ^
      "// Other states :\n\n" ^
      print_other_states (states (s), initial_states (s), transitions (s),
                          true) ^ "}\n";

      (* TODO *)
    proof of initials_in_states = assumed;
    proof of transitions_in_states_and_labels = assumed;
    proof of determinist = assumed;
    proof of left_total = assumed;
    proof of reachables_spec = assumed;

end;;




(* Tests *)

collection Simple_transition_Coll = implement Simple_transition (Entiers); end;;

collection Transition_Coll =

    implement Labelled_transition (Entiers, Simple_transition_Coll, Entiers);

end;;

let t = Transition_Coll!transition (Entiers!parse ("1"), Entiers!parse ("4"), Entiers!parse ("2"));;
(* print_string (Entiers!print (Transition_Coll!source (t)));; *)
(* print_string (" -" ^ (Entiers!print (Transition_Coll!label (t))) ^ "-> ");; *)
(* print_string (Entiers!print (Transition_Coll!destination (t)));; *)
(* print_string ("\n");; *)



species Liste_get (A is Setoid) =

    inherit Ensemble_fini (A), Liste (A);

    let un_element (l : Self) =
      match l with
        | [] -> focalize_error ("un_element from vide")
        | x :: _ -> x;

    proof of un_element_non_vide = assumed; (* TODO *)

end;;

species Liste_triee_get (A is Ordered_set) =
    inherit Ensemble_fini_ordonne (A), Liste_get (A), Liste_triee (A); end;;

collection Ensemble_entiers_get = implement Liste_triee_get (Entiers); end;;

collection Ensemble_transitions = implement Liste_get (Transition_Coll); end;;

collection Ensemble_executions =
    implement Liste_get (Ensemble_entiers_get); end;;

collection System_int =
    implement System_Impl (Entiers, Ensemble_entiers_get, Entiers,
                           Ensemble_entiers_get, Simple_transition_Coll,
                           Transition_Coll, Ensemble_transitions,
                           Ensemble_executions);
end;;


let zero = Entiers!parse ("0");;
let un = Entiers!parse ("1");;
let deux = Entiers!parse ("2");;
let trois = Entiers!parse ("3");;
let quatre = Entiers!parse ("4");;

let pairs =
  Ensemble_entiers_get!ajoute_element
   (quatre, Ensemble_entiers_get!ajoute_element
       (zero, Ensemble_entiers_get!ajoute_element
          (deux, Ensemble_entiers_get!vide)));;

let impairs =
   Ensemble_entiers_get!ajoute_element
     (trois, Ensemble_entiers_get!ajoute_element
        (un, Ensemble_entiers_get!vide));;

let total = Ensemble_entiers_get!union (pairs, impairs);;

let t1 = Transition_Coll!transition (zero, un, deux);;
let t2 = Transition_Coll!transition (zero, trois, zero);;
let t3 = Transition_Coll!transition (un, un, trois);;
let t4 = Transition_Coll!transition (un, trois, trois);;
let t5 = Transition_Coll!transition (deux, un, deux);;
let t6 = Transition_Coll!transition (deux, trois, un);;
let t7 = Transition_Coll!transition (trois, un, deux);;
let t8 = Transition_Coll!transition (trois, trois, quatre);;
let t9 = Transition_Coll!transition (quatre, un, quatre);;
let t10 = Transition_Coll!transition (quatre, trois, quatre);;
let trans =
  Ensemble_transitions!ajoute_element
    (t1, Ensemble_transitions!ajoute_element
       (t2, Ensemble_transitions!ajoute_element
          (t3, Ensemble_transitions!ajoute_element
             (t4, Ensemble_transitions!ajoute_element
                (t5, Ensemble_transitions!ajoute_element
                   (t6, Ensemble_transitions!ajoute_element
                      (t7, Ensemble_transitions!ajoute_element
                         (t8, Ensemble_transitions!ajoute_element
                            (t9, Ensemble_transitions!ajoute_element
                               (t10, Ensemble_transitions!vide))))))))));;
       

let sys = System_int!system (total, pairs, impairs, trans);;
print_string ("\n" ^ System_int!print (sys));;
print_string ("\n" ^ System_int!graphviz_print (sys));;
