open "basics";;
open "products";;
open "lts";;



(** A secure state has a normal state and can be secure or not. *)
species Secure_state (S is State) =

  inherit State;

  (** Non-secure state *)
  signature state : Self -> S;

  signature is_secure : Self -> bool;

  (** A secure state with the given non-secure state *)
  signature make : S -> Self;

  property make_state :
    all s : S, S!equal (state (make (s)), s);

  let is_initial  (x : Self) =
    S!is_initial (state (x)) && is_secure (x);

  theorem is_initial_spec :
    all x : Self,
    is_initial (x) <-> (S!is_initial (state (x)) /\ is_secure (x))
  proof = by definition of is_initial;

end;;



(** A system in which all reachable states are secure. *)
species Secure_transition_system (St is State, L is Label,
                                  Sys is Transition_system (St, L),
                                  Ss is Secure_state (St)) =

  inherit Transition_system (Ss, L);

  (** If a state is reachable from a secure state, it must be secure. *)
  let delta (x : Ss, l : L, y : Ss) =
    Sys!delta (Ss!state (x), l, Ss!state (y)) &&
    ( ~~ Ss!is_secure (x) || Ss!is_secure (y) );

  theorem all_secure : all x : Ss, is_reachable (x) -> Ss!is_secure (x)
  proof = assumed;              (* TODO *)

end;;



species Secure_operational_transition_system
  (St is State, L is Label,
   Sys is Operational_transition_system (St, L),
   Ss is Secure_state (St)) =

  inherit Secure_transition_system (St, L, Sys, Ss),
          Operational_transition_system (Ss, L);

  (** For completeness, non secure transitions are redirected to
      the same state. *)
  let delta (x : Ss, l : L, y : Ss) =
    if ~~ Ss!is_secure (x) || Ss!is_secure (y) then
      Sys!delta (Ss!state (x), l, Ss!state (y))
    else
      Ss!equal (x, y);

  (* la preuve sera cassee *)
  (* proof of all_secure = assumed;  (\* TODO *\) *)

  proof of determinist = assumed; (* TODO *)

  proof of complete = assumed;	  (* TODO *)

  (** Transition of the non secure system with the same configuration or,
      if not secure transition, the same state *)
  let transition (x, l) =
    let s = Sys!transition (Ss!state (x), l) in
    let y = Ss!make (s) in
    if delta (x, l, y) then y else x;

  proof of transition_is_valid = assumed; (* TODO *)

  theorem delta_and_some_implies_transition :
    all x y : Ss, all l : L,
    (delta (x, l, y) /\ Ss!equal (x, y)) -> Ss!equal (transition (x, l), y)
    (* \/ C!equal (Ss!configuration (x), Ss!configuration (y)) *)
  proof = assumed;              (* TODO *)

end;;
