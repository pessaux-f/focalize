open "basics";;
open "products";;
open "lts";;
open "p_policies";;


species Secure_state (A is Target, C is Configuration, P is P_policy (A, C),
                      S is State) =

  (* ??? egalite uniquement sur S ??? *)

  inherit Product_set (S, C), State;

  signature interpretation : S -> A;

  let state = first;
  let configuration = second;

  let is_secure (x : Self) =
    P!relation (interpretation (state (x)), configuration (x));

  let is_initial  (x : Self) =
    S!is_initial (state (x)) && is_secure (x);

end;;


species Secure_transition_system (A is Target, C is Configuration,
                                  P is P_policy (A, C),
                                  St is State, L is Label,
                                  S is Transition_system (St, L),
                                  Ss is Secure_state (A, C, P, St)) =

  inherit Transition_system (Ss, L);

  let delta (x : Ss, l : L, y : Ss) =
    S!delta (Ss!state (x), l, Ss!state (y)) &&
    ( ~~ (Ss!is_secure (x)) || Ss!is_secure (y) );

  theorem all_secure : all x : Ss, is_reachable (x) -> Ss!is_secure (x)
  proof = assumed;              (* TODO *)

end;;



(** /!\ Operational_transition_system not inherited (not complete) *)
species Secure_operational_transition_system
  (A is Target, C is Configuration,
   P is P_policy (A, C),
   St is State, L is Label,
   S is Operational_transition_system (St, L),
   Ss is Secure_state (A, C, P, St)) =

  inherit Secure_transition_system (A, C, P, St, L, S, Ss);

  theorem determinist : is_determinist
  proof = assumed;              (* TODO *)

    (* TODO *)

  (* let transition (x, l) = *)
  (*   let y = S!transition (Ss!state (x), l) in *)
  (*   if delta (x, l, y) then y else x; *)

  (* theorem delta_implies_transition : *)
  (*   all x y : St, all l : L, *)
  (*   delta (x, l, y) -> transition (x, l) =S y *)
  (* proof = assumed;              (\* TODO *\) *)

  (* theorem transition_diff_implies_delta : *)
  (*   all x y : St, all l : L, *)
  (*   (transition (x, l) =S y /\ ~ x =S y) -> delta (x, l, y) *)
  (* proof = assumed;              (\* TODO *\) *)

  (* (\** A multiple transition from state x with a list l of labels *\) *)
  (* let transition_iter = *)
  (*   let rec aux (l, x) = *)
  (*     match l with *)
  (*       | [] -> x *)
  (*       | h :: t -> aux (t, transition (x, h)) in *)
  (*   function x -> function l -> aux (l, x); *)

end;;
