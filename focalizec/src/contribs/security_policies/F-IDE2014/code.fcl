open "basics";;
open "sets";;
open "products";;


(** Binary relations *)


(** A : domain, B : codomain *)
species Binary_relations (A is Setoid, B is Setoid) =

  inherit Partial_set;

  (* the folowing property souldn't be there but rather in the setoid species *)
  logical let is_A_singleton = all a : A, A!equal (a, A!element);
  theorem is_A_singleton_spec :
    is_A_singleton <-> all a : A, A!equal (a, A!element)
  proof = by definition of is_A_singleton;

  logical let is_B_singleton = all b : B, B!equal (b, B!element);
  theorem is_B_singleton_spec :
    is_B_singleton <-> all b : B, B!equal (b, B!element)
  proof = by definition of is_B_singleton;

  signature relation : Self -> A -> B -> bool;

  property relation_compatible_left : all r: Self, all a1 a2: A, all b: B,
    A!equal(a1, a2) -> (relation(r, a1, b) -> relation(r, a2, b));

  property relation_compatible_right : all r: Self, all a: A, all b1 b2: B,
    B!equal(b1, b2) -> (relation(r, a, b1) -> relation(r, a, b2));

  signature is_contained: Self -> Self -> bool ;

  property is_contained_spec: all r_1 r_2: Self, 
        is_contained(r_1, r_2) 
   <->  all a: A, all b: B, 
         relation(r_1, a, b) -> relation(r_2, a, b);

  let equal(x, y) = is_contained(x, y) && is_contained(y, x) ;

  theorem equal_spec :
    all r1 r2 : Self,
    equal (r1, r2) <-> (all a : A, all b : B,
                       relation (r1, a, b) <-> relation (r2, a, b))
  proof = by definition of equal property is_contained_spec ;

  proof of equal_reflexive = by property equal_spec;
  proof of equal_symmetric = by property equal_spec;
  proof of equal_transitive = by property equal_spec;

  (** Construction of relations, properties and belonging to the species *)

  signature empty : unit -> Self;
 
  logical let is_internal_empty = true;

  property empty_spec :
    is_internal_empty ->
      all a : A, all b : B, ~ relation (empty (()), a, b);

  signature full : unit -> Self;

  logical let is_internal_full = true;

  property full_spec :
      is_internal_full ->
      all a : A, all b : B, relation (full (()), a, b);

  signature singleton : A -> B -> Self;

  logical let is_internal_singleton (_a : A, _b : B) = true;

  property singleton_spec :
    all a1 : A, all b1 : B,
    is_internal_singleton(a1, b1) ->
      all a2 : A, all b2 : B,
      relation (singleton (a1, b1), a2, b2) <->
      ( A!equal (a1, a2) && B!equal (b1, b2) );


  signature union : Self -> Self -> Self;

  logical let is_internal_union (_r1 : Self, _r2 : Self) = true;

  property union_spec :
    all r1 r2 : Self,
    is_internal_union(r1, r2) ->
      all a : A, all b : B,
      relation (union (r1, r2), a, b) <->
      ( relation (r1, a, b) \/ relation (r2, a, b) );

  signature inter : Self -> Self -> Self;

  logical let is_internal_inter (_r1 : Self, _r2 : Self) = true;

  property inter_spec :
    all r1 r2 : Self,
    is_internal_inter(r1, r2) ->
      all a : A, all b : B,
      relation (inter (r1, r2), a, b) <->
      ( relation (r1, a, b) /\ relation (r2, a, b) );

  signature diff : Self -> Self -> Self;

  logical let is_internal_diff (_r1 : Self, _r2 : Self) = true;

  property diff_spec :
    all r1 r2 : Self,
    is_internal_diff (r1, r2) ->
      all a : A, all b : B,
      relation (diff (r1, r2), a, b) <->
      ( relation (r1, a, b) /\ ~ relation (r2, a, b) );

  (* Witness for the Setoid *)
  let element = singleton(A!element, B!element) ;

(** Properties over relations *)

  logical let is_left_unique (r) =
    all a1 a2 : A, all b : B,
    ( relation (r, a1, b) /\ relation (r, a2, b) ) -> A!equal (a1, a2);

  theorem is_left_unique_spec : all r: Self, 
   (all a1 a2 : A, all b : B,
     ( relation (r, a1, b) /\ relation (r, a2, b) ) -> A!equal (a1, a2))
   <-> is_left_unique (r)
  proof = by definition of is_left_unique;

  logical let is_right_unique (r) =
    all a : A, all b1 b2 : B,
    ( relation (r, a, b1) /\ relation (r, a, b2) ) -> B!equal (b1, b2);

  theorem is_right_unique_spec : all r: Self,
    (all a : A, all b1 b2 : B,
      ( relation (r, a, b1) /\ relation (r, a, b2) ) -> B!equal (b1, b2))
    <-> is_right_unique (r)
  proof = by definition of is_right_unique;
 
  logical let is_left_total (r) =
    all a : A, ex b : B, relation (r, a, b);

 theorem is_left_total_spec : all r: Self,
    (all a : A, ex b : B, relation (r, a, b))
    <-> is_left_total(r)
  proof = by definition of is_left_total;

  logical let is_right_total (r) =
    all b : B, ex a : A, relation (r, a, b);

  theorem is_right_total_spec : all r: Self,
    (all b : B, ex a : A, relation (r, a, b))
    <-> is_right_total(r)
  proof = by definition of is_right_total;

end;;

species Injective_relations (A is Setoid, B is Setoid) =

  inherit Binary_relations (A, B);

  property left_unique : all r : Self, is_left_unique (r);


  (* A can't be empty so full is injective iff A is a singleton *)
  logical let is_internal_full = is_A_singleton;

  logical let is_internal_union(r1, r2) =
    all a1 a2 : A, all b : B,
    ( relation (r1, a1, b) /\ relation (r2, a2, b) ) -> A!equal (a1, a2) ;



  theorem left_unique_empty :
    is_internal_empty -> is_left_unique (empty (()))
  proof = by definition of is_left_unique property empty_spec ;

  theorem left_unique_full :
    is_internal_full -> is_left_unique (full (()))
(*  proof = by definition of is_left_unique, is_internal_full, is_A_singleton;*)
(* TODO : bizzare, tout est trop facile avec la propriété left_unique ... *)
  proof = by definition of is_left_unique property left_unique;

  theorem left_unique_singleton :
    all a : A, all b : B,
    is_internal_singleton (a, b) -> is_left_unique (singleton (a, b))
  proof = assumed;            (* TODO *)

  theorem  left_unique_union :
    all r1 r2 : Self,
    is_internal_union (r1, r2) -> is_left_unique (union (r1, r2))
  proof = by definition of is_internal_union, is_left_unique
             property union_spec, left_unique;

  theorem left_unique_inter :
    all r1 r2 : Self,
    is_internal_inter (r1, r2) -> is_left_unique (inter (r1, r2))
  proof = assumed;            (* TODO *)

  theorem left_unique_diff :
    all r1 r2 : Self,
    is_internal_diff (r1, r2) -> is_left_unique (diff (r1, r2))
  proof = assumed;
end;;

(* ========================================================================== *)


species Internal_binary_relations(A is Setoid)=
  
  inherit Binary_relations(A, A);

  (** Identity relation is added *)

  signature identity : unit -> Self;
  logical let is_internal_identity = true;

  property identity_spec : all x y : A,
    is_internal_identity ->
      (relation(identity(()), x, y) <-> A!equal(x, y));

  (** Properties over an internal relation *)

  logical let is_reflexive(r: Self) = 
     all x: A, relation(r, x, x);
  theorem is_reflexive_spec : all r: Self,
     (all x: A, relation(r, x, x)) <-> is_reflexive(r)
  proof = by definition of is_reflexive ;

  logical let is_transitive(r: Self) = 
     all x y z : A, (relation(r, x, y) /\ relation(r, y, z))
       -> relation(r, x, z) ;  
  theorem is_transitive_spec : all r: Self,
    (all x y z : A, (relation(r, x, y) /\ relation(r, y, z))
       -> relation(r, x, z))
    <-> is_transitive(r)
  proof = by definition of is_transitive ;

  logical let is_symmetric(r: Self) =
     all x y : A, relation(r, x, y) -> relation(r, y, x);
  theorem is_symmetric_spec : all r: Self,
     ( all x y : A, relation(r, x, y) -> relation(r, y, x) )
       <-> is_symmetric(r)
  proof = by definition of is_symmetric;

  logical let is_antisymmetric(r: Self) =
     all x y : A, ( relation(r, x, y) /\ relation(r, y, x) ) -> A!equal(x, y);
  theorem is_antisymmetric_spec : all r: Self,
   ( all x y : A, ( relation(r, x, y) /\ relation(r, y, x) ) -> A!equal(x, y) )
       <-> is_antisymmetric(r)
  proof = by definition of is_antisymmetric;

  logical let is_preorder(r: Self) =
    is_reflexive(r) /\ is_transitive(r);
  theorem is_preorder_spec : all r: Self,
    (is_reflexive(r) /\ is_transitive(r)) <-> is_preorder(r)
  proof = by definition of is_preorder;

  logical let is_equivalence(r: Self) =
    is_preorder(r) /\ is_symmetric(r);
  theorem is_equivalence_spec : all r: Self,
    (is_preorder(r) /\ is_symmetric(r)) <-> is_equivalence(r)
  proof = by definition of is_equivalence;

  logical let is_order(r: Self) =
    is_preorder(r) /\ is_antisymmetric(r);
  theorem is_order_spec : all r: Self,
    (is_preorder(r) /\ is_antisymmetric(r)) <-> is_order(r)
  proof = by definition of is_order;

  (** Operations on internal relations *)

  signature product : Self -> Self -> Self;

  property product_spec : all r1 r2 : Self, all x z : A,
    relation(product(r1, r2), x, z) <->
    (ex y : A, relation(r1, x, y) /\ relation(r2, y, z));

  (* TODO : inverse, ca se dit en anglais ? *)
  signature inverse : Self -> Self;

  property inverse_spec : all r : Self, all x y : A,
    relation(inverse(r), x, y) <-> relation(r, y, x);

  (* Theorems ... *)

  theorem thm01 : all r : Self,
    is_symmetric(r) <-> equal(r, inverse(r))
  proof = by property is_symmetric_spec, equal_spec, is_contained_spec, inverse_spec ;


  theorem thm02 : all r : Self,
    is_left_total(r) -> is_reflexive(product(r, inverse(r)))
  proof =
   <1>1 assume r : Self, assume x z : A,
        hypothesis H : is_left_total(r),
        prove A!equal(x, z) -> relation(product(r, inverse(r)), x, z)
    <2>1 (* assuming that an y exists *)
         assume y : A, hypothesis HE : relation(r, x, y),
         hypothesis Heq : A!equal(x, z),
         prove relation(product(r, inverse(r)), x, z)
     <3>1 prove relation(inverse(r), y, z)
          by property relation_compatible_left, inverse_spec hypothesis Heq, HE
     <3>f qed by step <3>1 hypothesis HE property product_spec
    <2>2 (* providing a witness *)
         prove ex y : A, relation(r, x, y)
         by property is_left_total_spec hypothesis H
    <2>f qed by step <2>1, <2>2 property product_spec
(* <1>f qed by property A!equal_reflexive, is_reflexive_spec *)
(* BUG ZENON : "exhausted search space without finding a proof" *)
(*             while the following is working : *)
   <1>2 prove all x: A, A!equal(x, x)
        by property A!equal_reflexive
   <1>3 assume r : Self,
        prove all x : A,
                is_left_total(r) -> relation(product(r, inverse(r)), x, x)
        by step <1>1, <1>2
   <1>f qed by step <1>3 property is_reflexive_spec ;

(* TODO : theoremes sur composition : *)
(* theorem R symetrique ssi R.inverse(R) = R *)
 
(* TODO : when possible, replace "by definition of ..." by    *)
(*                               "by property ..._spec"       *)

end;;

(****
pour l'implem : 
species relations_finies inheriths relation et finitepart puis species relationfiiesbylist 
inherits relationsfinies

donner le produit et l'inverse

+ def de l'espece des applications avec signature f:a->B et def de relation a partir de f + preuve 
de isdetermist

tri topo !!
***)