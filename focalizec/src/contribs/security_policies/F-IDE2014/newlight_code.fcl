open "basics";;
open "sets";;
open "products";;
(* open "listes";; *)
(* open "finite_sets_f";; *)

(** ======= Binary Relations ======= *)

(** A : domain, B : codomain *)

species Binary_relations (A is Setoid, B is Setoid) =

  inherit Setoid;  

  signature relation : Self -> A -> B -> bool;

  property relation_compatible_left : all r: Self, all a1 a2: A, all b: B,
    A!equal(a1, a2) -> (relation(r, a1, b) -> relation(r, a2, b));

  property relation_compatible_right : all r: Self, all a: A, all b1 b2: B,
    B!equal(b1, b2) -> (relation(r, a, b1) -> relation(r, a, b2));

  signature is_contained: Self -> Self -> bool ;

  property is_contained_spec: all r_1 r_2: Self, 
        is_contained(r_1, r_2) 
   <->  all a: A, all b: B, 
         relation(r_1, a, b) -> relation(r_2, a, b);

  let equal(x, y) = is_contained(x, y) && is_contained(y, x) ;

  theorem equal_spec :
    all r1 r2 : Self,
    equal (r1, r2) <-> (all a : A, all b : B,
                       relation (r1, a, b) <-> relation (r2, a, b))
  proof = by definition of equal property is_contained_spec ;

  proof of equal_reflexive = by property equal_spec;
  proof of equal_symmetric = by property equal_spec;
  proof of equal_transitive = by property equal_spec;

  logical let is_union_r(r1,r2,r3) = all a : A, all b : B, 
    relation(r3,a,b) <-> (relation(r1,a,b) \/ relation(r2,a,b));

  theorem is_union_r_spec : all r1 r2 r3 : Self,
    is_union_r(r1,r2,r3) <-> (all a : A, all b : B, 
    relation(r3,a,b) <-> (relation(r1,a,b) \/ relation(r2,a,b)))
  proof = by definition of is_union_r;

  logical let is_empty_r(r) = all a : A, all b : B, ~ relation(r,a,b) ;
  logical let is_full_r(r) = all a : A, all b : B, relation(r,a,b) ;

  logical let is_intersection_r(r1,r2,r3) = all a : A, all b : B, 
    relation(r3,a,b) <-> (relation(r1,a,b) /\ relation(r2,a,b));

  logical let is_diff_r(r1,r2,r3) = all a : A, all b : B, 
    relation(r3,a,b) <-> (relation(r1,a,b) /\ ~ relation(r2,a,b));

  logical let is_singleton_r(r,a,b) = all a1 : A, all b1 : B, 
    relation(r,a1,b1) <-> (A!equal(a,a1) /\ B!equal(b,b1));

  logical let is_left_unique (r) =
    all a1 a2 : A, all b : B,
    ( relation (r, a1, b) /\ relation (r, a2, b) ) -> A!equal (a1, a2);

  theorem is_left_unique_spec : all r: Self, 
   (all a1 a2 : A, all b : B,
     ( relation (r, a1, b) /\ relation (r, a2, b) ) -> A!equal (a1, a2))
   <-> is_left_unique (r)
  proof = by definition of is_left_unique;

  logical let is_right_unique (r) =
    all a : A, all b1 b2 : B,
    ( relation (r, a, b1) /\ relation (r, a, b2) ) -> B!equal (b1, b2);

  theorem is_right_unique_spec : all r: Self,
    (all a : A, all b1 b2 : B,
      ( relation (r, a, b1) /\ relation (r, a, b2) ) -> B!equal (b1, b2))
    <-> is_right_unique (r)
  proof = by definition of is_right_unique;

  logical let is_right_total (r) =
    all b : B, ex a : A, relation (r, a, b);

  logical let is_left_total (r) =
    all a : A, ex b : B, relation (r, a, b);

 theorem is_left_total_spec : all r: Self,
    (all a : A, ex b : B, relation (r, a, b))
    <-> is_left_total(r)
  proof = by definition of is_left_total;



  (* TODO : replace "by definition" by "property ..." in order to keep the *)
  (* proof valid when there are re-definitions                             *)
 theorem union_is_left_unique : all r1 r2 r3 : Self,
   is_union_r(r1,r2,r3) ->
   (
   (is_left_unique(r1) /\ is_left_unique(r2)
    /\ (all a1 a2 : A, all b : B,
         ((relation (r1, a1, b) /\ relation (r2, a2, b)) -> A!equal (a1, a2))))
   <-> is_left_unique(r3))
   proof =
    (* let s assume that r1 r2 and r3 are elements of Self and that we have *)
    (* is_union_r(r1,r2,r3)                                                 *)
    <0>1 assume r1 r2 r3 : Self,
         hypothesis Hunion : is_union_r(r1,r2,r3),
         prove (is_left_unique(r1) /\ is_left_unique(r2)
              /\ (all a1 a2 : A, all b : B,
                   ((relation (r1, a1, b) /\ relation (r2, a2, b))
                         -> A!equal (a1, a2))))
           <-> is_left_unique(r3)

     (* we broke the iff in two parts *)

     (* -> *)
     <1>1 hypothesis Hlu1 : is_left_unique(r1),
          hypothesis Hlu2 : is_left_unique(r2),
          hypothesis Heq : all a1 a2 : A, all b : B,
                             ((relation (r1, a1, b) /\ relation (r2, a2, b))
                                 -> A!equal (a1, a2)),
          prove is_left_unique(r3)

      (* to prove "left-uniqueness" we assume that we have two elements a1   *)
      (* and a2 with relation(r3, a1, b) and relation(r3, a2, b) and prove   *)
      (* that a1 = a2                                                        *)
      <2>1 assume a1 a2 : A, assume b : B,
           hypothesis Ha1 : relation(r3, a1, b),
           hypothesis Ha2 : relation(r3, a2, b),
           prove A!equal(a1, a2)

       (* then we just reason by cases and use our hypotheses *)

       <3>1 hypothesis H11 : relation(r1, a1, b),
            hypothesis H12 : relation(r1, a2, b),
            prove A!equal(a1, a2)
            by hypothesis H11, H12, Hlu1 definition of is_left_unique

       <3>2 hypothesis H21 : relation(r2, a1, b),
            hypothesis H22 : relation(r2, a2, b),
            prove A!equal(a1, a2)
            by hypothesis H21, H22, Hlu2 definition of is_left_unique

       <3>3 hypothesis H11 : relation(r1, a1, b),
            hypothesis H22 : relation(r2, a2, b),
            prove A!equal(a1, a2)
            by hypothesis H11, H22, Heq

       <3>4 hypothesis H21 : relation(r2, a1, b),
            hypothesis H12 : relation(r1, a2, b),
            prove A!equal(a1, a2)
            by hypothesis H21, H12, Heq property A!equal_symmetric

       <3>f qed by step <3>1, <3>2, <3>3, <3>4 hypothesis Hunion, Ha1, Ha2
                   definition of is_union_r

      <2>f qed by step <2>1 definition of is_left_unique


     (* <- *)
     <1>2 hypothesis Hlu3 : is_left_unique(r3),
          prove is_left_unique(r1)
             /\ is_left_unique(r2)
             /\ (all a1 a2 : A, all b : B,
                  ((relation (r1, a1, b) /\ relation (r2, a2, b))
                        -> A!equal (a1, a2)))
      (* we split the conjuciton into cases *)
      <2>1 prove is_left_unique(r1)
       (* classic method to prove left-uniqueness : *)
       <3>1 assume a1 a2 : A, assume b : B,
            hypothesis Hr1 : relation (r1, a1, b) /\ relation (r1, a2, b),
            prove A!equal(a1, a2)
        (* the following comes easily ... *)
        <4>1 prove relation (r3, a1, b) /\ relation (r3, a2, b)
             by hypothesis Hr1, Hunion definition of is_union_r
        <4>f qed by step <4>1 hypothesis Hlu3 definition of is_left_unique
       <3>f qed by step <3>1 definition of is_left_unique

      <2>2 prove is_left_unique(r2)
       (* again ... *)
       <3>1 assume a1 a2 : A, assume b : B,
            hypothesis Hr2 : relation (r2, a1, b) /\ relation (r2, a2, b),
            prove A!equal(a1, a2)
        <4>1 prove relation (r3, a1, b) /\ relation (r3, a2, b)
             by hypothesis Hr2, Hunion definition of is_union_r
        <4>f qed by step <4>1 hypothesis Hlu3 definition of is_left_unique
       <3>f qed by step <3>1 definition of is_left_unique

      <2>3 prove all a1 a2 : A, all b : B,
                  ((relation (r1, a1, b) /\ relation (r2, a2, b))
                        -> A!equal (a1, a2))
       (* there it is even easier : *)
       <3>1 assume a1 a2 : A, assume b : B,
            hypothesis H0 : relation (r1, a1, b) /\ relation (r2, a2, b),
            prove relation (r3, a1, b) /\ relation (r3, a2, b)
            by hypothesis H0, Hunion definition of is_union_r
       <3>f qed by step <3>1 hypothesis Hlu3 definition of is_left_unique


      <2>f conclude

     <1>f conclude
    <0>f conclude;

end;;



species Injective_relations (A is Setoid, B is Setoid) =

  inherit Binary_relations (A, B);

  property left_unique : all r : Self, is_left_unique (r);

  theorem injective_union : all r1 r2 r3 : Self, 
    is_union_r(r1,r2,r3) 
    -> (all a1 a2 : A, all b : B,
         ((relation (r1, a1, b) /\ relation (r2, a2, b)) -> A!equal (a1, a2)))
  proof = by property left_unique, union_is_left_unique ;

end;;


species Deterministic_relations (A is Setoid, B is Setoid) =

  inherit Binary_relations (A, B);

  property right_unique : all r : Self, is_right_unique (r);

end;;

species Left_total_relations (A is Setoid, B is Setoid) =

  inherit Binary_relations (A, B);

  property left_total : all r : Self, is_left_total (r);

end;;

species Functional_relations (A is Setoid, B is Setoid) =

  inherit Left_total_relations(A, B), Deterministic_relations(A, B);

  signature fct : Self -> A -> B;

  let relation(r,x,y) = B!equal(fct(r,x),y);

  proof of right_unique = by definition of relation, is_right_unique
                             property B!equal_symmetric, B!equal_transitive;


  proof of left_total = by definition of relation, is_left_total
                           property B!equal_reflexive;

end;;
