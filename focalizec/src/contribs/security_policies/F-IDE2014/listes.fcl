(* copy from lib ; do not modify *)
open "sets";;
open "basics";;

species Basic_list_util(A is Basic_object) =
  inherit Basic_object;
  
  representation = unit;
  
  let rec mem (x: A, l) =
    match l with
    | [] -> false
    | h :: q ->  h = x || (mem (x, q))
    termination proof = structural l
  ;

  theorem mem_cons_head: all x: A, all l: list(A), 
    mem(x, x::l)
  proof = by definition of mem;
  
  theorem mem_cons_tail: all x y: A, all l: list(A),
    mem(x, l) -> mem(x, y::l)
  proof = by definition of mem;

  theorem mem_empty_spec: all x: A, ~~(mem(x, []))
  proof = by definition of mem;
  
  theorem mem_contains: all l: list(A),
    ~~( l = [] ) <-> (ex x: A, mem(x, l))
  proof = 
  <1>1 assume l: list(A),
       prove (l = []) -> all x: A, ~~(mem(x, l))
       by property mem_empty_spec
  <1>2 prove all l: list(A), ~~(l = []) -> ex x: A, mem(x, l)
       <2>1 prove ~~([] = []) -> ex x: A, mem(x, [])
            conclude
       <2>2 assume l: list(A), assume a: A ,
            hypothesis I: ~~(l = []) -> ex x: A, mem(x, l),
            prove ex x: A, mem(x, a::l)
            <3>1 prove mem(a, a::l) by property mem_cons_head
            <3>f conclude
       <2>f conclude
  <1>f conclude;

theorem mem_spec: all l : list(A), all e h : A,  
 (mem (e, l) \/ (e = h)) <-> mem (e, h :: l)
proof = by definition of mem
; 
  

let rec rm (l, x : A) =
      match l with
        | [] -> []
        | h :: q ->  if h = x then q else h :: (rm (q, x)) 
termination proof = structural l
;

let rec length (l : list(A)) = 
      match l with
        | [] -> 0
        | h :: q ->  1 + (length (q)) 
termination proof = structural l
;
     
let rec append (l1 : list(A), l2) =
      match l1 with
        | [] -> l2
        | h :: q ->  h::(append (q, l2))
termination proof = structural l1
;

theorem append_def: 
 all l2: list(A),
   (append([], l2) = l2)
/\ (all h: A, all t: list(A),
     append(h::t, l2) = (h::append(t, l2)))
 proof = by definition of append
 ;


theorem append_def_nil: 
 all l2: list(A), append([], l2) = l2
 proof = by definition of append;

theorem append_def_cons : 
 all l2: list(A),
 all h: A, all t: list(A),
     append(h::t, l2) = (h::append(t, l2))
 proof = by definition of append
 ;


theorem append_right_neutral:
  all l : list(A), append(l,  []) = l
proof = 
  <1>1 prove append([], []) = []
       by definition of append
  <1>2 assume l: list(A), assume a: A,
       hypothesis I: append(l, []) = l,
       prove append(a::l, []) = a::l
       <2>1 prove append(a::l, []) = a::append(l, [])
            by definition of append
       <2>f qed by step <2>1 hypothesis I
  <1>f conclude
;

theorem append_left_neutral: all l: list(A),
  append([], l) = l
proof = by definition of append;

logical let append_neutral(n: list(A)) = 
  all l: list(A), (append(l, n) = l) /\ (append(n, l) = l);

theorem nil_neutral: append_neutral([])
proof = by property append_left_neutral, append_right_neutral
           definition of append_neutral;

theorem nil_unique: all n: list(A),
  append_neutral(n) -> n = []
proof = 
  <1>1 assume n: list(A),
       hypothesis N: append_neutral(n),
       prove n = []
       <2>1 prove append([], n) = []
            by hypothesis N definition of append_neutral
       <2>2 prove append([], n) = n
            by property append_left_neutral
       <2>f conclude
  <1>f conclude;


end
;;   


species List_util(A is Setoid) =
  inherit Basic_list_util(A);
  
  let rec belongs(x: A, l) =
    match l with
    | [] -> false
    | h :: q ->  A!equal(h, x) || (belongs (x, q))
    termination proof = structural l
  ;
  
  theorem mem_implies_belongs : all x: A, all l: list(A),
    mem(x, l) -> belongs(x, l)
  proof = 
   <1>1 assume x: A,
        prove mem(x, []) -> belongs(x, [])
        by definition of mem, belongs
   <1>2 assume x h : A,
        assume t: list(A),
        prove (mem(x, t) -> belongs(x, t))
           -> (mem(x, h::t) -> belongs(x, h::t))
        <2>1 hypothesis HI: (mem(x, t) -> belongs(x, t)),
             hypothesis H1: mem(x, h::t),
             prove belongs(x, h::t)
	     by definition of mem, belongs property A!equal_reflexive
                hypothesis HI, H1  
        <2>f conclude
   <1>f conclude
  ;

  theorem belongs_spec: all t: list(A), all h x: A,
    (belongs(x, t) \/ A!equal(h, x)) <-> belongs(x, h::t)
  proof = by definition of belongs;

  theorem belongs_cons_head: all x: A, all l: list(A), 
    belongs(x, x::l)
  proof = by property belongs_spec, A!equal_reflexive;
  
  theorem belongs_cons_tail: all x y: A, all l: list(A),
    belongs(x, l) -> belongs(x, y::l)
  proof = by property belongs_spec;

  theorem belongs_empty_spec: all x: A, ~~(belongs(x, []))
  proof = by definition of belongs;

end
;;   
