

Using these tools together
with an adequate methodology of development (as the one introduced
in~\cite{DBLP:journals/entcs/AyraultHP09}) also makes the developments
easier to formally evaluate  according to the aforementioned standards.
In the domains of safety and security, two main developments have been already
done within \focalize: a full formalization of airport security
regulations~\cite{DelahayeED06}, and 
the implementation of
a generic voter~\cite{DBLP:conf/tap/AyraultHP09}, which is a central
equipment of all
fault tolerant architectures, widely used for safety related systems.


Aids to
precision in each phase of software development 

Formal methods (FMs) are intended to provide the means for greater precision in
both thinking and documenting the preliminary stage of the software creation
process.

providing notations and tools that are readily
understood and used by practitioners,



educational tools used for conveying these concepts to students.



... is not very popular with students ... they feel SML is more linked
with mathematics than computer science


Hence, the main originality of \focalize is to provide an
object-oriented programming language that allows mixing
specifications, programs and
proofs.


Math majors will spend most of their time as undergraduates proving
things, and computer science majors will do a lot of programming; yet
they both need to do a little of the other. The fact is,
robust programs and correct proofs have a lot to do with each other,
not the least of which is that they both require clear, logical
thinking. We will see how proof techniques will allow us to check that
an algorithm is correct, and that proofs can prompt
algorithms. Moreover, the programming component motivates the
proof-based discrete math for the computer science majors and keeps it
relevant; the proof component should lighten the unfamiliarity that
math majors often experience in a programming course.


they lack the information what is
being proved at each point, and they lack structure. Proof language
close to the informal language of mathematics ... teach proofs, not
logic (fine structure of logic is studied) ... what intermediate step
might help the proof assistant


The software industry has a long-standing and well-earned reputation for
failing to deliver on its promises and it is clear that still nowadays, the
success of software projects with the current technologies cannot be assured.
For large complex projects ad hoc approaches have proven inadequate to assure
the correct behavior of the delivered software. The lack of formalization in
key places makes software engineering overly sensitive to the weaknesses that
are inevitable in the complex activities behind software creation. 

Formal methods (FMs) are intended to provide the means for greater precision in
both thinking and documenting the preliminary stage of the software creation
process. When done well, this can aid all aspects of software creation: user
requirement formulation, implementation, verification/testing, and the creation
of documentation. However, the maturing of formal techniques into real-life
software engineering involves providing notations and tools that are readily
understood and used by practitioners, and the integration of such tools with
activities that are far from the unrealistic assumptions that characterized
some earlier research in formal methods.

After decades of research, and despite significant advancement, formal methods
are still not widely used in industrial software development. This may be due
to the fact that the formal methods community has not enough focused its
attention to software engineering needs, and its specific role in the software
process. At the same time, from a software engineering perspective, there could
be a number of fundamental principles that might help to guide the design of
formal methods in order to make them more easily applicable in the development
of software applications.

The main goal of the workshop is to foster integration between the formal
methods and the software engineering communities with the purpose to examine
the link between the two more carefully than is currently the case.

Despite computer science and mathematics being kindred fields,
computer science major populations include many math-averse
students. Many are frustrated at the math requirements of the program
and are slow to un-
derstand the relevance. The situation is more likely to be aggravated than remedied when the discrete math course is taught by the mathematics department.
...
Com- puting is a vital topic for contemporary math majors. Many will
need some level of competency in programming at some point in their
studies, whether in professional practice as ac- tuaries, to introduce
algorithmic topics as high school math teachers, or in research as
graduate students. 
Unfortunately, many math majors find pro- gramming to be foreign and become frustrated when they do not see any immediate relevance for their mathematical stud- ies. Their frustration is especially understandable if they are dropped into a Java programming course that was not de- signed for their needs.
+
book \cite{bookvandrunen}
Discrete mathematics topics include symbolic logic and proofs, including proof by induction; number theory; set theory; functions and relations on sets; graph theory; algorithms, their analysis, and their correctness; matrices; sequences and recurrence relations; counting and combinatorics; discrete probability; and languages and automata. All of these would be appropriate in other courses or in their own course. Why teach them together? For one thing, students in a field like computer science need a basic knowledge of many of these topics but do not have time to take full courses in all of them; one course that meanders through these topics is thus a practical compromise.
...
Since functions are a major topic of discrete math anyway, the interplay is natural. As we shall see, functional programming is a useful forum for illustrating the other discrete math topics as well.
...
The slogan of this course is, “Math majors should learn to write
programs and computer science majors should learn to write proofs
together.”
...