open "basics";;
open "orders";;
open "finite_sets";;
open "utils";;
open "accesses";;
open "p_policies";;


(** Access control policies *)

(** Targets of access control policies describe accesses done in a system *)

species Target_ac (S is Subject,
		   O is Object,
		   A is Access_mode,
                   R is Ternary_relations(S, O, A)) =
  inherit Target, Weak_accesses (S, O, A, R);
  signature as_relation: Self -> R;
end;;

species Target_ac_by_sets_of_triples
          (S is Subject,
           O is Object,
	   A is Access_mode,
           SOA is Abstract_triple(S, O, A),
           PSOA is Finite_parts(SOA),
           R is Relations_by_sets_of_triples(S, O, A, SOA, PSOA)) =

  inherit Target_ac(S, O, A, R);

  representation = PSOA;

  let make(p: PSOA): Self = p;

  let as_part(t: Self): PSOA = t;

  let as_relation(t) = R!set_as_relation(t);

  let element = PSOA!element;

  let equal(t_1, t_2) = PSOA!equal(t_1, t_2);
  proof of equal_reflexive = 
    by definition of equal
       property PSOA!equal_reflexive
    ;
    
  proof of equal_symmetric = 
    by definition of equal
       property PSOA!equal_symmetric
    ;
    
  proof of equal_transitive = 
    by definition of equal
       property PSOA!equal_transitive
    ;
    
end;;

(** Access control policies a property-based security policies *)

species P_policy_ac (S is Subject,
		     O is Object,
		     A is Access_mode,
                     R is Ternary_relations(S, O, A),
                     T is Target_ac(S, O, A, R),
                     C is Configuration) =

  inherit P_policy (T, C);

end;;

(** Access control policies with Read/Write access modes *)

species P_policy_ac_rw (S is Subject,
			O is Object,
			A is Access_mode_rw,
                        R is Ternary_relations(S, O, A),
                        T is Target_ac (S, O, A, R),
                        C is Configuration) =

  inherit P_policy_ac (S, O, A, R, T, C);

end;;


(** HRU (Harrison, Ruzzo, Ullman) access control policy *)

(** Configurations as ternary relations specifying granted accesses *)

species Configuration_ac (S is Subject,
			  O is Object,
			  A is Access_mode,
			  R is Ternary_relations(S, O, A)) =
  inherit Configuration, Weak_accesses (S, O, A, R);
  signature as_relation: Self -> R;
end;;

(** HRU policy : secure targets are target containing granted accesses *)

species P_policy_hru (S is Subject,
		      O is Object,
		      A is Access_mode,
                      R is Ternary_relations(S, O, A),
                      T is Target_ac (S, O, A, R),
                      C is Configuration_ac (S, O, A, R)) =

  inherit P_policy_ac (S, O, A, R, T, C);

  let secure (t, c) = R!is_contained(T!as_relation(t), C!as_relation(c));
    
  theorem relation_is_is_contained: all t : T, all c : C,
    relation (t, c) <-> R!is_contained (T!as_relation(t), C!as_relation (c))
  proof = by definition of relation, secure
  ;

end;;

(** HRU policy whith Read/Write access modes *)

species P_policy_hru_rw(S is Subject,
                        O is Object,
                        A is Access_mode_rw,
                        R is Ternary_relations(S, O, A),
                        T is Target_ac (S, O, A, R),
                        C is Configuration_ac (S, O, A, R)) =

  inherit P_policy_ac_rw(S, O, A, R, T, C), 
          P_policy_hru(S, O, A, R, T, C);

end;;

(** MLS policies : Multi Level Security Policies *)


(** Security levels *)

species Security_level =

  inherit Partial_order;

end;;

(** MLS configurations describe security levels associated with subjects and objects *)

species Configuration_MLS(S is Subject,
                          O is Object,
                          L is Security_level) =
   inherit Configuration;

   signature fs: Self -> S -> L;

   signature fo: Self -> O -> L;

end;;

(** MLS access control policies with Read/Write access modes *)

species P_policy_MLS(S is Subject,
                     O is Object,
                     L is Security_level,
                     A is Access_mode_rw,
                     SOA is Abstract_triple(S, O, A),
                     PSOA is Finite_parts(SOA),
                     R is Relations_by_sets_of_triples(S, O, A, SOA, PSOA),
                     T is Target_ac_by_sets_of_triples(S, O, A, SOA, PSOA, R),
                     C is Configuration_MLS(S, O, L)) =

  inherit P_policy_ac_rw(S, O, A, R, T, C);

  representation = unit ;

  (** Confidentiality : Controlling read accesses - No read up *)

  logical let mac_read(c, r) =
    all s: S, all o: O, all a: A,
     R!relation(r, s, o, A!read) -> L!leq(C!fo(c, o), C!fs(c, s))
  ;

  let rec mac_secure_read(l, c) =  match l with
    | [] -> true
    | h::t -> ( ((~~ ( A!equal(SOA!third(h), A!read))) || 
                 (L!leq(C!fo(c, SOA!second(h)), C!fs(c, SOA!first(h))))) &&
                mac_secure_read(t, c));

  theorem mac_read_correct: all c: C, all t: T,
          mac_secure_read(PSOA!to_list(T!as_part(t)),c) 
      <-> mac_read(c, T!as_relation(t))
    proof = assumed;

  (** Integrity : Controlling write accesses - No write up *)

  logical let mac_write(c, r) =
    all s: S, all o: O, all a: A,
     R!relation(r, s, o, A!write) -> L!leq(C!fo(c, o), C!fs(c, s))
  ;

  let rec mac_secure_write(l, c) =  match l with
    | [] -> true
    | h::t -> ( ((~~ ( A!equal(SOA!third(h), A!write))) || 
                 (L!leq(C!fo(c, SOA!second(h)), C!fs(c, SOA!first(h))))) &&
                mac_secure_write(t, c));

  theorem mac_write_correct: all c: C, all t: T,
          mac_secure_write(PSOA!to_list(T!as_part(t)),c) 
      <-> mac_write(c, T!as_relation(t))
    proof = assumed;

  (** Confinment : No write down *)

  let rec no_write_down_elem(e, l, c) = match l with
  | [] -> true
  | h::t -> 
    (( ~~ ( A!equal(SOA!third(e), A!read) &&
            A!equal(SOA!third(h), A!write) ) ) ||
      L!leq(C!fo(c, SOA!second(e)),
            C!fo(c, SOA!second(h)))) &&
    no_write_down_elem(e, t, c)
  ;
    
  let rec no_write_down_secure(l, c) = match l with
  | [] -> true
  | h::t ->
     no_write_down_elem(h, l, c) && no_write_down_secure(t, c)
  ;

 logical let no_write_down(c, r) =
    all s_1 s_2: S, all o_1 o_2: O,
      (R!relation(r, s_1, o_1, A!read) /\ R!relation(r, s_2, o_2, A!write)) ->
         L!leq(C!fo(c, o_1), C!fo(c, o_2))
  ;

  theorem no_write_down_correct: all c: C, all t: T,
        no_write_down_secure(PSOA!to_list(T!as_part(t)), c) 
   <->  no_write_down(c, T!as_relation(t))
     proof = assumed;


  (** Confinment : No write up *)

  let rec no_write_up_elem(e, l, c) = match l with
  | [] -> true
  | h::t -> 
    (( ~~ ( A!equal(SOA!third(e), A!read) &&
            A!equal(SOA!third(h), A!write) ) ) ||
      L!leq(C!fo(c, SOA!second(h)),
            C!fo(c, SOA!second(e)))) &&
    no_write_up_elem(e, t, c)
  ;
    
  let rec no_write_up_secure(l, c) = match l with
  | [] -> true
  | h::t ->
     no_write_up_elem(h, l, c) && no_write_up_secure(t, c)
  ;

 logical let no_write_up(c, r) =
    all s_1 s_2: S, all o_1 o_2: O,
      (R!relation(r, s_1, o_1, A!read) /\ R!relation(r, s_2, o_2, A!write)) ->
         L!leq(C!fo(c, o_2), C!fo(c, o_1))
  ;

  theorem no_write_up_correct: all c: C, all t: T,
        no_write_up_secure(PSOA!to_list(T!as_part(t)), c) 
   <->  no_write_up(c, T!as_relation(t))
     proof = assumed;


  (** Bell and LaPadula : No read up, no write down *)

  let blp_secure(t, c) = 
    let l = PSOA!to_list(T!as_part(t)) in
      mac_secure_read(l, c) && no_write_down_secure(l, c)
  ;

  logical let is_blp_secure(t, c) =
    mac_read(c, T!as_relation(t)) /\ no_write_down(c, T!as_relation(t))
  ;

  theorem blp_secure_is_correct: all t: T, all c: C, 
    blp_secure(t, c) <-> is_blp_secure(t, c)
    proof = assumed;


  (** Biba : No write up *)

  let bb_secure(t, c) = 
    let l = PSOA!to_list(T!as_part(t)) in
      mac_secure_write(l, c) && no_write_up_secure(l, c)
  ;

  logical let is_bb_secure(t, c) =
    mac_write(c, T!as_relation(t)) /\ no_write_up(c, T!as_relation(t))
  ;

  theorem bb_secure_is_correct: all t: T, all c: C, 
    bb_secure(t, c) <-> is_bb_secure(t, c)
    proof = assumed;



end;;
