open "basics";;
open "sets";;


species Finite_set =

  inherit Setoid;

  (** Number of members of the species *)
  signature cardinal : int;

  (** All the members of the species. *)
  signature all_to_list : list (Self);


  let in_list =
    let rec aux (l, x) =
      match l with
        | [] -> false
        | h :: q -> equal (h, x) || aux (q, x) in
    function x -> function l -> aux (l, x);

  property all_in_all_to_list :
    all x : Self, in_list (x, all_to_list);

end;;


species Finite_parts(S is Setoid) =

  inherit Setoid ;

  signature cardinal: Self -> int;
  signature empty : Self;
  signature add : Self -> S -> Self;
  signature belongs: S -> Self -> bool;
  signature release : Self -> S -> Self;
  signature to_list : Self -> list(S) ;
  signature is_contained : Self -> Self -> bool;

  property belongs_left_substitution_rule: all s_1 s_2: S, all r: Self,
       S!equal(s_1, s_2) -> belongs(s_1, r) -> belongs(s_2, r);

  property empty_spec :
    all t: S, ~ belongs(t, empty);

  property add_spec :
    all x : Self, all t_1 t_2 : S,
    belongs(t_1, add (x, t_2)) <->
      S!equal(t_1, t_2) \/ belongs(t_2, x);

  property release_spec :
    all x : Self, all t_1 t_2 : S,
    belongs(t_1, release(x, t_2)) <-> S!different (t_1, t_2) /\ belongs(t_1, x);

  property is_contained_spec :
    all x y : Self,
    is_contained (x, y) <-> ( all t : S,
                              belongs(t, x) -> belongs(t, y) );

  theorem is_contained_reflexive : all x : Self, is_contained (x, x)
  proof = by property is_contained_spec;

  theorem is_contained_transitive :
    all x y z : Self,
    (is_contained (x, y) /\ is_contained (y, z)) -> is_contained (x, z)
  proof = by property is_contained_spec;

  let equal(x, y) = is_contained(x, y) && is_contained(y, x);

  proof of equal_reflexive = by definition of equal 
                                property is_contained_reflexive;
  proof of equal_transitive = by definition of equal  
                                property is_contained_transitive;
  proof of equal_symmetric = by definition of equal;

      
end;;

species Finite_parts_by_lists(S is Setoid) =

  inherit Finite_parts(S);

  representation = list(S);

  let empty = [];

  let element = empty;

  let rec belongs(s, e) = match e with
  | [] -> false
  | h::t -> 
     if S!equal(s, h)
     then true
     else belongs(s, t);

  proof of empty_spec = by definition of empty, belongs
  ;

  let add(e, s) =
    if belongs(s, e)
    then e
    else s::e;


  (* theorem belongs_right_substitution_rule: all s: S, all l_1 l_2: Self, *)
  (*   equal(l_1, l_2) -> belongs(s, l_1) -> belongs(s, l_2) *)
  (*   proof =  *)
  (*     by property equal_reflexive *)
  (*   ; *)

  proof of belongs_left_substitution_rule = assumed;

  proof of is_contained_spec = assumed;

  let rec cardinal(e) = match e with
  | [] -> 0
  | _h::t -> 1 + cardinal(t)
  ;


  proof of add_spec =
   <1>1 prove all s_1 s_2: S,
        (* [rr] ill formed! Statement reveals representation *)
         belongs(s_1, add([], s_2)) <-> S!equal(s_1, s_2) \/ belongs(s_1, [])
        <2>0 prove all s: S, [s] = add([], s)
            by definition of add, belongs
        <2>1 assume s_1 s_2: S,
             prove belongs(s_1, add([], s_2)) <-> 
                    S!equal(s_1, s_2) \/ belongs(s_1, [])
                     <3>1 hypothesis H: belongs(s_1, add([], s_2)),
                  prove S!equal(s_1, s_2)
                  <4>1 prove ~ belongs(s_1,[])
                       by definition of belongs
                  <4>2 prove belongs(s_2, add([], s_2))
                       assumed
                       (* by step <2>0  *)
                       (*    property S!equal_reflexive *)
                       (*    property belongs_left_substitution_rule *)
                  <4>f qed assumed
                  (* [rr] infinite loop? *)
                  (* by definition of belongs, add *)
                  (*    hypothesis H *)
                  (*    property S!equal_reflexive, *)
		  (*             S!equal_symmetric, *)
		  (*             S!equal_transitive *)
             <3>2 prove ~ belongs(s_1, [])
                  by definition of belongs
             <2>3 hypothesis H: S!equal(s_1, s_2),
                  prove belongs(s_1, add([], s_2))
                  by definition of belongs, add
                     hypothesis H
                     property S!equal_reflexive,
                              S!equal_symmetric,
                              S!equal_transitive
             <3>f conclude
        <2>f conclude
   <1>2 prove all s: S, all l: list(S),
        (* [rr] ill formed! Statement reveals representation *)
         (all s_1 s_2: S, belongs(s_1, add(l, s_2)) <->
                 S!equal(s_1, s_2) \/ belongs(s_1, l)) ->
            (all s_1 s_2: S, belongs(s_1, add(s::l, s_2)) <->
               S!equal(s_1, s_2) \/ belongs(s_1, s::l))
        <2>1 assume h: S, assume t: list(S),
             prove
               (all s_1 s_2: S, belongs(s_1, add(t, s_2)) <->
                         S!equal(s_1, s_2) \/ belongs(s_1, t)) ->
                  (all s_1 s_2: S, belongs(s_1, add(h::t, s_2)) <->
                    S!equal(s_1, s_2) \/ belongs(s_1, h::t))
              <3>1 hypothesis I: (all s_1 s_2: S, belongs(s_1, add(t, s_2)) <->
                                     S!equal(s_1, s_2) \/ belongs(s_1, t)),
                   prove  (all s_1 s_2: S, belongs(s_1, add(h::t, s_2)) <->
                              S!equal(s_1, s_2) \/ belongs(s_1, h::t))
                   <4>1 assume s_1 s_2: S,
                        prove belongs(s_1, add(h::t, s_2)) <->
                                  S!equal(s_1, s_2) \/ belongs(s_1, h::t)
                        <5>1 hypothesis H: belongs(s_1, add(h::t, s_2)),
                             prove S!equal(s_1, s_2) \/ belongs(s_1, h::t)
                             <6>1 hypothesis HH: S!equal(s_1, h),
                                  prove belongs(s_1, h::t)
                                  by definition of belongs
                                     hypothesis HH
                             <6>2 hypothesis HH: ~ S!equal(s_1, h),
                                  prove S!equal(s_1, s_2) \/ belongs(s_1, h::t)
                                  <7>1 hypothesis T: ~ S!equal(s_1, s_2),
                                       prove belongs(s_1, h::t)
                                       assumed
                                       (* by hypothesis HH, T, H, I *)
                                       (*    definition of belongs *)
                                       (*    property S!equal_reflexive, *)
                                       (*             S!equal_symmetric, *)
                                       (*             S!equal_transitive *)
                                  <7>f conclude
                             <6>f conclude
                        <5>2 hypothesis H: S!equal(s_1, s_2),
                             prove belongs(s_1, add(h::t, s_2))
                             <6>1 hypothesis T: S!equal(h, s_1),
                                  prove belongs(s_1, add(h::t, s_2))
                                  assumed
                                  (* (\** [rr] Coq translation fails *\) *)
                                  (* by definition of belongs, add *)
                                  (*    hypothesis T, H *)
                                  (*    property S!equal_reflexive, *)
                                  (*             S!equal_symmetric, *)
                                  (*             S!equal_transitive *)
                             <6>2 hypothesis T: ~ S!equal(h, s_1), 
                                  prove belongs(s_1, add(h::t, s_2))
                                  assumed
                                  (* by definition of belongs, add *)
                                  (*    hypothesis T, H, I *)
                                  (*    property S!equal_reflexive, *)
                                  (*             S!equal_symmetric, *)
                                  (*             S!equal_transitive *)
                             <6>f conclude
                        <5>3 hypothesis H: belongs(s_1, h::t),
                             prove belongs(s_1, add(h::t, s_2))
                             assumed
                             (* (\* [rr] Coq translation fails *\) *)
                             (* by definition of belongs, add *)
                             (*    hypothesis H, I *)
                        <5>f conclude
                   <4>f conclude
              <3>f conclude
         <2>f conclude
   <1>3 prove all l: list(S), all s_1 s_2: S,
        (* [rr] ill formed! Statement reveals representation *)
          belongs(s_1, add(l, s_2)) <->
             S!equal(s_1, s_2) \/ belongs(s_1, l)
        by step <1>1, <1>2
   <1>f qed assumed
   ;

  let to_list(e) = e;

  let rec release(e, s) = match e with
  | [] -> []
  | h::t -> 
    if S!equal(s, h)
    then t
    else h::release(t, s)        
    ;

  proof of release_spec = assumed;

  let rec is_contained(l_1, l_2) = match l_1 with
  | [] -> true
  | h::t -> 
    if belongs(h, l_2) 
    then is_contained(t, l_2)
    else false
  ;

  (* proof of is_contained_spec = *)
  (*  by definition of is_contained,  *)

end;;

