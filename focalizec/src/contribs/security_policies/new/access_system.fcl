open "basics";;
open "sets";;
open "finite_sets";;
open "utils";;
open "accesses";;
open "lts";;



(** 
   We define a system allowing to add or to release accesses using 
   a finite set P of allowed states as representation.
 *)
species State_add_release(S is Setoid,
			  P is Finite_parts(S)) =

  inherit State;

  representation = P;
  let element: Self = P!empty;

  let empty: Self = P!empty;

  let add(p: Self, e: S): Self = P!add(p, e);
  theorem add_equal_compat: all p_1 p_2: Self, all e: S,
    !equal(p_1, p_2) -> equal(add(p_1, e), add(p_2, e))
    proof = assumed
    (* proof = by definition of equal, add *)
    (*            property P!add_spec, P!belongs_left_substitution_rule, *)
    (*                     P!equal_reflexive, P!equal_transitive, P!equal_symmetric *)
    ;

  let release(p: Self, e: S): Self = P!release(p, e);

  theorem release_equal_compat: all p_1 p_2: Self, all e: S,
    !equal(p_1, p_2) -> equal(release(p_1, e), release(p_2, e))
    proof = assumed
    ;

  (** equality is that of representation *)
  let equal(x: Self, y: Self) = P!equal(x, y);
  proof of equal_reflexive =
    by definition of equal property P!equal_reflexive;
  proof of equal_symmetric =
    by definition of equal property P!equal_symmetric;
  proof of equal_transitive =
    by definition of equal property P!equal_transitive;

  (** Nothing known at begining, we start from an empty set *)
  let is_initial(x: Self) = equal(x, empty);
  theorem initial_is_empty : all x: Self, is_initial(x) <-> equal (x, empty)
  proof = by definition of is_initial;

end;;


(** 
   Individual states are commonly represented as parts of triples
   of subject, acces, mode.
 *)
species State_ac (S is Subject,
                  O is Object, 
                  A is Access_mode,
                  SOA is Abstract_triple(S, O, A),
		  PSOA is Finite_parts(SOA)) =

  inherit State_add_release(SOA, PSOA);

end;;


type action = | Add | Release;;

species Label_add_release(S is Setoid) =

   inherit Label;
   (** We use concrete types here *)
   signature action: Self -> action;
   (** Almost anything with equality *)
   signature entity: Self -> S;
   (** Abstract creator *)
   signature add: S -> Self;
   (** Abstract creator *)
   signature release: S -> Self;
   property add_spec: all s: S, (action(add(s)) = Add);
   property release_spec: all s: S, (action(release(s)) = Release);

end;;


species Label_ac(S is Subject,
                 O is Object, 
                 A is Access_mode,
                 SOA is Abstract_triple(S, O, A))=

  inherit Label_add_release(SOA);

end;;


species Transition_system_add_release(S is Setoid,
                                      L is Label_add_release(S),
                                      P is Finite_parts(S),
                                      St is State_add_release(S, P),
                                      SLS is Abstract_triple(St, L, St)) =
  inherit Transition_system(St, L, SLS);

  representation = unit;

  let delta (x, l, y) = match L!action(l) with
  | Add -> 
    St!equal(y, St!add(x, L!entity(l)))
  | Release ->
    St!equal(y, St!release(x, L!entity(l)))
  ;

  theorem deterministic: is_deterministic
    proof = by definition of is_deterministic, delta
               property St!equal_reflexive,
                        St!equal_symmetric,
                        St!equal_transitive
               type action
  ;

  (* theorem complete: is_complete *)
  (*  proof = by definition of is_complete, delta *)
  (*              property St!equal_reflexive, *)
  (*                       St!equal_symmetric, *)
  (*                       St!equal_transitive *)
  (*              type action *)
  (* ; *)

end;;

species Operational_transition_system_add_release
    (S is Setoid,
     L is Label_add_release(S),
     P is Finite_parts(S),
     St is State_add_release(S, P),
     SLS is Abstract_triple(St, L, St)) =

  inherit Transition_system_add_release(S, L, P, St, SLS),
          Operational_transition_system(St, L, SLS);

  let transition(s, l) = 
    match L!action(l) with
    | Add -> 
      St!add(s, L!entity(l))
    | Release ->
      St!release(s, L!entity(l))
    ;

   proof of transition_equal_compat =
     by definition of transition
        property St!add_equal_compat, St!release_equal_compat,
                 St!equal_reflexive, St!equal_transitive, St!equal_symmetric
        type action
   ;

end;;

species Transition_system_ac
                 (S is Subject,
                  O is Object, 
                  A is Access_mode,
                  SOA is Abstract_triple(S, O, A),
                  L is Label_ac(S, O, A, SOA),
		  PSOA is Finite_parts(SOA),
                  St is State_ac(S, O, A, SOA, PSOA),
                  SLS is Abstract_triple(St, L, St)) =

   inherit Transition_system_add_release(SOA, L, PSOA, St, SLS);

end;;

species Operational_transition_system_ac
                 (S is Subject,
                  O is Object, 
                  A is Access_mode,
                  SOA is Abstract_triple(S, O, A),
                  L is Label_ac(S, O, A, SOA),
		  PSOA is Finite_parts(SOA),
                  St is State_ac(S, O, A, SOA, PSOA),
                  SLS is Abstract_triple(St, L, St)) =

   inherit Transition_system_ac(S, O, A, SOA, L, PSOA, St, SLS),
           Operational_transition_system(St, L, SLS);

end;;
