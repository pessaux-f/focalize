open "basics";;
open "finite_sets";;
open "utils";;
open "accesses";;
open "access_p_policies";;
open "access_system";;
open "policy_secured_system";;
open "access_secure_system";;


(* two subjects *)

type subject = | S0 | S1;;

species Subject_test =

  inherit Subject;

  representation = subject;

  let s0 : Self = S0;
  let s1 : Self = S1;

  let cardinal = 2;
  let all_to_list = [S0; S1];

  let element = s0;
  let equal (s_1, s_2) = s_1 = s_2;
  let print (s) =
    match s with
      | S0 -> "s0" | S1 -> "s1";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

collection S = implement Subject_test; end;;


(* two objects *)
type object = | O0 | O1;;

species Object_test =

  inherit Object;

  representation = object;

  let o0 : Self = O0;
  let o1 : Self = O1;

  let cardinal = 2;
  let all_to_list = [O0; O1];

  let element = o0;
  let equal (o_1, o_2) = o_1 = o_2;
  let print (o) =
    match o with
      | O0 -> "o0" | O1 -> "o1";

  proof of equal_transitive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_reflexive = by definition of equal;

  proof of all_in_all_to_list = assumed;

end;;

collection O = implement Object_test; end;;



(* two security levels *)
type security_level = 
  | Public
  | Secret
;;

species Two_security_levels =
  inherit Security_level;

  representation = security_level;

  let element = Public;

  let pub:Self = Public;

  let secret:Self = Secret;

  let equal(l_1, l_2) = (l_1 = l_2);
  proof of equal_reflexive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_transitive = by definition of equal;

  let leq(l_1, l_2) = match l_1 with
    | Public -> true
    | Secret -> (match l_2 with
                 | Public -> false
                 | Secret -> true);

  proof of leq_extends_equal = 
    assumed
    (* by definition of leq, equal *)
    (*    type security_level *)
    ;

  proof of leq_transitive = 
    by definition of leq, equal
       type security_level
    ;
  proof of leq_antisymmetric = 
    by definition of leq, equal
       type security_level
    ;


end;;

collection Public_Secret = implement Two_security_levels ; end;;

(* Instanciate BLP *)

species BLP_Public_secret =
  inherit Configuration_BLP(S, O, Public_Secret) ;

  representation = unit;

  let element: Self = ();

  let equal(_s1, _s2) = true;
  proof of equal_reflexive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_transitive = by definition of equal;

  let fs(_c, s) = 
    if S!equal(s, S!s0)
    then Public_Secret!pub
    else Public_Secret!secret
  ;

  let fo(_c, o) = 
    if O!equal(o, O!o0)
    then Public_Secret!pub
    else Public_Secret!secret
  ;

end;;

collection BLP_Pub_sec = implement BLP_Public_secret ; end;;

(* *)

collection SOA_rw = implement Triples_by_pairs(S, O, Access_rw); end;;

collection PSOA_rw = implement Finite_parts_by_lists(SOA_rw); end;;

collection R_rw = 
  implement Relations_by_sets_of_triples(S, O, Access_rw, SOA_rw, PSOA_rw); 
end;;

collection T_rw =
  implement Target_ac_by_sets_of_triples
      (S, O, Access_rw, SOA_rw, PSOA_rw, R_rw);
end;;

collection BLP_policy_Pub_sec =
   implement P_policy_BLP(S, 
                          O, 
                          Public_Secret, 
                          Access_rw,
                          SOA_rw,
                          PSOA_rw,
                          R_rw,
                          T_rw,
                          BLP_Pub_sec);
end;;
                          

collection BLP_state_ac =
   implement State_ac(S, O, Access_rw, SOA_rw, PSOA_rw);
end;;

collection BLP_label_ac =
  implement Label_ac(S, O, Access_rw, SOA_rw);
end;;

collection SLS_blp =
  implement Triples_by_pairs(BLP_state_ac, BLP_label_ac, BLP_state_ac);
end;;

collection BLP_operational_transition =
  implement Operational_transition_system_ac
    (S, O, Access_rw, SOA_rw, BLP_label_ac, PSOA_rw, BLP_state_ac, SLS_blp);
end;;

species BLP_interpretation_state =
   inherit Secured_state_pol
    (T_rw, BLP_Pub_sec, BLP_policy_Pub_sec, BLP_state_ac);

   let interpretation(l: BLP_state_ac) = T_rw!make(BLP_state_ac!as_part(l));
end;;

collection BLP_secured_state = 
  implement BLP_interpretation_state;
end;;

collection BLP_ss_ls =
  implement Triples_by_pairs
    (BLP_secured_state, BLP_label_ac, BLP_secured_state);
end;;

collection BLP_secure_lts =
  implement Secure_system_blp 
           (S, 
            O, 
            Public_Secret, 
            Access_rw, 
            SOA_rw, 
            PSOA_rw, 
            BLP_state_ac, 
            BLP_label_ac, 
            SLS_blp, 
            R_rw, 
            T_rw, 
            BLP_Pub_sec, 
            BLP_policy_Pub_sec, 
            BLP_operational_transition, 
            BLP_secured_state,
            BLP_ss_ls
            )
  ;
end;;

let label_01 = BLP_label_ac!add(SOA_rw!make(S!s0, O!o1, Access_rw!read));;

let label_00 = BLP_label_ac!add(SOA_rw!make(S!s0, O!o0, Access_rw!read));;

let conf = BLP_Pub_sec!element ;;

let empty = BLP_state_ac!empty ;;

let state = BLP_secured_state!pair(empty, conf) ;;

let state_ok = BLP_secure_lts!transition(state, label_01) in
  if BLP_secured_state!equal(state, state_ok)
  then print_string("OK\n")
  else print_string("KO\n")
  ;;



let state_ok = BLP_secure_lts!transition(state, label_00) in
let new_state = BLP_secured_state!pair(
     BLP_state_ac!add(empty, SOA_rw!make(S!s0, O!o0, Access_rw!read)),
     conf) in
  if BLP_secured_state!equal(new_state, state_ok)
  then print_string("OK\n")
  else print_string("KO\n")
  ;;

