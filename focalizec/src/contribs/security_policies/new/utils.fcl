open "basics";;
open "sets";;
open "finite_sets";;



species Relation(A is Setoid, B is Setoid) =

  inherit Basic_object;

  signature relation: A -> B -> bool;
end;;

species Ternary_relations(A is Setoid, B is Setoid, C is Setoid) =

  inherit Basic_object ;

  signature relation: Self -> A -> B -> C -> bool;


  signature is_contained: Self -> Self -> bool ;

  property is_contained_spec: all r_1 r_2: Self, all a: A, all b: B, all c: C,
             relation(r_1, a, b, c) -> relation(r_2, a, b, c);

end;;

species Abstract_triple(A is Setoid, B is Setoid, C is Setoid) =

  inherit Setoid;

  signature first: Self -> A;
  signature second: Self -> B;
  signature third: Self -> C;

  signature make: A -> B -> C -> Self;

  property is_first : all a: A, all b: B, all c: C,
    A!equal(first(make(a, b, c)), a);

  property is_second : all a: A, all b: B, all c: C,
    B!equal(second(make(a, b, c)), b);

  property is_third : all a: A, all b: B, all c: C,
    C!equal(third(make(a, b, c)), c);

  let equal(x, y) = 
     A!equal(first(x), first(y)) &&
     B!equal(second(x), second(y)) &&
     C!equal(third(x), third(y));


  theorem equal_spec: all x y: Self,
    !equal(x, y) <-> 
       A!equal(first(x), first(y)) /\
       B!equal(second(x), second(y)) /\
       C!equal(third(x), third(y))
     proof = by definition of equal;

  proof of equal_reflexive =
    by property equal_spec,
	          A!equal_reflexive, B!equal_reflexive, C!equal_reflexive	
  ;

  proof of equal_symmetric =
   by property equal_spec,
            A!equal_symmetric, B!equal_symmetric, C!equal_symmetric
  ;
   proof of equal_transitive =
      by property equal_spec,
	          A!equal_transitive, B!equal_transitive, C!equal_transitive
  ;

end;;

species Relations_by_sets_of_triples(A is Setoid, B is Setoid, C is Setoid,
                                     T is Abstract_triple(A, B, C),
                                     P is Finite_parts(T)) =

  inherit Ternary_relations(A, B, C);

  representation = P;

  let relation(r, a, b, c) = P!belongs(T!make(a, b, c), r);

  let is_contained(r_1, r_2) = P!is_contained(r_1, r_2);

  proof of is_contained_spec = 
    by definition of is_contained, relation
       property P!is_contained_spec
    ;

end;;


species Triples_by_pairs(A is Setoid, B is Setoid, C is Setoid) =
 inherit Abstract_triple(A, B, C) ;
 representation = (A * B) * C ;
 let first (t: Self) = fst(fst(t)) ;  
 let second (t: Self) = snd(fst(t));
 let third (t:Self) = snd(t);
 let make(a, b, c):Self = pair(pair(a, b), c);

 proof of is_first = assumed;
 proof of is_second = assumed;
 proof of is_third = assumed;


end;;

