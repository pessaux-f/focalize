(***********************************************************************)
(*                                                                     *)
(*                        FoCaLize compiler                            *)
(*                                                                     *)
(*            Philippe Ayrault                                         *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                                                                     *)
(*                               LIP6  -  INRIA Rocquencourt           *)
(*                                                                     *)
(*  Copyright 2007 - 2009 LIP6 and INRIA                               *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: value_with_valid.fcl,v 1.1 2009-06-11 07:36:07 ayrault Exp $ *)

use "basics";;
use "sets_orders";;
use "valid_meas";;
use "gen_value";;
use "basic_type";;
use "pair";;

open "basics";;
open "sets_orders";;
open "valid_meas";;
open "gen_value";;
open "basic_type";;
open "pair";;

species Sp_value_with_valid( T is Gen_basic_type, V is Sp_valid_meas) =
  inherit Gen_value, Sp_pair(T, V);

end ;;


species Imp_value_with_valid( T is Gen_basic_type, V is Sp_valid_meas) =
  inherit  Sp_value_with_valid( T, V), Imp_pair(T, V);

  let consistency_rule( x in Self, y in Self) in bool =
    if V!equal(prj_b(x), V!valid) then
      if V!equal(prj_b(y), V!valid) then
        T!equal (prj_a(x), prj_a(y))
      else
        false
    else
     false
  ;

  let parse (x) = element;

  let print (x) = 
    let a = "( " in
    let b = T!print (prj_a(x)) in
    let c = ", " in
    let d = V!print (prj_b(x)) in
    let e = ")" in
    (a ^ b ^ c ^ d ^ e);

  proof of consistency_rule_symmetric =
    by property T!equal_symmetric definition of consistency_rule;

  proof of consistency_rule_reflexive =
  assumed {* To complete *}
(*
  <1>1
    assume x in Self,
    assume y in Self,
    assume H1: consistency_rule (x, y),
    prove
     consistency_rule (y, x)
     <2>1 assume H11: V!equal(prj_b(x), V!valid),
     prove
     consistency_rule (y, x)
      <3>1 assume H0:T!equal (prj_a(x), prj_a(y)),
      prove 
      T!equal (prj_a(y), prj_a(x))
      by property T!equal_reflexive hypothesis H0
      
      <3>2 assume H111: V!equal(prj_b(y), V!valid),
      prove
      consistency_rule (y, x)
      by step <3>1 hypothesis H1, H11, H111 
         definition of consistency_rule

      <3>3 assume H112: ~ (V!equal(prj_b(y), V!valid)),
      prove
      consistency_rule (y, x)
      by  hypothesis H1, H11, H112 definition of consistency_rule

      <3>f conclude

     <2>2 assume H12: ~(V!equal(prj_b(x), V!valid)),
     prove
     consistency_rule (y, x)
     by  hypothesis H1, H12 definition of consistency_rule
     
     <2>f conclude

 <1>f conclude
*)
;

end;;

collection Coll_int_value_with_valid =

  implement Imp_value_with_valid (Coll_int_value, Coll_valid_meas);

end;;

