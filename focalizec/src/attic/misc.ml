(* Transforms a tuple into pairs left-nested.
   (a, b, c, d) -> (((a, b), c), d) *)
let encode_tuple_as_left_nested_pairs expr =
  match expr.Parsetree.ast_desc with
   | Parsetree.E_tuple components ->
       (begin
       let rec rec_encode accu = function
         | [] -> accu
         | h :: q ->
             (* "(" ^ accu ^ "," ^ h ^ ")" in *)
             let accu_ty =
               (match accu.Parsetree.ast_type with
                | Parsetree.ANTI_type t -> t | _ -> assert false) in
             let h_ty =
               (match h.Parsetree.ast_type with
                | Parsetree.ANTI_type t -> t | _ -> assert false) in
             let accu' = {
               Parsetree.ast_loc = expr.Parsetree.ast_loc ;
               Parsetree.ast_desc = Parsetree.E_tuple [accu ; h] ;
               Parsetree.ast_doc = [] ;
               Parsetree.ast_type =
                 Parsetree.ANTI_type (Types.type_tuple [accu_ty ; h_ty]) } in
             rec_encode accu' q in
       match components with
        | [] -> assert false
        | [one] -> one
        | h :: q ->
            let transformed_expr = rec_encode h q in
            (* We assign the documentation of the initial whole expression to
               the outer pair generated by the transformation. *)
            { transformed_expr with
                Parsetree.ast_doc = expr.Parsetree.ast_doc }
       end)
   | _ -> expr
;;
