% $Id: cadavers.tex,v 1.6 2009-05-18 16:21:34 pessaux Exp $
\label{cadavers}
Here is the holly section of things that are not yet done and for
which we know there is still something to do. Currently, most of them
are not very intricate and do not impact the general sanity of the
compiler. However, it is possible to create some cases of programs
falling in these open points. Here are the cadavers we hide under the
carpet\ldots\smiley


\begin{itemize}
\item The verification that {\tt Self} is really compatible with the
  list of species types encountered during species expression typing
  is not currently done. This deals with inheritance from parametrised
  species applied to {\tt Self} as described in
  \ref{cadaver-self-must-be}. Most of the points in the code are
  tagged by a comment {\tt [Unsure]} and involve an identifier
  named {\tt self\_must\_be} to represent the unused list of these
  species types {\tt Self} must be compatible with. In fact, the
  function performing compatibility test already exists and is called
  {\tt is\_sub\_species\_of} in the source file {\tt typing/infer.ml}
  but we do not use it for this task.

\item Recursive functions with termination proofs using \coq's
  {\tt Function} construct are to be finished. I have some notes
  about this and must scan them instead of rewriting all. $A
  priori$, there is not tons of work to do for this and major
  identified points are:
  \begin{itemize}
  \item Adding $\alpha$ conversion in some parts of the generated
    code to prevent name conflicts in \coq.
  \item Rewrite the {\tt LTac} of William that should provide a mean
    to prove well foundation of orders from simple basic orders.
  \item Instead of using {\tt magic\_order} at the end of the proof,
    use the defined order (can be done only when the above {\tt LTac}
    will work since it will provide the well foundation of the
    order.
  \item Verify the {\tt measure} kind of proof and implement the
    {\tt structural} kind based on the primary brick {\tt order}.
  \item Provide a way for the user to see the proof he has to do for
    termination by showing him the theorems generated by the compiler
    for this termination proof.
  \end{itemize}

\item Check record label exhaustivity when dealing with expressions of
  type record. Currently the compiler only issues a warning to say
  that it is not done.
  
\item Have an automated and transparent renaming mechanism to prevent
  identifiers used in \focalize\ to make syntax errors in the target
  languages if they are token of these languages. For instance,
  defining an identifier ``{\tt module}'' will make a syntax error in
  the generated \ocaml\ code since ``{\tt module}'' is a keyword in
  \ocaml.

\item Local collections are not yet re-implemented. One must
  understand the semantics of the structure we want before.

\item Implement an effective API to allow passes to be added by users
  after scoping and typechecking and re-analyse the possibliy (by
  these user-passes) modified code. To prevent a useless re-analyse if
  no pass was inserted, the API could provide a function toggling an
  internal boolean telling if the code must be analysed again for
  example.

\item And most generally, the few points in the code tagged by a
  comment  {\tt [Unsure]}. These are the points where I strongly
  wondered without having yet found a solution in which I have a
  strong, indubitable confidence.

\item The notion of ``{\tt local}'' {\tt let} is not implemented. Some
  questions about its semantics\ldots Should it be inherited,
  i.e. visible in the children ? but not when the species is used as
  parameter ? as collection ? Does it appear in the signature ? What
  are the usage restrictions (ok or not in proofs) ? Does it lead to
  code ? Depending on these points, one must be careful to prevent
  dependencies on a {\tt local} that would not visible. What does it
  means to have a ``{\tt local}'' {\tt signature}, {\tt theorem},
  {\tt property} ?

\item Change the patterns so that they are as simple as those that
  \coq\ can handle. We don't want to keep our \ocaml-like patterns and
  decompose them into simpler patterns to prevent the user from trying
  to make proofs on a code that is not really the one he wrote.

\item Records expressions are not generated in \coq.

\item Unification currently implements the ``{\tt Self} preference''
  rule (rules [{\tt Self1}] and [{\tt Self2}] in Virgile's Phd section
  3.3, definition 9 page 27. It seems to be a hack to tend to
  introduce the maximum of {\tt Self} but doesn't seem to lead to a
  general type. In fact, this problem is circumvented by the notion of
  signature matching that allows to verify that the infered type of a
  method is compatible with the given signature of the method and keep
  as result the given signature. It may be possible to do so that the
  unification doens't return any type, hence leading to a regular
  ML-like unification, the signature matching process acting alone to
  abstract types (that are compatible with the known definition of the
  carrier) into {\tt Self}.

\item We should generate ``.mli'' interface files to prevent
  visibility of internal structure of species if manually hacking
  (interfacing) \ocaml\ code with source generated by \focalizec.

\item Question: {\tt proof by type Self}. What does it do ? What does
  it mean ?

\item Feature allowing to use a fully defined species instead of a
collection ? Wanted or not ? What's about the abstraction ? Remove ?!

\item Error: Unexpected error: "Failure("Euhhhh2 ?")"
  ({\tt from commoncode\_gen/misc\_common.ml}).
\noindent
{\footnotesize
\begin{lstlisting}
open "basics" ;;

species B =
  let x = 1 ;
end ;;

species S (A is B) =
  representation = A ;
  let x = 6 ;
end ;;

species C inherits S (Self) = end ;;
\end{lstlisting}
}
\item Species parametrised by {\tt Self} are currently handled by
  delaying the verification that {\tt Self} is really compatible with
  all the interfaces encountered in the {\tt inherits} clause
  involving {\tt Self} as effective argument of a collection. May be
  this verification shoud be done on the fly, considering only the
  interface of {\tt Self} we can build with the methods we currently
  know for {\tt Self}. {\bf Question}: Ok, rrrrrright, but is it
  possible to check interface compliance although we do not have yet a
  normal form of ourselves ?

\item The \focalizec\ command should be enhanced upon producing an
  executable instead of stopping only on object files (.cmo).

\end{itemize}
