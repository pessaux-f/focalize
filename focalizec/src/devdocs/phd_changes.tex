% $Id: phd_changes.tex,v 1.3 2009-03-16 10:35:17 pessaux Exp $
\subsection{Type unification}
\noindent Section 3.3, definition 9, page 27.

\noindent Rule [SELF1] should be: $mg(t, {\bf Self}, t) = {\bf Self}, id$

\noindent Rule [SELF2] should be: $mg(t, t, {\bf Self}) = {\bf Self}, id$



\subsection{Normal form algorithm}
\noindent Section 3.7.1, page 36.

\noindent In the algorithm, line 10 should be:
$\mathbb{W}_1 \leftarrow ((\psi_{i_{0}} \varogreaterthan \phi), \mathbb{X}).$

\smallskip

\noindent In the algorithm, line 13 should be:
$\mathbb{W}_2 \leftarrow (\mathbb{W}_2, \phi)$.

\smallskip
\noindent In the running text, page 37, line 8, the same modification
must be done to get ``on garde $\psi_{i_{0}} \varogreaterthan \phi$
dans $\mathbb{W}_1$ \ldots''.



\subsection{Typing rules for parametrised species}
\noindent Section 3.8, figure 3.2, page 43.

\noindent Rule [COL-PRM] should be:

\inferrule
  {
  {\cal C}, \Omega \vdash e^S : a \\
  {\cal C} + C : {\cal A} (a, C), \Omega \vdash
    {\bf species}\ S (prms)\ {\bf inherits}\ e^{S}_1, \ldots
    e^{S}_{h_f} = \Phi_1 \ldots \Phi_n : t_S
  }
  {
  {\cal C}, \Omega \vdash {\bf species}\ S(C \ {\bf is}\ e^S, prms)
  \ {\bf inherits}\ e^{S}_1, \ldots e^{S}_{h_f} =
  \Phi_1 \ldots \Phi_n : (C\ {\bf is}\ a)t_S
  }



\subsection{Dependency on the carrier}
\noindent Section 3.9.4, definition 28, page 50.

\noindent The definition should be: ``Soit une expression $e$, si une
sous-expression de $e$ \rlap{----------}a le type {\bf fait référence à
(``contient'')} {\tt Self}, il y a une
 decl-dépendance
vis-à-vis du type support.''.

\noindent In English: ''Let's have $e$ an expression, if a
sub-expression of $e$ \rlap{-----------}has type {\bf makes reference
to (``contains'')} {\tt Self}, then there is a decl-dependency
on the carier''.

\medskip
This is more  accurate since an expression having type
${\tt int} \rightarrow {\tt Self}$ does not have type {\tt Self}, but
when we state its type, {\tt Self} occurs in the type and must be
bound somewhere (and the decl-dependency on the carrier is just there
for this purpose).



% MERDE !!! Je ne me souviens plus pourquoi. L'explication que j'ai
% foutue sur la version papier de la thèse est merdique. Bon, à
% investiguer plus tard...
%
% \subsection{Inference rules for logical statements}
% \noindent Section 3.9.5, figure 3.3, page 52.

% \noindent The rule [EXPR] states that one can infer that an expression
% $expr$ has type {\tt prop} in $\Sigma$ if one can infer that is has
% type {\tt bool} in the ``reduced'' $\Sigma^{*}$.
% This is correct in the context of type checking. But this is not exact
% in the context of type {\bf inference}. In fact, it doen't work since
% the rules [EX] and [ALL] need to enter the bound variables 



\subsection{Dependencies in a species}
\noindent Section 3.9.5, definition 31, page 53.

\noindent Lines 3 and 4 should be:

\hspace{1cm} $\forall j < n,
   \ y_{j} \in \decldeps{y_{i}}_S \cup \defdeps{y_{j+1}}_S$

\noindent $x_1 <^{def}_{S} x_2 \ \widehat{=}\ \exists \{y_i\}_{i=1\ldots n}
  \ tel\ que \ y_1 \circlearrowright_S x_1, y_n \circlearrowright_S x_2,
  \forall j < n,\ y_j \in \defdeps{y_{j+1}}_S$



\subsection{Parameters used by a method}
\noindent Section 3.9.5, definition 66, page 124.

\noindent To understand the rules [BODY], [TYPE], [DEF-DEP], [UNIVERS]
and [PRM], it should be stated that implicitely the parameter $C_{p'}$
has the form: $$C_{p'} {\tt is/in\ } \tau_{p'}$$.


\subsection{Instanciation of species parameters}
\noindent Section 3.9.5, definition 67, page 124.

\noindent Second rule should be:
\inferrule
  {
  x \Lsh S = S_h \\
  {\cal E}(S_h) = (C_1 \centerdot \tau_1, \ldots,
                   C_{p_f} \centerdot \tau_{p_f}) \\
  l_h = e_1 \ldots\ e_{p_f}
  }
  {
  {\tt Inst}_S (x) = \{ {\tt Inst}_{C_p}(e_p)_{C_p\in {\cal U}_{S_h}(x)}\}
  }



\subsection{Traduction example in \ocaml}
\noindent Section 8.2, page 152.

The code sample shown and the explanation about {\tt create} at the
top of the page is wrong or at least not complete. In effect, if
presented this way, we don't know from where {\tt create} comes. In
fact, we must used the one coming from the species we
``implement''. So a qualified notation (i.e. module name + function
name) is required.



\subsection{Dependencies of a method}
\noindent Section 8.3.1, definition 72, page 153.


\subsubsection{Missing notion of order}
All along the rules, dependencies are stated as a set of names. In
fact this is uncomplete since there can be dependencies between these
names for a collection parameter. So they must be ordered according to
their own dependencies (i.e. according to def-depencendies inside the
hosting species that is that collection parameter).

\noindent For instance:

{\scriptsize
\begin{lstlisting}
species S1 ... =
  let eq = ... ;
  theorem th1 : all x in ..., !eq (...) ...
 proof = ... ;
end ;;

species S2 (P is S1) ... =
  theorem th2 : all x in P, ...
  proof = ... property P!th1 ... ;
end ;;
\end{lstlisting}
}

In {\tt S1}, {\tt th1} decl-depends on {\tt eq}. In {\tt S2}, method
{\tt th2} has a dependencies on its collection parameter {\tt P}
methods. Especially, on {\tt P!th1}, and completions rules require to
add {\tt P!eq} (in order to express the ``type'' of {\tt th1},
i.e. its statement). Since in {\tt P},  {\tt th1} decl-depends on
{\tt eq}, when making $\lambda$-liftings to abstract {\tt P}'s methods
in the depdencencies on methods of parameters in {\tt S1}, we must
ensure that {\tt eq} is $\lambda$-filter before {\tt th1} otherwise
{\tt eq} will be unbound in {\tt th1}.

This order is given be the dependencies of the methods inside the
species used as collection parameter.


\subsubsection{Missing rule}
The rules [DEF-DEP], [UNIVERS] and [PRM] can add dependencies on
parameters after rule [BODY] and [TYPES]. However, the added methods
can have decl-dependencies via their ``types''. An this is not taken
into account by the current set of rules.
To circumvent, a new rule is added, [DIDOU] (better name to be found,
but the day I thought to this rule, I was very poor in naming schemes
\smiley). This rule intuitively takes the all dependencies found by
[BODY], [TYPES], [DEF-DEP], [UNIVERS] and [PRM] as initial set and
performs a fixpoint by adding for each method of dependencies, its
decl-dependencies coming from its ``type'' (i.e. ML-like type for
computational methods, and statement for logical methods). Of course,
when tracking decl-dependencies of a method, we adress the method body
in its species. But this species is a collection parameter. So before
adding the found method to the set of dependencies on collection
parameters of the analysed species, we must replace in the method,
occurrences of {\tt Self} by the by the species parameter from where
this method comes.


\subsubsection{Missing substitution in rule [PRM]}
First, the rule [PRM] needs further explanations to understand its
presentation. It must first be understood that in this rule, the
species {\tt S} has the folloging form:

${\tt species}\ S (C_p\ {\tt is}\ \ldots, C_{p'}\ {\tt is}\ S'(C_p))$

Moreover, implicitely $i_{p'}$ is the infertace of $C_{p'}$. And $C_p$
is a valid implementation of the parameter $C'_k$ (having the
interface $i'_k$) of the species $S'$.

\medskip
\noindent Now, the rule says:

\inferrule
  {
  z \in Deps (S, C_{p'})[x] \\
  i_{p'} = S'(e_1, \ldots, C_p, \ldots) \\
  {\cal E}(S') = (C'_1 \centerdot i'_1, \ldots, C'_k\ {\tt is}\  i'_k,\ldots) \\
  y \in Deps (S', C'_k) [z]
  }
  {
  y \in Deps (S, C_p)[x]
  }

\noindent This rule forget to show that we must instanciate the formal
parameter of {\tt S'} by the effective argument provided. In effect,
in the bodies/types of the methods of {\tt S'} (those methods the
conclusion adds to the curently computed dependencies set), parameters
are those of {\tt S'}, not our current ones we use to instanciate the
formal ones of {\tt S'} ! To prevent those of {\tt S'} to remain in
the expressions and be unbound, we do the instanciation here.


\subsubsection{Inconsistence between inherited/re-computed dependencies}
{\scriptsize
\begin{lstlisting}
species Simple =
   signature equal : Self -> Self -> bool ;
end ;;

species Couple (S is Simple, T is Simple) =
  signature morph: S -> T;
  let equiv(e1, e2) = T!equal(!morph(e1), !morph(e2));
end ;;

species Bug (G is Simple) inherits Couple (G, G) =
  theorem theo: true
  proof =
    <1>1 
         prove true
         <2>f qed assumed {* *}
    <1>2 qed by definition of equiv ;
end ;;
\end{lstlisting}
}


\subsection{Coq code generation model}
\subsection{Missing rule for dependencies on parameters}
\subsection{Missing order for dependencies on parameters}

