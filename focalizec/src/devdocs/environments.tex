% $Id: environments.tex,v 1.9 2009-03-27 15:02:10 pessaux Exp $

All along the compilation pass, we need to keep trace of various
information about compiled entities (methods, types, identifiers,
\ldots). This is done by a kind of association list, mapping a name of
entity onto an information.

Depending on the compilation passe, the nature of the recorded
information is different. However, the basis of name mapping is always
the same. For this reason, instead of building several times the name
mapping system, we decided to create a structure of generic
environments which can be instantiated by specific information to
record for each compilation pass.

Environments implementation is located in the file
{\tt src/typing/env.ml}.


\section{The generic environment}

\subsection{Environment ``recording'' structure}
As previously stated, the core of an environment is to map names onto
information. In \focalize\, names can designate several types of
entities:
\begin{itemize}
  \item Sum type value constructors (e.g. {\tt None}, {\tt Some}).
  \item Record type field labels.
  \item Types constructors (e.g. {\tt int}, {\tt option}).
  \item Values.
  \item Species.
\end{itemize}

To ensure there is no conflicts between these different types of
entities, i.e. to be allowed to give a same name to a record types
field and to a type constructor or a value identifier, en environment
will keep separate name-spaces for each type of entity.

As we stated before, an environment maps a name (the {\bf key}) onto
an information (the {\bf value}). Hence, the {\bf key} of an
environment being a name, it will be mapped onto a
{\tt Parsetree.vname}. Since we want environments to record different
values (to be polymorphic in fact), the {\bf value} will be a
different type variable for each name-space.

Hence, the generic environments have type:
{\scriptsize
\begin{lstlisting}[language=MyOCaml]
type ('a, 'b, 'c, 'd, 'e) generic_env = {
  constructors : (Parsetree.constructor_name * 'a binding_origin) list ;
  labels : (Parsetree.vname * 'b binding_origin) list ;
  types : (Parsetree.vname * 'c binding_origin) list ;
  values : (Parsetree.vname * 'd binding_origin) list ;
  species : (Parsetree.vname * 'e binding_origin) list
}
\end{lstlisting}
}

To create a module system, we need to wrap this core structure inside
a module providing access to this structure, i.e. search the
{\bf value} bound to a {\bf key}: {\tt find} and add binding of a
{\bf key} to a {\bf value} : {\tt add}. Obviously, we need these 2
functions for each name-space.



\subsection{Principle of making an environment}
We would like to directly create a functor taking as argument a module
whose signature implements the types of bound information in each
name-space for an environment and gives back a module providing the
functions {\tt find} and {\tt add} for each name-space, in this
environment. The idea is then to apply this functor to a set of
various modules to get the scoping environment, the typing
environment, the \ocaml\ and the \coq\ code generation environments.

\medskip
This simplistic view fails because of the notion of ``modules'',
i.e. in \focalize\, compilation units.

In effect, since compilation units host definitions, they can be seen
as modules. Hence we need an extra function to search inside
``modules''. This will especially serve to look-up names qualified by
the \#-notation . For example the identifier {\tt basics!int} is bound
in the module {\tt basics} by the name {\tt int}. This
{\tt find\_module} function doesn't need to be visible in our generic
environments since it only serves for internal purpose. It must
conceptual take a module name, an environment and return the
``sub''-environment composed of all the definitions hosted by the
module. This {\tt find\_module} function is then dependant of the type
of the the name-space in which to look-up in the managed environment.
On must have 1 {\tt find\_module} for when we look-up for values, one
for when we look-up for types, one for sum type constructors, one for
record field labels, etc\ldots The problem is that ``creating'' the
''sub''-environment from the in formations contained in a module
depend on the structure of information recorded in the environment.
This means that we can't consider these in formations as anymore
polymorphic since we know to know their structure to build the
''sub''-environment.

\medskip
For this reason, we proceed in two steps, i.e. two functors. One,
{\tt EMAccess}), will provide the ``way to access'' the information
kept as {\bf values} in the environment. The second ({\tt Make}) will
take a module produced by the previous one and glue the structure of
the environment (i.e. in fact the association list) with the access
primitives provided.

\subsection{{\tt EMAccess} : accessing functions for an environment}
module is required to have the signature:
{\scriptsize
\begin{lstlisting}[language=MyOCaml]
module type EnvModuleAccessSig =
  type constructor_bound_data
  type label_bound_data
  type type_bound_data
  type value_bound_data
  type species_bound_data
  val find_module :
    loc: Location.t -> current_unit: Types.fname -> Types.fname option ->
      (constructor_bound_data, label_bound_data, type_bound_data,
       value_bound_data, species_bound_data)
      generic_env ->
        (constructor_bound_data, label_bound_data, type_bound_data,
         value_bound_data, species_bound_data)
      generic_env
  val pervasives : unit ->
    (constructor_bound_data, label_bound_data, type_bound_data,
     value_bound_data, species_bound_data)
      generic_env
  val make_value_env_from_species_methods :
    Parsetree.qualified_vname -> species_bound_data ->
      (constructor_bound_data, label_bound_data, type_bound_data,
       value_bound_data, species_bound_data)
        generic_env
  val post_process_method_value_binding :
    Parsetree.qualified_vname -> value_bound_data -> value_bound_data
  end
\end{lstlisting}
}{\sc Sample code for EMAccess signature}

\medskip
The fields type definitions {\tt constructor\_bound\_data},
{\tt label\_bound\_data}, {\tt type\_bound\_data}, {\tt value\_bound\_data}
and {\tt species\_bound\_data} respectively represent the information the
environment maps onto names of sum type value constructors, record
field labels, type constructors, values and species.

\medskip
Next come the {\tt find\_module} function that looks for a ``module''
name (the {\tt Types.fname option}, we will see later the reason of
the {\tt option}) in the current environment and returns the
environment composed of all the definitions present in this module
(compilation unit). For technical reason, some extra arguments are
passed to this function and we will explain their presence later.

\medskip
Next come the {\tt pervasives} value that is the initial (may
non-empty) environment containing built-in bindings that are
needed. Note that this environment may be the empty environment
(i.e. containing no binding) is nothing has to exist in a built-in
way.

\medskip
Next come a the function {\tt make\_value\_env\_from\_species\_methods}
whose purpose can be understood once the module system is
understood. Basically, this function must create an environment,
populating the values name-space with information extracted from the
methods of a species.

\medskip
Finally, the function {\tt post\_process\_method\_value\_binding} can
also be understood via the module system mechanism. This function takes
a collection name, an information bound to a value and is applied on
this information. This function is called by {\tt find\_value} to
post-process the information bound to a value name if needed.

\medskip
For sake of simplicity, we decide to group the types definitions
representing information bound for each name-space of an environment
in a module. This is not mandatory but allows a better structure of
the code.


\subsection{{\tt Make}-ing the environment}
This functor finally create the final environment structure, linking
the access functions provided by its argument (of interface
{\tt EMAccess}) and the basic structure of generic environment
({\tt ('a, 'b, 'c, 'd, 'e) generic\_env}).

\medskip
This functor must create a module whose signature contains an abstract
type representing the environment, an abstract value representing the
empty environment (i.e. with no binding), an abstract value
representing the ``pervasives'' environment and finally, for each
name-space a search function and an extension function (i.e. a
function that adds a binding to an environment, then returning this
environment with the binding ``in front''). This means that an
environment (dedicated to a ``Blabla'' processing) will have a
signature like (forget the noisy arguments we spoke about, like
{\tt loc}, {\tt current\_unit}, we will check them in detail later) :
{\scriptsize
\begin{lstlisting}[language=MyOCaml]
module BlablaEnv :
  sig
    type t
    val empty : unit -> t
    val pervasives : unit -> t

    val add_value :
      Parsetree.vname -> BlablaInformation.value_binding_info -> t -> t
    val find_value :
      loc: Location.t -> current_unit: Types.fname ->
        current_species_name: string option -> Parsetree.expr_ident -> t ->
          BlablaInformation.value_binding_info

    val add_constructor : Parsetree.constructor_name -> Types.fname -> t -> t
    val find_constructor :
      loc: Location.t -> current_unit:Types.fname ->
        Parsetree.constructor_ident -> t -> Types.fname

    val add_label : Parsetree.vname -> Types.fname -> t -> t
    val find_label :
      loc: Location.t -> current_unit: Types.fname -> Parsetree.label_ident ->
        t -> Types.fname

    val add_type :
      loc: Location.t -> Parsetree.vname ->
        BlablaInformation.type_binding_info ->
      t -> t
    val find_type :
      loc: Location.t -> current_unit: Types.fname -> Parsetree.ident -> t ->
        BlablaInformation.type_binding_info

    val add_species :
      loc: Location.t -> Parsetree.vname ->
        BlablaInformation.species_binding_info -> t -> t
    val find_species :
        loc: Location.t -> current_unit: Types.fname -> Parsetree.ident ->
      t -> BlablaInformation.species_binding_info
  end
\end{lstlisting}
}

\medskip
We address now some remarks about the {\tt Make} functor. This functor
provides the environment access functions that do not depends on the
structure of data stored in the environment. However, it uses the
functions that depends on that are provided by its argument module.

As a general scheme, for each name-space {\tt xxx}, we have 3
functions:
\begin{itemize}
\item {\tt add\_xxx} : Adds a binding to the environment (exported
  function).
\item {\tt find\_xxx} : Entry point to find the information bound to
  an identifier (exported function).
\item {\tt find\_xxx\_vname} : Find the information bound to a
{\tt Parsetree.vname} (not exported). This function is just an
internal used by {\tt find\_xxx\_vname} once it decomposed the
initially looked-up identifier into a primitive
{\tt Parsetree.vname}.
\end{itemize}



\subsubsection{Adding a binding}
All the environment extension functions ({\tt add\_xxx}) are quite
simple, they just add a binding to the association list in field of
the environment related to the right name-space. One may note that an
added binding is always tagged {\tt BO\_absolute}. This means that the
binding comes in the environment from the current compilation unit,
opposite as the tag {\tt BO\_opened} that serves to identify bindings
present in the environment due to an {\tt open} directive.



\subsubsection{Looking for a binding (except for values)}
Look-up functions are more complex, especially the one looking for
values. We now describe the general look-up mechanism that is exactly
the one used for {\tt find\_label}, {\tt find\_constructor} and
{\tt find\_type}.

\medskip
The first and simplest case is when the looked-up identifier doesn't
have any qualification. In this case, it must trivially be searched in
the related association list of the current environment.

The second case involves a qualified identifier and is more complex.The
principle is to split the looked-up name into a scope specifier (a
qualification) and a simple name. For instance, {\tt foo} has no scope
specifier and a simple name equal to ``foo''. Conversely,
{\tt basics\#bar} has the scope specifier ``basics'' and the simple
name ``bar''.
Then, from the scope specifier (i.e. in fact an ``module'' name), we
try to load the (``sub'')-environment of this module. If the specifier
is {\tt None}, then we will get back the current environment. It is in
this environment that we will perform the search (like in the first
case described above since the obtained identifier doesn't have
anymore qualification) . Now, the point is to check if we are allowed
to accept to find a binding induced by an {\tt open} directive. This
is usually the case except if the identifier has an explicit
qualification equal to {\tt None} or {\tt Some (file)} where
{\tt file} is the current compilation unit. 

The first point allows to recover an identifier defined in the
{\bf current compilation unit} even if some opened modules imported
identifiers wearing the same name. This features strongly relies on
the fact that the parser {\bf must} parse qualified identifiers like
{\tt \#foo} as a {\bf global} one with {\tt None} as qualifier. In
other words, such an identifier means ``the related definition being
at toplevel in the current compilation unit''.

The second point simply states that if we are looking for a qualified
identifier being in the current compilation unit, then is must not be
searched among identifiers imported by opened modules.

Based on this information, we simply look-up in the association list to
find the related binding.
{\scriptsize
\begin{lstlisting}[language=MyOCaml]
  (* ****************************************************************** *)
  (** {b Descr} : Looks-up for an [ident] inside the types environment.

      {b Rem} : Exported outside this module.                           *)
  (* ****************************************************************** *)
  let rec find_type ~loc ~current_unit type_ident (env : t) =
    match type_ident.Parsetree.ast_desc with
     | Parsetree.I_local vname ->
         (* No explicit scoping information was provided, hence *)
         (* opened modules bindings are acceptable.             *)
         find_type_vname ~loc ~allow_opened: true vname env
     | Parsetree.I_global qvname ->
         let (opt_scope, vname) = opt_scope_vname qvname in
         let env' = EMAccess.find_module ~loc ~current_unit opt_scope env in
         (* Check if the lookup can return something *)
         (* coming from an opened module.            *)
         let allow_opened = allow_opened_p current_unit opt_scope in
         find_type_vname ~loc ~allow_opened vname env'


  (* **************************************************************** *)
  (** {b Descr} : Looks-up for a [vname] inside the types environment.

      {b Rem} : Not exported outside this module.                     *)
  (* **************************************************************** *)
  and find_type_vname ~loc ~allow_opened vname (env : t) =
    try env_list_assoc ~allow_opened vname env.types with
    | Not_found -> raise (Unbound_type (vname, loc))
\end{lstlisting}
}{\sc Sample code for simple look-up function}


\subsubsection{Looking for a binding for values}
This case is more subtle since it involves more kinds of identifiers,
especially because of the ``!-notation''. Processing for local and
global identifiers ({\tt Parsetree.I\_local} and {\tt Parsetree.I\_global})
are the same as previously described.

We must then address the case of finding a binding for a method with
the ``!''-notation (i.e. {\tt Parsetree.EI\_method}). There are two
different cases.
\begin{enumerate}
\item There is no species qualification before the !, or the specified
  species is {\tt Self}. In this case then the searched identifier
  must belong to the inheritance of {\tt Self}. First, this means that
  opened stuff is forbidden. Next, because the {\tt values} bucket is so
  that inherited methods and our methods belong to it, we just have to
  search for the {\tt vname} inside the current environment.
\item There remain the case where these is an explicit species
  qualifier different of {\tt Self}. We still have two cases.
  \begin{enumerate}
  \item The specified species is the current species (not {\tt Self},
    the real name of the current species). This may arise because of
    substitution performed during typechecking in species
    signatures. In this case, the search is obviously the same than
    the previous case since it is really like the case where the
    qualifier is {\tt Self}.
  \item In the other cases, we must recover the environment in where
    to search (i.e. the environment compound of the definitions present
    in the species), according to if the species is qualified by a
    module name. Note that in this environment, all the imported
    bindings are tagged {\tt BO\_absolute}. This tag allows to make the
    difference between bindings introduced by the definitions of the
    current compilation unit and those brought by opened modules.
    So if the species is hosted in a module (i.e. compilation unit),
    we first get this module's environment otherwise we keep the
    current environment. Then we look for the species/collection
    definition. We transform all its definitions into an environment
    via the function {\tt EMAccess.make\_value\_env\_from\_species\_methods}.
    Finally in this environment, we look for the binding of the
    method name.

    This should be sufficient, but in case of scoping environment, we
    still have to modify the value bound to our identifier. For this
    reason, we have an extra function provided by the {\tt EMAccess}
    module that will be finally applied on the obtained
    value. Currently, in the other environments, this function is the
    identity (do nothing on the argument) since we only found a job to
    do in case of the scoping environment. We will describe what this
    function really does in the case of the scoping environment in its
    dedicated section.
  \end{enumerate}
\end{enumerate}


\section{Scoping environment}
The scoping environment provides information required to compute the
scope of an identifier. In other words, it enables to state the extend
in the program where an identifier is visible. The aim is to prevent
name confusion and to ensure that names are identified by
(i.e. related to) only one definition.

\subsection{The {\tt ScopeInformation} module}
We first look at the information bound to each name in the different
name-spaces.

\subsubsection{Sum type value constructors}
Since these identifiers are always introduced by type definitions that
are at toplevel, we only need to remind in which compilation unit they
were introduced, hence hosted. Then a constructor will be bound in the
environment to a compilation unit name.

\subsubsection{Record type field names}
For the same reason than for the sum type value constructors, Record
type field names are bound to a compilation unit name.

\subsubsection{Values}
Information bound to value identifiers is more complex since it must
depict the different cases of identifiers.
\begin{itemize}
\item{\tt SBI\_file}\ \ The identifier is at toplevel of
  a file (including the current file). We record the file name.
  
\item {\tt SBI\_method\_of\_self}\ \ The identifier is a method
  implicitly of {\tt Self}.

\item {\tt SBI\_method\_of\_coll}\ \ The identifier is a method
  explicitly of a collection. We record the fully qualified name of
  the collection.\\
  {\bf Attention}: while inserting a method at its definition point in
  the environment, it must always be tagged with
  {\tt SBI\_method\_of\_self}. The tag {\tt SBI\_method\_of\_coll} can
  only be returned by \\
  {\tt find\_value} who may perform a change on the fly if required.

\item {\tt SBI\_local}\ \ The identifier is locally bound ({\tt let}
  or function parameter).
\end{itemize}

\subsubsection{Types}
Type constructors may be separated in two categories:
\begin{itemize}
\item {\tt TBI\_builtin\_or\_var}\ \ The type identifier is either a
  type variable name ({\tt 'a} for instance) or a built-in type. In
  these two cases, the constructor is not hosted in a type definition
  in a particular compilation unit. In effect, type variables arise
  during the type-checking process and are not attached to a
  particular type definition. In fact, a type variable {\bf is not} a
  type constructor and only this justifies the fact is doesn't belong
  to a particular compilation unit. \\
  On the other side, we allow the possibility to have built-in type
  constructors in the \focalize\ language. This means that we can have
  type constructors related to no type definition written as
  \focalize. In this case, the compiler must deal internally with this
  type constructor. Currently this feature is not used since even
  basic types constructors like {\tt int}, {\tt bool}, {\tt char},
  \ldots have a regular \focalize\ (external) definition.

\item {\tt TBI\_defined\_in}\ \ The identifier is a type constructor
  name defined at toplevel by a type definition in a file. We record
  the hosting compilation unit.
\end{itemize}

\subsubsection{Species}
Data recorded for species is the most complex. It must depicts the
scope of the species name itself, but also give information about the
methods and parameters available through this species. For this
reason, we have a record grouping several things.

First, ({\tt spbi\_methods} records the list of {\bf all} the methods
names owned by the species, {\bf including those added by
inheritance}. Methods however appear only once and are ordered from
the most recent ancestor are in head of the list. In case of multiple
inheritance, we consider that ancestors are older from left to right.

Next, we record information about the species's parameters
({\tt spbi\_params\_kind}). For each parameter we simple
record if it is a collection ({\tt SPK\_is}) or entity
({\tt SPK\_in}) parameter.

Finally ({\tt spbi\_scope}), we record if the current species is
defined at toplevel in a compilation unit ({\tt SPBI\_file}) or is a
collection parameter of another species ({\tt SPBI\_parameter}).

\subsection{The {\tt ScopingEMAccess} module}
This module provides the functions we previously stated to help the
generic environment module to access the information stored in the
environment. We have 2 functions to inspect.

\medskip
The function {\tt make\_value\_env\_from\_species\_methods} simply
takes the list of the method names of the species and add them as
methods {\bf ``of the species''} passed as argument
(usage of {\tt SBI\_method\_of\_coll}) in the {\bf values}
name-space. Here the insertion explicitly shows that the methods
inserted in the environment are those of a particular species, not of
{\tt Self}. Moreover, the methods are tagged as {\tt BO\_absolute} to
say that by default they do not come from an ``opened'' module since
we consider that may be the species comes from an ``opened'' module,
but not its methods who are hosted {\bf in} the species.

\medskip
The function {\tt post\_process\_method\_value\_binding} is important
for the scoping environment (and in fact, currently we have such a
function in the interface of {\tt EMAccess} only because we need to
make a special job in the case of the scoping environment). Its job
consists in changing the tag of the methods of the species from
{\tt SBI\_method\_of\_self} to {\tt SBI\_method\_of\_coll}. In effect
when we create a species, its methods are tagged as being
``of {\tt Self}''. But when we load the methods of this species in an
environment we must say that these methods are not belonging to the
currently processed species but are belonging to the species from
which we loaded the methods in our environment.

For example, let's examine the following source code:
{\scriptsize
\begin{lstlisting}
species S (P is ...) =
  let meth1 (x) = ... P!meth2 ... ;
end ;;
}
\end{lstlisting}
}
When we are scoping in the Species {\tt S} the method {\tt meth1} we
encounter the expression (identifier) {\tt P!meth2}. To scope this
identifier we need to get the list (i.e. a ``sub''-environment)
containing the methods of {\tt P} in order to search for the name
{\tt meth2} among them. When {\tt P} was ``created'' (in fact when it
was scoped) we inserted in its scoping description the fact that it
had a method {\tt meth2} \ldots of {\tt Self} (yep, inside {\tt P},
{\tt meth2} is really a method of {\tt Self}). So it was tagged with
{\tt SBI\_method\_of\_self}. So if we insert straight-line this
information in our environment, while scoping our species {\tt S} we
will see that there exists a method {\tt meth2} \ldots of {\tt Self},
i.e. of {\tt S} which is wrong. For this reason, we must change the
tag of {\tt meth2} before inserting the binding in our environment.



\section{Typing environment}
The typing environment provides information required to type-check the
program, i.e. to infer types where they are not written, to check that
explicitly written types are correct and to annotate the AST with the
type found type of each AST node. Moreover, \focalize\ requires more
than type-checking ``à la'' ML. We will also record information about
dependencies.

\subsection{The {\tt TypeInformation} module}
We first look at the information bound to each name in the different
name-spaces. We will speak here of {\em type} and
{\em type scheme}. The different between them will be exposed later
while presenting the type-checking process. Let's intuitively say that
a {\em type scheme} is a ``template'' from which one can extract a
{\em type} by ``instanciation'' of the scheme. So in {\bf expressions},
only {\em types} are present, {\em type schemes} are bound to
{\bf definitions}.


\subsubsection{Sum type value constructors}
A sum type value constructor is considered as a function taking as
many parameters as they have arguments and returning a value whose
type is the one hosting the constructor (i.e. the current type
definition). For example:
{\scriptsize
\begin{lstlisting}
type t =
  | A
  | B of (int * bool)
  | C of (int, bool)
;;
\end{lstlisting}
}
leads to 3 value constructors of types: {\tt A: t},
{\tt B : (int * bool) -> t} and {\tt C: int -> bool -> t}. Note the
difference between {\tt B} and {\tt C}: the first one take 1 argument
that is a pair, the second take 2 arguments.

So, for each constructor of a sum type, we record its type scheme
({\tt cstr\_scheme}) and if it has arguments or not ({\tt cstr\_arity},
that can be {\tt CA\_zero} or {\tt CA\_some}).

Later, to type-checking an expression using a constructor applied to
some arguments, we will simply simulate a regular function
application and type-check this application like any other one. That
the reason why we also need to know if the constructor has argument(s)
or not since if it has none, there is no application to simulate: the
constructor in not a function but a value with the right type
directly.


\subsubsection{Record type field names}
In the same idea than for sum type value constructors, a record type
field label will be considered as a function taking 1 argument whose
type is the type of the field an returning a value value whose
type is the one hosting the field label (i.e. the current type
definition). For example:
{\scriptsize
\begin{lstlisting}
type t = {
  lbl1 : int ;
  lbl2 : string }
;;
\end{lstlisting}
}
leads to 2 value field labels of types: {\tt lbl1: int -> t} and
{\tt lbl2 : string -> t}.

So, for each field label, we simply record its type scheme
({\tt field\_scheme}) . We also record if the field is mutable or not
({\tt field\_mut}) but this features is not used (for extension
purpose) since \focalize\ doesn't handle mutability (i.e references).


\subsubsection{Values}
Values are simply bound to their type scheme.

\subsubsection{Types}
Type constructors must be bound to more complex information since they
must exhibit the kind of definition they are introduced by. We have 4
kinds of definitions:

\begin{itemize}
\item {\tt TK\_abstract} \ \ The constructor represents an abstract
  definition, i.e. a type whose values are not introduced by the
  definition itself. For instance, {\tt int} is abstract since its
  values do not appear in the type definition: they are built-in in
  the compiler. Type abbreviations are also handled this way. This
  means that defining {\tt type t = (int * string)} create a type
  {\tt t} that is abstract. Since there is no value and no structure
  information in the definition, we do not need to record anything
  special.

\item {\tt TK\_external} \ \ The constructor represents a type whose
  representation is explicitly provided for external languages. In
  other words, we import in \focalize\ types from (an)other
  language(s). We record on what this constructor must be mapped in
  the various foreign languages, the value constructors or field
  labels if some exist that can be used on \focalize's side and on
  what to map them in the various foreign languages.

\item {\tt TK\_variant} \ \ The constructor represents a sum type
  definition. Hence values are given in the definition's structure
  itself. Hence we record the list of value constructor names with for
  each its arity and its type scheme (in fact these 2 things are the
  same than recorded for each value constructor in the related
  name-space).

\item {\tt TK\_record} \ \ The constructor represents a record type
  definition. Hence, field labels are given in the definition's structure
  itself. Hence we record the list of these fields names with their
  type scheme and their mutability (like for sum types value
  constructors, these 2 things are those recorded for each field label
  in the related name-space).
\end{itemize}


\subsubsection{Species}
The structure of information recorded about species is pretty complex
since it must depict the complete species structure, most
importantly the parameters and all the methods stuff, but some other
additional things used during type-checking stage.

\begin{itemize}
\item {\tt spe\_kind} \ \ Describes if the species is a toplevel
  collection ({\tt SCK\_toplevel\_collection}), a toplevel species
  ({\tt SCK\_toplevel\_species}) or a collection parameter
  ({\t SCK\_species\_parameter}).

\item {\tt spe\_is\_closed} \ \ This boolean tells if the species if
  fully defined (even if not turned into a collection). This information
  will be useful to known when collection generators must be created.

\item {\tt spe\_sig\_params} \ \  The list of descriptions of the
  paremeters the species has, ordered the same way they appear in the
  species definition (i.e. the left-most in head of the list). We will
  examine the structure of this information a bit later. 

\item {\tt spe\_sig\_methods} \ \ The list of description of all the
  methods of the species. We will examine the structure of this
  information a bit later. One may note that like for scoping
  information, all the methods are present, i.e. the inherited also,
  once and in the inheritance resolution order. This way, the methods
  represent the ``normal form'' of the species as described in the
  theory.

\item {\tt spe\_dep\_graph} \ \ We record here the dependency graph of
  the species' methods. Hence, this deals with methods
  ``of {\tt Self}'' and represents def and decl-dependencies. This
  doens't include dependencies on collection parameters !

\end{itemize}



\subsection{The {\tt TypingEMAccess} module}



\section{\ocaml\ code generation environment}

\subsection{The {\tt MlGenInformation} module}

\subsubsection{Sum type value constructors}

\subsubsection{Record type field names}

\subsubsection{Values}

\subsubsection{Types}

\subsubsection{Species}



\section{\coq\ code generation environment}

\subsection{The {\tt CoqGenInformation} module}

\subsection{The {\tt CoqGenEMAccess} module}

\subsubsection{Sum type value constructors}

\subsubsection{Record type field names}

\subsubsection{Values}

\subsubsection{Types}

\subsubsection{Species}

\subsection{The {\tt MlGenEMAccess} module}

