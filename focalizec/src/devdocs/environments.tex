% $Id: environments.tex,v 1.16 2009-04-28 16:56:10 pessaux Exp $

All along the compilation pass, we need to keep trace of various
information about compiled entities (methods, types, identifiers,
\ldots). This is done by a kind of association list, mapping a name of
entity onto an information.

Depending on the compilation passe, the nature of the recorded
information is different. However, the basis of name mapping is always
the same. For this reason, instead of building several times the name
mapping system, we decided to create a structure of generic
environments which can be instantiated by specific information to
record for each compilation pass.

Environments implementation is located in the file
{\tt src/typing/env.ml}.


\section{The generic environment}
\index{environment!generic}
\subsection{Environment ``recording'' structure}
As previously stated, the core of an environment is to map names onto
information. In \focalize\, names can designate several types of
entities:
\begin{itemize}
  \item Sum type value constructors (e.g. {\tt None}, {\tt Some}).
  \item Record type field labels.
  \item Types constructors (e.g. {\tt int}, {\tt option}).
  \item Values.
  \item Species.
\end{itemize}

To ensure there is no conflicts between these different types of
entities, i.e. to be allowed to give a same name to a record types
field and to a type constructor or a value identifier, en environment
will keep separate name-spaces for each type of entity.

As we stated before, an environment maps a name (the {\bf key}) onto
an information (the {\bf value}). Hence, the {\bf key} of an
environment being a name, it will be mapped onto a
{\tt Parsetree.vname}. Since we want environments to record different
values (to be polymorphic in fact), the {\bf value} will be a
different type variable for each name-space.

Hence, the generic environments have type:
\begin{table}[h]
{\footnotesize
\begin{lstlisting}[language=MyOCaml]
type ('a, 'b, 'c, 'd, 'e) generic_env = {
  constructors : (Parsetree.constructor_name * 'a binding_origin) list ;
  labels : (Parsetree.vname * 'b binding_origin) list ;
  types : (Parsetree.vname * 'c binding_origin) list ;
  values : (Parsetree.vname * 'd binding_origin) list ;
  species : (Parsetree.vname * 'e binding_origin) list
}
\end{lstlisting}
}
\end{table}

To create a module system, we need to wrap this core structure inside
a module providing access to this structure, i.e. search the
{\bf value} bound to a {\bf key}: {\tt find} and add binding of a
{\bf key} to a {\bf value} : {\tt add}. Obviously, we need these 2
functions for each name-space.



\subsection{Principle of making an environment}
We would like to directly create a functor taking as argument a module
whose signature implements the types of bound information in each
name-space for an environment and gives back a module providing the
functions {\tt find} and {\tt add} for each name-space, in this
environment. The idea is then to apply this functor to a set of
various modules to get the scoping environment, the typing
environment, the \ocaml\ and the \coq\ code generation environments.

\medskip
This simplistic view fails because of the notion of ``modules'',
i.e. in \focalize\, compilation units.

In effect, since compilation units host definitions, they can be seen
as modules. Hence we need an extra function to search inside
``modules''. This will especially serve to look-up names qualified by
the \#-notation . For example the identifier {\tt basics!int} is bound
in the module {\tt basics} by the name {\tt int}. This
{\tt find\_module} function doesn't need to be visible in our generic
environments since it only serves for internal purpose. It must
conceptual take a module name, an environment and return the
``sub''-environment composed of all the definitions hosted by the
module. This {\tt find\_module} function is then dependant of the type
of the the name-space in which to look-up in the managed environment.
On must have 1 {\tt find\_module} for when we look-up for values, one
for when we look-up for types, one for sum type constructors, one for
record field labels, etc\ldots The problem is that ``creating'' the
''sub''-environment from the in formations contained in a module
depend on the structure of information recorded in the environment.
This means that we can't consider these in formations as anymore
polymorphic since we know to know their structure to build the
''sub''-environment.

\medskip
For this reason, we proceed in two steps, i.e. two functors. One,
{\tt EMAccess}), will provide the ``way to access'' the information
kept as {\bf values} in the environment. The second ({\tt Make}) will
take a module produced by the previous one and glue the structure of
the environment (i.e. in fact the association list) with the access
primitives provided.

\subsection{{\tt EMAccess} : accessing functions for an environment}
module is required to have the signature:
\begin{table}[h]
{\footnotesize
\begin{lstlisting}[language=MyOCaml]
module type EnvModuleAccessSig =
  type constructor_bound_data
  type label_bound_data
  type type_bound_data
  type value_bound_data
  type species_bound_data
  val find_module :
    loc: Location.t -> current_unit: Types.fname -> Types.fname option ->
      (constructor_bound_data, label_bound_data, type_bound_data,
       value_bound_data, species_bound_data)
      generic_env ->
        (constructor_bound_data, label_bound_data, type_bound_data,
         value_bound_data, species_bound_data)
      generic_env
  val pervasives : unit ->
    (constructor_bound_data, label_bound_data, type_bound_data,
     value_bound_data, species_bound_data)
      generic_env
  val make_value_env_from_species_methods :
    Parsetree.qualified_vname -> species_bound_data ->
      (constructor_bound_data, label_bound_data, type_bound_data,
       value_bound_data, species_bound_data)
        generic_env
  val post_process_method_value_binding :
    Parsetree.qualified_vname -> value_bound_data -> value_bound_data
  end
\end{lstlisting}
}
\caption{Sample code for EMAccess signature}
\end{table}

\medskip
The fields type definitions {\tt constructor\_bound\_data},
{\tt label\_bound\_data}, {\tt type\_bound\_data}, {\tt value\_bound\_data}
and {\tt species\_bound\_data} respectively represent the information the
environment maps onto names of sum type value constructors, record
field labels, type constructors, values and species.

\medskip
Next come the {\tt find\_module} function that looks for a ``module''
name (the {\tt Types.fname option}, we will see later the reason of
the {\tt option}) in the current environment and returns the
environment composed of all the definitions present in this module
(compilation unit). For technical reason, some extra arguments are
passed to this function and we will explain their presence later.

\medskip
Next come the {\tt pervasives} value that is the initial (may
non-empty) environment containing built-in bindings that are
needed. Note that this environment may be the empty environment
(i.e. containing no binding) is nothing has to exist in a built-in
way.

\medskip
Next come a the function {\tt make\_value\_env\_from\_species\_methods}
whose purpose can be understood once the module system is
understood. Basically, this function must create an environment,
populating the values name-space with information extracted from the
methods of a species.

\medskip
Finally, the function {\tt post\_process\_method\_value\_binding} can
also be understood via the module system mechanism. This function takes
a collection name, an information bound to a value and is applied on
this information. This function is called by {\tt find\_value} to
post-process the information bound to a value name if needed.

\medskip
For sake of simplicity, we decide to group the types definitions
representing information bound for each name-space of an environment
in a module. This is not mandatory but allows a better structure of
the code.


\subsection{{\tt Make}-ing the environment}
This functor finally create the final environment structure, linking
the access functions provided by its argument (of interface
{\tt EMAccess}) and the basic structure of generic environment
({\tt ('a, 'b, 'c, 'd, 'e) generic\_env}).

\medskip
This functor must create a module whose signature contains an abstract
type representing the environment, an abstract value representing the
empty environment (i.e. with no binding), an abstract value
representing the ``pervasives'' environment and finally, for each
name-space a search function and an extension function (i.e. a
function that adds a binding to an environment, then returning this
environment with the binding ``in front''). This means that an
environment (dedicated to a ``Blabla'' processing) will have a
signature like (forget the noisy arguments we spoke about, like
{\tt loc}, {\tt current\_unit}, we will check them in detail later) :
\begin{table}[h]
{\footnotesize
\begin{lstlisting}[language=MyOCaml]
module BlablaEnv :
  sig
    type t
    val empty : unit -> t
    val pervasives : unit -> t

    val add_value :
      Parsetree.vname -> BlablaInformation.value_binding_info -> t -> t
    val find_value :
      loc: Location.t -> current_unit: Types.fname ->
        current_species_name: string option -> Parsetree.expr_ident -> t ->
          BlablaInformation.value_binding_info

    val add_constructor : Parsetree.constructor_name -> Types.fname -> t -> t
    val find_constructor :
      loc: Location.t -> current_unit:Types.fname ->
        Parsetree.constructor_ident -> t -> Types.fname

    val add_label : Parsetree.vname -> Types.fname -> t -> t
    val find_label :
      loc: Location.t -> current_unit: Types.fname -> Parsetree.label_ident ->
        t -> Types.fname

    val add_type :
      loc: Location.t -> Parsetree.vname ->
        BlablaInformation.type_binding_info ->
      t -> t
    val find_type :
      loc: Location.t -> current_unit: Types.fname -> Parsetree.ident -> t ->
        BlablaInformation.type_binding_info

    val add_species :
      loc: Location.t -> Parsetree.vname ->
        BlablaInformation.species_binding_info -> t -> t
    val find_species :
        loc: Location.t -> current_unit: Types.fname -> Parsetree.ident ->
      t -> BlablaInformation.species_binding_info
  end
\end{lstlisting}
}
\end{table}

\medskip
We address now some remarks about the {\tt Make} functor. This functor
provides the environment access functions that do not depends on the
structure of data stored in the environment. However, it uses the
functions that depends on that are provided by its argument module.

As a general scheme, for each name-space {\tt xxx}, we have 3
functions:
\begin{itemize}
\item {\tt add\_xxx} : Adds a binding to the environment (exported
  function).
\item {\tt find\_xxx} : Entry point to find the information bound to
  an identifier (exported function).
\item {\tt find\_xxx\_vname} : Find the information bound to a
{\tt Parsetree.vname} (not exported). This function is just an
internal used by {\tt find\_xxx\_vname} once it decomposed the
initially looked-up identifier into a primitive
{\tt Parsetree.vname}.
\end{itemize}



\subsubsection{Adding a binding}
All the environment extension functions ({\tt add\_xxx}) are quite
simple, they just add a binding to the association list in field of
the environment related to the right name-space. One may note that an
added binding is always tagged {\tt BO\_absolute}. This means that the
binding comes in the environment from the current compilation unit,
\label{tag-BO-opened}
opposite as the tag {\tt BO\_opened} that serves to identify bindings
present in the environment due to an {\tt open} directive.



\subsubsection{Looking for a binding (except for values)}
Look-up functions are more complex, especially the one looking for
values. We now describe the general look-up mechanism that is exactly
the one used for {\tt find\_label}, {\tt find\_constructor} and
{\tt find\_type}.

\medskip
The first and simplest case is when the looked-up identifier doesn't
have any qualification. In this case, it must trivially be searched in
the related association list of the current environment.

The second case involves a qualified identifier and is more complex.The
principle is to split the looked-up name into a scope specifier (a
qualification) and a simple name. For instance, {\tt foo} has no scope
specifier and a simple name equal to ``foo''. Conversely,
{\tt basics\#bar} has the scope specifier ``basics'' and the simple
name ``bar''.
Then, from the scope specifier (i.e. in fact an ``module'' name), we
try to load the (``sub'')-environment of this module. If the specifier
is {\tt None}, then we will get back the current environment. It is in
this environment that we will perform the search (like in the first
case described above since the obtained identifier doesn't have
anymore qualification) . Now, the point is to check if we are allowed
to accept to find a binding induced by an {\tt open} directive. This
is usually the case except if the identifier has an explicit
qualification equal to {\tt None} or {\tt Some (file)} where
{\tt file} is the current compilation unit. 

The first point allows to recover an identifier defined in the
{\bf current compilation unit} even if some opened modules imported
identifiers wearing the same name. This features strongly relies on
the fact that the parser {\bf must} parse qualified identifiers like
{\tt \#foo} as a {\bf global} one with {\tt None} as qualifier. In
other words, such an identifier means ``the related definition being
at toplevel in the current compilation unit''.

The second point simply states that if we are looking for a qualified
identifier being in the current compilation unit, then is must not be
searched among identifiers imported by opened modules.

Based on this information, we simply look-up in the association list to
find the related binding.
\begin{table}[h]
{\footnotesize
\begin{lstlisting}[language=MyOCaml]
  (* ****************************************************************** *)
  (** {b Descr} : Looks-up for an [ident] inside the types environment.

      {b Rem} : Exported outside this module.                           *)
  (* ****************************************************************** *)
  let rec find_type ~loc ~current_unit type_ident (env : t) =
    match type_ident.Parsetree.ast_desc with
     | Parsetree.I_local vname ->
         (* No explicit scoping information was provided, hence *)
         (* opened modules bindings are acceptable.             *)
         find_type_vname ~loc ~allow_opened: true vname env
     | Parsetree.I_global qvname ->
         let (opt_scope, vname) = opt_scope_vname qvname in
         let env' = EMAccess.find_module ~loc ~current_unit opt_scope env in
         (* Check if the lookup can return something *)
         (* coming from an opened module.            *)
         let allow_opened = allow_opened_p current_unit opt_scope in
         find_type_vname ~loc ~allow_opened vname env'


  (* **************************************************************** *)
  (** {b Descr} : Looks-up for a [vname] inside the types environment.

      {b Rem} : Not exported outside this module.                     *)
  (* **************************************************************** *)
  and find_type_vname ~loc ~allow_opened vname (env : t) =
    try env_list_assoc ~allow_opened vname env.types with
    | Not_found -> raise (Unbound_type (vname, loc))
\end{lstlisting}
}
\caption{Sample code for simple look-up function}
\end{table}

\subsubsection{Looking for a binding for values}
This case is more subtle since it involves more kinds of identifiers,
especially because of the ``!-notation''. Processing for local and
global identifiers ({\tt Parsetree.I\_local} and {\tt Parsetree.I\_global})
are the same as previously described.

We must then address the case of finding a binding for a method with
the ``!''-notation (i.e. {\tt Parsetree.EI\_method}). There are two
different cases.
\begin{enumerate}
\item There is no species qualification before the !, or the specified
  species is {\tt Self}. In this case then the searched identifier
  must belong to the inheritance of {\tt Self}. First, this means that
  opened stuff is forbidden. Next, because the {\tt values} bucket is so
  that inherited methods and our methods belong to it, we just have to
  search for the {\tt vname} inside the current environment.
\item There remain the case where these is an explicit species
  qualifier different of {\tt Self}. We still have two cases.
  \begin{enumerate}
  \item The specified species is the current species (not {\tt Self},
    the real name of the current species). This may arise because of
    substitution performed during typechecking in species
    signatures. In this case, the search is obviously the same than
    the previous case since it is really like the case where the
    qualifier is {\tt Self}.
  \item In the other cases, we must recover the environment in where
    to search (i.e. the environment compound of the definitions present
    in the species), according to if the species is qualified by a
    module name. Note that in this environment, all the imported
    bindings are tagged {\tt BO\_absolute}. This tag allows to make the
    difference between bindings introduced by the definitions of the
    current compilation unit and those brought by opened modules.
    So if the species is hosted in a module (i.e. compilation unit),
    we first get this module's environment otherwise we keep the
    current environment. Then we look for the species/collection
    definition. We transform all its definitions into an environment
    via the function
    {\tt EMAccess.make\_value\_env\_from\_species\_methods}.
    Finally in this environment, we look for the binding of the
    method name.

    This should be sufficient, but in case of scoping environment, we
    still have to modify the value bound to our identifier. For this
    reason, we have an extra function provided by the {\tt EMAccess}
    module that will be finally applied on the obtained
    value. Currently, in the other environments, this function is the
    identity (do nothing on the argument) since we only found a job to
    do in case of the scoping environment. We will describe what this
    function really does in the case of the scoping environment in its
    dedicated section.
  \end{enumerate}
\end{enumerate}


\section{Scoping environment}
\index{environment!scoping}
\label{scoping-environment-presentation}
The scoping environment provides information required to compute the
scope of an identifier. In other words, it enables to state the extend
in the program where an identifier is visible. The aim is to prevent
name confusion and to ensure that names are identified by
(i.e. related to) only one definition.

\subsection{The {\tt ScopeInformation} module}
We first look at the information bound to each name in the different
name-spaces.

\subsubsection{Sum type value constructors}
Since these identifiers are always introduced by type definitions that
are at toplevel, we only need to remind in which compilation unit they
were introduced, hence hosted. Then a constructor will be bound in the
environment to a compilation unit name.

\subsubsection{Record type field names}
For the same reason than for the sum type value constructors, Record
type field names are bound to a compilation unit name.

\subsubsection{Values}
Information bound to value identifiers is more complex since it must
depict the different cases of identifiers.
\begin{itemize}
\item{\tt SBI\_file}\ \ The identifier is at toplevel of
  a file (including the current file). We record the file name.
  
\item {\tt SBI\_method\_of\_self}\ \ The identifier is a method
  implicitly of {\tt Self}.

\item {\tt SBI\_method\_of\_coll}\ \ The identifier is a method
  explicitly of a collection. We record the fully qualified name of
  the collection.\\
  {\bf Attention}: while inserting a method at its definition point in
  the environment, it must always be tagged with
  {\tt SBI\_method\_of\_self}. The tag {\tt SBI\_method\_of\_coll} can
  only be returned by \\
  {\tt find\_value} who may perform a change on the fly if required.

\item {\tt SBI\_local}\ \ The identifier is locally bound ({\tt let}
  or function parameter).
\end{itemize}

\subsubsection{Types}
Type constructors may be separated in two categories:
\begin{itemize}
\item {\tt TBI\_builtin\_or\_var}\ \ The type identifier is either a
  type variable name ({\tt 'a} for instance) or a built-in type. In
  these two cases, the constructor is not hosted in a type definition
  in a particular compilation unit. In effect, type variables arise
  during the type-checking process and are not attached to a
  particular type definition. In fact, a type variable {\bf is not} a
  type constructor and only this justifies the fact is doesn't belong
  to a particular compilation unit. \\
  On the other side, we allow the possibility to have built-in type
  constructors in the \focalize\ language. This means that we can have
  type constructors related to no type definition written as
  \focalize. In this case, the compiler must deal internally with this
  type constructor. Currently this feature is not used since even
  basic types constructors like {\tt int}, {\tt bool}, {\tt char},
  \ldots have a regular \focalize\ (external) definition.

\item {\tt TBI\_defined\_in}\ \ The identifier is a type constructor
  name defined at toplevel by a type definition in a file. We record
  the hosting compilation unit.
\end{itemize}

\subsubsection{Species}
Data recorded for species is the most complex. It must depicts the
scope of the species name itself, but also give information about the
methods and parameters available through this species. For this
reason, we have a record grouping several things.

First, ({\tt spbi\_methods} records the list of {\bf all} the methods
names owned by the species, {\bf including those added by
inheritance}. Methods however appear only once and are ordered from
the most recent ancestor are in head of the list. In case of multiple
inheritance, we consider that ancestors are older from left to right.

Next, we record information about the species's parameters
({\tt spbi\_params\_kind}). For each parameter we simple
record if it is a collection ({\tt SPK\_is}) or entity
({\tt SPK\_in}) parameter.

Finally ({\tt spbi\_scope}), we record if the current species is
defined at toplevel in a compilation unit ({\tt SPBI\_file}) or is a
collection parameter of another species ({\tt SPBI\_parameter}).

\subsection{The {\tt ScopingEMAccess} module}
This module provides the functions we previously stated to help the
generic environment module to access the information stored in the
environment. We have 2 functions to inspect.

\medskip
The function {\tt make\_value\_env\_from\_species\_methods} simply
takes the list of the method names of the species and add them as
methods {\bf ``of the species''} passed as argument
(usage of {\tt SBI\_method\_of\_coll}) in the {\bf values}
name-space. Here the insertion explicitly shows that the methods
inserted in the environment are those of a particular species, not of
{\tt Self}. Moreover, the methods are tagged as {\tt BO\_absolute} to
say that by default they do not come from an ``opened'' module since
we consider that may be the species comes from an ``opened'' module,
but not its methods who are hosted {\bf in} the species.

\medskip
The function {\tt post\_process\_method\_value\_binding} is important
for the scoping environment (and in fact, currently we have such a
function in the interface of {\tt EMAccess} only because we need to
make a special job in the case of the scoping environment). Its job
consists in changing the tag of the methods of the species from
{\tt SBI\_method\_of\_self} to {\tt SBI\_method\_of\_coll}. In effect
when we create a species, its methods are tagged as being
``of {\tt Self}''. But when we load the methods of this species in an
environment we must say that these methods are not belonging to the
currently processed species but are belonging to the species from
which we loaded the methods in our environment.

For example, let's examine the following source code:
\begin{table}[h]
{\footnotesize
\begin{lstlisting}
species S (P is ...) =
  let meth1 (x) = ... P!meth2 ... ;
end ;;
}
\end{lstlisting}
}
\end{table}
When we are scoping in the Species {\tt S} the method {\tt meth1} we
encounter the expression (identifier) {\tt P!meth2}. To scope this
identifier we need to get the list (i.e. a ``sub''-environment)
containing the methods of {\tt P} in order to search for the name
{\tt meth2} among them. When {\tt P} was ``created'' (in fact when it
was scoped) we inserted in its scoping description the fact that it
had a method {\tt meth2} \ldots of {\tt Self} (yep, inside {\tt P},
{\tt meth2} is really a method of {\tt Self}). So it was tagged with
{\tt SBI\_method\_of\_self}. So if we insert straight-line this
information in our environment, while scoping our species {\tt S} we
will see that there exists a method {\tt meth2} \ldots of {\tt Self},
i.e. of {\tt S} which is wrong. For this reason, we must change the
tag of {\tt meth2} before inserting the binding in our environment.



\section{Typing environment}
\label{typing-environment}
\index{environment!typing}
The typing environment provides information required to type-check the
program, i.e. to infer types where they are not written, to check that
explicitly written types are correct and to annotate the AST with the
type found type of each AST node. Moreover, \focalize\ requires more
than type-checking ``à la'' ML. We will also record information about
dependencies.

\subsection{The {\tt TypeInformation} module}
We first look at the information bound to each name in the different
name-spaces. We will speak here of {\em type} and
{\em type scheme}. The different between them will be exposed later
while presenting the type-checking process. Let's intuitively say that
a {\em type scheme} is a ``template'' from which one can extract a
{\em type} by ``instanciation'' of the scheme. So in {\bf expressions},
only {\em types} are present, {\em type schemes} are bound to
{\bf definitions}.


\subsubsection{Sum type value constructors}
A sum type value constructor is considered as a function taking as
many parameters as they have arguments and returning a value whose
type is the one hosting the constructor (i.e. the current type
definition). For example:
\begin{table}[h]
{\footnotesize
\begin{lstlisting}
type t =
  | A
  | B of (int * bool)
  | C of (int, bool)
;;
\end{lstlisting}
}
\end{table}
leads to 3 value constructors of types: {\tt A: t},
{\tt B : (int * bool) -> t} and {\tt C: int -> bool -> t}. Note the
difference between {\tt B} and {\tt C}: the first one take 1 argument
that is a pair, the second take 2 arguments.

So, for each constructor of a sum type, we record its type scheme
({\tt cstr\_scheme}) and if it has arguments or not ({\tt cstr\_arity},
that can be {\tt CA\_zero} or {\tt CA\_some}).

Later, to type-checking an expression using a constructor applied to
some arguments, we will simply simulate a regular function
application and type-check this application like any other one. That
the reason why we also need to know if the constructor has argument(s)
or not since if it has none, there is no application to simulate: the
constructor in not a function but a value with the right type
directly.


\subsubsection{Record type field names}
In the same idea than for sum type value constructors, a record type
field label will be considered as a function taking 1 argument whose
type is the type of the field an returning a value value whose
type is the one hosting the field label (i.e. the current type
definition). For example:
\begin{table}[h]
{\footnotesize
\begin{lstlisting}
type t = {
  lbl1 : int ;
  lbl2 : string }
;;
\end{lstlisting}
}
\end{table}
leads to 2 value field labels of types: {\tt lbl1: int -> t} and
{\tt lbl2 : string -> t}.

So, for each field label, we simply record its type scheme
({\tt field\_scheme}) . We also record if the field is mutable or not
({\tt field\_mut}) but this features is not used (for extension
purpose) since \focalize\ doesn't handle mutability (i.e references).


\subsubsection{Values}
Values are simply bound to their type scheme.

\subsubsection{Types}
Type constructors must be bound to more complex information since they
must exhibit the kind of definition they are introduced by. We have 4
kinds of definitions:

\begin{itemize}
\item {\tt TK\_abstract} \ \ The constructor represents an abstract
  definition, i.e. a type whose values are not introduced by the
  definition itself. For instance, {\tt int} is abstract since its
  values do not appear in the type definition: they are built-in in
  the compiler. Type abbreviations are also handled this way. This
  means that defining {\tt type t = (int * string)} create a type
  {\tt t} that is abstract. Since there is no value and no structure
  information in the definition, we do not need to record anything
  special.

\item {\tt TK\_external} \ \ The constructor represents a type whose
  representation is explicitly provided for external languages. In
  other words, we import in \focalize\ types from (an)other
  language(s). We record on what this constructor must be mapped in
  the various foreign languages, the value constructors or field
  labels if some exist that can be used on \focalize's side and on
  what to map them in the various foreign languages.

\item {\tt TK\_variant} \ \ The constructor represents a sum type
  definition. Hence values are given in the definition's structure
  itself. Hence we record the list of value constructor names with for
  each its arity and its type scheme (in fact these 2 things are the
  same than recorded for each value constructor in the related
  name-space).

\item {\tt TK\_record} \ \ The constructor represents a record type
  definition. Hence, field labels are given in the definition's structure
  itself. Hence we record the list of these fields names with their
  type scheme and their mutability (like for sum types value
  constructors, these 2 things are those recorded for each field label
  in the related name-space).
\end{itemize}


\subsubsection{Species}
The structure of information recorded about species is pretty complex
since it must depict the complete species structure, most
importantly the parameters and all the methods stuff, but some other
additional things used during type-checking stage.

\begin{itemize}
\item {\tt spe\_kind} \ \ Describes if the species is a toplevel
  collection ({\tt SCK\_toplevel\_collection}), a toplevel species
  ({\tt SCK\_toplevel\_species}) or a collection parameter
  ({\tt SCK\_species\_parameter}).

\item {\tt spe\_is\_closed} \ \ This boolean tells if the species if
  fully defined (even if not turned into a collection). This information
  will be useful to known when collection generators must be created.

\item {\tt spe\_sig\_params} \ \  The list of descriptions of the
  parameters the species has, ordered the same way they appear in the
  species definition (i.e. the left-most in head of the list). We will
  examine the structure of this information a bit later. 

\item {\tt spe\_sig\_methods} \ \ The list of description of all the
  methods of the species. We will examine the structure of this
  information a bit later. One may note that like for scoping
  information, all the methods are present, i.e. the inherited also,
  once and in the inheritance resolution order. This way, the methods
  represent the ``normal form'' of the species as described in the
  theory.

\item {\tt spe\_dep\_graph} \ \ We record here the dependency graph of
  the species' methods. Hence, this deals with methods
  ``of {\tt Self}'' and represents def and decl-dependencies. This
  doesn't include dependencies on collection parameters !
\end{itemize}

\paragraph{Species parameter information}
Since \focalize\ provides 2 kinds of parameters we have 2 types of
information to record:
\begin{itemize}
\item For entity parameters, {\tt SPAR\_in}, we keep the parameter's
  name, the collection representing its type and the flag telling if
  this collection is a parameter, a toplevel one (like for the field
  {\tt spe\_kind} of a species description seen above).

  For example, {\tt species S (Nat is ..., n in Nat)} will record for
  {\tt n} that its name is ``{\tt in}'', its type is {\tt Nat} and that
  this type is from a collection that is a collection parameter (i.e.
  {\tt SCK\_species\_parameter}) and not a toplevel one.

\item For collection parameters, {\tt SPAR\_is} we record more
  information, especially things that have already be computed about
  the species the parameter is ``{\tt is}'' in order to have a quick
  access to information instead of computing it each time we encounter
  a collection parameter of a certain ``type''. To base our
  presentation let's take the case of the species taken just above for
  the entity parameters.

  \begin{itemize}
  \item We record the name of the parameter with its compilation unit
    name. In fact, this will be the ``type'' of the collection this
    parameter makes available in the hosting species. In our example,
    {\tt Nat} is both the name of the parameter and the type that
    uniquely represents the collection is bring. In effect, to use
    methods of this parameter, we will use {\tt Nat!xxx}. By adding
    the compilation unit name, we exactly build a ``type of species''
    like we use anywhere else in the compiler.

  \item Like for entity parameters  we record the flag telling if the
    species the parameter is ``{\tt is}'' a parameter, a toplevel
    collection or a toplevel species. In our example, assuming that
    {\tt Nat} is a species defined somewhere else, we would have
    {\tt SCK\_toplevel\_species}.

  \item Next come the list of all the methods descriptions the
    parameter has. This list is exactly of the same type than the list
    that describes a species methods (whose structure will be examined
    just after). It is in fact the normalised form of the species
    methods the parameter has.

  \item Since a collection parameter ``is'' a species expression, not
    only a simple identifier (for example {\tt P2} and {\tt P3} in
    {\tt species S (P1 is ..., P2 is T (P1), P3 is U (P1, P2)) = ... ;;}
    who are built by applying arguments to parametrised species, we
    must record the complete species expression denoting what ``is''
    the parameter. Instead of directly recording the AST part
    representing the expression, we translate it into a custom type.

    In effect, in the AST, expressions used to represent species
    expressions are general expressions for sake of parsing technical
    issues. But in fact, due to the structure of the syntax, only a
    few kinds of AST nodes can be created. In particular, expressions
    coming out from the parser have restricted forms (invariants due
    to the syntax). Hence, instead of always assuming these invariants
    hold in the expressions representing species expressions, we
    prefer to convert them in a dedicated structure, more restricted
    than the general expressions, to enforce these invariants to hold
    directly by the type of the structure. For this reason, we record
    the species expression under the form of a \\
    {\tt Parsetree\_utils.simple\_species\_expr}.
  \end{itemize}
\end{itemize}


\paragraph{Method information}
Depending on the kind of the methods we have different strucutures to
record. In any case, we always record the history of the method,
i.e. where it was defined and from where and how it was inherited
until it arrives in the current species (structure
{\tt from\_history}) and its name. The kinds of method are basically
sumarised by the type {\tt spe\_sig\_methods} and can be:
\begin{itemize}
\item {\tt SF\_sig} \ \ represents a signature. since we do not have
  anything more than a type for this method, we keep it as a type
  scheme.

\item {\tt SF\_let} \ \ represents a {\tt let} definition, either
  ``computational'' or ``logical''. We record the list of parameter
  names of the definition (if it's a constant, then this list is
  empty), the type scheme of the definition, its the body
  (``computational'' or ``logical''), a termination proof if it has
  some, a structure telling if during type-checking we detected
  def and decl-dependencies on the carrier (on {\tt representation})
  and finally the flags found in the AST telling if the definition was
  {\tt logical} and was recursive.

\item {\tt SF\_let\_rec} \ \ Here is a list of information identical
  to what we store for {\tt SF\_let}, one for each recursively defined
  functions (i.e. only 1 element in the list if there is no mutually
  recursive functions).

\item {\tt SF\_theorem} \ \ represents a theorem definition. We record
  the mapping of type variables found in the {\tt forall} and
  {\tt exists}" in the property's logical expression onto their
  name. This is a technical point. In fact, theorems and properties do
  not have a type scheme. Their ``type'' is their logical
  statement. However, it is possible to have universally quantified
  type variables appearing in a theorem statement. Without a type
  scheme we are not able to technically instanciate these variables in
  a consistent way. To we patch this leak of scheme by recording for
  each universally quantified type variables, what identifier in the
  statement has this type.
  Next, we record the logical statement of the theorem, its proof, and
  like for {\tt SF\_let}, information on dependencies found on the
  carrier.
\item {\tt SF\_property} \ \  represents a property definition. We
  record the same information than for a theorem, except the proof
  since a property doesn't have any proof.
\end{itemize}



\subsection{The {\tt TypingEMAccess} module}
The access module for the typing environments is quite trivial. The
function {\tt make\_value\_env\_from\_species\_methods} works simply
inserting the methods of a species in the value bucket like it's done
for the scoping environments. The only point is that since theorems
and properties no do have a type scheme, we insert them with a trivial
type scheme whose body (core type) is simply {\tt prop}.

The function {\tt post\_process\_method\_value\_binding} is trivial
and is the identity. In effect, we do not need any post-processing
like we needed for scoping environments.



\section{\ocaml\ code generation environment}
\index{environment!ocaml code gen}
The \ocaml\ code generation environment provides information required
to generate the target \ocaml\ source code.

\subsection{The {\tt MlGenInformation} module}
We first look at the information bound to each name in the different
name-spaces.

\subsubsection{Sum type value constructors}
In this bucket, we only record on which string a sum type value
constructor that has been introduced by a type definition involving an
external representation must be translated into \ocaml.

For instance, in \ocaml, {\tt Nil} will be mapped onto {\tt []} and
{\tt Cons} to {\tt ( :: )}.  It may be clearly noticed that for
\ocaml, only constructors coming from {\bf external} sum types are
entered in the generation environment. Hence, if a constructor is not
found, then this means that it comes from a regular \focalize\ type
definition, not dealing with any external material, hence must be
simply translated into \ocaml\ using the name given in \focalize\
side.

\subsubsection{Record type field names}
\focalize's records are generated as real records in the target
languages. Hence, we only need to remind the name on which to map each
record field name of the \focalize\ type definition. Conversely to the
sum type value constructors, all the record field labels are recorded
in the environment.

\subsubsection{Values}
For \ocaml\ code generation, we do not need any information about
values. Hence, the type of the bound values is trivially
{\tt unit}. But in fact, we will never enter values not look for
values in such an environment.


\subsubsection{Types}
Types also do not need any information to be generated. Hence, they
are handled like values above in term of environment.


\subsubsection{Species}
For species (and collections) we must find a way to know their methods
and other information coming from the dependency computation. All this
is recorded in the {\tt species\_binding\_info} structure below:
\begin{itemize}
\item The list of parameters (collection and entity) of the species
  with their kind. This information is the same than the one stored
  in the type-checking environment.

\item The list of methods the species has. This information is the
  same than the one stored in the type-checking environment. Remember
  that is represents the methods present in the normal form of the
  species, i.e. with not double, with inheritance resolved and in the
  right order (to prevent dependency issues).

\item An optional {\tt collection\_generator\_info} describing, if
  available, the structure of the species' collection generator. This
  generator is optional because species that are non fully defined do
  not have any collection generator although they are entered in the
  environment. Generator data is used to prevent computing several
  times (in case where several collections are built from a same
  closed species) and contains:
  \begin{itemize}
  \item The list of species parameters names and kinds the species
    whose collection generator belongs to has. This list is
    positional, i.e. that the first name of the list is the name of
    the first species parameter and so on. The kind of a parameter is
    the same thing than the one recorded in the scoping environment.
  \item The list mapping for each parameter name, the set of methods the
    collection generator depends on, hence must be provided an instance
    to be used. Note that the list is not guaranteed to be ordered
    according to the order of the species parameters names (that's why
    we have the information about this order given in the first
    component of the {\tt species\_binding\_info} structure we are
    globally describing).
  \end{itemize}

\item Finally, a flag telling if this information is bound to a
  species ({\tt COS\_species} or a collection ({\tt COS\_collection}).
\end{itemize}



\subsection{The {\tt MlGenEMAccess} module}
The access module for the \ocaml\ code generation environments is
really trivial. The function
{\tt make\_value\_env\_from\_species\_methods} has no meaning for
\ocaml\ code generation environments because we do not provide any
{\tt find\_value} function and that's this function that requires
{\tt make\_value\_env\_from\_species\_methods}.

The function {\tt post\_process\_method\_value\_binding} is trivial
and is the identity. In effect, we do not need any post-processing
like we needed for scoping environments.



\section{\coq\ code generation environment}
\index{environment!coq code gen}
The \coq\ code generation environment provides information required
to generate the target \coq\ source code. Its structure will be pretty
close to the \ocaml\ environment. Most of the differences are induced
by the explicit polymorphism in \coq\ (that imposes to keep trace of
polymorphic type variables) and by the presence of logical methods
(i.e. theorems, that were discarded in \ocaml).

\subsection{The {\tt CoqGenInformation} module}
We first look at the information bound to each name in the different
name-spaces.


\subsubsection{Sum type value constructors}
The idea behind information bound to sum type value constructors is
about the same than in \ocaml. We want to know if needed on what
string to map a constructor name if it comes from an external type
definition. But we always need another information to handle
polymorphic constructors.

In effect, in \coq\ a polymorphic function (because constructors are
functions in fact) must be provided one extra argument for each
polymorphic type variable appearing in the type of the function. This
argument must have type {\tt Set} and be provided at application-time,
like the other remaining (regular) explicit arguments of the function
definition. In fact, \coq\ can infer the value of these arguments and
we can simply use a {\tt \_} (underscore) in place of these extra
arguments at application-time. However, we need to know how many
{\tt \_}s must be generated (i.e. how many extra arguments the
constructor has due to its polymorphism). For instance, the type
{\tt t} defined in \coq\ by:
\begin{table}[h]
{\footnotesize
\begin{lstlisting}[language=MyCoq]
Inductive t (alpha : Set) : Set :=
 | A : (alpha -> (t alpha)).
\end{lstlisting}
}
\end{table}
introduces 1 value constructor {\tt A} with not 1 argument, but 2 ! If
we want to create a {\tt t} value parametrised by the integer {\tt 1},
\begin{verbatim}
Coq < Check (A 1).
Toplevel input, characters 9-10:
> Check (A 1).
>          ^
Error: The term "1" has type "nat" while it is expected to have type "Set".
\end{verbatim}
To have a valid application, we must add one {\tt \_} before our
{\tt 1}, like in:
\begin{verbatim}
Coq < Check (A _ 1).
A nat 1
     : t nat
\end{verbatim}
We could be more explicit by directly providing the value of the first
argument that is in our case {\tt nat}:
\begin{verbatim}
Coq < Check (A nat 1). 
A nat 1
     : t nat
\end{verbatim}
but since \coq\ knows to infer it, we prefer let \coq\ doing the work
(type-checking get simpler on \focalize\'s side).


For this reason any sum type value constructor is recorded in the
environment with an optional mapping to a name on \coq\ side and the
number of extra arguments it must be apply to due to the type
generalised variables appearing in its type.


\subsubsection{Record type field names}
Record type field names are handled like in \ocaml.

\subsubsection{Values}
In the same order of idea than for sum type value constructors we need
to record the number of extra arguments to apply (when the value is
functional) due to polymorphic type variables present in the value's
type.

Moreover, for technical reasons due to \zenon, we also need to remind
if the value is a toplevel property ({\tt VB\_toplevel\_property} with
its logical expression body), a toplevel let-bound value
({\tt VB\_toplevel\_let\_bound}) or something else
({\tt VB\_non\_toplevel}).

\subsubsection{Types}
Like in \ocaml, types also do not need any information to be generated.

\subsubsection{Species}
Species are bound to exactly the same information than they are in
\ocaml\ code generation environments.


\subsection{The {\tt CoqGenEMAccess} module}
The access module for the \ocaml\ code generation environments is
pretty simple and works exactly like for type-checking environments.