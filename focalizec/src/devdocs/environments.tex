% $Id: environments.tex,v 1.3 2009-03-18 17:25:16 pessaux Exp $

All allong the compilation pass, we need to keep trace of various
informations about compiled entities (methods, types, identifiers,
\ldots). This is done by a kind of association list, mapping a name of
entity onto an information.

Depending on the compilation passe, the nature of the recorded
information is different. However, the basis of name mapping is always
the same. For this reason, instead of building several times the name
mapping system, we decided to create a structure of generic
environments which can be instantiated by specific information to
record for each compilation pass.

Environments implementation is located in the file
{\tt src/typing/env.ml}.


\section{The generic environment}

\subsection{Environement ``recording'' structure}
As previously stated, the core of an environment is to map names onto
informations. In \focalize\, names can designate several types of
entities:
\begin{itemize}
  \item Sum type value constructors (e.g. {\tt None}, {\tt Some}).
  \item Record type field labels.
  \item Types constructors (e.g. {\tt int}, {\tt option}).
  \item Values.
  \item Species.
\end{itemize}

To ensure there is no conflicts between these different types of
entities, i.e. to be allowed to give a same name to a record types
field and to a type constructor or a value identifier, en environment
will keep separate namespaces for each type of entity.

As we stated before, an environment maps a name (the {\bf key}) onto
an information (the {\bf value}). Hence, the {\bf key} of an
environment being a name, it will be mapped onto a
{\tt Parsetree.vname}. Since we want environments to record different
values (to be polymorphic in fact), the {\bf value} will be a
different type variable for each namespace.

Hence, the generic environments have type:
{\scriptsize
\begin{lstlisting}[language=MyOCaml]
type ('a, 'b, 'c, 'd, 'e) generic_env = {
  constructors : (Parsetree.constructor_name * 'a binding_origin) list ;
  labels : (Parsetree.vname * 'b binding_origin) list ;
  types : (Parsetree.vname * 'c binding_origin) list ;
  values : (Parsetree.vname * 'd binding_origin) list ;
  species : (Parsetree.vname * 'e binding_origin) list
}
\end{lstlisting}
}

To create a module system, we need to wrap this core structure inside
a module providing access to this structure, i.e. search the
{\bf value} bound to a {\bf key}: {\tt find} and add binding of a
{\bf key} to a {\bf value} : {\tt add}. Obviously, we need these 2
functions for each namespace.



\subsection{Principle of making an environment}
We would like to directly create a functor taking as argument a module
whose signature implements the types of bound information in each
namespace for an environement and gives back a module providing the
functions {\tt find} and {\tt add} for each namespace, in this
environment. The idea is then to apply this functor to a set of
various modules to get the scoping environment, the typing
environment, the \ocaml\ and the \coq\ code generation environments.

\medskip
This simplistic view fails because of the notion of ``modules'',
i.e. in \focalize\, compilation units.

In effect, since compilation units host definitions, they can be seen
as modules. Hence we need an extra function to search inside
``modules''. This will especially serve to look-up names qualified by
the \#-notation . For example the identifier {\tt basics!int} is bound
in the module {\tt basics} by the name {\tt int}. This
{\tt find\_module} function doesn't need to be visible in our generic
environments since it only serves for internal purpose. It must
conceptuall take a module name, an environment and return the
``sub''-environment composed of all the definitions hosted by the
module. This {\tt find\_module} function is then dependant of the type
of the the namespace in which to look-up in the managed environment.
On must have 1 {\tt find\_module} for when we look-up for values, one
for when we look-up for types, one for sum type constructors, one for
record field labels, etc\ldots The problem is that ``creating'' the
''sub''-environment from the informations contained in a module
depend on the structure of information recorded in the environment.
This means that we can't consider these informations as anymore
polymorphic since we know to know their structure to build the
''sub''-environment.

\medskip
For this reason, we proceed in two steps, i.e. two functors. One,
{\tt EMAccess}), will provide the ``way to access'' the informations
kept as {\bf values} in the environment. The second ({\tt Make}) will
take a module produced by the previous one and glue the structure of
the environment (i.e. in fact the association list) with the access
primitives provided.

\subsection{{\tt EMAccess} : accessing functions for an environment}
module is required to have the signature:
{\scriptsize
\begin{lstlisting}[language=MyOCaml]
module type EnvModuleAccessSig =
  type constructor_bound_data
  type label_bound_data
  type type_bound_data
  type value_bound_data
  type species_bound_data
  val find_module :
    loc: Location.t -> current_unit: Types.fname -> Types.fname option ->
      (constructor_bound_data, label_bound_data, type_bound_data,
       value_bound_data, species_bound_data)
      generic_env ->
        (constructor_bound_data, label_bound_data, type_bound_data,
         value_bound_data, species_bound_data)
      generic_env
  val pervasives : unit ->
    (constructor_bound_data, label_bound_data, type_bound_data,
     value_bound_data, species_bound_data)
      generic_env
  val make_value_env_from_species_methods :
    Parsetree.qualified_vname -> species_bound_data ->
      (constructor_bound_data, label_bound_data, type_bound_data,
       value_bound_data, species_bound_data)
        generic_env
  val post_process_method_value_binding :
    Parsetree.qualified_vname -> value_bound_data -> value_bound_data
  end
\end{lstlisting}
}

\medskip
The fields type definitions {\tt constructor\_bound\_data},
{\tt label\_bound\_data}, {\tt type\_bound\_data}, {\tt value\_bound\_data}
and {\tt species\_bound\_data} respectively represent the information the
environment maps onto names of sum type value constructors, record
field labels, type constructors, values and species.

\medskip
Next come the {\tt find\_module} function that looks for a ``module''
name (the {\tt Types.fname option}, we will see later the reason of
the {\tt option}) in the current environment and returns the
environment composed of all the definitions present in this module
(compilation unit). For technical reason, some extra arguments are
passed to this function and we will explain their presence later.

\medskip
Next come the {\tt pervasives} value that is the initial (may
non-empty) environment containing built-in bindings that are
needed. Note that this environment may be the empty environment
(i.e. containing no binding) is nothing has to exist in a built-in
way.

\medskip
Next come a the function {\tt make\_value\_env\_from\_species\_methods}
whose purpose can be understood once the module system is
understood. Basically, this function must create an environment,
populating the values name-space with informations extracted from the
methods of a species.

\medskip
Finally, the function {\tt post\_process\_method\_value\_binding} can
also be understood via the module system mechanism. This function takes
a collection name, an information bound to a value and is applied on
this information. This function is called by {\tt find\_value} to
post-process the information bound to a value name if needed.

\medskip
For sake of simplicity, we decide to group the types definitions
representing informations bound for each name-space of an environment
in a module. This is not mandatory but allows a better structure of
the code.


\subsection{{\tt Make}-ing the environment}
This functor finally create the final environment structure, linking
the access functions provided by its argument (of interface
{\tt EMAccess}) and the basic structure of generic environment
({\tt ('a, 'b, 'c, 'd, 'e) generic\_env}).

\medskip
This functor must create a module whose signature contains an abstract
type representing the environment, an abstract value representing the
empty environment (i.e. with no binding), an abstract value
representing the ``pervasives'' environment and finally, for each
name-space a search function and an extention function (i.e. a
function that adds a binding to an environement, then returning this
environement with the binding ``in front''). This means that an
environement (dedicated to a ``Blabla'' processing) will have a
signature like (forget the noisy arguments we spoke about, like
{\tt loc}, {\tt current\_unit}, we will check them in detail later) :
{\scriptsize
\begin{lstlisting}[language=MyOCaml]
module BlablaEnv :
  sig
    type t
    val empty : unit -> t
    val pervasives : unit -> t

    val add_value :
      Parsetree.vname -> BlablaInformation.value_binding_info -> t -> t
    val find_value :
      loc: Location.t -> current_unit: Types.fname ->
        current_species_name: string option -> Parsetree.expr_ident -> t ->
          BlablaInformation.value_binding_info

    val add_constructor : Parsetree.constructor_name -> Types.fname -> t -> t
    val find_constructor :
      loc: Location.t -> current_unit:Types.fname ->
        Parsetree.constructor_ident -> t -> Types.fname

    val add_label : Parsetree.vname -> Types.fname -> t -> t
    val find_label :
      loc: Location.t -> current_unit: Types.fname -> Parsetree.label_ident ->
        t -> Types.fname

    val add_type :
      loc: Location.t -> Parsetree.vname ->
        BlablaInformation.type_binding_info ->
      t -> t
    val find_type :
      loc: Location.t -> current_unit: Types.fname -> Parsetree.ident -> t ->
        BlablaInformation.type_binding_info

    val add_species :
      loc: Location.t -> Parsetree.vname ->
        BlablaInformation.species_binding_info -> t -> t
    val find_species :
        loc: Location.t -> current_unit: Types.fname -> Parsetree.ident ->
      t -> BlablaInformation.species_binding_info
  end
\end{lstlisting}
}


\section{Scoping environment}

\section{Typing environment}

\section{\ocaml\ code generation environment}

\section{\coq\ code generation environment}
