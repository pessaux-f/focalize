% $Id: environments.tex,v 1.6 2009-03-24 13:13:58 pessaux Exp $

All allong the compilation pass, we need to keep trace of various
informations about compiled entities (methods, types, identifiers,
\ldots). This is done by a kind of association list, mapping a name of
entity onto an information.

Depending on the compilation passe, the nature of the recorded
information is different. However, the basis of name mapping is always
the same. For this reason, instead of building several times the name
mapping system, we decided to create a structure of generic
environments which can be instantiated by specific information to
record for each compilation pass.

Environments implementation is located in the file
{\tt src/typing/env.ml}.


\section{The generic environment}

\subsection{Environement ``recording'' structure}
As previously stated, the core of an environment is to map names onto
informations. In \focalize\, names can designate several types of
entities:
\begin{itemize}
  \item Sum type value constructors (e.g. {\tt None}, {\tt Some}).
  \item Record type field labels.
  \item Types constructors (e.g. {\tt int}, {\tt option}).
  \item Values.
  \item Species.
\end{itemize}

To ensure there is no conflicts between these different types of
entities, i.e. to be allowed to give a same name to a record types
field and to a type constructor or a value identifier, en environment
will keep separate namespaces for each type of entity.

As we stated before, an environment maps a name (the {\bf key}) onto
an information (the {\bf value}). Hence, the {\bf key} of an
environment being a name, it will be mapped onto a
{\tt Parsetree.vname}. Since we want environments to record different
values (to be polymorphic in fact), the {\bf value} will be a
different type variable for each namespace.

Hence, the generic environments have type:
{\scriptsize
\begin{lstlisting}[language=MyOCaml]
type ('a, 'b, 'c, 'd, 'e) generic_env = {
  constructors : (Parsetree.constructor_name * 'a binding_origin) list ;
  labels : (Parsetree.vname * 'b binding_origin) list ;
  types : (Parsetree.vname * 'c binding_origin) list ;
  values : (Parsetree.vname * 'd binding_origin) list ;
  species : (Parsetree.vname * 'e binding_origin) list
}
\end{lstlisting}
}

To create a module system, we need to wrap this core structure inside
a module providing access to this structure, i.e. search the
{\bf value} bound to a {\bf key}: {\tt find} and add binding of a
{\bf key} to a {\bf value} : {\tt add}. Obviously, we need these 2
functions for each namespace.



\subsection{Principle of making an environment}
We would like to directly create a functor taking as argument a module
whose signature implements the types of bound information in each
namespace for an environement and gives back a module providing the
functions {\tt find} and {\tt add} for each namespace, in this
environment. The idea is then to apply this functor to a set of
various modules to get the scoping environment, the typing
environment, the \ocaml\ and the \coq\ code generation environments.

\medskip
This simplistic view fails because of the notion of ``modules'',
i.e. in \focalize\, compilation units.

In effect, since compilation units host definitions, they can be seen
as modules. Hence we need an extra function to search inside
``modules''. This will especially serve to look-up names qualified by
the \#-notation . For example the identifier {\tt basics!int} is bound
in the module {\tt basics} by the name {\tt int}. This
{\tt find\_module} function doesn't need to be visible in our generic
environments since it only serves for internal purpose. It must
conceptuall take a module name, an environment and return the
``sub''-environment composed of all the definitions hosted by the
module. This {\tt find\_module} function is then dependant of the type
of the the namespace in which to look-up in the managed environment.
On must have 1 {\tt find\_module} for when we look-up for values, one
for when we look-up for types, one for sum type constructors, one for
record field labels, etc\ldots The problem is that ``creating'' the
''sub''-environment from the informations contained in a module
depend on the structure of information recorded in the environment.
This means that we can't consider these informations as anymore
polymorphic since we know to know their structure to build the
''sub''-environment.

\medskip
For this reason, we proceed in two steps, i.e. two functors. One,
{\tt EMAccess}), will provide the ``way to access'' the informations
kept as {\bf values} in the environment. The second ({\tt Make}) will
take a module produced by the previous one and glue the structure of
the environment (i.e. in fact the association list) with the access
primitives provided.

\subsection{{\tt EMAccess} : accessing functions for an environment}
module is required to have the signature:
{\scriptsize
\begin{lstlisting}[language=MyOCaml]
module type EnvModuleAccessSig =
  type constructor_bound_data
  type label_bound_data
  type type_bound_data
  type value_bound_data
  type species_bound_data
  val find_module :
    loc: Location.t -> current_unit: Types.fname -> Types.fname option ->
      (constructor_bound_data, label_bound_data, type_bound_data,
       value_bound_data, species_bound_data)
      generic_env ->
        (constructor_bound_data, label_bound_data, type_bound_data,
         value_bound_data, species_bound_data)
      generic_env
  val pervasives : unit ->
    (constructor_bound_data, label_bound_data, type_bound_data,
     value_bound_data, species_bound_data)
      generic_env
  val make_value_env_from_species_methods :
    Parsetree.qualified_vname -> species_bound_data ->
      (constructor_bound_data, label_bound_data, type_bound_data,
       value_bound_data, species_bound_data)
        generic_env
  val post_process_method_value_binding :
    Parsetree.qualified_vname -> value_bound_data -> value_bound_data
  end
\end{lstlisting}
}{\sc Sample code for EMAccess signature}

\medskip
The fields type definitions {\tt constructor\_bound\_data},
{\tt label\_bound\_data}, {\tt type\_bound\_data}, {\tt value\_bound\_data}
and {\tt species\_bound\_data} respectively represent the information the
environment maps onto names of sum type value constructors, record
field labels, type constructors, values and species.

\medskip
Next come the {\tt find\_module} function that looks for a ``module''
name (the {\tt Types.fname option}, we will see later the reason of
the {\tt option}) in the current environment and returns the
environment composed of all the definitions present in this module
(compilation unit). For technical reason, some extra arguments are
passed to this function and we will explain their presence later.

\medskip
Next come the {\tt pervasives} value that is the initial (may
non-empty) environment containing built-in bindings that are
needed. Note that this environment may be the empty environment
(i.e. containing no binding) is nothing has to exist in a built-in
way.

\medskip
Next come a the function {\tt make\_value\_env\_from\_species\_methods}
whose purpose can be understood once the module system is
understood. Basically, this function must create an environment,
populating the values name-space with informations extracted from the
methods of a species.

\medskip
Finally, the function {\tt post\_process\_method\_value\_binding} can
also be understood via the module system mechanism. This function takes
a collection name, an information bound to a value and is applied on
this information. This function is called by {\tt find\_value} to
post-process the information bound to a value name if needed.

\medskip
For sake of simplicity, we decide to group the types definitions
representing informations bound for each name-space of an environment
in a module. This is not mandatory but allows a better structure of
the code.


\subsection{{\tt Make}-ing the environment}
This functor finally create the final environment structure, linking
the access functions provided by its argument (of interface
{\tt EMAccess}) and the basic structure of generic environment
({\tt ('a, 'b, 'c, 'd, 'e) generic\_env}).

\medskip
This functor must create a module whose signature contains an abstract
type representing the environment, an abstract value representing the
empty environment (i.e. with no binding), an abstract value
representing the ``pervasives'' environment and finally, for each
name-space a search function and an extention function (i.e. a
function that adds a binding to an environement, then returning this
environement with the binding ``in front''). This means that an
environement (dedicated to a ``Blabla'' processing) will have a
signature like (forget the noisy arguments we spoke about, like
{\tt loc}, {\tt current\_unit}, we will check them in detail later) :
{\scriptsize
\begin{lstlisting}[language=MyOCaml]
module BlablaEnv :
  sig
    type t
    val empty : unit -> t
    val pervasives : unit -> t

    val add_value :
      Parsetree.vname -> BlablaInformation.value_binding_info -> t -> t
    val find_value :
      loc: Location.t -> current_unit: Types.fname ->
        current_species_name: string option -> Parsetree.expr_ident -> t ->
          BlablaInformation.value_binding_info

    val add_constructor : Parsetree.constructor_name -> Types.fname -> t -> t
    val find_constructor :
      loc: Location.t -> current_unit:Types.fname ->
        Parsetree.constructor_ident -> t -> Types.fname

    val add_label : Parsetree.vname -> Types.fname -> t -> t
    val find_label :
      loc: Location.t -> current_unit: Types.fname -> Parsetree.label_ident ->
        t -> Types.fname

    val add_type :
      loc: Location.t -> Parsetree.vname ->
        BlablaInformation.type_binding_info ->
      t -> t
    val find_type :
      loc: Location.t -> current_unit: Types.fname -> Parsetree.ident -> t ->
        BlablaInformation.type_binding_info

    val add_species :
      loc: Location.t -> Parsetree.vname ->
        BlablaInformation.species_binding_info -> t -> t
    val find_species :
        loc: Location.t -> current_unit: Types.fname -> Parsetree.ident ->
      t -> BlablaInformation.species_binding_info
  end
\end{lstlisting}
}

\medskip
We address now some remarks about the {\tt Make} functor. This functor
provides the environment access functions that do not depends on the
structure of data stored in the environment. However, it uses the
functions that depends on that are provided by its argument module.

As a general scheme, for each name-space {\tt xxx}, we have 3
functions:
\begin{itemize}
\item {\tt add\_xxx} : Adds a binding to the environment (exported
  function).
\item {\tt find\_xxx} : Entry point to find the information bound to
  an identifier (exported function).
\item {\tt find\_xxx\_vname} : Find the information bound to a
{\tt Parsetree.vname} (not exported). This function is just an
internal used by {\tt find\_xxx\_vname} once it decomposed the
initially looked-up identifier into a primitive
{\tt Parsetree.vname}.
\end{itemize}



\subsubsection{Adding a binding}
All the environment extention functions ({\tt add\_xxx}) are quite
simple, they just add a bindind to the association list in field of
the environment related to the right name-space. One may note that an
added bindind is always tagged {\tt BO\_absolute}. This means that the
binding comes in the environment from the current compilation unit,
opposite as the tag {\tt BO\_opened} that serves to identify bindings
present in the environment due to an {\tt open} directive.



\subsubsection{Looking for a binding (except for values)}
Look-up functions are more complex, especially the one lokoing for
values. We now describe the general look-up mechanism that is exactly
the one used for {\tt find\_label}, {\tt find\_constructor} and
{\tt find\_type}.

\medskip
The first and simplest case is when the looked-up identifier doesn't
have any qualification. In this case, it must trivially be searched in
the related association list of the current environment.

The second case inolves a qualified identifier and is more complex.The
principle is to split the looked-up name into a scope specifier (a
qualification) and a simple name. For instance, {\tt foo} has no scope
specifier and a simple name equal to ``foo''. Conversely,
{\tt basics\#bar} has the scope specifier ``basics'' and the simple
name ``bar''.
Then, from the scope specifier (i.e. in fact an ``module'' name), we
try to load the (``sub'')-environment of this module. If the specifier
is {\tt None}, then we will get back the current environment. It is in
this environment that we will perform the search (like in the first
case described above since the obtained identifier doesn't have
anymore qualification) . Now, the point is to check if we are allowed
to accept to find a binding induced by an {\tt open} directive. This
is usually the case except if the identifier has an explicit
qualification equal to {\tt None} or {\tt Some (file)} where
{\tt file} is the current compilation unit. 

The first point allows to recover an identifier defined in the
{\bf current compilation unit} even if some opened modules imported
identifiers wearing the same name. This features strongly relies on
the fact that the parser {\bf must} parse qualified identifiers like
{\tt \#foo} as a {\bf global} one with {\tt None} as qualifier. In
other words, such an identifier means ``the related definition being
at toplevel in the current compilation unit''.

The second point simply states that if we are looking for a qualified
identifier being in the current compilation unit, then is must not be
searched among identifiers imported by opened modules.

Based on this information, we simply look-up in the assocition list to
find de related binding.
{\scriptsize
\begin{lstlisting}[language=MyOCaml]
  (* ****************************************************************** *)
  (** {b Descr} : Looks-up for an [ident] inside the types environment.

      {b Rem} : Exported outside this module.                           *)
  (* ****************************************************************** *)
  let rec find_type ~loc ~current_unit type_ident (env : t) =
    match type_ident.Parsetree.ast_desc with
     | Parsetree.I_local vname ->
         (* No explicit scoping information was provided, hence *)
         (* opened modules bindings are acceptable.             *)
         find_type_vname ~loc ~allow_opened: true vname env
     | Parsetree.I_global qvname ->
         let (opt_scope, vname) = opt_scope_vname qvname in
         let env' = EMAccess.find_module ~loc ~current_unit opt_scope env in
         (* Check if the lookup can return something *)
         (* coming from an opened module.            *)
         let allow_opened = allow_opened_p current_unit opt_scope in
         find_type_vname ~loc ~allow_opened vname env'


  (* **************************************************************** *)
  (** {b Descr} : Looks-up for a [vname] inside the types environment.

      {b Rem} : Not exported outside this module.                     *)
  (* **************************************************************** *)
  and find_type_vname ~loc ~allow_opened vname (env : t) =
    try env_list_assoc ~allow_opened vname env.types with
    | Not_found -> raise (Unbound_type (vname, loc))
\end{lstlisting}
}{\sc Sample code for simple look-up function}


\subsubsection{Looking for a binding for values}
This case is more subtil since it involves more kinds of ideitifiers,
especially because of the ``!-notation''. Processing for local and
global identifiers ({\tt Parsetree.I\_local} and {\tt Parsetree.I\_global})
are the same as previously described.

We must then address the case of finding a binding for a method with
the ``!''-notation (i.e. {\tt Parsetree.EI\_method}). There are two
different cases.
\begin{enumerate}
\item There is no species qualification before the !, or the specified
  species is {\tt Self}. In this case then the searched identifier
  must belong to the inheritance of {\tt Self}. First, this means that
  opened stuff is forbidden. Next, because the {\tt values} bucket is so
  that inherited methods and our methods belong to it, we just have to
  search for the {\tt vname} inside the current environment.
\item There remain the case where these is an explicit species
  qualifier different of {\tt Self}. We still have two cases.
  \begin{enumerate}
  \item The specified species is the current species (not {\tt Self},
    the real name of the current species). This may arise because of
    substitution performed during typechecking in species
    signatures. In this case, the search is obviously the same than
    the previous case since it is really like the case where the
    qualifier is {\tt Self}.
  \item In the other cases, we must recover the environment in where
    to search,according to if the species is qualified by a module
    name. Note that in this environment, all the imported bindings are
    tagged {\tt BO_absolute}. This tag allows to make the difference
    between bindings introduced by the definitions of the current
    compilation unit and those brought by opened modules.
  \end{enumerate}
\end{enumerate}


\section{Scoping environment}

\section{Typing environment}

\section{\ocaml\ code generation environment}

\section{\coq\ code generation environment}
