% $Id: codegen_model.tex,v 1.17 2009-04-21 12:47:19 pessaux Exp $

The code generation model is the now closely the same for both \ocaml\
and \coq\ generated source files. The main difference comes from the
fact that in \ocaml, logical methods are discarded. However, except
for the case of \zenon\ proofs where we introduce \coq\ {\tt Section},
the generation model for ``computation'' and logical methods are
exactly the the same. This especially means that dependencies are
``manually'' abstracted by explicit $\lambda$-lifting instead of using
(like in the previous compiler) the \coq's {\tt Section}
mechanism. In the same order of idea, in order to have a common model,
both \ocaml\ and \coq\ code are based on a record-oriented structure
for the species and collection, with explicit record fields accesses.

\section{Species}

\subsection{Species header}
The generated code for a species is hosted by a module whose name is
the species' name. This way, it is possible to have species having the
same names of methods without conflict. The module hence defines the
name-space of ``things'' contained in and induced by a species.


\subsection{Carrier representation}
In \ocaml, if the structure of the carrier of the species is known
(i.e. if the method {\tt representation} was defined), then we
generate a type definition whose name is {\tt me\_as\_carrier} and
body is the type translation of the corresponding \focalize\ type
expression.

In such a type definition, carriers of species parameters appearing in
the species' carrier are abstracted by type variables. The naming
scheme of these variable is ''{\tt '}'' + the species parameter's name
un-capitalised + ``{\tt \_as\_carrier}'' + an integer stamp that is
unique (inside this type definition). Since species names in
\focalize\ are capitalised and capitalised identifiers in \ocaml\ are
reserved for modules and sum type value constructors, we need to
un-capitalise the name when generating \ocaml\ code. For the stamp, it
is required to prevent several type variable from having the same name
in case the species is parameterised by both a collection parameter
and an entity parameter whose names differ only by the capitalisation
of the first letter.

For instance, the following header of a species definition:
{\footnotesize
\begin{lstlisting}
species Cartesian_product(A is Setoid, B is Setoid) =
  representation = A * B;
  ...
\end{lstlisting}
}
will generate the \ocaml\ type definition:
{\footnotesize
\begin{lstlisting}[language=MyOCaml]
module Cartesian_product =
  struct
  (* Carrier's structure explicitly given by "rep". *)
  type ('a0_as_carrier, 'b1_as_carrier) me_as_carrier =
    'a0_as_carrier * 'b1_as_carrier
  ...
\end{lstlisting}
}

In fact, {\em a posteriori}, I think now that it's useless in case
of a species, even closed. This type definition is only used in the
case of a collection.

\medskip
In \coq, no definition generated, the knowledge of the structure of
the carrier being reflected directly is needed in the methods (see
later).



\subsection{The record type}
The type of data representing a species is a record type. We first
examine its header, i.e. stuff before this type definition's body,
then it's body.


\subsubsection{The record header}
The name of this type is always {\tt me\_as\_species}. It can be
parametrised due to various abstraction requirements induced by the
late-binding feature of \focalize. \ocaml\ requires a parameter not
needed for \coq: this is the only fundamental difference. We will see
that abstractions (hence, parameters) required by \coq\ can involve
methods but this is only because some of the dependencies that are
present in the \coq code are always trivially absent in the
\ocaml\ code.


\begin{enumerate}
\item First come all the species parameter carriers appearing in the
  {\bf types} of the methods of the species. Each carrier will be
  abstracted by one type variable. This allows to ``late-bind'' the
  {\tt representation} of the species parameters. We say here 
  ``appearing in the {\bf types}\ldots'': be aware that the type of
  ``computational'' methods are ML-like types and the ones of logical
  methods are their {\bf statement} ! We do not explain here how these
  parameters are found: this is the role of dependency computation on
  species parameters.

  The naming scheme of these type variable in \ocaml\ is the same than
  described above for the carrier representation.

  In \coq\, these parameters of the type are not ``really type
  variables'' but arguments of type {\tt Set} (simply a technical
  question). Their naming scheme is the species parameter's name +
  ``{\tt \_T}''.

\item Next, {\bf only in the \ocaml\ code}, the record type is always
  parametrised by a type variable representing the carrier of
  (i.e. the internal representation of the type encapsulated in this)
  species. By convention, this type variable is always named
  {\tt 'me\_as\_carrier} (don't confuse with {\tt me\_as\_carrier}
  that is the name of the type definition representing the effective
  structure of the carrier when it is known).

  In \coq\ we don't have this mandatory type parameter, but instead of
  it, we will have one extra field in the body of the record. This
  variable enable to ``late-bind'' the {\tt representation} of the
  species.

\item Finally come all the methods of the species parameter appearing
  in the {\bf types} of the methods of the species. Since in \ocaml\
  the type of a method can only involve type constructors (a ML-like
  type), it is clear that we won't have any such parameters. In
  effect, in \ocaml\ the logical methods are discarded. However,
  since for the type of a logical method is its logical statement, to
  \coq's side, we can have any expression inside their type.. In
  particular, we can have calls to some collection parameters'
  methods. Having these parameters in the record type allows the
  ``late-binding'' on the collection parameter itself (i.e. on by
  which effective collection will be used to instantiate the
  parameter). The naming scheme for the parameters induced by these
  dependencies is ``{\tt \_p\_}'' + the species parameter's name  +
  {\tt \_} + the method's name.

  There is a special a case: the entity parameters. We will explain
  this after the following example.
\end{enumerate}

Let's now change our previous example to illustrate the header of our
record type in \ocaml\ and \coq:

{\footnotesize
\begin{lstlisting}
species Cartesian_product(A is Setoid, B is Setoid) =
  representation = A * B;
  let make (x in A, y in B) in Self = (x, y) ;
  let equiv (x in Self) = ... A!equal (...) && B!equal (...) ;
  theorem thm : all x in A, A!tst (x) -> ...
    proof = ... by property A!commutes ... ;
  ...
\end{lstlisting}
}

We can see that we have:
\begin{itemize}
\item the carrier defined,
\item a method {\tt make} of type {\tt A -> B -> Self}
\item a method {\tt equiv} having type {\tt Self -> bool}, having
  dependencies on the methods {\tt equal} of the collection parameters
  {\tt A} and {\tt B}, but in its {\bf body}, not in its type
  ({\tt equal} doesn't appear in {\tt equiv}'s type). Hence, the
  record type (in \coq\ and in \ocaml) won't have any parameter to
  abstract the dependencies on these methods.
\item a theorem {\tt thm} of ``type''
  {\tt all x in A, A!tst (x) -> ...} and ``body'' (proof)
  {\tt ... by property A!commutes ...}. Hence, it has dependencies on
  {\tt A!tst} in its type and on {\tt A!commutes} in its body. This
  means that in \coq\ the record type will have a parameter to abstract
  the dependency found in the type of the theorem, i.e. {\tt A!tst}
  but not for {\tt A!commutes}
\end{itemize}

The record type for \ocaml\ will then look like:
{\footnotesize
\begin{lstlisting}[language=MyOCaml]
module Cartesian_product =
  struct
  (* Carrier's structure explicitly given by "rep". *)
  type ('a0_as_carrier, 'b1_as_carrier) me_as_carrier =
    'a0_as_carrier * 'b1_as_carrier
  type ('a0_as_carrier, 'b1_as_carrier, 'me_as_carrier) me_as_species =
  ...
\end{lstlisting}
}

\label{mk-record-introduction1}
In \coq\ a record is introduced by a constructor. By convention, we
always name it {\tt mk\_record}. The record type for \coq\ will then
look like:
{\footnotesize
\begin{lstlisting}[language=MyCoq]
Module Cartesian_product.
  Record Cartesian_product (A_T : Set) (B_T : Set)
    (_p_A_tst : A_T -> basics.bool__t) : Type :=
    mk_record
  ...
\end{lstlisting}
}

\medskip
\paragraph{The entity parameters} In \ocaml\ they can never appear in
the record type since in ML-like types, we can't have expressions. 
However, in \coq\ it is possible to have dependency on an entity
parameter in a theorem or property statement (i.e. in the type of a
logical method). For example:
{\footnotesize
\begin{lstlisting}
species Me (Naturals is IntModel, n in Naturals) =
  representation = Naturals ;

 theorem myth : all x in Self,
    basics#syntactic_equal (n, Naturals!un)
  proof = assumed {* *} ;
  end ;;
\end{lstlisting}
}

The theorem {\tt myth} shows a dependency on the entity parameter
{\tt n}. In this case, the record type will be parametrised by this
entity parameter like if it was a collection parameter's
method. Obviously, an entity parameter doesn't have methods since it
is a ``value'' and not a species. So we don't have any notion of
method in the naming scheme. We choose to name these entity parameters
by ``{\tt \_p\_}'' + the entity parameter's name  + {\tt \_} + the
the entity parameter's name again.
{\footnotesize
\begin{lstlisting}[language=MyCoq]
Module Me.
  Record Me (Naturals_T : Set) (_p_n_n : Naturals_T)
    (_p_Naturals_un : Naturals_T) : Type :=
    mk_record 
  ...
\end{lstlisting}
}


The record type for \ocaml\ will then look like:
{\scriptsize
\begin{lstlisting}[language=MyOCaml]
module Cartesian_product =
  struct
  (* Carrier's structure explicitly given by "rep". *)
  type ('a0_as_carrier, 'b1_as_carrier) me_as_carrier =
    'a0_as_carrier * 'b1_as_carrier
  type ('a0_as_carrier, 'b1_as_carrier, 'me_as_carrier) me_as_species =
  ...
\end{lstlisting}
}


The record type for \coq\ will then look like:
{\scriptsize
\begin{lstlisting}[language=MyCoq]
Module Cartesian_product.
  Record Cartesian_product (A_T : Set) (B_T : Set)
    (_p_A_tst : A_T -> basics.bool__t) : Type :=
    mk_record
  ...
\end{lstlisting}
}

\medskip
\paragraph{The entity parameters} In \ocaml\ they can never appear in
the record type since in ML-like types, we can't have expressions. 
However, in \coq\ it is possible to have dependency on an entity
parameter in a theorem or property statement (i.e. in the type of a
logical method). For example:
{\scriptsize
\begin{lstlisting}
species Me (Naturals is IntModel, n in Naturals) =
  representation = Naturals ;

 theorem myth : all x in Self,
    basics#syntactic_equal (n, Naturals!un)
  proof = assumed {* *} ;
  end ;;
\end{lstlisting}
}
The theorem {\tt myth} show a dependency on the entity parameter
{\tt n}. In this case, the record type will be parameterised by this
entity parameter like if it was a collection parameter's
method. Obviously, an entity parameter doesn't have methods since it
is a ``value'' and not a species. So we don't have any notion of
method in the naming scheme. We choose to name these entity parameters
by ``{\tt \_p\_}'' + the entity parameter's name  + {\tt \_} + the
the entity parameter's name again.

\subsubsection{Fields and their types}
Now we saw the header of the record type definition, we must address
its body, i.e. its fields. Roughly speaking, the fields will be all
the methods with their types hosted in the species in normal form. By
``all'' we mean the methods declared, defined in the species and those
inherited. Because the species is in normal form, this means that we
do not have several times a method: inheritance has been resolved and
chose the right version of each method to keep.

The type accompanying each method is, like we previously said, a
ML-like type for ``computational'' methods and a logical statement for
logical methods. This especially means that since logical methods are
discarded in \ocaml, in this target language, we will only have
ML-like types.

The only important difference between \ocaml\ and \coq is that in
\coq\ we always have an extra (and first) field representing the
carrier of the species (remember that in \ocaml, instead, we had a
type definition that we didn't have in \coq). This field always
appears as {\tt  rf\_T :> Set ;} and represents the type encapsulated
in the species. In \ocaml, the field corresponding to a method is
straight the method's name. In \coq, the field's name is
``{\tt rf\_}'' + the method's name (``rf'' for {\bf r}ecord
{\bf f}ield).

Let's now take a simple example and seen the record types in
\ocaml\ and in \coq.
{\footnotesize
\begin{lstlisting}
species Me (Naturals is IntModel, n in Naturals) =
  representation = Naturals ;

 theorem daube : all x in Self,
    basics#syntactic_equal (n, Naturals!un)
  proof = assumed {* *} ;

  let junk (x in Self) in int = 1 ;

  let reduce (x in Naturals) in Self =
    Naturals!modulo (x, n) ;
end ;;
\end{lstlisting}
}


{\footnotesize
\begin{lstlisting}[language=MyOCaml]
module Me =
  struct
  (* Carrier's structure explicitly given by "rep". *)
  type ('naturals0_as_carrier, 'n1_as_carrier) me_as_carrier =
    'naturals0_as_carrier
  type ('naturals0_as_carrier, 'n1_as_carrier, 'me_as_carrier) me_as_species = {
    (* From species ok__in_example#Me. *)
    junk : 'me_as_carrier -> Basics._focty_int ;
    (* From species ok__in_example#Me. *)
    reduce : 'naturals0_as_carrier -> 'me_as_carrier ;
    }
\end{lstlisting}
}


{\footnotesize
\begin{lstlisting}[language=MyCoq]
Module Me.
  Record Me (Naturals_T : Set) (_p_n_n : Naturals_T)
    (_p_Naturals_un : Naturals_T) : Type :=
  mk_record {
    rf_T :> Set ;
    (* From species ok__in_example#Me. *)
    rf_daube :
      forall x : rf_T,
        Is_true ((basics.syntactic_equal _ _p_n_n _p_Naturals_un)) ;
    (* From species ok__in_example#Me. *)
    rf_junk : rf_T -> basics.int__t ;
    (* From species ok__in_example#Me. *)
    rf_reduce : Naturals_T -> rf_T
    }.
\end{lstlisting}
}

\label{coq-explicit-polymorphism}
Note that in the generated \coq\ code, the method {\tt daube} (in
fact, the theorem) contains an application of \\
{\tt basics.syntactic\_equal}. We can see the mechanism of explicit
polymorphism and the interest of having kept in the \coq\ code
generation environment the number of extra arguments ({\tt \_}s) that
must be added to identifiers in applicative position.



\subsection{Methods}
\label{code-gen-model-methods}
Once the record type is defined, it is time to generate the
definitions corresponding to the various methods of the
species. Several cases exist: a method can be declared, defined and in
each case either at the current inheritance level or inherited from an
ancestor.

\subsubsection{Inherited, declared, defined ?}
First of all, the point is that methods only declared or {\bf inherited}
are {\bf never} leading to generated code, neither in \ocaml, nor in
\coq. This means that only methods freshly defined in the species are
leading to code.

\subsubsection{Defined methods}
In term of generation model, there is no difference between \ocaml\
and \coq. The point is because in \ocaml\ we don't have logical
methods, all what we will explain about theorems and proof is
trivially out of the subject for \ocaml. Hence we won't make any
difference in our explanation here, simply considering both kinds of
methods independently of the target language.

There are 2 kinds of methods: ``computational'' and logical. The
generation model makes only a difference for theorems because they
have a proof, but the final definition of both kinds of method uses
the same mechanism: making explicit abstractions ($\lambda$-lifts) for
all the types and {\bf declared} methods (from {\tt Self} or from the
species parameters) the defined method depends on. Moreover, an entity
parameter (since it's in fact a value) will appear as an argument of a
method if it is used by it: it becomes hence an argument of the
method.

To help us, we need 3 notions. We don't examine here how they are
computed. This will be investigated later and is mostly described in
Virgile Prevosto's PhD.
\begin{itemize}
\item The carriers present in the methods from parameters (and in the
  type of entity parameters) and methods of {\tt Self} the method
  depends on. Since they are atomic types, there is no ordering issue
  in this set.
\item The ``minimal typing environment''. It represents the
  {\bf ordered} set of methods of {\tt Self} a method depends on. It
  must be ordered because some of the dependencies can depend on some
  others. Because of the well-formation property, we are sure this
  order exists.
\item The {\bf ordered} set of methods from parameters the method
  depends on.
\end{itemize}

A method will lead to a {\tt let} of {\tt theorem} definition
depending on its kind. The generated name is the same than in the
\focalize\ source.
label{ident-stringification}
Only a ``stringification'' is done when the method
is an operator (e.g. {\tt =}, {\tt +}, {\tt +=e}, \ldots). This
stringification is done on the fly using a very simple mechanism
(check function \\
{\tt pp\_vname\_with\_operators\_expanded} in the source
file \\
{\tt focalize/focalizec/src//basement/parsetree\_utils.ml}.

The generated definition is in fact a {\bf method generator}, not the
method itself. Its is a function that is parametrised by all the thing
the method depends on, and whose body is the method's body''. This
mechanism serves the late-binding feature and allow to really create a
method once things it depends on are defined by applying the generator
to the effective definitions of the methods the current method depends
on. Hence, until the method we depend on are not yet defined, one can
still work with our method generator. Moreover, this allows to make
several effective methods from a same generator, by applying
different effective definitions for $\lambda$-lifted  parameters of
the generator.

\medskip
Next come all the $\lambda$-lifts that represent the dependencies of
the method: In the following order come:
\begin{enumerate}
\item The parameters representing the carriers of species parameters
  appearing in the method (i.e. used in its whole definition). Their
  name is ``{\tt \_p\_}'' + the species parameter's name +
  ``{\tt \_T}. 
\item The parameters representing the methods of species' parameters
  the current method depends on. They are ordered in 2
  directions. First, all the methods of a same parameter are
  consecutive and we $\lambda$-lift following the order of apparition of
  the species parameters. Second, for each species parameter, the
  consecutive list of its methods is ordered according to their own
  dependencies together.

  The first point naturally ensure that following the species
  parameters' order, definitions of methods of a parameter can only
  depend on former parameters (otherwise, scoping and type-checking
  would have told ``Unbound ...''). The second point is not obtained
  for free. We must really order the methods of a species parameter
  according to their own dependencies ``on Self's methods'' in their
  hosting species. For instance, let's imagine that in a species, we
  need to abstract
  {\tt P1!eq\_refl : all x in Self, !equal (x, x)} and
  {\tt P1!equal : Self -> Self -> bool}, clearly to have
  {\tt P1!eq\_refl} well typed, {\tt P1!equal} must be known, hence
  appear sooner (i.e. must be $\lambda$-lifted before
  {\tt P1!eq\_refl}).

  Methods are named by ``{\tt \_p\_}'' + the species parameter's name
  + ``{\tt \_}'' + the method's name.

  The translation mechanisms of expressions is not studied in this
  section since it isn't really part of the ``species'' compilation
  model. We can however note that in the body of a species
  parameter's method, calls performed to other methods of {\bf this}
  parameter (i.e. so, obviously, on which the method of the parameter
  depends on) are done using the naming scheme: ``{\tt \_p\_}''+ the
  species parameter's name + ``{\tt \_}'' + called method's name (flag
  {\tt SMS\_from\_param} used when calling the function \\
  {\tt Species\_record\_type\_generation.generate\_logical\_expr}).

\item The parameters representing the methods of ourselves (i.e. of
  {\tt Self}) we {\bf decl}-depend on. They are named by
  ``{\tt abst\_}'' + the method's name. The only exception is in case
  where the method is the {\tt representation}, the name will be
  {\tt abst\_T}.

  Methods on which we {\bf def}-depend are not abstracted (i.e. not
  represented by $\lambda$-lifting). In effect, since we depend on
  their {\bf def}inition, they are defined (the compiler ensures that)
  and their effective definition must be used in the body of the
  method that depends on. Otherwise, their would be no link between
  the fact the method depends on a definition and a $\lambda$-lift
  that would represent any definition that will be provided one days,
  nobody know when and where !
\end{enumerate}

\medskip
Finally comes the translation of the method definition itself,
i.e. it's parameters (if the definition is functional) and its
body. As above, we leave for later the translation mechanisms of
expressions. We can however note that in the body of a method, calls
performed to other methods of {\tt Self} (i.e. so obviously on which
we depend) are done using the naming scheme: ``{\tt abst\_}''+ the
called method's name (flag {\tt SMS\_abstracted} used when calling the
function \\
{\tt Species\_record\_type\_generation.generate\_logical\_expr}).

\medskip
{\bf {\Large Attention, theorems}} require some intermediate cooking
before one can directly build their method generator. In effect, their
proof may involve a script for \zenon\ and in this case, a complex
process must be inserted in order to get the proof done to finally get
the method generator. This will be explained in section {\ref todo1}.


\subsubsection{Sample code to help to summarise}
\label{sample-code-virgile-part1}
We take a part of the example given in Virgile Prevosto's Phd, section
2.2.2 starting page 14 to illustrate the model we exposed until
now. Attention, we explicitly skipped (removed in the generated
listings) code dealing with collection generator we will explain in
the next section.

{\footnotesize
\begin{lstlisting}
species Setoide inherits Basic_object =
  signature ( = ) : Self -> Self -> bool ;
  signature element : Self ;
  let different (x, y) = basics#not_b (x = y) ;

  property refl : all x in Self, x = x ;
  property symm : all x y in Self, Self!( = ) (x, y) -> y = x ;
end ;;

species Monoide inherits Setoide =
  signature ( * ) : Self -> Self -> Self ;
  signature un : Self ;
  let element = Self! un * !un ;
end ;;

species Setoide_produit (A is Setoide, B is Setoide) inherits Setoide =
  representation = (A * B) ;

  let ( = ) (x, y) =
     and_b
       (A!( = ) (basics#fst (x), basics#fst (y)),
        B!( = ) (snd (x), snd (y))) ;
  let creer (x, y) in Self = basics#pair (x, y) ;
  let element = Self!creer (A!element, B!element) ;
  let print (x) =
     "(" ^ A!print (fst (x)) ^ "," ^ B!print (snd (x)) ^ ")" ;

  proof of refl = (* by definition of ( = ) *) assumed {* *} ;
  proof of symm = assumed {* *} ;

end ;;
\end{lstlisting}
}


{\footnotesize
\begin{lstlisting}[language=MyOCaml]
module Setoide =
  struct
  type 'me_as_carrier me_as_species = {
    (* From species ok__phd_sample#Setoide. *)
    element : 'me_as_carrier ;
    (* From species ok__phd_sample#Setoide. *)
    _equal_ : 'me_as_carrier -> 'me_as_carrier -> Basics._focty_bool ;
    (* From species basics#Basic_object. *)
    parse : Basics._focty_string -> 'me_as_carrier ;
    (* From species basics#Basic_object. *)
    print : 'me_as_carrier -> Basics._focty_string ;
    (* From species ok__phd_sample#Setoide. *)
    different : 'me_as_carrier -> 'me_as_carrier -> Basics._focty_bool ;
    }
  let different abst__equal_ (x : 'me_as_carrier) (y : 'me_as_carrier) =
    (Basics.not_b (abst__equal_ x y))
  end ;;

module Monoide =
  struct
  type 'me_as_carrier me_as_species = {
    (* From species ok__phd_sample#Monoide. *)
    un : 'me_as_carrier ;
    (* From species ok__phd_sample#Monoide. *)
    _star_ : 'me_as_carrier -> 'me_as_carrier -> 'me_as_carrier ;
    (* From species ok__phd_sample#Setoide. *)
    _equal_ : 'me_as_carrier -> 'me_as_carrier -> Basics._focty_bool ;
    (* From species basics#Basic_object. *)
    parse : Basics._focty_string -> 'me_as_carrier ;
    (* From species basics#Basic_object. *)
    print : 'me_as_carrier -> Basics._focty_string ;
    (* From species ok__phd_sample#Monoide. *)
    element : 'me_as_carrier ;
    (* From species ok__phd_sample#Setoide. *)
    different : 'me_as_carrier -> 'me_as_carrier -> Basics._focty_bool ;
    }
  let element abst_un abst__star_ = (abst__star_ abst_un abst_un)
  end ;;

module Setoide_produit =
  struct
  (* Carrier's structure explicitly given by "rep". *)
  type ('a0_as_carrier, 'b1_as_carrier) me_as_carrier =
    'a0_as_carrier * 'b1_as_carrier
  type ('a0_as_carrier, 'b1_as_carrier, 'me_as_carrier) me_as_species = {
    (* From species ok__phd_sample#Setoide_produit. *)
    creer : 'a0_as_carrier -> 'b1_as_carrier -> 'me_as_carrier ;
    (* From species basics#Basic_object. *)
    parse : Basics._focty_string -> 'me_as_carrier ;
    (* From species ok__phd_sample#Setoide_produit. *)
    print : 'me_as_carrier -> Basics._focty_string ;
    (* From species ok__phd_sample#Setoide_produit. *)
    _equal_ : 'me_as_carrier -> 'me_as_carrier -> Basics._focty_bool ;
    (* From species ok__phd_sample#Setoide_produit. *)
    element : 'me_as_carrier ;
    (* From species ok__phd_sample#Setoide. *)
    different : 'me_as_carrier -> 'me_as_carrier -> Basics._focty_bool ;
    }
  let creer (x : 'a0_as_carrier) (y : 'b1_as_carrier) = (Basics.pair x y)
  let print _p_A_print _p_B_print (x : 'me_as_carrier) =
    (Basics._hat_ "("
      (Basics._hat_ (_p_A_print (Basics.fst x))
        (Basics._hat_ "," (Basics._hat_ (_p_B_print (Basics.snd x)) ")"))))
  let _equal_ _p_A__equal_ _p_B__equal_ (x : 'me_as_carrier)
    (y : 'me_as_carrier) =
    (Basics.and_b (_p_A__equal_ (Basics.fst x) (Basics.fst y))
      (_p_B__equal_ (Basics.snd x) (Basics.snd y)))
  let element _p_A_element _p_B_element abst_creer =
    (abst_creer _p_A_element _p_B_element)

  <<<< ATTENTION:                                                   >>>>
  <<<< SKIPPED THE COLLECTION GENERATOR STUFF THAT WE EXPLAIN LATER >>>>
 end ;;
\end{lstlisting}
}


{\footnotesize
\begin{lstlisting}[language=MyCoq]
Module Setoide.
  Record Setoide : Type :=
    mk_record {
    rf_T :> Set ;
    (* From species ok__phd_sample#Setoide. *)
    rf_element : rf_T ;
    (* From species ok__phd_sample#Setoide. *)
    rf__equal_ : rf_T -> rf_T -> basics.bool__t ;
    (* From species basics#Basic_object. *)
    rf_parse : basics.string__t -> rf_T ;
    (* From species basics#Basic_object. *)
    rf_print : rf_T -> basics.string__t ;
    (* From species ok__phd_sample#Setoide. *)
    rf_different : rf_T -> rf_T -> basics.bool__t ;
    (* From species ok__phd_sample#Setoide. *)
    rf_refl : forall x : rf_T, Is_true ((rf__equal_ x x)) ;
    (* From species ok__phd_sample#Setoide. *)
    rf_symm :
      forall x  y : rf_T,
        Is_true ((rf__equal_ x y)) -> Is_true ((rf__equal_ y x))
    }.
  
  Definition different (abst_T : Set)
    (abst__equal_ : abst_T -> abst_T -> basics.bool__t) (x : abst_T)
    (y : abst_T) : basics.bool__t := (basics.not_b (abst__equal_ x y)).
  
End Setoide.

Module Monoide.
  Record Monoide : Type :=
    mk_record {
    rf_T :> Set ;
    (* From species ok__phd_sample#Monoide. *)
    rf_un : rf_T ;
    (* From species ok__phd_sample#Monoide. *)
    rf__star_ : rf_T -> rf_T -> rf_T ;
    (* From species ok__phd_sample#Setoide. *)
    rf__equal_ : rf_T -> rf_T -> basics.bool__t ;
    (* From species basics#Basic_object. *)
    rf_parse : basics.string__t -> rf_T ;
    (* From species basics#Basic_object. *)
    rf_print : rf_T -> basics.string__t ;
    (* From species ok__phd_sample#Monoide. *)
    rf_element : rf_T ;
    (* From species ok__phd_sample#Setoide. *)
    rf_different : rf_T -> rf_T -> basics.bool__t ;
    (* From species ok__phd_sample#Setoide. *)
    rf_refl : forall x : rf_T, Is_true ((rf__equal_ x x)) ;
    (* From species ok__phd_sample#Setoide. *)
    rf_symm :
      forall x  y : rf_T,
        Is_true ((rf__equal_ x y)) -> Is_true ((rf__equal_ y x))
    }.
  
  Definition element (abst_T : Set) (abst_un : abst_T)
    (abst__star_ : abst_T -> abst_T -> abst_T) : abst_T :=
    (abst__star_ abst_un abst_un).
  
End Monoide.

Module Setoide_produit.
  Record Setoide_produit (A_T : Set) (B_T : Set) : Type :=
    mk_record {
    rf_T :> Set ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_creer : A_T -> B_T -> rf_T ;
    (* From species basics#Basic_object. *)
    rf_parse : basics.string__t -> rf_T ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_print : rf_T -> basics.string__t ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf__equal_ : rf_T -> rf_T -> basics.bool__t ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_element : rf_T ;
    (* From species ok__phd_sample#Setoide. *)
    rf_different : rf_T -> rf_T -> basics.bool__t ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_refl : forall x : rf_T, Is_true ((rf__equal_ x x)) ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_symm :
      forall x  y : rf_T,
        Is_true ((rf__equal_ x y)) -> Is_true ((rf__equal_ y x))
    }.
  
  Definition creer (_p_A_T : Set) (_p_B_T : Set)
    (abst_T := ((_p_A_T * _p_B_T)%type)) (x : _p_A_T) (y : _p_B_T) :
    abst_T := (basics.pair _ _ x y).
  Definition print (_p_A_T : Set) (_p_B_T : Set) (_p_A_print :
    _p_A_T -> basics.string__t) (_p_B_print : _p_B_T -> basics.string__t)
    (abst_T := ((_p_A_T * _p_B_T)%type)) (x : abst_T) : basics.string__t :=
    (basics._hat_ coq_builtins.___a_string
      (basics._hat_ (_p_A_print (basics.fst _ _ x))
        (basics._hat_ coq_builtins.___a_string
          (basics._hat_ (_p_B_print (basics.snd _ _ x))
            coq_builtins.___a_string)))).
  Definition _equal_ (_p_A_T : Set) (_p_B_T : Set) (_p_A__equal_ :
    _p_A_T -> _p_A_T -> basics.bool__t) (_p_B__equal_ :
    _p_B_T -> _p_B_T -> basics.bool__t) (abst_T := ((_p_A_T * _p_B_T)%type))
    (x : abst_T) (y : abst_T) : basics.bool__t :=
    (basics.and_b (_p_A__equal_ (basics.fst _ _ x) (basics.fst _ _ y))
      (_p_B__equal_ (basics.snd _ _ x) (basics.snd _ _ y))).
  Definition element (_p_A_T : Set) (_p_B_T : Set) (_p_A_element : _p_A_T)
    (_p_B_element : _p_B_T) (abst_T : Set)
    (abst_creer : _p_A_T -> _p_B_T -> abst_T) : abst_T :=
    (abst_creer _p_A_element _p_B_element).
  
  (* From species ok__phd_sample#Setoide_produit. *)
  Theorem refl  (_p_A_T : Set) (_p_B_T : Set) (abst_T : Set)
    (abst__equal_ : abst_T -> abst_T -> basics.bool__t):
    forall x : abst_T, Is_true ((abst__equal_ x x)).
  (* Proof assumed because " ". *)
  apply coq_builtins.magic_prove.
  Qed.
  
  (* From species ok__phd_sample#Setoide_produit. *)
  Theorem symm  (_p_A_T : Set) (_p_B_T : Set) (abst_T : Set)
    (abst__equal_ : abst_T -> abst_T -> basics.bool__t):
    forall x  y : abst_T,
      Is_true ((abst__equal_ x y)) -> Is_true ((abst__equal_ y x)).
  (* Proof assumed because " ". *)
  apply coq_builtins.magic_prove.
  Qed.
  
    <<<< ATTENTION:                                                   >>>>
  <<<< SKIPPED THE COLLECTION GENERATOR STUFF THAT WE EXPLAIN LATER >>>>
End Setoide_produit.
\end{lstlisting}
}



\subsubsection{Defined recursive methods}
The compilation scheme of a recursive function is pretty different and
will be explained in the dedicated section \ref{todo0}. It however
finally uses the same abstraction mechanism (i.e. $\lambda$-lifted
things). The main difference is induced by the use of the \coq\
construct ``{\tt Function}'' and the need for a termination proof.



\subsection{Fully defined species}
In case a species is fully defined, i.e. all its methods are defined,
no more remaining only declared, the species can be turned into a
collection by an {\tt implements}. To allow creating collections, we
must then add to this species a {\bf collection generator}. The
intuitive view of such a generator is that it is a function that takes
the parameters required by the method generators and feed them with
their related parameters to produce a bunch of effective {\bf methods}.
Hence, the collection generator takes as many parameters as the method
generators of the species need to abstract the dependencies of the
methods (i.e. in fact, the $\lambda$-lifts of each method generator)
and apply each method generator to the set of parameters it needs.
Hence applying the collection to effective arguments will create a
bunch of effective methods of the species by applying the method
generators. Technically, this bunch of methods is stored in a value of
\ldots the record type representing the species. Hence, a collection
is just a value of this record type, storing functions (methods)
provided to process value whose type is the carrier of the species.

You may note that this carrier type is not recorded in the record
structure. However, methods of the record will obviously have traces
of this type in their own type schemes. Turning the carrier abstract
(i.e. not exporting its internal structure), it becomes impossible to
manipulate it except via the provided methods, i.e. functions stored
in the record value representing one collection.


\subsubsection{Collection generator function's header}
As presented above, the collection generator is a function. Its name
is always {\tt collection\_create}. As we said, this functions take
arguments that represent all the things abstracted in the method
generators of the species.

{\bf Attention}: Because to have a collection generator, the species
must be fully defined, it is clear that the only things that can
remain abstracted are species parameters' carriers, species
parameters' methods and entity parameters ! Never some methods of
``{\tt Self}'' since all the methods of ``{\tt Self}'' are \ldots
defined !


\subsubsection{Local functions}
For each method of the species, we will create a ``real method'',
i.e. create a local function of the collection generator, applying the
method generator to its required arguments taken among the effective
arguments of the collection generator. Hence, for each method of the
species, we build (locally to the collection generator) a function.
These local functions will be named: ``{\tt local\_}'' + method's
name. We have 2 possible cases to find the method generator to use to
create the collection generator:
\begin{itemize}
  \item Either the method generator belongs to the current inheritance
    level (i.e. the method was defined at this level in the species).
    In this case, this generator is simply the name of the method
    because a local function in the module was generated with this
    name. In the following sample code, that's the case for the
    methods {\tt creer}, {\tt print}, {\tt element}, \ldots
  \item Or the method generator belongs a previous inheritance level
    (i.e. the method was defined previously, in an ancestor). In this
    case, the name of the method generator is qualified by the module
    hosting the ancestor. This means that is the ancestor belongs to
    another compilation unit, we need to also specify the module on
    which the compilation unit is mapped. This gives a name like:
    file as module + ``{\tt .} + hosting species name + ``{\tt .} +
    name of the method corresponding to this generator.
    In the following sample code, that's the case for the method
    {\tt parse} defined in the species {\tt Basic\_object} of the
    compilation unit ``{\tt basics.fcl}''.
\end{itemize}


\subsubsection{Creating the record value}
Now we have our bunch of functions representing the methods of the
species, we just need to create a value of the record type by feeding
each record fields with its related function we locally created.

And then, the return value of the collection generator is the record
value. Hence, this shows clearly that a collection is in fact a value
whose type is the record type we created to model the species.


\subsubsection{Sample code to help to summarise}
Like we did to explain the code generation model of species in
\ref{code-gen-model-methods}, we use the same sample we used in
\ref{sample-code-virgile-part1} and complete the parts about
collection generators we previously snipped in the species
{\tt Setoide\_produit} (the other species, not being fully defined,
don't have a collection generator).
{\footnotesize[language=MyOCaml]
\begin{lstlisting}
<<<< ATTENTION:                                             >>>>
<<<< STUFF BEFORE, PREVIOUSLY SEEN IN PREVIOUS EXPLANATIONS >>>>

module Setoide_produit =
  struct
  <<<< ATTENTION:                                             >>>>
  <<<< STUFF BEFORE, PREVIOUSLY SEEN IN PREVIOUS EXPLANATIONS >>>>

  (* Fully defined 'Setoide_produit' species's collection generator. *)
  let collection_create () _p_B_element _p_B__equal_ _p_B_print _p_A_element
    _p_A__equal_ _p_A_print =
    (* From species ok__phd_sample#Setoide_produit. *)
    let local_creer = creer in
    (* From species basics#Basic_object. *)
    let local_parse = Basics.Basic_object.parse in
    (* From species ok__phd_sample#Setoide_produit. *)
    let local_print = print _p_A_print _p_B_print in
    (* From species ok__phd_sample#Setoide_produit. *)
    let local__equal_ = _equal_ _p_A__equal_ _p_B__equal_ in
    (* From species ok__phd_sample#Setoide_produit. *)
    let local_element = element _p_A_element _p_B_element local_creer in
    (* From species ok__phd_sample#Setoide. *)
    let local_different = Setoide.different local__equal_ in
    { creer = local_creer ;
      parse = local_parse ;
      print = local_print ;
      _equal_ = local__equal_ ;
      element = local_element ;
      different = local_different ;
       }
    
  end ;;
\end{lstlisting}
}

\label{point-the-extra-unit-parameter-need}
In the above \ocaml\ you may notice that the collection generator
takes a ``spurious'' {\tt ()} (``{\tt unit}'') parameter. This is not
a mistake and is only used to prevent a collection generator that does
not need any parameter (because there is no collection and entity
parameter for this species) from having no argument.

In effect, in this case, for sake of non-expansivity, ML type system
doesn't allow to generalise type variables appearing in values that
are not functional (roughly, very roughly speaking, since there are
other cases \ldots Let's say that functional value can have their
type generalised).

This is a problem since type variables appearing the the module
representing a species won't be generalisable, then, as soon we create
a collection, we instance these type variables by the carrier
representation and by parameters' carriers. And if we want to create
another collection, since the variables are now instantiated (they are
not polymorphic) we can't instantiate them by other types. And we get
a type error on \ocaml\ side. For a full example, see the sample code
in section \ref{sample-code-coll-gen-no-param}.

Obviously, we could add this extra parameter only if the collection
generator has no parameter, but for sake of simplicity and
homogeneity, we prefer to add it in all the cases.


{\footnotesize[language=MyCoq]
\begin{lstlisting}
<<<< ATTENTION:                                             >>>>
<<<< STUFF BEFORE, PREVIOUSLY SEEN IN PREVIOUS EXPLANATIONS >>>>

Module Setoide_produit.
  <<<< ATTENTION:                                             >>>>
  <<<< STUFF BEFORE, PREVIOUSLY SEEN IN PREVIOUS EXPLANATIONS >>>>

  (* Fully defined 'Setoide_produit' species's collection generator. *)
  Definition collection_create (_p_A_T : Set) (_p_B_T : Set) _p_A_element
    _p_A__equal_ _p_A_print _p_B_element _p_B__equal_ _p_B_print :=
    let local_rep := ((_p_A_T * _p_B_T)%type) in
    (* From species ok__phd_sample#Setoide_produit. *)
    let local_creer := creer _p_A_T _p_B_T in
    (* From species basics#Basic_object. *)
    let local_parse := basics.Basic_object.parse local_rep in
    (* From species ok__phd_sample#Setoide_produit. *)
    let local_print := print _p_A_T _p_B_T _p_A_print _p_B_print in
    (* From species ok__phd_sample#Setoide_produit. *)
    let local__equal_ := _equal_ _p_A_T _p_B_T _p_A__equal_ _p_B__equal_ in
    (* From species ok__phd_sample#Setoide_produit. *)
    let local_element := element _p_A_T _p_B_T _p_A_element _p_B_element
      local_rep local_creer in
    (* From species ok__phd_sample#Setoide. *)
    let local_different := Setoide.different local_rep local__equal_ in
    (* From species ok__phd_sample#Setoide_produit. *)
    let local_refl := refl _p_A_T _p_B_T local_rep local__equal_ in
    (* From species ok__phd_sample#Setoide_produit. *)
    let local_symm := symm _p_A_T _p_B_T local_rep local__equal_ in
    mk_record (_p_A_T : Set) (_p_B_T : Set) local_rep local_creer local_parse
    local_print local__equal_ local_element local_different local_refl
    local_symm.
  
End Setoide_produit.
\end{lstlisting}
}

\subsubsection{Sample code for extra () parameter for \ocaml}
\label{sample-code-coll-gen-no-param}
As described in \ref{point-the-extra-unit-parameter-need}, here is a
full example showing the need to have an extra {\tt ()} in \ocaml\ for
collection generators.

{\footnotesize
\begin{lstlisting}
use "basics" ;;
open "basics" ;;


let print_bool =
   internal bool -> string
   external | caml -> {* string_of_bool *} | coq -> {* (* [Unsure] *) *}
;;
let ext_nil =
   internal list ('a)
   external | caml -> {* [] *} | coq -> {* (* [Unsure] *) *}
;;
let ext_cons =
   internal 'a -> list ('a) -> basics#list ('a)
   external | caml -> {* (fun e l -> e :: l) *} | coq -> {* (* [Unsure] *) *}
;;
let ext_head =
  internal list ('a) -> 'a
  external | caml -> {* List.hd *} | coq -> {* (* [Unsure] *) *}
;;
let ext_tail =
  internal list ('a) -> list ('a)
  external | caml -> {* List.tl *} | coq -> {* (* [Unsure] *) *}
;;


species Concrete_list (E is Basic_object) =
  representation = basics#list (E) ;
  let equal (x in Self, y in Self) in bool = syntactic_equal (x, y) ;
  let nil in Self = ext_nil ;
  let cons (e, l) in Self = ext_cons (e, l) ;
  let head (l in Self) in E = ext_head (l) ;
  let tail (l in Self) in Self = ext_tail (l) ;
   let rec map (f, l) =
     if equal (l, nil) then nil
     else
       let h = head (l) in
       let q = tail (l) in
       let h2 = f (h) in
       let q2 = map (f, q) in
       cons (h2, q2) ;
end ;;

\end{lstlisting}
}
Once compiled to \ocaml\, we get the following code:
{\footnotesize
\begin{lstlisting}[language=MyOCaml,
                   emph={WE, REMOVED, THE, EXTRA, ()}, emphstyle=\color{red}]
let print_bool =  string_of_bool ;;
let ext_nil = [] ;;
let ext_cons = (fun e l -> e :: l) ;;
let ext_head = List.hd ;;
let ext_tail = List.tl ;;

module Concrete_list =
  struct
  (* Carrier's structure explicitly given by "rep". *)
  type 'e0_as_carrier me_as_carrier = 'e0_as_carrier Basics._focty_list
  type ('e0_as_carrier, 'me_as_carrier) me_as_species = {
    (* From species test#Concrete_list. *)
    cons : 'e0_as_carrier ->
             'e0_as_carrier Basics._focty_list -> 'me_as_carrier ;
    (* From species test#Concrete_list. *)
    equal : 'me_as_carrier -> 'me_as_carrier -> Basics._focty_bool ;
    (* From species test#Concrete_list. *)
    head : 'me_as_carrier -> 'e0_as_carrier ;
    (* From species test#Concrete_list. *)
    nil : 'me_as_carrier ;
    (* From species test#Concrete_list. *)
    tail : 'me_as_carrier -> 'me_as_carrier ;
    (* From species test#Concrete_list. *)
    map : ('e0_as_carrier -> 'e0_as_carrier) ->
            'me_as_carrier -> 'me_as_carrier ;
    }
  let cons (e : 'e0_as_carrier) (l : 'e0_as_carrier Basics._focty_list) =
    (ext_cons e l)
  let equal (x : 'me_as_carrier) (y : 'me_as_carrier) =
    (Basics.syntactic_equal x y)
  let head (l : 'me_as_carrier) = (ext_head l)
  let nil = ext_nil
  let tail (l : 'me_as_carrier) = (ext_tail l)
  let rec map abst_cons abst_equal abst_head abst_nil abst_tail
    (f : 'e0_as_carrier -> 'e0_as_carrier) (l : 'me_as_carrier) =
    if (abst_equal l abst_nil) then abst_nil else let h = (abst_head l)
      in
      let q = (abst_tail l) in
      let h2 = (f h)
      in
      let q2 = (map abst_cons abst_equal abst_head abst_nil abst_tail f q)
      in
      (abst_cons h2 q2)
  (* Fully defined 'Concrete_list' species's collection generator. *)
  let collection_create !!! WE REMOVED THE EXTRA () !!! =
    (* From species test#Concrete_list. *)
    let local_cons = cons in
    (* From species test#Concrete_list. *)
    let local_equal = equal in
    (* From species test#Concrete_list. *)
    let local_head = head in
    (* From species test#Concrete_list. *)
    let local_nil = nil in
    (* From species test#Concrete_list. *)
    let local_tail = tail in
    (* From species test#Concrete_list. *)
    let local_map = map local_cons local_equal local_head local_nil
      local_tail in
    { cons = local_cons ;
      equal = local_equal ;
      head = local_head ;
      nil = local_nil ;
      tail = local_tail ;
      map = local_map ;
       }
    
  end ;;
\end{lstlisting}
}
If we check the interface of the \ocaml\ compilatio unit, we can see
that the module {\tt Concrete\_list} has type:
{\footnotesize
\begin{lstlisting}[language=MyOCaml]
module Concrete_list :
  sig
    type 'a me_as_carrier = 'a Basics._focty_list
    type ('a, 'b) me_as_species = {
      cons : 'a -> 'a Basics._focty_list -> 'b;
      equal : 'b -> 'b -> Basics._focty_bool;
      head : 'b -> 'a;
      nil : 'b;
      tail : 'b -> 'b;
      map : ('a -> 'a) -> 'b -> 'b;
    }
    val cons : 'a -> 'a Basics._focty_list -> 'a list
    val equal : 'a -> 'a -> bool
    val head : 'a list -> 'a
    val nil : 'a list
    val tail : 'a list -> 'a list
    val map :
      ('a -> 'b -> 'b) ->
      ('c -> 'b -> bool) ->
      ('c -> 'a) -> 'b -> ('c -> 'c) -> ('a -> 'a) -> 'c -> 'b
    val collection_create : ('_a, '_a Basics._focty_list) me_as_species
  end
\end{lstlisting}
}
where the function {\tt collection\_create} has a non generalised type
variable {\tt '\_a}. Hence, to continue the example, we just need to
create two collections, one with {\tt int} as carrier, the other with
{\tt bool} and to create 2 collections of lists using these 2 collections
as argument.
{\footnotesize
\begin{lstlisting}
species Contrete_int inherits Basic_object =
  representation = basics#int ;
  let print = string_of_int ;
end ;;
collection Int implements Contrete_int ;;

species Contrete_bool inherits Basic_object =
  representation = basics#bool ;
  let print = print_bool ;
end ;;
collection Bool implements Contrete_bool ;;
\end{lstlisting}
}
When creating the last collection implementing list of booleans, the
{\tt '\_a} type variable was already instantiated by {\tt int}, hence
leading to \ocaml\ complaining:
\begin{verbatim}
File ".....", line 210, characters 13-33:
This expression has type
  int -> int Basics._focty_list -> int Basics._focty_list
but is here used with type
  bool -> Bool.me_as_carrier Basics._focty_list -> me_as_carrier
\end{verbatim}

Hence, adding a dummy parameter to the collection generator, it can
now be generalised (i.e. become polymorphic) and there is no more
instanciation issue.

\section{Collection}
Collections are compiled differently as species but they start by
exactly the same kind of record type definition. This record type will
represent the type of data in the target language collections are
mapped onto.

Things differ after. In effect, we do not need anymore to create the
methods since all were already defined in the fully defined species we
``{\tt implements}. The aim to get a collection, it to get a value of
the record type, where fields are filled with the functions
representing methods of the species we ``{\tt implements}''. In this
species we created a ``collection generator'' that was a function
taking arguments representing dependencies on the species parameters
(collection and entity) and returning a value of the record type \ldots
a collection. So, to compile a collection, we will apply the
collection generator to things it need to give us material to finally
create the collection value that will always be named
{\tt effective\_collection}.

Once done, we will get from the record generated by the collection
generator of the species we ``{\tt implements}'', each field's value
and put it in a record whose type is {\bf our} (i.e. the collection)
type. It is then simply a verbatim copy since collection never add
fields; so the species the collection implements and the collection
have the same methods, so the records have the same fields. With this
process, we ensure that the collection will be only type-compatible
with itself and won't be type-compatible with the species it
``{\tt implements}'' and also not with other collections extracted
from this species (with the same arguments).

Now, the question is to know what to apply to the collection generator
of the species we ``{\tt implements}''. In fact, we need to apply this
generator to the methods of the collections used to instantiate the
collection parameters of the species we ``{\tt implements}''.
For instance, going on with our example started in
\ref{sample-code-virgile-part1}, we add a few \focalize\ code to
create a {\tt Monoide\_produit} some fully defined species to
represent integers to finally build a collection representing couples
of integers:
{\footnotesize
\begin{lstlisting}[title=More \focalize\ code to create collections]
species Monoide_produit (C is Monoide, D is Monoide)
  inherits Monoide, Setoide_produit (C, D) =
...
end ;;

species Entiers_concrets inherits Monoide =
  representation = basics#int ;
...
end ;;

collection Les_entiers implements Entiers_concrets ;;

collection Couple_d_entiers implements
  Monoide_produit (Les_entiers, Les_entiers)
;;
\end{lstlisting}
}
We get interested directly by the way to get the collection
{\tt Couple\_d\_entiers} since it is more interesting because the
implemented species has collection parameters. For the collection
{\tt Les\_entiers}, the process is the same, except there is no
problem of instanciation because there is no parameter.
Here we see that the collection parameters {\tt C} and {\tt D} of
{\tt Monoide\_produit} were instantiated by the collections
{\tt Les\_entiers} and {\tt Les\_entiers}. The collection generator of
{\tt Couple\_d\_entiers} is parametrised (due to dependencies on
species parameters) by several methods of the species parameters
(amongst others, trust me \smiley, {\tt un}, {\tt print},
{\tt element}, \ldots).
We then must apply the collection generator to the corresponding
methods of ``by what C'' was instantiated and ``by what D'' was
instantiated, i.e from {\tt Les\_entiers} and from
{\tt Les\_entiers}.

Now, where can we get these methods of {\tt Les\_entiers} ? Since it is
a collection, the module hosting the collection contains a
{\tt effective\_collection} value that has a type being a record. Then
we just need to pick in the fields of this value to have the arguments
we want to give to the collection generator.

\medskip
{\bf Note}: It appears that in this case, since the 2
parameters are ``{\tt is} the same collection'', the dependencies will
be the same twice. But that's just for this particular case. By the
way, this also means that we do not ``optimise'' telling ``Oh, I see
the dependencies are exactly on the same functions of the same species,
so let's keep only one occurrence of the parameter\ldots''. No we keep
the model without exception.

We then get the generated \ocaml\ code for the 2 create collections:
{\footnotesize
\begin{lstlisting}[language=MyOCaml, title=\ocaml\ code for collections]
module Les_entiers =
  struct
  (* Carrier's structure explicitly given by "rep". *)
  type me_as_carrier = Basics._focty_int
  type 'me_as_carrier me_as_species = {
    (* From species ok__phd_sample#Entiers_concrets. *)
    parse : Basics._focty_string -> me_as_carrier ;
    (* From species ok__phd_sample#Entiers_concrets. *)
    print : me_as_carrier -> Basics._focty_string ;
    (* From species ok__phd_sample#Entiers_concrets. *)
    un : me_as_carrier ;
    (* From species ok__phd_sample#Entiers_concrets. *)
    _star_ : me_as_carrier -> me_as_carrier -> me_as_carrier ;
    (* From species ok__phd_sample#Entiers_concrets. *)
    _equal_ : me_as_carrier -> me_as_carrier -> Basics._focty_bool ;
    (* From species ok__phd_sample#Monoide. *)
    element : me_as_carrier ;
    (* From species ok__phd_sample#Setoide. *)
    different : me_as_carrier -> me_as_carrier -> Basics._focty_bool ;
    }
  let effective_collection =
    let t =
      Entiers_concrets.collection_create () in
    { parse = t.Entiers_concrets.parse ;
      print = t.Entiers_concrets.print ;
      un = t.Entiers_concrets.un ;
      _star_ = t.Entiers_concrets._star_ ;
      _equal_ = t.Entiers_concrets._equal_ ;
      element = t.Entiers_concrets.element ;
      different = t.Entiers_concrets.different ;
       }
  end ;;

module Couple_d_entiers =
  struct
  (* Carrier's structure explicitly given by "rep". *)
  type me_as_carrier = Les_entiers.me_as_carrier * Les_entiers.me_as_carrier
  type 'me_as_carrier me_as_species = {
    (* From species ok__phd_sample#Setoide_produit. *)
    creer : Les_entiers.me_as_carrier ->
              Les_entiers.me_as_carrier -> me_as_carrier ;
    (* From species basics#Basic_object. *)
    parse : Basics._focty_string -> me_as_carrier ;
    (* From species ok__phd_sample#Setoide_produit. *)
    print : me_as_carrier -> Basics._focty_string ;
    (* From species ok__phd_sample#Monoide_produit. *)
    _star_ : me_as_carrier -> me_as_carrier -> me_as_carrier ;
    (* From species ok__phd_sample#Setoide_produit. *)
    _equal_ : me_as_carrier -> me_as_carrier -> Basics._focty_bool ;
    (* From species ok__phd_sample#Setoide_produit. *)
    element : me_as_carrier ;
    (* From species ok__phd_sample#Monoide_produit. *)
    un : me_as_carrier ;
    (* From species ok__phd_sample#Setoide. *)
    different : me_as_carrier -> me_as_carrier -> Basics._focty_bool ;
    }
  let effective_collection =
    let t =
      Monoide_produit.collection_create ()
      Les_entiers.effective_collection.Les_entiers.un
      Les_entiers.effective_collection.Les_entiers._star_
      Les_entiers.effective_collection.Les_entiers._equal_
      Les_entiers.effective_collection.Les_entiers.print
      Les_entiers.effective_collection.Les_entiers.element
      Les_entiers.effective_collection.Les_entiers.un
      Les_entiers.effective_collection.Les_entiers._star_
      Les_entiers.effective_collection.Les_entiers._equal_
      Les_entiers.effective_collection.Les_entiers.print
      Les_entiers.effective_collection.Les_entiers.element in
    { creer = t.Monoide_produit.creer ;
      parse = t.Monoide_produit.parse ;
      print = t.Monoide_produit.print ;
      _star_ = t.Monoide_produit._star_ ;
      _equal_ = t.Monoide_produit._equal_ ;
      element = t.Monoide_produit.element ;
      un = t.Monoide_produit.un ;
      different = t.Monoide_produit.different ;
       }
  end ;;
\end{lstlisting}
}

The \coq\ code follows exactly the same scheme. It appears to be more
tricky and bigger for 2 reasons: first logical methods are in the
model, second the record access notation is much more complex in
\coq\ that it is in \ocaml\ (where one just need to say
{\tt val.field}).

In effect in \coq\, to access a field of a value of type record, one
must provide, of course the value and the field name, but also all the
effective arguments that were provided when the type record was
created from the {\tt mk\_record}
\label{mk-record-introduction2}
that represents the species.
For instance, our collection {\tt Couple\_d\_entiers}
{\tt ``implements''} a {\tt Monoide\_produit}. Looking at the record
type of {\tt Monoide\_produit}, we see:
{\footnotesize
\begin{lstlisting}[language=MyCoq]
  Record Monoide_produit (C_T : Set) (D_T : Set) : Type :=
    mk_record {
    rf_T :> Set ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_creer : C_T -> D_T -> rf_T ;
    ...
\end{lstlisting}
}
that is we have 2 parameters that are the carriers of the collection
parameters. When we want to pick values from the fields of the value
returned by the collection generator (hence from the one of
{\tt Monoide\_produit}), we will need to make explicit by what these
parameters were instantiated when we used the generator. And here, we
instantiated twice with the carrier of {\tt Les\_entiers}.
Then, accessing the field {\tt rf\_creer} (corresponding to the method
{\tt creer} of the species {\tt Monoide\_produit}) of the value
{\tt v} returned by the collection generator:
{\footnotesize
\begin{lstlisting}[language=MyCoq]
let t :=
  Monoide_produit.collection_create
  Les_entiers.effective_collection.(Les_entiers.rf_T)
  Les_entiers.effective_collection.(Les_entiers.rf_T)
  .... in
\end{lstlisting}
}
will look like:
{\footnotesize
\begin{lstlisting}[language=MyCoq]
 t.(Monoide_produit.rf_creer
      Les_entiers.effective_collection.(Les_entiers.rf_T)
      Les_entiers.effective_collection.(Les_entiers.rf_T))
\end{lstlisting}
}

So the full generated \coq\ code will be:
{\footnotesize
\begin{lstlisting}[language=MyCoq,title=\coq\ code for collections]
Module Les_entiers.
  Record Les_entiers : Type :=
    mk_record {
    rf_T :> Set ;
    (* From species ok__phd_sample#Entiers_concrets. *)
    rf_parse : basics.string__t -> rf_T ;
    (* From species ok__phd_sample#Entiers_concrets. *)
    rf_print : rf_T -> basics.string__t ;
    (* From species ok__phd_sample#Entiers_concrets. *)
    rf_un : rf_T ;
    (* From species ok__phd_sample#Entiers_concrets. *)
    rf__star_ : rf_T -> rf_T -> rf_T ;
    (* From species ok__phd_sample#Entiers_concrets. *)
    rf__equal_ : rf_T -> rf_T -> basics.bool__t ;
    (* From species ok__phd_sample#Monoide. *)
    rf_element : rf_T ;
    (* From species ok__phd_sample#Setoide. *)
    rf_different : rf_T -> rf_T -> basics.bool__t ;
    (* From species ok__phd_sample#Entiers_concrets. *)
    rf_refl : forall x : rf_T, Is_true ((rf__equal_ x x)) ;
    (* From species ok__phd_sample#Entiers_concrets. *)
    rf_symm :
      forall x  y : rf_T,
        Is_true ((rf__equal_ x y)) -> Is_true ((rf__equal_ y x))
    }.
  
  Let effective_collection :=
    let t :=
      Entiers_concrets.collection_create in 
    mk_record t.(Entiers_concrets.rf_T) t.(Entiers_concrets.rf_parse)
      t.(Entiers_concrets.rf_print) t.(Entiers_concrets.rf_un)
      t.(Entiers_concrets.rf__star_) t.(Entiers_concrets.rf__equal_)
      t.(Entiers_concrets.rf_element) t.(Entiers_concrets.rf_different)
      t.(Entiers_concrets.rf_refl) t.(Entiers_concrets.rf_symm).
    
End Les_entiers.

Module Couple_d_entiers.
  Record Couple_d_entiers : Type :=
    mk_record {
    rf_T :> Set ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_creer : Les_entiers.effective_collection.(Les_entiers.rf_T) ->
                 Les_entiers.effective_collection.(Les_entiers.rf_T) -> rf_T ;
    (* From species basics#Basic_object. *)
    rf_parse : basics.string__t -> rf_T ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_print : rf_T -> basics.string__t ;
    (* From species ok__phd_sample#Monoide_produit. *)
    rf__star_ : rf_T -> rf_T -> rf_T ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf__equal_ : rf_T -> rf_T -> basics.bool__t ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_element : rf_T ;
    (* From species ok__phd_sample#Monoide_produit. *)
    rf_un : rf_T ;
    (* From species ok__phd_sample#Setoide. *)
    rf_different : rf_T -> rf_T -> basics.bool__t ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_refl : forall x : rf_T, Is_true ((rf__equal_ x x)) ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_symm :
      forall x  y : rf_T,
        Is_true ((rf__equal_ x y)) -> Is_true ((rf__equal_ y x))
    }.
  
  Let effective_collection :=
    let t :=
      Monoide_produit.collection_create
      Les_entiers.effective_collection.(Les_entiers.rf_T)
      Les_entiers.effective_collection.(Les_entiers.rf_T)
      Les_entiers.effective_collection.(Les_entiers.rf_un)
      Les_entiers.effective_collection.(Les_entiers.rf__star_)
      Les_entiers.effective_collection.(Les_entiers.rf__equal_)
      Les_entiers.effective_collection.(Les_entiers.rf_print)
      Les_entiers.effective_collection.(Les_entiers.rf_element)
      Les_entiers.effective_collection.(Les_entiers.rf_un)
      Les_entiers.effective_collection.(Les_entiers.rf__star_)
      Les_entiers.effective_collection.(Les_entiers.rf__equal_)
      Les_entiers.effective_collection.(Les_entiers.rf_print)
      Les_entiers.effective_collection.(Les_entiers.rf_element) in 
    mk_record
      t.(Monoide_produit.rf_T
         Les_entiers.effective_collection.(Les_entiers.rf_T)
         Les_entiers.effective_collection.(Les_entiers.rf_T))
      t.(Monoide_produit.rf_creer
         Les_entiers.effective_collection.(Les_entiers.rf_T)
         Les_entiers.effective_collection.(Les_entiers.rf_T))
      t.(Monoide_produit.rf_parse
         Les_entiers.effective_collection.(Les_entiers.rf_T)
         Les_entiers.effective_collection.(Les_entiers.rf_T))
      t.(Monoide_produit.rf_print
         Les_entiers.effective_collection.(Les_entiers.rf_T)
         Les_entiers.effective_collection.(Les_entiers.rf_T))
      t.(Monoide_produit.rf__star_
         Les_entiers.effective_collection.(Les_entiers.rf_T)
         Les_entiers.effective_collection.(Les_entiers.rf_T))
      t.(Monoide_produit.rf__equal_
         Les_entiers.effective_collection.(Les_entiers.rf_T)
         Les_entiers.effective_collection.(Les_entiers.rf_T))
      t.(Monoide_produit.rf_element
         Les_entiers.effective_collection.(Les_entiers.rf_T)
         Les_entiers.effective_collection.(Les_entiers.rf_T))
      t.(Monoide_produit.rf_un
         Les_entiers.effective_collection.(Les_entiers.rf_T)
         Les_entiers.effective_collection.(Les_entiers.rf_T))
      t.(Monoide_produit.rf_different
         Les_entiers.effective_collection.(Les_entiers.rf_T)
         Les_entiers.effective_collection.(Les_entiers.rf_T))
      t.(Monoide_produit.rf_refl
         Les_entiers.effective_collection.(Les_entiers.rf_T)
         Les_entiers.effective_collection.(Les_entiers.rf_T))
      t.(Monoide_produit.rf_symm
         Les_entiers.effective_collection.(Les_entiers.rf_T)
         Les_entiers.effective_collection.(Les_entiers.rf_T)).
    
End Couple_d_entiers.
\end{lstlisting}
}


\section{Toplevel values}
At toplevel, since we are not in a species, there is no possible
dependencies on species parameters (since there is no parameter) and
no possible dependencies on methods of {\tt Self} (since there is no
notion of {\tt Self}). For this reason, we do not have to wonder about
how naming methods od {\tt Self} and of species parameters.

Hence, code generation for toplevel value definitions (either constants
or functions) is a simple translation into the target language with no
particular analysis to do before-hand. The name of the generated
definition is simply the name given in the \focalize\ source file and
the definition is generated at toplevel.

Hence, we are in the case where there is no more problems than those
intrinsic to the target language. For instance, in \coq, we will have
to be careful with polymorphic identifiers and handle the explicit
polymorphism by providing extra type arguments like seen in
\ref{coq-explicit-polymorphism}.

For instance:
{\footnotesize
\begin{lstlisting}[title=\focalize\ toplevel value definition]
let x = 42 ;;

let fst (x) =
  match x with
  | (v, _) -> v
;;
\end{lstlisting}
}


{\footnotesize
\begin{lstlisting}[language=MyOCaml,
                   title=Generated \ocaml\ toplevel value definition]
let x = 42 ;;

let snd (x : 'a * 'b) =
  match x with
   | (_, v) ->
     (begin
     v
     end)
;;
\end{lstlisting}
}

\index{\%type}\index{tuple}\index{type!tuple}
In the \coq\ code, we see again here a hack to speak of the type of
tuples. In effect, we must explicitly tell \coq\ that the {\tt *} used
in the type expression {\tt (\_\_var\_a * \_\_var\_b)} is the {\tt *}
dealing with {\bf types}. That's the reason of the presence of the
{\tt \%type} notation post-fixing the type expression of the tuple.

{\footnotesize
\begin{lstlisting}[language=MyCoq,
                   title=Generated \coq\ toplevel value definition]
Let x : basics.int__t := 42.

Let snd (__var_a : Set) (__var_b : Set) (x : ((__var_a * __var_b)%type)) :
    __var_b :=
  match x with
   | (_, v) =>
        v
  end.
\end{lstlisting}
}


\section{Toplevel theorems}
Toplevel theorems, like toplevel values do not have any dependencies
since they are not in a species. Hence they are generated like other
theorems, with the {\tt Section} mechanism for the proof part (if the
proof is done in \focal\ Proof Language), but with no
$\lambda$-lifting stuff.

For instance:
{\footnotesize
\begin{lstlisting}[title=\focalize\ toplevel theorem definition]
theorem beq_trans :
  all x y z in 'a, x = y -> y = z -> x = z
  proof = assumed {* Import trusted external code. *} ;;
\end{lstlisting}
}

{\footnotesize
\begin{lstlisting}[language=MyCoq,
                   title=Generated \coq\ toplevel theorem definition]
Theorem beq_trans :
  forall __var_a : Set, forall x  y  z : __var_a,
    Is_true ((_equal_ _ x y)) ->
      Is_true ((_equal_ _ y z)) -> Is_true ((_equal_ _ x z)).
(* Proof assumed because " Import trusted external code. ". *)
apply coq_builtins.magic_prove.
Qed.
\end{lstlisting}
}

\section{Type definitions}
Type definitions always appear at toplevel, i.e. outside a
species. For a given type definition named ``{\tt myty}'' in
\focalize, the corresponding generated names are historically a few
different in \ocaml\ and in \coq. In \ocaml\ the generated type will
be named ``{tt \_focty\_}'' + {\tt mtty}. In \coq, the generated type
will be named {\tt mtty} + ``{\tt \_\_t}''.

We have 4 kinds of type definitions:
\begin{itemize}
  \item Alias : the definition doesn't create a new type (i.e. a new
    set of values inhabiting a type) but is a shortcut for naming a
    (complex ?) type expression. For instance:
    {\footnotesize\lstinline!type t = alias (int * char * int) ;;!}
    The type constructor {\tt t} is only an alias for the type of
    tuples with 3 components whose first and third components are an
    integer and second one is a character. In particular, {\tt t} will
    be unifiable with any occurrence of its alias. 
  \item Union : the definition create a new sum type and gives its
    value constructors. This new type will be compatible with only
    itself. For instance:
    {\footnotesize\lstinline!type t = | A | B (int * char) ;;!}
    The type constructor {\tt t} denotes the type whose 2 value
    constructors are {\tt A} and {\tt B}. The constructor {\tt B} is
    parametrised by a pair of an integer and a character.
  \item Record: the definition create a new record type and gives its
    fields names and types. This new type will be compatible with only
    itself. For instance:
    {\footnotesize\lstinline!type t = { name : string ; birth : int } ;;!}
    The type constructor {\tt t} denotes the record type whose 2
    fields are named {\tt name} and {\tt birth} and types are
    respectively {\tt string} and {\tt int}.
  \item External : the definition establishes the link between a type
    of an external language and its representation in
    \focalize. Because they are quite complex, they will be studied in
    more details in a next dedicated section (
    see \ref{external-typedefinition}).
\end{itemize}


\subsection{Type alias}
\index{type!alias}
\index{alias}
As stated before, such a {\bf type definition} introduces a new type
name (i.e. type constructor) to represent a
{\bf type expression}. Fortunately, both \ocaml\ and \coq\ have the
notion of type alias. Hence, we simply need to translate the
\focalize\ type expression in the corresponding target type
expression. This doesn't pose any particular problem. The only thing
to remind is that since in \coq\ polymorphism is explicit, if a type
definition is parametrised by a type variable, then one must
explicitly give this variable the type {\tt Set}. In \ocaml\, there
is no need to give the type of this variable, the syntax only requires
to bind this variable name in the type definition's name (i.e. \\
\lstinline!type 'a t = ... ;;!).

Below follow a few simple alias type definitions examples with their
corresponding generated source code in \coq\ and \ocaml.
{\footnotesize
\begin{lstlisting}[language=MyOCaml,
                   title=Generated \coq\ type definition]
open "basics" ;;

type t = alias int ;;
type u = alias (t * (char * bool * string)) ;;
type poly_pair ('a) = alias ('a * 'a) ;;
type inv_prod ('a, 'b) = alias ('b * 'a) ;;
\end{lstlisting}
}

{\footnotesize
\begin{lstlisting}[language=MyOCaml,
                   title=Generated \coq\ type definition]
type _focty_t = Basics._focty_int ;;
type _focty_u =
  Basics._focty_int *
    (Basics._focty_char * Basics._focty_bool * Basics._focty_string) ;;
type 'a _focty_poly_pair = 'a * 'a ;;
type ('a, 'b) _focty_inv_prod = 'b * 'a ;;
\end{lstlisting}
}

{\footnotesize
\begin{lstlisting}[language=MyCoq,
                   title=Generated \coq\ type definition]
Require basics.
Definition t__t := basics.int__t.
Definition u__t :=
  ((basics.int__t
    * (((basics.char__t * basics.bool__t * basics.string__t)%type)))%type).
Definition poly_pair__t (__var_a : Set) := ((__var_a * __var_a)%type).
Definition inv_prod__t (__var_b : Set) (__var_c : Set) :=
  ((__var_c * __var_b)%type).
\end{lstlisting}
}

The only technical thing is to make sure that type variables are
correctly identified all along the unifications to be sure that they
are properly link between their declaration (with the type name) and
their usage. This is illustrated by the {\tt inv\_prod} definition
where we want to have variables inverted between the binding order and
their usage order.

\medskip
Be careful that the aliases we made here are {\bf tuples}. They use
the type constructor {\tt *} (star) to create {\bf one} type
expression that is a tuple compound of several type
(sub-)expressions. This will not have to be confused with the problem
of parametrising sum type value constructors with {\bf one} tuple of
several components or several values as explained later in
\ref{sum-value-cstr-tuple-versus-several-args}.


\subsection{Type union (sum type)}
\index{type!union}
\index{type!sum}
As stated before, such a sum type definition introduces a new type
name (i.e. type constructor) with its value constructors. Again
fortunately, both \ocaml\ and \coq\ have the notion of sum
type. Hence, we do not need to encode sums, we need to translate them
into the corresponding constructs in the target languages. Each value
constructor in \focalize\ will lead to a value constructor in the
target languages.

In \ocaml\ the return type of a constructor doesn't need to be
explicit. Conversely, in \coq\ it needs to be. Hence for the simple
sum type definition:
{\footnotesize
\begin{lstlisting}[title=Simple sum type in \focalize]
type t =
  | A
  | B
 ;;
\end{lstlisting}
}
we get the following \ocaml\ code where only the value constructors
names {\tt A} and {\tt B} are emitted:
{\footnotesize
\begin{lstlisting}[language=MyOCaml,
                   title=Simple sum type generated in \ocaml]
type _focty_t = 
  | A
  | B
 ;;
\end{lstlisting}
}
Whereas in \coq, in addition to the constructors names, one must
explicitly say that they are values of this type:
{\footnotesize
\begin{lstlisting}[language=MyCoq,
                   title=Simple sum type generated in \coq]
Inductive t__t : Set := 
  | A : (t__t)
  | B : (t__t).
\end{lstlisting}
}

\medskip
Parametrised value constructors are a bit more complex. We first
introduce the simplest case, where value constructors have one
parameter. In this case, in \ocaml\ code, we have the quite obvious
translation that tells ``{\tt of}'' the argument's type. In \coq\,
the constructor will simply be considered to have a functional type
whose argument is the type of the value constructor's argument and
whose return type is the defined type itself.
Hence, even for recursive and/or parametrised type definitions, we
easily generate the code of the example:
{\footnotesize
\begin{lstlisting}[title=Sum types with simply parametrised value
  constructors]
type t_poly ('a) =
  | None
  | Some ('a)
;;

type t_rec =
  | TR1 (int)
  | TR2 (t_rec)
;;

type t_poly_rec ('a) =
  | TPR1 ('a)
  | TPR2 (t_poly_rec ('a))
;;
\end{lstlisting}
}
\noindent in \ocaml\ to get:
{\footnotesize
\begin{lstlisting}[language=MyOCaml, title=Sum type generated in \ocaml]
type 'a _focty_t_poly = 
  | None
  | Some of ('a)
 ;;
type _focty_t_rec = 
  | TR1 of (Basics._focty_int)
  | TR2 of (_focty_t_rec)
 ;;
type 'a _focty_t_poly_rec = 
  | TPR1 of ('a)
  | TPR2 of ('a _focty_t_poly_rec)
 ;;
\end{lstlisting}
}

\noindent and in \coq\ to get:
{\footnotesize
\begin{lstlisting}[language=MyCoq, title=Sum type generated in \coq]
Inductive t_poly__t (__var_a : Set) : Set := 
  | None : (t_poly__t __var_a)
  | Some : (__var_a -> (t_poly__t __var_a)).

Inductive t_rec__t : Set := 
  | TR1 : (basics.int__t -> t_rec__t)
  | TR2 : (t_rec__t -> t_rec__t).

Inductive t_poly_rec__t (__var_b : Set) : Set := 
  | TPR1 : (__var_b -> (t_poly_rec__t __var_b))
  | TPR2 : ((t_poly_rec__t __var_b) -> (t_poly_rec__t __var_b)).
\end{lstlisting}
}
in both of which see see that the generated type constructor's name is
consistently the same between the code of the name of the definition
and the generated type expressions (so, recursive) where this type
constructor's name appears.

\medskip
\label{sum-value-cstr-tuple-versus-several-args}
The translation of sum type is quite complete, but we still need to
deal with a choice of representation to do about value
constructors that ``look having'' several parameters, like in
{\footnotesize
\begin{lstlisting}[title=Value constructor parameterised by
  ``several'' arguments]
type t_prm_val_cstr =
  | C (int * int * int)
;;
\end{lstlisting}
}
In such a case, is the value constructor {\tt C} parametrised by
{\bf three} integers or by {\bf one} tuple of 3 integers ? This makes
a particular difference in \coq\ because value constructors are
curried. For \coq\, unless an explicit tuple is stated, the value
constructor for the above example must have the functional type
{\tt int -> int -> int -> int -> t\_prm\_val\_cstr}.

Of course, it would be possible to always group the arguments into one
unique tuple,but making proofs using such a value constructor would
not be tractable (dixit Renaud). In \ocaml, since we do not have this
concern of proof, this choice would not be a real problem.

In fact, in the syntax, \focalize\ propose two value constructor
argument expressions different: one for ``several'' parameters and one
for 1 tuple parameter of ``several'' components. Hence, translation
into the target languages are not ambiguous. In a sum type definition,
for a value constructor, arguments separated by {\tt ,} (``comma'')
are considered as ``several arguments'', and arguments separated by
{\tt *} (``star'') are considered as grouped inside one unique
argument that is a tuple. Hence, for the following \focalize\ example:
{\footnotesize
\begin{lstlisting}[title=Value constructor parameterised by
  ``several'' arguments (2)]
type t_prm_val_cstr =
  | C (int * int * int)
  | D (int, int, int)
;;
\end{lstlisting}
}
we get the generated \ocaml\ code that follows, where we do make any
difference between one and several arguments: all is every considered
as a tuple
{\footnotesize
\begin{lstlisting}[language=MyOCaml,
                   title=Value constructor parameterised by
                   ``several'' arguments in \ocaml\ (2)]
type _focty_t_prm_val_cstr = 
  | C of ((Basics._focty_int * Basics._focty_int * Basics._focty_int))
  | D of (Basics._focty_int * Basics._focty_int * Basics._focty_int)
 ;;
\end{lstlisting}
}
and the generated \coq\ code where the types of {\tt C} and {\tt D}
are clearly different:
{\footnotesize
\begin{lstlisting}[language=MyCoq,
                   title=Value constructor parameterised by
                   ``several'' arguments in \coq\ (2)]
Inductive t_prm_val_cstr__t : Set := 
  | C :
    ((((basics.int__t * basics.int__t * basics.int__t)%type)) ->
      t_prm_val_cstr__t)
  | D :
    (basics.int__t -> basics.int__t -> basics.int__t -> t_prm_val_cstr__t).
\end{lstlisting}
}



\subsection{Record type}
\index{type!record}
As stated before, such a record type definition introduces a new type
name (i.e. type constructor) with its fields labels and types. Again
fortunately, both \ocaml\ and \coq\ have the notion of record
type. Hence, we do not need to encode record, we need to translate them
into the corresponding constructs in the target languages. Each field
in \focalize\ will lead to a field in the record generated in the
target languages.

The translation process is simple since it map a each field label of
the \focalize\ definition onto a field label of the same name in the
target language: The type of the field is generated like any type
expression in the target language.
{\footnotesize
\begin{lstlisting}[title=Record type definitions in \focalize]
type r0 = { x0 = int ; y0 = float } ;;
type r1 ('a) = { x1 = 'a } ;;
\end{lstlisting}
}

{\footnotesize
\begin{lstlisting}[language=MyOCaml,
                   title=Generated record type definitions in \ocaml]
type _focty_r0 = { 
   x0 : Basics._focty_int ;
   y0 : Basics._focty_float ;
} ;;

type 'a _focty_r1 = { 
    x1 : 'a ;
} ;;
\end{lstlisting}
}

The only difference for \coq\ is (like already encountered when
dealing with the record type representing species and collections,
in \ref{mk-record-introduction1} and \ref{mk-record-introduction2}) 
that a record type definition requires a ``record constructor''. By
convention, it will always be named by ``{\tt mk\_}'' + the record
type's name + ``{\tt \_\_t}''. 
{\footnotesize
\begin{lstlisting}[language=MyCoq,
                   title=Generated record type definitions in \coq]
Record r0__t : Type :=
  mk_r0__t {
  x0 : basics.int__t ;
  y0 : basics.float__t
  }.

Record r1__t (__var_c : Set) : Type :=
  mk_r1__t {
  x1 : __var_c
  }.
\end{lstlisting}
}


\section{External definitions}
External definitions are intended to make the interface between code
imported from foreign target languages to be able to use it on
\focalize's side. There are 2 kinds of external definitions: type
definitions and value definitions.

Type definitions are used either to import basic types and to allows
\focalize to map its internal types on them (for instance, {\tt int},
{\tt bool}, etc that are built-in type in \focalize\ and that must be
mapped onto their \ocaml\ and \coq\ counterparts), or to specify the
type of values developed outside \focalize\ and that we want to use
from \focalize.

Value definitions are used to provide support (i.e. primitives to
manipulate) and inhabitants to external types or to provide values of
a type known in \focalize\ but whose construction was done outside the
\focalize\ source code.

Any external definition contains 2 aspects: its ``internal'' view that
says how the defined entity must be seen by \focalize (during its
analyses) and its ``external'' view that says how this entity must be
mapped onto target languages (during code generation) when it is used
in a \focalize\ source code.


\subsection{External type definitions}
An external type definition starts like a regular type definition,
i.e. by the type constructor's name and possibly parameters:
\lstinline!type ('a, 'b) t =!). The body of the definition shows that
it is an external by having the following shape:
{\footnotesize
\begin{lstlisting}
type t  =
  internal ...
  external ...
and ...
and ...
\end{lstlisting}
}

{\bf Attention}: Be careful that the {\tt and ...} are {\bf not} other
type definitions: they are optional and belong to the current external
type definition. We will see later the meaning.

\subsubsection{The {\tt internal} clause}
For a type definition, the {\tt internal} clause shows at which
\focalize\ type definition the body of the external definition
corresponds. In fact this is equivalent to establish an alias between
the structure of the external type and the structure of the type
definition inside \focalize.

However, since we do not always want to really have this alias
(i.e. an equivalence between the internal and external
representations), this clause can be empty. In this case, the created
type constructor will be fully abstract on \focalize's side and the
only way to make and manipulate values of this type will have to be
provided via other external (values) definitions or via built-ins of
the compiler.

\medskip
So, when the {\tt internal} clause is not empty, we said that is
represented a type definition. Hence this clause can have 3 shapes: an
alias, a sum or a record (the 3 kinds of type definitions in
\focalize). For example (with the first case representing a fully
abstract type as described above):
{\footnotesize
\begin{lstlisting}[title=External type definitions]
type int =
  internal (* Internal#int *)
  ...
;;

type foc_diag ('a) =
  internal alias ('a * 'a)
  ...
;;

type list ('a) =
  internal
  | []
  | ( :: ) ('a, list ('a))
  ...
;;

type foc_record ('a, 'b) =
  internal  { hcode = int ; contents = ('b * 'a) }
  ...
;;
\end{lstlisting}
}
The first definition creates a type {\tt int} that is fully
abstract. Obviously, this one will be used magically by the internals
of the compiler, so no need to have external definitions tomanipulate
its representation, this will be built-in in the compiler. Consult
\ref{external-ty-defs-and-builtin-tys} for a discussion about this
mechanism.

The second definition creates a parameterised type {\tt foc\_diag}
that will internally be compatible with a pair of elements of the same
type.

The third definition creates a parameterised type {\tt list} that is
made of 2 value constructors: {\tt []} with no argument and {\tt ::}
with 2 arguments (not a tuple). Hence this corresponds to an internal
representation of a sum type. We can see here how to define the lists
like they are in \coq\ and \ocaml\ to directmy map them onto those of 
\coq\ and \ocaml, without making any internal hack inside the
compiler. We could have defined our custom lists by a regular type
definition like
{\footnotesize
\begin{lstlisting}
type list ('a) =
  | []
  | ( :: ) ('a, list ('a))
;;
\end{lstlisting}
}
but we wouldn't have been able to make so that constructors directly
map onto their counterparts in \coq\ and \ocaml\ (in effect, these
constructors being non-regular identifiers, they would have been
``stringified'' like we saw in \ref{ident-stringification}).

The fourth and last definition creates a parameterised type
{\tt foc\_record} that is a record type with 2 fields:
{\tt hcode} and {\tt contents}.

\medskip
{\bf So, a question}: but why to use external definitions to create
such types ? It should be possible to define these sum and record
types by a regular definition ! The answer, partially given about the
{\tt list} example is that this allows to control manually and
explicitely the mapping of the type and of its components (fields and
value constructors) into the target languages. We will see a clear
example once we have ended the case of {\tt foc\_diag}.

\medskip
To summarise, the {\tt internal} clause controls how the type is seen
on \focalize's side.


\subsubsection{The {\tt external} clause}
The external clause tells how the {\bf type constructor} (not it's
components like fields, value constructors : this will be done by the
extra {\tt and ...} clauses descibed below in
\ref{external-ty-def-extra-clauses} ) must be {\bf defined} into the
target languages. In other words, what to emit to define the type
constructor in the target languages.

Like in any {\tt external clause}, we have an enumeration of mapping
``language $\mapsto$ external code''. Languages can syntactically be
{\tt coq}, {\tt caml} or a string for other languages not internally
handled by the \focalize\ compiler. External code is an arbitrary
string enclosed by {\tt \{*} and {\tt *\}} that will be emited
verbatim at code generation pass when the type constructor will have
to be defined.

At code generation time, the shape of the definition in \ocaml\ will
look like: {\tt type} followed by the enumeration of polymorphic type
variables ``{\tt \_focty\_}'' + type's name {\tt =} followed by the
vertatim copy of the external code. The polymorphic type variables are
named as usual in \ocaml. If there are several then they
comma-separated and enclosed between parentheses. Their name are
{\tt, 'a}, then {\tt, 'b}, then {\tt, 'c} and if there are more than
26, it goes on with {\tt 'aa}, {\tt 'ab} etc\ldots. In fact it is like
printing their numbers in base 26, using lowercase letters as digits.

In \coq, it will look like: {\tt Definition} followed the the type's
name + ``{\tt \_t}'' followed by the enumeration of the polymorphic
type variables {\tt :=} followed by the vertatim copy of the
external code. The polymorphic type variables are named by
``{\tt \_\_var\_}'' + ``a'', then ``b'', then ``c''. Like for \ocaml\
the suffix is the variable's number writen in base 26. Hence the name
of the 27$^{th}$ variable will be {\tt \_\_var\_ab}. In \coq\, we must
explicitly anotate variables with the type {\tt Set}.

Hence, with the definitions we started in our example, the beginning
of the generated code in \ocaml\ and \coq\ will look like:
{\footnotesize
\begin{lstlisting}[language=MyOCaml,
                   title=\ocaml\ code for external definitions]
type _focty_int = ...
type 'a _focty_foc_diag = ...
type 'a _focty_list = ...
type ('a, 'b) _focty_foc_record = ...
\end{lstlisting}
}

{\footnotesize
\begin{lstlisting}[language=MyCoq,
                   title=\coq\ code for external definitions]
Definition foc_diag__t (__var_a : Set) := ...
Definition list__t (__var_a : Set) := ...
Definition foc_record__t (__var_a : Set) (__var_b : Set) :=
\end{lstlisting}
}


Continuing our previous example, we state the \focalize\ external type
definitions:
{\footnotesize
\begin{lstlisting}[title=External type definitions (2)]
type int =
  internal (* Internal#int *)
  external
  | caml -> {* int *}
  | coq -> {* Z *}
;;

type foc_diag ('a) =
  internal alias ('a * 'a)
  external
  | caml -> {* ('a * 'a) *}
  | coq -> {* coq_stubs.foc_diag ['a] *}
;;

type list ('a) =
  internal
  | []
  | ( :: ) ('a, list ('a))
  external
  | caml -> {* 'a list *}
  | coq -> {* (list __var_a) *} (* From the List module. *)
  ...
;;

type foc_record ('a, 'b) =
  internal  { hcode = int ; contents = ('b * 'a) }
  external
  | caml -> {* ('b, 'a) Ml_stubs.bbt_record *}
  | coq -> {* coq_stubs.foc_record ['b, 'a] *}
  ...
;;
\end{lstlisting}
}

In the first definition we see that to define the {\tt int}
{\bf type constructor} in \ocaml, we will emit ``int'' and in \coq, we
will emit ``Z''. That's because we want the {\tt int}
{\bf type constructor} to be mapped onto these existing types of the
target languages.

The second definition shows that we want {\tt foc\_diag} to be defined
as a pair in \ocaml. In \coq, we don't want a pair, instead let's say
that we want 

In the third definition, we say that lists are implemented in \ocaml\
by its native lists and in \coq, by an existing data-type (the one
provided my \coq's module ``List'').

Finally, in the last definition, we want to say that the type
{\tt foc\_record} is implemented by a user-defined type. For instance,
a record type in both \ocaml\ and \coq. Due to the way the code is
emitted we can't write directly in the external code a record
definition in each of the target languages: it would be syntactically
incorrect. So, instead, we say that the type {\tt foc\_record} is
implemented by a type name given in a other source file (one file for
\ocaml\ and one for \coq). We must remember that de generated
definition in the target languages will correspond to an alias
(i.e. of the form {\tt type} name {\tt =} external-code in \ocaml, and
{\tt Definition} name {\tt :=} external-code in \coq), so we must put
in the external code only things that will comply the target
language's syntax. For instance, specifying for the \coq\ language a
definition like:
{\footnotesize
\begin{lstlisting}
type foc_diag ('a) =
  internal alias ('a * 'a)
  external
  | caml -> {* ('a * 'a) *}
  | coq -> {* Record : Type :=
                mk_foc_diag (alpha : Set) {
                  fst : alpha ;
                  snd : alpha } *}
;;
\end{lstlisting}
}
would lead to a syntactically incorrect garbage rejected by \coq\
like:
{\footnotesize
\begin{lstlisting}[language=MyCoq]
Definition foc_diag__t (__var_a : Set) :=
   Record : Type :=
                mk_foc_diag (alpha : Set) {
                  fst : alpha ;
                  snd : alpha } .
\end{lstlisting}
}

\medskip
Finally, one may note in this last definition that a
\focalize\ {\tt foc\_record ('a, 'b)} is implemented by a
{\tt ('b, 'a) Ml\_stubs.bbt\_record}. We inverted the parameters !
This means that so they will be in the generated definifion (have a
look in the sample generated code below) !

\medskip
We now continue to inspect the generated code in both \ocaml and \coq:
{\footnotesize
\begin{lstlisting}[language=MyOCaml,
                   title=\ocaml\ code for external definitions (2)]
type _focty_int =  int ;;
type 'a _focty_foc_diag =  ('a * 'a)  ;;
type 'a _focty_list =  'a list ;;
type ('a, 'b) _focty_foc_record =  ('b, 'a) Ml_stubs.bbt_record ;;
\end{lstlisting}
}
\noindent and:
{\footnotesize
\begin{lstlisting}[language=MyCoq,
                   title=\coq\ code for external definitions (2)]
Definition int__t :=  Z.
................
\end{lstlisting}
}



\subsubsection{The extra {\tt and ...} clauses}
\label{external-ty-def-extra-clauses}


\subsubsection{External type definitions and built-in types.}
\label{external-ty-defs-and-builtin-tys}
A propos de basics.fcl.
Blabla  propos du fait que le nom (int) est justement bien senti car
dans le compilo, on utilise justement ``int'' comme nom de
constructeur pour infrer le type des expressions entires. Etc...


\subsection{External value definitions}
\label{external-type-definition}

%  External definitions can be either manifest or
%     abstract. In the first case, it is possible to have access in
%     \focalize\ the structure of the type as seen under \focalize. In
%     the second case, the type doesn't have any explicit representation
%     in \focalize\ and is considered as purely abstracted. The only way
%     to manipulate it will be via functions defined later (obviously
%     defined as ``external'', i.e. establishing a link between
%     \focalize\ and the target  languages. See
%     \ref{external-definitions}).
%     External definitions may provide value constructors (if the
%     definition is a sum) or field labels (if the definition is a
%     record) and their mapping into the target languages.
