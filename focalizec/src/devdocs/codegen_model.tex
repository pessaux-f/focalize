% $Id: codegen_model.tex,v 1.9 2009-04-08 15:33:58 pessaux Exp $

The code generation model is the now closely the same for both \ocaml\
and \coq\ generated source files. The main difference comes from the
fact that in \ocaml, logical methods are discarded. However, except
for the case of \zenon\ proofs where we introduce \coq\ {\tt Section},
the generation model for ``computation'' and logical methods are
exactly the the same. This especially means that dependencies are
``manually'' abstracted by explicit $\lambda$-lifting instead of using
(like in the previous compiler) the \coq's {\tt Section}
mechanism. In the same order of idea, in order to have a common model,
both \ocaml\ and \coq\ code are based on a record-oriented structure
for the species and collection, with explicit record fields accesses.

\section{Species}

\subsection{Species header}
The generated code for a species is hosted by a module whose name is
the species' name. This way, it is possible to have species having the
same names of methods without conflict. The module hence defines the
name-space of ``things'' contained in and induced by a species.


\subsection{Carrier representation}
In \ocaml, if the structure of the carrier of the species is known
(i.e. if the method {\tt representation} was defined), then we
generate a type definition whose name is {\tt me\_as\_carrier} and
body is the type translation of the corresponding \focalize\ type
expression.

In such a type definition, carriers of species parameters appearing in
the species' carrier are abstracted by type variables. The naming
scheme of these variable is ''{\tt '}'' + the species parameter's name
un-capitalised + ``{\tt \_as\_carrier}'' + an integer stamp that is
unique (inside this type definition). Since species names in
\focalize\ are capitalised and capitalised identifiers in \ocaml\ are
reserved for modules and sum type value constructors, we need to
un-capitalise the name when generating \ocaml\ code. For the stamp, it
is required to prevent several type variable from having the same name
in case the species is parameterised by both a collection parameter
and an entity parameter whose names differ only by the capitalisation
of the first letter.

For instance, the following header of a species definition:
{\footnotesize
\begin{lstlisting}
species Cartesian_product(A is Setoid, B is Setoid) =
  representation = A * B;
  ...
\end{lstlisting}
}
will generate the \ocaml\ type definition:
{\footnotesize
\begin{lstlisting}[language=MyOCaml]
module Cartesian_product =
  struct
  (* Carrier's structure explicitly given by "rep". *)
  type ('a0_as_carrier, 'b1_as_carrier) me_as_carrier =
    'a0_as_carrier * 'b1_as_carrier
  ...
\end{lstlisting}
}

In fact, {\em a posteriori}, I think now that it's useless in case
of a species, even closed. This type definition is only used in the
case of a collection.

\medskip
In \coq, no definition generated, the knowledge of the structure of
the carrier being reflected directly is needed in the methods (see
later).



\subsection{The record type}
The type of data representing a species is a record type. We first
examine its header, i.e. stuff before this type definition's body,
then it's body.


\subsubsection{The record header}
The name of this type is always {\tt me\_as\_species}. It can be
parametrised due to various abstraction requirements induced by the
late-binding feature of \focalize. \ocaml\ requires a parameter not
needed for \coq: this is the only fundamental difference. We will see
that abstractions (hence, parameters) required by \coq\ can involve
methods but this is only because some of the dependencies that are
present in the \coq code are always trivially absent in the
\ocaml\ code.


\begin{enumerate}
\item First come all the species parameter carriers appearing in the
  {\bf types} of the methods of the species. Each carrier will be
  abstracted by one type variable. This allows to ``late-bind'' the
  {\tt representation} of the species parameters. We say here 
  ``appearing in the {\bf types}\ldots'': be aware that the type of
  ``computational'' methods are ML-like types and the ones of logical
  methods are their {\bf statement} ! We do not explain here how these
  parameters are found: this is the role of dependency computation on
  species parameters.

  The naming scheme of these type variable in \ocaml\ is the same than
  described above for the carrier representation.

  In \coq\, these parameters of the type are not ``really type
  variables'' but arguments of type {\tt Set} (simply a technical
  question). Their naming scheme is the species parameter's name +
  ``{\tt \_T}''.

\item Next, {\bf only in the \ocaml\ code}, the record type is always
  parametrised by a type variable representing the carrier of
  (i.e. the internal representation of the type encapsulated in this)
  species. By convention, this type variable is always named
  {\tt 'me\_as\_carrier} (don't confuse with {\tt me\_as\_carrier}
  that is the name of the type definition representing the effective
  structure of the carrier when it is known).

  In \coq\ we don't have this mandatory type parameter, but instead of
  it, we will have one extra field in the body of the record. This
  variable enable to ``late-bind'' the {\tt representation} of the
  species.

\item Finally come all the methods of the species parameter appearing
  in the {\bf types} of the methods of the species. Since in \ocaml\
  the type of a method can only involve type constructors (a ML-like
  type), it is clear that we won't have any such parameters. In
  effect, in \ocaml\ the logical methods are discarded. However,
  since for the type of a logical method is its logical statement, to
  \coq's side, we can have any expression inside their type.. In
  particular, we can have calls to some collection parameters'
  methods. Having these parameters in the record type allows the
  ``late-binding'' on the collection parameter itself (i.e. on by
  which effective collection will be used to instantiate the
  parameter). The naming scheme for the parameters induced by these
  dependencies is ``{\tt \_p\_}'' + the species parameter's name  +
  {\tt \_} + the method's name.

  There is a special a case: the entity parameters. We will explain
  this after the following example.
\end{enumerate}

Let's now change our previous example to illustrate the header of our
record type in \ocaml\ and \coq:

{\footnotesize
\begin{lstlisting}
species Cartesian_product(A is Setoid, B is Setoid) =
  representation = A * B;
  let make (x in A, y in B) in Self = (x, y) ;
  let equiv (x in Self) = ... A!equal (...) && B!equal (...) ;
  theorem thm : all x in A, A!tst (x) -> ...
    proof = ... by property A!commutes ... ;
  ...
\end{lstlisting}
}

We can see that we have:
\begin{itemize}
\item the carrier defined,
\item a method {\tt make} of type {\tt A -> B -> Self}
\item a method {\tt equiv} having type {\tt Self -> bool}, having
  dependencies on the methods {\tt equal} of the collection parameters
  {\tt A} and {\tt B}, but in its {\bf body}, not in its type
  ({\tt equal} doesn't appear in {\tt equiv}'s type). Hence, the
  record type (in \coq\ and in \ocaml) won't have any parameter to
  abstract the dependencies on these methods.
\item a theorem {\tt thm} of ``type''
  {\tt all x in A, A!tst (x) -> ...} and ``body'' (proof)
  {\tt ... by property A!commutes ...}. Hence, it has dependencies on
  {\tt A!tst} in its type and on {\tt A!commutes} in its body. This
  means that in \coq\ the record type will have a parameter to abstract
  the dependency found in the type of the theorem, i.e. {\tt A!tst}
  but not for {\tt A!commutes}
\end{itemize}

The record type for \ocaml\ will then look like:
{\footnotesize
\begin{lstlisting}[language=MyOCaml]
module Cartesian_product =
  struct
  (* Carrier's structure explicitly given by "rep". *)
  type ('a0_as_carrier, 'b1_as_carrier) me_as_carrier =
    'a0_as_carrier * 'b1_as_carrier
  type ('a0_as_carrier, 'b1_as_carrier, 'me_as_carrier) me_as_species =
  ...
\end{lstlisting}
}

In \coq\ a record is introduced by a constructor. By convention, we
always name it {\tt mk\_record}. The record type for \coq\ will then
look like:
{\footnotesize
\begin{lstlisting}[language=MyCoq]
Module Cartesian_product.
  Record Cartesian_product (A_T : Set) (B_T : Set)
    (_p_A_tst : A_T -> basics.bool__t) : Type :=
    mk_record
  ...
\end{lstlisting}
}

\medskip
\paragraph{The entity parameters} In \ocaml\ they can never appear in
the record type since in ML-like types, we can't have expressions. 
However, in \coq\ it is possible to have dependency on an entity
parameter in a theorem or property statement (i.e. in the type of a
logical method). For example:
{\footnotesize
\begin{lstlisting}
species Me (Naturals is IntModel, n in Naturals) =
  representation = Naturals ;

 theorem myth : all x in Self,
    basics#syntactic_equal (n, Naturals!un)
  proof = assumed {* *} ;
  end ;;
\end{lstlisting}
}

The theorem {\tt myth} shows a dependency on the entity parameter
{\tt n}. In this case, the record type will be parametrised by this
entity parameter like if it was a collection parameter's
method. Obviously, an entity parameter doesn't have methods since it
is a ``value'' and not a species. So we don't have any notion of
method in the naming scheme. We choose to name these entity parameters
by ``{\tt \_p\_}'' + the entity parameter's name  + {\tt \_} + the
the entity parameter's name again.
{\footnotesize
\begin{lstlisting}[language=MyCoq]
Module Me.
  Record Me (Naturals_T : Set) (_p_n_n : Naturals_T)
    (_p_Naturals_un : Naturals_T) : Type :=
    mk_record 
  ...
\end{lstlisting}
}


The record type for \ocaml\ will then look like:
{\scriptsize
\begin{lstlisting}[language=MyOCaml]
module Cartesian_product =
  struct
  (* Carrier's structure explicitly given by "rep". *)
  type ('a0_as_carrier, 'b1_as_carrier) me_as_carrier =
    'a0_as_carrier * 'b1_as_carrier
  type ('a0_as_carrier, 'b1_as_carrier, 'me_as_carrier) me_as_species =
  ...
\end{lstlisting}
}


The record type for \coq\ will then look like:
{\scriptsize
\begin{lstlisting}[language=MyCoq]
Module Cartesian_product.
  Record Cartesian_product (A_T : Set) (B_T : Set)
    (_p_A_tst : A_T -> basics.bool__t) : Type :=
    mk_record
  ...
\end{lstlisting}
}

\medskip
\paragraph{The entity parameters} In \ocaml\ they can never appear in
the record type since in ML-like types, we can't have expressions. 
However, in \coq\ it is possible to have dependency on an entity
parameter in a theorem or property statement (i.e. in the type of a
logical method). For example:
{\scriptsize
\begin{lstlisting}
species Me (Naturals is IntModel, n in Naturals) =
  representation = Naturals ;

 theorem myth : all x in Self,
    basics#syntactic_equal (n, Naturals!un)
  proof = assumed {* *} ;
  end ;;
\end{lstlisting}
}
The theorem {\tt myth} show a dependency on the entity parameter
{\tt n}. In this case, the record type will be parameterised by this
entity parameter like if it was a collection parameter's
method. Obviously, an entity parameter doesn't have methods since it
is a ``value'' and not a species. So we don't have any notion of
method in the naming scheme. We choose to name these entity parameters
by ``{\tt \_p\_}'' + the entity parameter's name  + {\tt \_} + the
the entity parameter's name again.

\subsubsection{Fields and their types}
Now we saw the header of the record type definition, we must address
its body, i.e. its fields. Roughly speaking, the fields will be all
the methods with their types hosted in the species in normal form. By
``all'' we mean the methods declared, defined in the species and those
inherited. Because the species is in normal form, this means that we
do not have several times a method: inheritance has been resolved and
chose the right version of each method to keep.

The type accompanying each method is, like we previously said, a
ML-like type for ``computational'' methods and a logical statement for
logical methods. This especially means that since logical methods are
discarded in \ocaml, in this target language, we will only have
ML-like types.

The only important difference between \ocaml\ and \coq is that in
\coq\ we always have an extra (and first) field representing the
carrier of the species (remember that in \ocaml, instead, we had a
type definition that we didn't have in \coq). This field always
appears as {\tt  rf\_T :> Set ;} and represents the type encapsulated
in the species. In \ocaml, the field corresponding to a method is
straight the method's name. In \coq, the field's name is
``{\tt rf\_}'' + the method's name (``rf'' for {\bf r}ecord
{\bf f}ield).

Let's now take a simple example and seen the record types in
\ocaml\ and in \coq.
{\footnotesize
\begin{lstlisting}
species Me (Naturals is IntModel, n in Naturals) =
  representation = Naturals ;

 theorem daube : all x in Self,
    basics#syntactic_equal (n, Naturals!un)
  proof = assumed {* *} ;

  let junk (x in Self) in int = 1 ;

  let reduce (x in Naturals) in Self =
    Naturals!modulo (x, n) ;
end ;;
\end{lstlisting}
}


{\footnotesize
\begin{lstlisting}[language=MyOCaml]
module Me =
  struct
  (* Carrier's structure explicitly given by "rep". *)
  type ('naturals0_as_carrier, 'n1_as_carrier) me_as_carrier =
    'naturals0_as_carrier
  type ('naturals0_as_carrier, 'n1_as_carrier, 'me_as_carrier) me_as_species = {
    (* From species ok__in_example#Me. *)
    junk : 'me_as_carrier -> Basics._focty_int ;
    (* From species ok__in_example#Me. *)
    reduce : 'naturals0_as_carrier -> 'me_as_carrier ;
    }
\end{lstlisting}
}


{\footnotesize
\begin{lstlisting}[language=MyCoq]
Module Me.
  Record Me (Naturals_T : Set) (_p_n_n : Naturals_T)
    (_p_Naturals_un : Naturals_T) : Type :=
  mk_record {
    rf_T :> Set ;
    (* From species ok__in_example#Me. *)
    rf_daube :
      forall x : rf_T,
        Is_true ((basics.syntactic_equal _ _p_n_n _p_Naturals_un)) ;
    (* From species ok__in_example#Me. *)
    rf_junk : rf_T -> basics.int__t ;
    (* From species ok__in_example#Me. *)
    rf_reduce : Naturals_T -> rf_T
    }.
\end{lstlisting}
}

Note that in the generated \coq\ code, the method {\tt daube} (in
fact, the theorem) contains an application of \\
{\tt basics.syntactic\_equal}. We can see the mechanism of explicit
polymorphism and the interest of having kept in the \coq\ code
generation environment the number of extra arguments ({\tt \_}s) that
must be added to identifiers in applicative position.



\subsection{Methods}
Once the record type is defined, it is time to generate the
definitions corresponding to the various methods of the
species. Several cases exist: a method can be declared, defined and in
each case either at the current inheritance level or inherited from an
ancestor.

\subsubsection{Inherited, declared, defined ?}
First of all, the point is that methods only declared or {\bf inherited}
are {\bf never} leading to generated code, neither in \ocaml, nor in
\coq. This means that only methods freshly defined in the species are
leading to code.

\subsubsection{Defined methods}
In term of generation model, there is no difference between \ocaml\
and \coq. The point is because in \ocaml\ we don't have logical
methods, all what we will explain about theorems and proof is
trivially out of the subject for \ocaml. Hence we won't make any
difference in our explanation here, simply considering both kinds of
methods independently of the target language.

There are 2 kinds of methods: ``computational'' and logical. The
generation model makes only a difference for theorems because they
have a proof, but the final definition of both kinds of method uses
the same mechanism: making explicit abstractions ($\lambda$-lifts) for
all the types and {\bf declared} methods (from {\tt Self} or from the
species parameters) the defined method depends on. Moreover, an entity
parameter (since it's in fact a value) will appear as an argument of a
method if it is used by it: it becomes hence an argument of the
method.

To help us, we need 3 notions. We don't examine here how they are
computed. This will be investigated later and is mostly described in
Virgile Prevosto's PhD.
\begin{itemize}
\item The carriers present in the methods from parameters (and in the
  type of entity parameters) and methods of {\tt Self} the method
  depends on. Since they are atomic types, there is no ordering issue
  in this set.
\item The ``minimal typing environment''. It represents the
  {\bf ordered} set of methods of {\tt Self} a method depends on. It
  must be ordered because some of the dependencies can depend on some
  others. Because of the well-formation property, we are sure this
  order exists.
\item The {\bf ordered} set of methods from parameters the method
  depends on.
\end{itemize}

A method will lead to a {\tt let} of {\tt theorem} definition
depending on its kind. The generated name is the same than in the
\focalize\ source. Only a ``stringification'' is done when the method
is an operator (e.g. {\tt =}, {\tt +}, {\tt +=e}, \ldots). This
stringification is done on the fly using a very simple mechanism
(check function \\
{\tt pp\_vname\_with\_operators\_expanded} in the source
file \\
{\tt focalize/focalizec/src//basement/parsetree\_utils.ml}.

The generated definition is in fact a {\bf method generator}, not the
method itself. Its is a function that si parametrised by all the thing
the method depends on, and whose body is the method's body''. This
mechanism serves the late-binding feature and allow to really create a
method once things it depends on are defined by applying the generator
to the effective definitions of the methods teh current method depends
on. Hence, until the method we depend on are not yet defined, one can
still work with our method generator. Moreover, this allows to make
several effective methods from a same generator, by applying
different effective definitions for $\lambda$-lifted  parameters of
thbe generator.

\medskip
Next come all the $\lambda$-lifts that represent the dependencies of
the method: In the following order come:
\begin{enumerate}
\item The parameters representing the carriers of species parameters
  appearing in the method (i.e. used in its whole definition). Their
  name is ``{\tt \_p\_}'' + the species parameter's name +
  ``{\tt \_T}. 
\item The parameters representing the methods of species' parameters
  the current method depends on. They are ordered in 2
  directions. First, all the methods of a same parameter are
  consecutive and we $\lambda$-lift following the order of apparition of
  the species parameters. Second, for each species parameter, the
  consecutive list of its methods is ordered according to their own
  dependencies together.

  The first point naturally ensure that following the species
  parameters' order, definitions of methods of a parameter can only
  depend on former parameters (otherwise, scoping and type-checking
  would have told ``Unbound ...''). The second point is not obtained
  for free. We must really order the methods of a species parameter
  according to their own dependencies ``on Self's methods'' in their
  hosting species. For instance, let's imagine that in a species, we
  need to abstract
  {\tt P1!eq\_refl : all x in Self, !equal (x, x)} and
  {\tt P1!equal : Self -> Self -> bool}, clearly to have
  {\tt P1!eq\_refl} well typed, {\tt P1!equal} must be known, hence
  appear sooner (i.e. must be $\lambda$-lifted before
  {\tt P1!eq\_refl}).

  Methods are named by ``{\tt \_p\_}'' + the species parameter's name
  + ``{\tt \_}'' + the method's name.

  The translation mechanisms of expressions is not studied in this
  section since it isn't really part of the ``species'' compilation
  model. We can however note that in the body of a species
  parameter's method, calls performed to other methods of {\bf this}
  parameter (i.e. so, obviously, on which the method of the parameter
  depends on) are done using the naming scheme: ``{\tt \_p\_}''+ the
  species parameter's name + ``{\tt \_}'' + called method's name (flag
  {\tt SMS\_from\_param} used when calling the function \\
  {\tt Species\_record\_type\_generation.generate\_logical\_expr}).

\item The parameters representing the methods of ourselves (i.e. of
  {\tt Self}) we depend on. They are named by ``{\tt abst\_}'' + the
  method's name. The only exception is in case where the method is the
  {\tt representation}, the name will be {\tt abst\_T}.
\end{enumerate}

\medskip
Finally come the translation of the definition itself, i.e. it's
parameters (if the definition is functional) and its body. As above,
we leave for later the translation mechanisms of expressions.
We can however note that in the body of a method, calls performed to
other methods of {\tt Self} (i.e. so obviously on which we depend) are
done using the naming scheme: ``{\tt abst\_}''+ the called method's
name (flag {\tt SMS\_abstracted} used when calling the function \\
{\tt Species\_record\_type\_generation.generate\_logical\_expr}).


\subsubsection{Sample code to help summary}
We take a part of the example given in Virgile Prevosto's Phd, section
2.2.2 starting page 14 to illustrate the model we exposed until
now. Attention, we explicitly skipped (removed in the generated
listings) code dealing with collection generator we will explain in
the next section.

{\footnotesize
\begin{lstlisting}
species Setoide inherits Basic_object =
  signature ( = ) : Self -> Self -> bool ;
  signature element : Self ;
  let different (x, y) = basics#not_b (x = y) ;

  property refl : all x in Self, x = x ;
  property symm : all x y in Self, Self!( = ) (x, y) -> y = x ;
end ;;

species Monoide inherits Setoide =
  signature ( * ) : Self -> Self -> Self ;
  signature un : Self ;
  let element = Self! un * !un ;
end ;;

species Setoide_produit (A is Setoide, B is Setoide) inherits Setoide =
  representation = (A * B) ;

  let ( = ) (x, y) =
     and_b
       (A!( = ) (basics#fst (x), basics#fst (y)),
        B!( = ) (snd (x), snd (y))) ;
  let creer (x, y) in Self = basics#pair (x, y) ;
  let element = Self!creer (A!element, B!element) ;
  let print (x) =
     "(" ^ A!print (fst (x)) ^ "," ^ B!print (snd (x)) ^ ")" ;

  proof of refl = (* by definition of ( = ) *) assumed {* *} ;
  proof of symm = assumed {* *} ;

end ;;
\end{lstlisting}
}


{\footnotesize
\begin{lstlisting}[language=MyOCaml]
module Setoide =
  struct
  type 'me_as_carrier me_as_species = {
    (* From species ok__phd_sample#Setoide. *)
    element : 'me_as_carrier ;
    (* From species ok__phd_sample#Setoide. *)
    _equal_ : 'me_as_carrier -> 'me_as_carrier -> Basics._focty_bool ;
    (* From species basics#Basic_object. *)
    parse : Basics._focty_string -> 'me_as_carrier ;
    (* From species basics#Basic_object. *)
    print : 'me_as_carrier -> Basics._focty_string ;
    (* From species ok__phd_sample#Setoide. *)
    different : 'me_as_carrier -> 'me_as_carrier -> Basics._focty_bool ;
    }
  let different abst__equal_ (x : 'me_as_carrier) (y : 'me_as_carrier) =
    (Basics.not_b (abst__equal_ x y))
  end ;;

module Monoide =
  struct
  type 'me_as_carrier me_as_species = {
    (* From species ok__phd_sample#Monoide. *)
    un : 'me_as_carrier ;
    (* From species ok__phd_sample#Monoide. *)
    _star_ : 'me_as_carrier -> 'me_as_carrier -> 'me_as_carrier ;
    (* From species ok__phd_sample#Setoide. *)
    _equal_ : 'me_as_carrier -> 'me_as_carrier -> Basics._focty_bool ;
    (* From species basics#Basic_object. *)
    parse : Basics._focty_string -> 'me_as_carrier ;
    (* From species basics#Basic_object. *)
    print : 'me_as_carrier -> Basics._focty_string ;
    (* From species ok__phd_sample#Monoide. *)
    element : 'me_as_carrier ;
    (* From species ok__phd_sample#Setoide. *)
    different : 'me_as_carrier -> 'me_as_carrier -> Basics._focty_bool ;
    }
  let element abst_un abst__star_ = (abst__star_ abst_un abst_un)
  end ;;

module Setoide_produit =
  struct
  (* Carrier's structure explicitly given by "rep". *)
  type ('a0_as_carrier, 'b1_as_carrier) me_as_carrier =
    'a0_as_carrier * 'b1_as_carrier
  type ('a0_as_carrier, 'b1_as_carrier, 'me_as_carrier) me_as_species = {
    (* From species ok__phd_sample#Setoide_produit. *)
    creer : 'a0_as_carrier -> 'b1_as_carrier -> 'me_as_carrier ;
    (* From species basics#Basic_object. *)
    parse : Basics._focty_string -> 'me_as_carrier ;
    (* From species ok__phd_sample#Setoide_produit. *)
    print : 'me_as_carrier -> Basics._focty_string ;
    (* From species ok__phd_sample#Setoide_produit. *)
    _equal_ : 'me_as_carrier -> 'me_as_carrier -> Basics._focty_bool ;
    (* From species ok__phd_sample#Setoide_produit. *)
    element : 'me_as_carrier ;
    (* From species ok__phd_sample#Setoide. *)
    different : 'me_as_carrier -> 'me_as_carrier -> Basics._focty_bool ;
    }
  let creer (x : 'a0_as_carrier) (y : 'b1_as_carrier) = (Basics.pair x y)
  let print _p_A_print _p_B_print (x : 'me_as_carrier) =
    (Basics._hat_ "("
      (Basics._hat_ (_p_A_print (Basics.fst x))
        (Basics._hat_ "," (Basics._hat_ (_p_B_print (Basics.snd x)) ")"))))
  let _equal_ _p_A__equal_ _p_B__equal_ (x : 'me_as_carrier)
    (y : 'me_as_carrier) =
    (Basics.and_b (_p_A__equal_ (Basics.fst x) (Basics.fst y))
      (_p_B__equal_ (Basics.snd x) (Basics.snd y)))
  let element _p_A_element _p_B_element abst_creer =
    (abst_creer _p_A_element _p_B_element)

  <<<< ATTENTION:                                                   >>>>
  <<<< SKIPPED THE COLLECTION GENERATOR STUFF THAT WE EXPLAIN LATER >>>>
 end ;;
\end{lstlisting}
}


{\footnotesize
\begin{lstlisting}[language=MyCoq]
Module Setoide.
  Record Setoide : Type :=
    mk_record {
    rf_T :> Set ;
    (* From species ok__phd_sample#Setoide. *)
    rf_element : rf_T ;
    (* From species ok__phd_sample#Setoide. *)
    rf__equal_ : rf_T -> rf_T -> basics.bool__t ;
    (* From species basics#Basic_object. *)
    rf_parse : basics.string__t -> rf_T ;
    (* From species basics#Basic_object. *)
    rf_print : rf_T -> basics.string__t ;
    (* From species ok__phd_sample#Setoide. *)
    rf_different : rf_T -> rf_T -> basics.bool__t ;
    (* From species ok__phd_sample#Setoide. *)
    rf_refl : forall x : rf_T, Is_true ((rf__equal_ x x)) ;
    (* From species ok__phd_sample#Setoide. *)
    rf_symm :
      forall x  y : rf_T,
        Is_true ((rf__equal_ x y)) -> Is_true ((rf__equal_ y x))
    }.
  
  Definition different (abst_T : Set)
    (abst__equal_ : abst_T -> abst_T -> basics.bool__t) (x : abst_T)
    (y : abst_T) : basics.bool__t := (basics.not_b (abst__equal_ x y)).
  
End Setoide.

Module Monoide.
  Record Monoide : Type :=
    mk_record {
    rf_T :> Set ;
    (* From species ok__phd_sample#Monoide. *)
    rf_un : rf_T ;
    (* From species ok__phd_sample#Monoide. *)
    rf__star_ : rf_T -> rf_T -> rf_T ;
    (* From species ok__phd_sample#Setoide. *)
    rf__equal_ : rf_T -> rf_T -> basics.bool__t ;
    (* From species basics#Basic_object. *)
    rf_parse : basics.string__t -> rf_T ;
    (* From species basics#Basic_object. *)
    rf_print : rf_T -> basics.string__t ;
    (* From species ok__phd_sample#Monoide. *)
    rf_element : rf_T ;
    (* From species ok__phd_sample#Setoide. *)
    rf_different : rf_T -> rf_T -> basics.bool__t ;
    (* From species ok__phd_sample#Setoide. *)
    rf_refl : forall x : rf_T, Is_true ((rf__equal_ x x)) ;
    (* From species ok__phd_sample#Setoide. *)
    rf_symm :
      forall x  y : rf_T,
        Is_true ((rf__equal_ x y)) -> Is_true ((rf__equal_ y x))
    }.
  
  Definition element (abst_T : Set) (abst_un : abst_T)
    (abst__star_ : abst_T -> abst_T -> abst_T) : abst_T :=
    (abst__star_ abst_un abst_un).
  
End Monoide.

Module Setoide_produit.
  Record Setoide_produit (A_T : Set) (B_T : Set) : Type :=
    mk_record {
    rf_T :> Set ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_creer : A_T -> B_T -> rf_T ;
    (* From species basics#Basic_object. *)
    rf_parse : basics.string__t -> rf_T ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_print : rf_T -> basics.string__t ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf__equal_ : rf_T -> rf_T -> basics.bool__t ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_element : rf_T ;
    (* From species ok__phd_sample#Setoide. *)
    rf_different : rf_T -> rf_T -> basics.bool__t ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_refl : forall x : rf_T, Is_true ((rf__equal_ x x)) ;
    (* From species ok__phd_sample#Setoide_produit. *)
    rf_symm :
      forall x  y : rf_T,
        Is_true ((rf__equal_ x y)) -> Is_true ((rf__equal_ y x))
    }.
  
  Definition creer (_p_A_T : Set) (_p_B_T : Set)
    (abst_T := ((_p_A_T * _p_B_T)%type)) (x : _p_A_T) (y : _p_B_T) :
    abst_T := (basics.pair _ _ x y).
  Definition print (_p_A_T : Set) (_p_B_T : Set) (_p_A_print :
    _p_A_T -> basics.string__t) (_p_B_print : _p_B_T -> basics.string__t)
    (abst_T := ((_p_A_T * _p_B_T)%type)) (x : abst_T) : basics.string__t :=
    (basics._hat_ coq_builtins.___a_string
      (basics._hat_ (_p_A_print (basics.fst _ _ x))
        (basics._hat_ coq_builtins.___a_string
          (basics._hat_ (_p_B_print (basics.snd _ _ x))
            coq_builtins.___a_string)))).
  Definition _equal_ (_p_A_T : Set) (_p_B_T : Set) (_p_A__equal_ :
    _p_A_T -> _p_A_T -> basics.bool__t) (_p_B__equal_ :
    _p_B_T -> _p_B_T -> basics.bool__t) (abst_T := ((_p_A_T * _p_B_T)%type))
    (x : abst_T) (y : abst_T) : basics.bool__t :=
    (basics.and_b (_p_A__equal_ (basics.fst _ _ x) (basics.fst _ _ y))
      (_p_B__equal_ (basics.snd _ _ x) (basics.snd _ _ y))).
  Definition element (_p_A_T : Set) (_p_B_T : Set) (_p_A_element : _p_A_T)
    (_p_B_element : _p_B_T) (abst_T : Set)
    (abst_creer : _p_A_T -> _p_B_T -> abst_T) : abst_T :=
    (abst_creer _p_A_element _p_B_element).
  
  (* From species ok__phd_sample#Setoide_produit. *)
  Theorem refl  (_p_A_T : Set) (_p_B_T : Set) (abst_T : Set)
    (abst__equal_ : abst_T -> abst_T -> basics.bool__t):
    forall x : abst_T, Is_true ((abst__equal_ x x)).
  (* Proof assumed because " ". *)
  apply coq_builtins.magic_prove.
  Qed.
  
  (* From species ok__phd_sample#Setoide_produit. *)
  Theorem symm  (_p_A_T : Set) (_p_B_T : Set) (abst_T : Set)
    (abst__equal_ : abst_T -> abst_T -> basics.bool__t):
    forall x  y : abst_T,
      Is_true ((abst__equal_ x y)) -> Is_true ((abst__equal_ y x)).
  (* Proof assumed because " ". *)
  apply coq_builtins.magic_prove.
  Qed.
  
    <<<< ATTENTION:                                                   >>>>
  <<<< SKIPPED THE COLLECTION GENERATOR STUFF THAT WE EXPLAIN LATER >>>>
End Setoide_produit.
\end{lstlisting}
}



\subsubsection{Defined recursive methods}
The compilation scheme of a recursive function is pretty different and
will be explained in a dedicated section. It however finally uses the
same abstraction mechanism (i.e. $\lambda$-lifted things). The main
difference is induced by the use of the \coq\ construct
``{\tt Function}'' and the need for a termination proof.



\subsection{Fully defined species}
In case a species is fully defined, i.e. all its methods are defined,
no more only declared, the species can be turned into a collection by
an {\tt implements}. To allow creating collections, we must then add
to this species a {\bf collection generator}. The intuitive view.

\subsubsection{Collection generator function's header}
\subsubsection{Local functions}
\subsubsection{Creating the record value}


\section{Collection}
\section{Toplevel functions}
\section{Toplevel theorems}
\section{Type definitions}
\section{External definitions}
