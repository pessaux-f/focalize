% $Id: intermediate.tex,v 1.3 2009-05-12 18:00:34 pessaux Exp $
Once type-checking pass is ended, we saw that in addition to have the
type of each expression computed and screwed in each AST node, we put
the species and collections in normal form, having resolved
inheritance and ordering problems between the methods. More over we
computed the dependency graph of each method, hence indicated for each
method which other method of {\tt Self} is directly depends on (decl
or def, via type, via body or via termination proof).

However this is not sufficient yet to known exactly what to abstract
(i.e. $\lambda$-lift) in our method generators, then collection
generators. We still need to find the complete set of methods of
{\tt Self} a method depends on and the set of collection parameters'
methods a method depends on.

The first point will be carried out by computing the ``visible
universe'' of a method. The second will be by computing the ``minimal
\coq\ typing environment''. Once these sets are known, the current
pass will create a compact form of several data useful for code
generation, hence preventing from having to compute several time the
same things and to ensure that the same structure (in fact, most
often, the order dependencies are abstracted) will be used every time
needed. For instance, if in a method {\tt m} we $\lambda$-lifted
{\tt m2}, then {\tt m1}, extra arguments of this method will appear
and will need to be always used consistently with this order (i.e. one
must sure that we instantiate {\tt m2} by a a method implementing the
signature of {\tt m2} and idem for {\tt m1}. Moreover, since this
$\lambda$-lifts information will be used at various points of the code
generation, it is better to record it once for all instead of compute
it again and again.

All this work is performed by stuff located in the source directly
{\tt src/commoncodegen} whose ``entry'' point is mostly the function
{\tt compute\_abstractions\_for\_fields} of the source file
{\tt src/commoncodegen/abstraction.ml} (note that we have a dedicated
function to process toplevel theorems because they are not hosted in
species although they may require abstractions).

As explained in \ref{becoming-of-typing-output} The call to this pass
is triggered by each target code generator (i.e. once by the
\ocaml\ code generation back-end, and once by the \coq\ one, obviously
only if the code generation is requested for these target languages
via the command line options). Conversely to previous passes, this one
does not enrich any environment. However it takes a code generation
environment. Since we have 2 target languages, we have 2 code
generation environments (c.f. \ref{ocaml-code-gen-envt} and
\ref{coq-code-gen-envt}). Hence, the entry point of abstractions
computation must be able to work with the 2 kinds of
environments. That the reason why the environment is passed as a sum
type
{\footnotesize
\begin{lstlisting}[language=MyOCaml]
type environment_kind =
  | EK_ml of Env.MlGenEnv.t
  | EK_coq of Env.CoqGenEnv.t
\end{lstlisting}
}

\noindent to allow to have only one set of functions to do this pass
instead of duplicating the code and adapting it's behaviour in the few
cases where one are interested in accessing the environment. The
output of this pass is directly used by the code generation that
called it to produce its final output (i.e. target language source
code).



\section{``Computing abstractions''}
As stated in introduction the aim is to fully build the set of
methods of {\tt Self} and the set of collection parameters' methods a
method depends on. At the end of this process, we want to get for each
definition a structure grouping both the information present in the
typing environment and the one synthesised about abstractions. Such a
structure will then be suitable to be sent to a code generation
back-end and looks like:

{\footnotesize
\begin{lstlisting}[language=MyOCaml]
type field_abstraction_info =
  | FAI_sig of
     (Env.TypeInformation.sig_field_info * abstraction_info)
  | FAI_let of
     (Env.TypeInformation.let_field_info * abstraction_info)
  | FAI_let_rec of
     (Env.TypeInformation.let_field_info * abstraction_info) list
  | FAI_theorem of
     (Env.TypeInformation.theorem_field_info * abstraction_info)
  | FAI_property of
     (Env.TypeInformation.property_field_info * abstraction_info)
\end{lstlisting}
}

As we said, the second component of each parameters of the
constructors is a {\tt abstraction\_info} that summarises all the
things we will compute. Nothing very special about the constructors of
this type: it is clear that we have one for each kind of method (just
note that, as we presented before in the type-checking section, there
is no more methods {\tt proof of} since they have been collapsed with
their respective property into theorems). This structure groups the
results of various abstractions computation passes:

{\footnotesize
\begin{lstlisting}[language=MyOCaml]
type abstraction_info = {
  ai_used_species_parameter_tys : Parsetree.vname list ;
  (** Dependencies on species parameters' methods. They are the union of:
        - dependencies found via [BODY] of definition 72 page 153 of Virgile
          Prevosto's Phd,
        - dependencies found via [TYPE] of definition 72 page 153 of Virgile
          Prevosto's Phd,
        - other dependencies found via [DEF-DEP], [UNIVERSE] and [PRM] of
          definition 72 page 153 of Virgile Prevosto's Phd + those found
          by the missing rule in Virgile Prevosto's Phd that temporarily
          named [DIDOU]. *)
  ai_dependencies_from_params :
    ((** The species parameter's name and kind. *)
     Env.TypeInformation.species_param *
     Env.ordered_methods_from_params)  (** The set of methods we depend on. *)
      list ;
  (* Dependencies used to generate the record type's parameters. It only
     contains dependencies obtained by [TYPE] and [DIDOU]. *)
  ai_dependencies_from_params_for_record_type :
    ((** The species parameter's name and kind. *)
     Env.TypeInformation.species_param *
     Env.ordered_methods_from_params)  (** The set of methods we depend on
                                           only through types and completion. *)
      list ;
  ai_min_coq_env : MinEnv.min_coq_env_element list
}
\end{lstlisting}
}

In effect, knowledge of what to $\lambda$-lift is acquired along
different steps (corresponding to rules of definition 72 page 153 in
Virgile Prevosto's PhD + one new rule that didn't exist and appeared
to be mandatory). Hence this structure reminds the state of computed
dependencies at some key steps. In fact, before being able to create
so a summarising (!!$\smiley$) view of the information, we need to
internally remind more key steps and use a more detailed structure
where the results of the consecutive steps are not yet collapsed:

{\footnotesize
\begin{lstlisting}[language=MyOCaml]
type internal_abstraction_info = {
  iai_used_species_parameter_tys : Parsetree.vname list ;
  (** Dependencies found via [BODY] of definition 72 page 153 of Virgile
      Prevosto's Phd. *)
  iai_dependencies_from_params_via_body :
    ((** The species parameter's name and kind. *)
     Env.TypeInformation.species_param *
     Parsetree_utils.ParamDepSet.t)  (** The set of methods we depend on. *)
      list ;
  (** Dependencies found via [TYPE] of definition 72 page 153 of Virgile
      Prevosto's Phd. *)
  iai_dependencies_from_params_via_type :
    ((** The species parameter's name and kind. *)
     Env.TypeInformation.species_param *
     Parsetree_utils.ParamDepSet.t)  (** The set of methods we depend on. *)
      list ;
  (** Dependencies found via only [PRM]. Obviously they are all present in
      the set below ([iai_dependencies_from_params_via_completions]). *)
  iai_dependencies_from_params_via_PRM :
    ((** The species parameter's name and kind. *)
     Env.TypeInformation.species_param *
       Parsetree_utils.ParamDepSet.t)
      list ;
  (** Other dependencies found via [DEF-DEP], [UNIVERSE] and [PRM] of definition
      72 page 153 of Virgile Prevosto's Phd + [DIDOU] applied on the rules
      [DEF-DEP], [UNIVERSE] and [PRM]. *)
  iai_dependencies_from_params_via_completions :
    ((** The species parameter's name and kind. *)
     Env.TypeInformation.species_param *
     Parsetree_utils.ParamDepSet.t)  (** The set of methods we depend on. *)
      list ;
  iai_min_coq_env : MinEnv.min_coq_env_element list
}
\end{lstlisting}
}

As already said, the steps correspond to rules and we will a bit later
explain how they are implemented. The rules deal with dependencies on
species parameters' methods. The only point dealing with
dependencies on methods of {\tt Self} is the ``minimal \coq\ typing
environment stored in the field {\tt iai\_min\_coq\_env} (respectively
in {\tt ai\_min\_coq\_env}).

At the end of each rule, the compiler will record the state of
dependencies on the species parameters for further usage. Finally,
once all the key steps are no more needed, we merge all the
computed dependencies, keeping only the 3 different sets:
\begin{itemize}
\item {\tt used\_species\_parameter\_tys} that records the list of
  collection parameters' names that are used by the species and hence
  that must be abstracted.
\item {\tt ai\_dependencies\_from\_params} that records the dependencies
  on species parameters' methods that need to be abstracted to
  ``write'' (emit the code so that it is well-typed in the target
  language) the definition of the method.
\item {\tt ai\_dependencies\_from\_params\_for\_record\_type} that
  records the dependencies on species parameters that impose
  abstractions when ``writing'' the record type representing the
  species. In effect, the record type doesn't mandatorily requires all
  the dependencies required by the definition of a method. Note that
  in \ocaml, since the record type only makes visible types, there is
  never dependencies on species parameters' methods).
\item {\tt ai\_min\_coq\_env} the minimal \coq\ typing environment that
  describes the set of methods of {\tt Self} that must be abstracted
  because of dependencies in the method.
\end{itemize}


Hence, the abstractions computation is done in 2 shots. The inner one
that processes fields and create the internal abstraction structure
(function {\tt \_\_compute\_abstractions\_for\_fields} returning a
list of {\tt internal\_field\_abstraction\_info}. We may note that
this function is a ``fold'' since at some point, to recover the
already computed dependencies from parameters on previous fields since
this info will possibly used to apply rules [{\tt DEF-DEP}],
[{\tt UNIVERSE}] and [{\tt PRM}] of definition 72 page 153 from
Virgile Prevosto's Phd. next, the outer one (the only exported
outside) that is in fact a wrapper around the inner one, and that only 
merge the abstraction information {\bf and sort it} (that was missing
in Virgile Prevosto's PhD) to get the ``compact'' representation of
the abstraction for each method (i.e. it then returns a
{\tt field\_abstraction\_info list}).

Since the core of the computation is hosted in the inner function, we
will investigate its work in detail. The outer function doesn't
present any special difficulty and will be explained in a shorter way.


\section{The inner computation}
The basic process to apply to a method is always the same. Only
{\tt signature}s are a bit simpler because some rules do not apply
(i.e. trivially lead to empty sets of dependencies). Hence, we will
expose the general case, more specifically presenting the case of
theorems when we need an example (since for them, no rule lead to
trivially empty dependencies sets since theorems can induce both def
and decl-dependencies).

\medskip
\subsubsection{{\tt compute\_lambda\_liftings\_for\_field}}
The first step is to compute the dependencies on species parameters
appearing in the body of the method. This is basically the rule
[BODY]. This process is done by a structural descent on the body of
the method, looking for identifiers of the form {\tt C!meth}.

.......................ICI


By the way, we recover the decl and def-children of the current
method. The idea is simply to split the list of children of the node
representing the current method in 2 parts, the ones whose edge is
tagged {\tt DepGraphData.DK\_decl} and the ones whose edge is tagged
{\tt DepGraphData.DK\_def}. We do this at this stage because these 2
lists will be useful later and this allows to directly compute the
species parameters' carriers appearing in the type of the method. This
could be done in a separate part, but that's simply our historic
choice. May be the reason of this history is that before, dependency
computation for \ocaml\ and for \coq\ each used a pretty different
algorithm. And in the \ocaml\ code generation, since there was less
things to compute, we did all in the same pass. Later, when the
compilation process was better understood, we identified the common
algorithm and rules and made to that now abstractions computation is
exactly the same for both target languages. And then, the part dealing
with def and decl-dependencies splitting remained here.


\section{The outer computation (wrapper)}
Donner le processus appliqué sur 1 champ, ceci étant pareil pour tous
les types de champs. Parler du merge, du remap (!!!!) et du tri.
