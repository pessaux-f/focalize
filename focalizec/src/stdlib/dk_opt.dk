#NAME dk_opt.

(; options ;)
option : cc.uT -> cc.uT.
Option : cc.uT -> Type.
[ A : cc.uT ] Option A --> cc.eT (option A).

None : A : cc.uT -> Option A.
Some : A : cc.uT -> cc.eT A -> Option A.

match_option : A : cc.uT ->
               P : (Option A -> cc.uT) ->
               cc.eT (P (None A)) ->
               (a : cc.eT A -> cc.eT (P (Some A a))) ->
               o : Option A ->
               cc.eT (P o).
[A : cc.uT,
 P : Option A -> cc.uT,
 Hnone : cc.eT (P (None A)),
 Hsome : a : cc.eT A -> cc.eT (P (Some A a))]
    match_option A P Hnone Hsome (None A) --> Hnone
[A : cc.uT,
 P : Option A -> cc.uT,
 Hnone : cc.eT (P (None A)),
 Hsome : a : cc.eT A -> cc.eT (P (Some A a)),
 a : cc.eT A]
    match_option A P Hnone Hsome (Some A a) --> Hsome a.

simple_match_option : A : cc.uT ->
                      return : cc.uT ->
                      cc.eT return ->
                      (a : cc.eT A -> cc.eT return) ->
                      o : Option A ->
                      cc.eT return
                    :=
                      A : cc.uT =>
                      return : cc.uT =>
                      match_option A (_x : cc.eT (option A) => return).
