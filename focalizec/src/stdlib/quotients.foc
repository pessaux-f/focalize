(***********************************************************************)
(*                                                                     *)
(*                        FoCaL compiler                               *)
(*            Renaud Rioboo                                            *)
(*            Virgile Prevosto                                         *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                               LIP6   -  INRIA Rocquencourt          *)
(*                                                                     *)
(*  Copyright 2007 LIP6 and INRIA                                      *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: quotients.foc,v 1.4 2008-09-12 09:56:19 pessaux Exp $ *)

(** Renaud Rioboo based on Louis Mandel's code.
    Quotient structures. *)

(* ************************************************************************)
(* Auteur : Louis Mandel   louis.mandel@aemiaif.lip6.fr                   *)
(**************************************************************************)

use "sets_orders" ;;
use "additive_law" ;;
use "multiplicative_law" ;;
use "weak_structures" ;;
use "rings_fields" ;;

open "weak_structures" ;;


species Function_reduire (T is additive_law#Additive_group) =
  rep = T -> T ;
  signature reduire : T -> T ;
end ;;


(**
To be revised, incomplete notions
*)
species Quotient_group (G is additive_law#Additive_group,
                        Red is Function_reduire (G),
                        reduire in Red)
 (* here we assume that reduire is compatible with some equivalence relation *)
  inherits additive_law#Additive_group =

  (** 
    an element of g should be reduced 
  *)
  rep = G ;

  let equal (x, y) = G!equal (x, y) ;
  proof of equal_reflexive = assumed {* Because todo *} ;
  proof of equal_symmetric = assumed {* Because todo *} ;
  proof of equal_transitive = assumed {* Because todo *} ;

  let to_rep (x in Self) in G = x ;
  let zero = G!zero ;
  proof of zero_is_neutral = assumed {* Because todo *} ;
  let plus (x, y) = Red!reduire (G!plus (x, y)) ;
  proof of plus_is_right_regular = assumed {* Because todo *} ;
  proof of plus_is_left_regular = assumed {* Because todo *} ;
  proof of plus_is_associative = assumed {* Because todo *} ;
  proof of plus_commutes = assumed {* Because todo *} ;
  proof of plus_left_substitution_rule = assumed {* Because todo *} ;
  proof of plus_right_substitution_rule = assumed {* Because todo *} ;
  let opposite (x) = Red!reduire (G!opposite (x)) ;
  proof of opposite_is_opposite = assumed {* Because todo *} ;
  let print = G!print ;
end ;;

(**
To be revised incomplete notions
*)
species Quotient_ring (R is rings_fields#Commutative_ring,
                       Red is Function_reduire (R),
                       reduire in Red)
  inherits Quotient_group (R, Red, reduire), rings_fields#Commutative_ring =
 (* again we assume that reduire is compatible *)
  let one = R!one ;
  proof of one_is_left_neutral = assumed {* Because todo *} ;
  let is_one = R!is_one ;
  let mult (x, y) = Red!reduire (R!mult (x, y)) ;
  proof of mult_left_distributes_on_plus = assumed {* Because todo *} ;
  proof of mult_commutes = assumed {* Because todo *} ;
  proof of mult_left_substitution_rule = assumed {* Because todo *} ;
  proof of mult_right_substitution_rule = assumed {* Because todo *} ;
  proof of mult_assoc = assumed {* Because todo *} ;
end ;;

(* [Unsure] Snipped.

(**
This is the quotient of a ring by a principal ideal
*)
species Modular_ring (R is rings_fields#Euclidean_domain, n in R) 
    inherits Quotient_ring (R, (function x -> R!remainder (x, n))) =
end ;;


(**
Some quotient rings are fields
*)
species Modular_field (R is rings_fields#Euclidean_domain, n in R)
  inherits Modular_ring (R, n), Field =

  (** n is assumed to be prime *)
  proof of mult_is_integral = assumed {* Because todo *} ;

  (** we define inversion and divison from inversion *)
  let inv (x) = 
   let res = R!bezout (x, n) in
   let g = weak_structures#gcd (res) in
   let c1 = weak_structures#coef1 (res) in      
   let ig = R!recip (g) in
   if #is_failed (ig)
   then #foc_error ("ModField: inv: Bad Gcd")
   else  R!remainder (R!mult (based#non_failed (ig), c1), n) ;
  proof of inv_substitution_rule = assumed {* Because todo *} ;

  let div (x, y) = !mult (x, !inv (y)) ;

  proof of div_left_substitution_rule = 
   by property !mult_left_substitution_rule
      definition of div ;

  proof of div_right_substitution_rule = 
   by property !mult_right_substitution_rule, !inv_substitution_rule
      definition of div ;

  proof of div_is_complete = assumed {* Because todo *} ;
end ;;
*)
