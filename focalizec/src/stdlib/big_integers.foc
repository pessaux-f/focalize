(** Ocamls bigint in FoC *)
type big_int =
  internal
  external
  | caml -> {*  Big_int.big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integers_t *}
;;

type foc_nat =
  internal
  external
  | caml -> {* Nat.nat *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integers_nat *}
;;

let zero_big_int =
  internal big_int
  external
  | caml -> {* Big_int.zero_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_zero_big_int *}
;;

let unit_big_int =
  internal big_int
  external
  | caml -> {* Big_int.unit_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_unit_big_int *}
;;

let minus_big_int =
  internal big_int -> big_int
  external
  | caml -> {* Big_int.minus_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_minus_big_int *}
;;

let abs_big_int =
  internal big_int -> big_int
  external
  | caml -> {* Big_int.abs_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_abs_big_int *}
;;

let add_big_int =
  internal big_int -> big_int -> big_int
  external
  | caml -> {* Big_int.add_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_add_big_int *}
;;
let succ_big_int =
  internal big_int -> big_int
  external
  | caml -> {* Big_int.succ_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_succ_big_int *}
;;

let add_int_big_int =
  internal basics#int -> big_int -> big_int
  external
  | caml -> {* Big_int.add_int_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_add_int_big_int *}
;;

let sub_big_int =
  internal big_int -> big_int -> big_int
  external
  | caml -> {* Big_int.sub_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_sub_big_int *}
;;

let pred_big_int =
  internal big_int -> big_int
  external
  | caml -> {* Big_int.pred_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_pred_big_int *}
;;

let mult_big_int =
  internal big_int -> big_int -> big_int
  external
  | caml -> {* Big_int.mult_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_mult_big_int *}
;;

let mult_int_big_int =
  internal basics#int -> big_int -> big_int
  external
  | caml -> {* Big_int.mult_int_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_mult_int_big_int *}
;;

let square_big_int =
  internal big_int -> big_int
  external
  | caml -> {* Big_int.square_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_square_big_int *}
;;

let sqrt_big_int =
  internal big_int -> big_int
  external
  | caml -> {* Big_int.sqrt_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_sqrt_big_int *}
;;

let quomod_big_int =
  internal big_int -> big_int -> (big_int * big_int)
  external
  | caml -> {* Big_int.quomod_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_quomod_big_int *}
;;

let div_big_int =
  internal  big_int -> big_int -> big_int
  external
  | caml -> {* Big_int.div_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_div_big_int *}
;;

let mod_big_int =
  internal big_int -> big_int -> big_int
  external
  | caml -> {* Big_int.mod_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_mod_big_int *}
;;

let gcd_big_int =
  internal big_int -> big_int -> big_int
  external
  | caml -> {* Big_int.gcd_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_gcd_big_int *}
;;

let power_int_positive_int =
  internal basics#int -> basics#int -> big_int
  external
  | caml -> {* Big_int.power_int_positive_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_power_int_positive_int *}
;;

let power_big_int_positive_int =
 internal big_int -> basics#int -> big_int
 external
  | caml -> {* Big_int.power_big_int_positive_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_power_big_int_positive_int *}
;;

let power_int_positive_big_int =
  internal basics#int -> big_int -> big_int
  external
  | caml -> {* Big_int.power_int_positive_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_power_int_positive_big_int *}
;;

let power_big_int_positive_big_int =
  internal big_int -> big_int -> big_int
  external
  | caml -> {* Big_int.power_big_int_positive_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_power_int_positive_big_int *}
;;

let sign_big_int =
  internal big_int -> basics#int
  external
  | caml -> {* Big_int.sign_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_sign_big_int *}
;;

let compare_big_int =
  internal big_int -> big_int -> basics#int
  external
  | caml -> {* Big_int.compare_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_compare_big_int *}
;;

let eq_big_int =
  internal big_int -> big_int -> basics#bool
  external
  | caml -> {* Big_int.eq_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_eq_big_int *}
;;

let le_big_int =
  internal big_int -> big_int -> basics#bool
  external
  | caml -> {* Big_int.le_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_le_big_int *}
;;

let ge_big_int =
  internal big_int -> big_int -> basics#bool
  external
  | caml -> {* Big_int.ge_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_ge_big_int *}
;;

let lt_big_int =
  internal big_int -> big_int -> basics#bool
  external
  | caml -> {* Big_int.lt_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_lt_big_int *}
;;

let gt_big_int =
  internal big_int -> big_int -> basics#bool
  external
  | caml -> {* Big_int.gt_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_gt_big_int *}
;;

let max_big_int =
  internal big_int -> big_int -> big_int
  external
  | caml -> {* Big_int.max_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_max_big_int *}
;;

let min_big_int =
  internal big_int -> big_int -> big_int
  external
  | caml -> {* Big_int.min_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_mon_big_int *}
;;

let num_digits_big_int =
  internal big_int -> basics#int
  external
  | caml -> {* Big_int.num_digits_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_num_digits_big_int *}
;;

let string_of_big_int =
  internal big_int -> basics#string
  external
  | caml -> {* Big_int.string_of_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_string_of_big_int *}
;;

let big_int_of_string =
  internal basics#string -> big_int
  external
  | caml -> {* Big_int.big_int_of_string *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_big_int_of_string *}
;;

let big_int_of_int =
  internal basics#int -> big_int
  external
  | caml -> {* Big_int.big_int_of_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_big_int_of_int *}
;;

let is_int_big_int =
  internal big_int -> basics#bool
  external
  | caml -> {* Big_int.is_int_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_is_int_big_int *}
;;

let int_of_big_int =
  internal big_int -> basics#int
  external
  | caml -> {* Big_int.int_of_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_int_of_big_int *}
;;

let float_of_big_int =
  internal big_int -> basics#float
  external
  | caml -> {* Big_int.float_of_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_float_of_big_int *}
;;

let nat_of_big_int =
  internal big_int -> foc_nat
  external
  | caml -> {* Big_int.nat_of_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_nat_of_big_int *}
;;

let big_int_of_nat =
  internal foc_nat -> big_int
  external
  | caml -> {* Big_int.big_int_of_nat *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_big_int_of_nat *}
;;

let base_power_big_int =
  internal basics#int -> basics#int -> big_int -> big_int
  external
  | caml -> {* Big_int.base_power_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_base_power_big_int *}
;;

let sys_big_int_of_string =
  internal basics#string -> basics#int -> basics#int -> big_int
  external
  | caml -> {* Big_int.sys_big_int_of_string *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_sys_big_int_of_string *}
;;

let round_futur_last_digit =
  internal basics#string -> basics#int -> basics#int -> basics#bool
  external
  | caml -> {* Big_int.round_futur_last_digit *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_round_futur_last_digit *}
;;

let approx_big_int =
  internal basics#int -> big_int -> basics#string
  external
  | caml -> {* Big_int.approx_big_int *}
  | coq -> {* (* [Unsure] *) *}
  | "c" -> {* big_integer_approx_big_int *}
;;

use "additive_law" ;;
use "weak_structures" ;;
use "rings_fields" ;;
use "integers" ;;

open "weak_structures" ;;

(** Basic big integers simply form a monoid with an element one*)
species Base_big_int
  inherits additive_law#Cancellative_additive_monoid, Unitary_additive_monoid =
  rep = big_int ;
  let one = #unit_big_int ;
  let zero = #zero_big_int ;
  let is_zero (m)= #eq_big_int (m, #zero_big_int) ;
  proof of is_zero_spec = by definition of is_zero, zero, equal ;
  let plus (m, n) = #add_big_int (m, n) ;
  proof of zero_is_neutral= assumed {* Because todo *} ;
  proof of plus_is_left_regular = assumed {* Because todo *} ;
  proof of plus_is_associative = assumed {* Because todo *} ;
  proof of plus_commutes = assumed {* Because todo *} ;
  proof of plus_right_substitution_rule = assumed {* Because todo *} ;
  let equal (m, n) =  #eq_big_int (m, n) ;
  proof of equal_symmetric = assumed {* Because todo *} ;
  proof of equal_reflexive = assumed {* Because todo *} ;
  proof of equal_transitive = assumed {* Because todo *} ;
  let of_int (n) = #big_int_of_int (n) ;
  let print = #string_of_big_int ;
  let parse = #big_int_of_string ;
end ;;

collection Foc_basic_integers implements Base_big_int ;;

(** Big integers *)
species Integers_big_int inherits integers#Integer_system, Base_big_int =
  proof of one_is_left_neutral = assumed {* Because todo *};
  let mult (m, n) = #mult_big_int (m, n) ;
  proof of mult_is_integral = assumed {* Because todo *} ;
  proof of mult_assoc = assumed {* Because todo *} ;
  proof of mult_commutes = assumed {* Because todo *} ;
  proof of mult_left_distributes_on_plus = assumed {* Because todo *} ;
  proof of mult_left_substitution_rule = assumed {* Because todo *} ;
  let sign (x) = #sign_big_int (x) ;
  proof of order_compatible_with_plus = assumed {* Because todo *} ;
  proof of mult_compat_with_order = assumed {* Because todo *} ;

  let quo_rem (m, n) =
    let nn = n in
    let mm = m in
      let s = #sign_big_int (nn) in
      if basics#int_eq (s, 0) then basics#foc_error ("must be non zero")
      else
        let qr = #quomod_big_int (mm, ( #mult_int_big_int (s, nn))) in
        let q = basics#first (qr) in let r = basics#scnd (qr) in
        cr_qrr (#mult_int_big_int (s, q), r);

  let opposite (x) = #minus_big_int (x) ;

  proof of opposite_is_opposite = assumed {* Because todo *} ;

  logical let euclidean_ordering (x, y) =
    if basics#int_lt (!sign(x), 0) then
      if basics#int_lt (#sign_big_int (y), 0) then !lt (x, y)
      else !lt (x, !opposite (y))
    else
      if basics#int_lt (#sign_big_int (y), 0) then !lt (x, !opposite (y))
      else !lt (x, y) ;

  proof of euclidean_ordering_is_irreflexive = assumed {* Because todo *} ;
  proof of euclidean_order_is_antisymmetric = assumed {* Because todo *} ;
  proof of euclidean_ordering_is_transitive = assumed {* Because todo *} ;
  proof of remainder_is_smaller = assumed {* Because todo *} ;
end ;;

collection Foc_big_integers implements Integers_big_int ;;
