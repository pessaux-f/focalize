(***********************************************************************)
(*                                                                     *)
(*                        FoCaL compiler                               *)
(*            Renaud Rioboo                                            *)
(*            Virgile Prevosto                                         *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                               LIP6  -  INRIA Rocquencourt           *)
(*                                                                     *)
(*  Copyright 2007 LIP6 and INRIA                                      *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: sets.fcl,v 1.2 2008-10-14 07:33:45 weis Exp $ *)

(** Basic sets operations, orderings and lattices. *)

use "basics";;
open "basics";;

(** In a setoid, we can test the equality (note for logicians: this is
   a congruence). The setoid can not be empty. *)
species Setoid inherits Basic_object =

  (** @mathml <eq/> *)
  (* sig ( = ) : Self -> Self -> bool ; *)
  signature equal : Self -> Self -> bool ;

  (*
  property ``equal is reflexive'' : all x y in Self,
    Self!( = ) (x, x) and x = x ;
   *)
  property equal_reflexive : all x in Self, !equal (x, x) ;

  property equal_symmetric : all x y in Self,
    Self!equal(x, y) -> !equal(y, x) ;

  property equal_transitive : all x y z in Self,
    !equal(x, y) -> !equal(y, z) -> !equal(x, z) ;

  (** element returns some element of our non empty setoid *)
  signature element : Self ;

  (** @mathml <neq/> *)
  let different (x, y) = basics#not_b(!equal(x, y)) ;

  theorem same_is_not_different : all x y in Self,
     !different(x, y) <-> ~ (!equal(x, y))
  proof:
    by definition of different ;

  theorem different_is_irreflexive: all x in Self,
    ~ (!different (x, x))
  proof:
    (* by property ``equal is reflexive'', same_is_not_different *)
    by property equal_reflexive, same_is_not_different ;

  theorem different_is_symmetric: all x y in Self,
    !different (x, y) -> !different (y, x)
  proof: by property equal_symmetric, same_is_not_different ;

end
;;

(**
   By an Anti_setoid we mean a setoid where appartness id considered as a
   primitive operation. We have the same functiuonalities as Setoid!
*)

species Anti_setoid inherits Basic_object =
  (** An appartness decidable relation *)
  signature different: Self -> Self -> bool;

  property different_is_symmetric: all x y in Self,
    !different (x, y) -> !different (y, x);

  property different_is_irreflexive: all x in Self,
    ~ (!different (x, x));

  (**
     Take two distinct elements then any third element is distinct from
     one of the first two
  *)
  property different_is_complete: all x y z in Self,
    !different(x, y) -> (!different(x, z) \/ !different(y, z));

  (** element returns some element of our non empty setoid *)
  signature element : Self ;

  let equal(x, y) = basics#not_b(!different(x, y));

  theorem same_is_not_different : all x y in Self,
    !equal(x, y) <-> ~ (!different(x, y))
  proof: by definition of equal ;

  theorem equal_reflexive: all x in Self, !equal(x, x)
    proof: by property !same_is_not_different, !different_is_irreflexive ;

  theorem equal_symmetric: all x y in Self,
    Self!equal(x, y) -> !equal(y, x)
    proof: by property !different_is_symmetric, !same_is_not_different ;

  theorem equal_transitive : all x y z in Self,
    !equal(x, y) -> !equal(y, z) -> !equal(x, z)
    proof:
     by property !different_is_complete, !different_is_symmetric,
                       !different_is_irreflexive, !same_is_not_different ;
end
;;

(**
   Here we state that in some cases we may view partial operations
   as total operations.
   This requires to include some form of predicate for failing operations.

 *)
species Partial_set inherits Setoid =
  (** this is intended to model failure *)
  let failed in (string -> Self) =
    let ifailed (r in string, elt in Self) in Self =
      external
      | caml -> {* Sets_externals.i_failed r elt *}
      | coq -> {* elt *}
      end in
    function reason -> ifailed (reason, !element) ;
end
;;

(**
   The FoCaL way to use functions, abstract into a species!
 *)
species Setoid_morphism(A is Setoid, B is Setoid)
  (** strictly speaking we don't need rep here *)
  inherits Basic_object =
    (** an explicit signature *)
    signature morph: A -> B;
    (**
      A function taking setoids as arguments should be compatible with equality
     *)
    property morph_substitution_rule: all x y in A,
      A!equal(x, y) -> B!equal(!morph(x), !morph(y));
end
;;


