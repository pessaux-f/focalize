(***********************************************************************)
(*                                                                     *)
(*                        FoCaL compiler                               *)
(*            Renaud Rioboo                                            *)
(*            Virgile Prevosto                                         *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                               LIP6  -  INRIA Rocquencourt           *)
(*                                                                     *)
(*  Copyright 2007 LIP6 and INRIA                                      *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: sets_orders.fcl,v 1.13 2008-09-11 09:26:21 pessaux Exp $ *)

(** Basic sets operations, orderings and lattices. *)

-- This is a file in new syntax!

use "basics";;
open "basics";;

(** In a setoid, we can test the equality (note for logicians: this is
   a congruence). The setoid can not be empty. *)
species Setoid inherits Basic_object =

  (** @mathml <eq/> *)
  (* sig ( = ) : Self -> Self -> bool ; *)
  signature equal : Self -> Self -> bool ;

  (*
  property ``equal is reflexive'' : all x y in Self,
    Self!( = ) (x, x) and x = x ;
   *)
  property equal_reflexive : all x in Self, !equal (x, x) ;

  property equal_symmetric : all x y in Self,
    Self!equal(x, y) -> !equal(y, x) ;

  property equal_transitive : all x y z in Self,
    !equal(x, y) -> !equal(y, z) -> !equal(x, z) ;

  (** element returns some element of our non empty setoid *)
  signature element : Self ;

  (** @mathml <neq/> *)
  let different (x, y) = basics#not_b(!equal(x, y)) ;

  theorem same_is_not_different : all x y in Self,
     !different(x, y) <-> ~( !equal(x, y))
  proof:
    by definition of different ;

  theorem different_is_irreflexive: all x in Self,
    ~ (!different (x, x))
  proof:
    (* by property ``equal is reflexive'', same_is_not_different *)
    by property equal_reflexive, same_is_not_different ;

  theorem different_is_symmetric: all x y in Self,
    !different (x, y) -> !different (y, x)
  proof: by property equal_symmetric, same_is_not_different ;

end
;;

(**
  This is a first attempt to specify representations.
  We define two functions and two properties relating
  concrete values of rep and abstract values of Self
*)
species Represented_by (S is Basic_object) inherits Setoid =

  rep = S ;

  (** An element of Self is encoded by an element of S. *)
  let to_rep (x in Self) in S = x ;

  (** One should be able to describe which values of s correspond to some
     abstract Self. *)
  signature represents_some_Self : S -> prop;

  (** A way to abstract concrete values, not intended to be used by the
     programmer *)
  signature from_rep : S -> Self;

  (** This property enables to state theorems about abstract Self. *)
  logical let correct_representation (x) =
    !represents_some_Self (!to_rep (x))
  ;

  theorem correct_rep_spec: all x in Self,
     !correct_representation (x) <-> !represents_some_Self (!to_rep (x))
     proof: by definition of correct_representation
  ;

  (** Combining to_rep and from_rep gives identity. *)
  property to_rep_reverses: all x in Self, !equal (!from_rep (!to_rep (x)), x) ;

  (** Since we provide an injection to s from_rep is a surjection. *)
  theorem from_rep_is_surjective: all x in Self, ex y in S,
    !equal (!from_rep (y), x)
  proof:
   <1>1 assume x in Self,
        prove !equal (!from_rep (x), x)
        by property to_rep_reverses
        definition of to_rep
   <1>f qed.
  ;

  (** Every element of Self should verify an invariant. *)
  property correct_invariant: all x in Self, !correct_representation (x) ;

  (** By default we print the concrete data. *)
  let print (x) = S!print (!to_rep (x)) ;
  (** By default we parse concrete data and abstract it. *)
  let parse (p) = !from_rep (S!parse (p)) ;
end
;;


(**
   Here we state that in some cases we may view partial operations
   as total operations.
   This requires to include some form of predicate for failing operations.

 *)
species Partial_set inherits Setoid =

  (** this is intended to model failure*)
  let failed in (string -> Self) =
    let ifailed (r in string, elt in Self) in Self =
       external
       | caml -> {* Sets_orders_externals.i_failed r elt *}
       | coq -> {* elt *}
       end in
    function reason -> ifailed (reason, !element) ;
end ;;



(** pre orderings are sometimes called quasi orderings *)
species Pre_order inherits Setoid =
  (** leq(x,y) is x &le; y
      @mathml <leq/> *)
  signature leq : Self -> Self -> bool;

  property leq_reflexive: all x y in Self,
    !equal (x, y) -> !leq (x, y) ;
  property leq_transitive: all x y  z in Self,
    !leq (x, y) -> !leq (y, z) -> !leq (x, z) ;

   (** we may reverse inequalities by simply changing notations
    @mathml <geq/> *)
  let geq(x, y)= !leq(y, x);

  (** a characteristic property *)
  theorem geq_is_leq: all x y in Self,
    (!geq(x, y) -> !leq(y, x)) /\  (!leq(x, y) -> !geq(y, x))
    proof: by definition of geq
  ;

  theorem geq_reflexive: all x y in Self, !equal(x, y) -> !geq(x, y)
  proof: by property leq_reflexive, equal_symmetric, geq_is_leq
  ;

  theorem geq_transitive: all x y z in Self,
    !geq(x, y) -> !geq(y, z) -> !geq(x, z)
    proof: by property leq_transitive, geq_is_leq
  ;


  (** strict inequality
     @mathml <lt/> *)
  let lt(x, y) = basics#and_b(!leq(x, y), basics#not_b(!equal(x, y)));

  (** some results about strict and large inequalities *)
  theorem lt_is_not_leq : all x y in Self,
    ((!lt(x, y) -> (!leq(x, y) /\ !different(x, y)))
  /\
     (!leq(x, y) -> (!lt(x, y) \/ !equal(x, y))))
    proof:
      by definition of lt, different
  ;



  (** @mathml <gt/> *)
  let gt(x, y) = !lt(y, x);

  theorem gt_is_lt: all x y in Self,
    (!gt(x, y) -> (!geq(x, y) /\ !different(x, y)))
  /\
    (!geq(x, y) -> (!gt(x, y) \/ !equal(x, y)))
    proof:
      by property lt_is_not_leq, equal_symmetric
         definition of gt, geq, different
  ;

end
;;


(** In a set an ordering is often called a partial order *)
species Partial_order inherits Pre_order =
  property leq_antisymmetric:  all x y in Self,
    !leq(x, y) -> !leq(y, x) -> !equal(x, y)
  ;


  theorem geq_antisymmetric: all x y in Self,
    !geq(x, y) -> !geq(y, x) -> !equal(x, y)
    proof: by property leq_antisymmetric, geq_is_leq
  ;

end
;;

(** in a meet semi lattice we have an operation inducing an ordering (&lt;=)*)
species Meet_semi_lattice inherits Setoid =
  (** the infimum of two elements *)
  (* [rr]: need a mathml symbol for that,
     we don't want to use <min/> nor <intersect/>
  *)
  signature inf : Self -> Self -> Self ;
  (** compatibility with equality *)
  property inf_left_substitution_rule : all x y z in Self,
    !equal (x, y) -> !equal (!inf (x, z), !inf (y, z))
  ;
  (** inf is a commutative law*)
  property inf_commutes : all x y in Self,
    !equal(!inf(x, y), !inf(y, x));
  (**
     for a  commutative law right congruence is a consequence
      of left congruence
   *)
  theorem inf_right_substitution_rule : all x y z in Self,
     !equal(y, z) -> !equal(!inf(x, y), !inf(x, z))
     proof:
       by property
          inf_left_substitution_rule,
          inf_commutes,
          (*!equal_reflexive,*)
          equal_transitive
     ;
  (** users should use global congruence when possible *)
  theorem inf_substitution_rule: all x y z t in Self,
    !equal(x, y) -> !equal(z, t) -> !equal(!inf(x, z), !inf(y, t))
(*    !equal(x, y) -> !equal(y, t) -> !equal(!inf(x, y), !inf(y, t)) *)
    proof:
      by property
         inf_left_substitution_rule, inf_right_substitution_rule,
         (* [rr]: if not given reflexivity Zenon fails *)
         (* [dd]: now it works *)
         (* [pw]: now it breaks again! *)
         equal_transitive(*, equal_reflexive*)
    ;
  (* inf is an associative law *)
  property inf_is_associative : all x y z in Self,
    !equal(!inf(!inf(x, y), z), !inf(x, !inf(y, z)));
  (* inf is an idempotent law  *)
  property inf_idempotent : all x y in Self,
    !equal(x, y) -> !equal(x, !inf(x, y));

  (** order_inf is the least defined ordering compatible with inf *)
  (* [rr]: need a mathml symbol for that,
     we don't want to use <leq/>
  *)
  let order_inf(x, y) = !equal(x, !inf(x, y));
  theorem order_inf_is_reflexive : all x y in Self,
     !equal(x, y) -> !order_inf(x, y)
     proof :
       by property inf_idempotent
       definition of order_inf
     ;

  theorem order_inf_is_antisymmetric : all x y in Self,
     !order_inf(x, y) -> !order_inf(y, x) -> !equal(x, y)
     (* x=inf(x, y) et y=inf(x, y) *)
     proof:
       by
        property inf_commutes, equal_transitive, equal_symmetric
        definition of order_inf
     ;
  theorem order_inf_is_transitive : all x y z in Self,
     !order_inf(x, y) -> !order_inf(y, z) -> !order_inf(x, z)
     (* x=inf(x, y) et y=inf(y, z) x=inf(x, inf(y, z))=inf(inf(x, y), z)=inf(x, z)*)
     proof:
       <1>1 assume x in Self,
            assume y in Self,
            assume z in Self,
            assume H1: !order_inf (x, y),
            assume H2: !order_inf (y, z),
            prove !order_inf (x, z)
         <2>0 prove !equal (x, !inf (x, y))
           by
             hypothesis H1
             definition of order_inf
         <2>1 prove !equal (x, !inf (x, !inf (y, z)))
           by
              step <2>0
              hypothesis H2
              property inf_right_substitution_rule, equal_transitive
              definition of order_inf
         <2>2 prove !equal (x, !inf (!inf (x, y), z))
           by
              step <2>1
              property inf_is_associative, equal_transitive, equal_symmetric
         <2>3 prove !equal (x, !inf (x, z))
              by step <2>2, <2>0
                 property equal_symmetric, equal_transitive,
                   inf_left_substitution_rule
         <2>4 qed
              by step <2>3
                 definition of order_inf
       <1>2 qed.
     ;
  (** any element smaller than x and y is smaller than their infimum *)
  theorem order_inf_is_infimum: all x y i in Self,
    !order_inf(i, x) -> !order_inf(i, y) ->
      !order_inf(i, !inf(x, y))
    proof:
      <1>1 assume x in Self,
           assume y in Self,
           assume i in Self,
           assume H1: !order_inf(i, x),
           assume H2: !order_inf(i, y),
           prove !order_inf(i, !inf(x, y))
        <2>1 prove !equal(i, !inf(!inf(i, x), y))
          by hypothesis H1, H2
             property inf_left_substitution_rule,
               equal_symmetric, equal_transitive
             definition of order_inf
        <2>9 qed
          by step <2>1
             property inf_is_associative, equal_transitive
             definition of order_inf
      <1>2 qed.
    ;

end
;;


(** in a join semi lattice we have an operation inducing an ordering (&gt;=) *)
species Join_semi_lattice inherits Setoid =

  (** the supremum of two elements *)
  (* [rr]: need a mathml symbol for that,
     we don't want to use <max/> nor <union/>
  *)
  signature sup : Self -> Self -> Self ;
  (** compatibility with equality *)
  property sup_left_substitution_rule : all x y z in Self,
    !equal (x, y) -> !equal (!sup (x, z), !sup (y, z))
  ;
  property sup_commutes : all x y in Self,
    !equal(!sup(x, y), !sup(y, x));

  (**
     for a  commutative law right congruence is a consequence
      of left congruence
   *)
  theorem sup_right_substitution_rule : all x y z in Self,
     !equal(y, z) -> !equal(!sup(x, y), !sup(x, z))
     proof:
       by
        property sup_left_substitution_rule, sup_commutes, equal_transitive
     ;
  (** users should use global congruence when possible *)
  theorem sup_substitution_rule: all x y z t in Self,
    !equal(x, y) -> !equal(z, t) -> !equal(!sup(x, z), !sup(y, t))
(*    !equal(x, y) -> !equal(y, t) -> !equal(!sup(x, y), !sup(y, t)) *)
    proof:
      by
        property sup_left_substitution_rule, sup_right_substitution_rule,
           (* [rr]: if not given reflexivity Zenon fails *)
           equal_transitive(*, !equal_reflexive*)
    ;
  (* sup is an associative law *)
  property sup_is_associative : all x y z in Self,
    !equal(!sup(!sup(x, y), z), !sup(x, !sup(y, z)));
  (* sup is an idempotent law  *)
  property sup_idempotent : all x y in Self,
    !equal(x, y) -> !equal(x, !sup(x, y));

  (** order_sup is the least defined ordering compatible with sup *)
  (* [rr]: need a mathml symbol for that,
     we don't want to use <geq/>
  *)
  let order_sup(x, y) = !equal(x, !sup(x, y));

  theorem order_sup_is_reflexive : all x y in Self,
     !equal(x, y) -> !order_sup(x, y)
     proof:
       by property sup_idempotent
          definition of order_sup
  ;

  theorem order_sup_is_antisymmetric : all x y in Self,
     !order_sup(x, y) -> !order_sup(y, x) -> !equal(x, y)
     proof:
       by property sup_commutes, equal_symmetric, equal_transitive
          definition of order_sup
     ;

  theorem order_sup_is_transitive : all x y z in Self,
     !order_sup(x, y) -> !order_sup(y, z) -> !order_sup(x, z)
     (* x=inf(x, y) et y=inf(y, z) x=inf(x, inf(y, z)=inf(inf(x, y), z)=inf(x, z)*)
     proof:
       <1>1 assume x in Self,
            assume y in Self,
            assume z in Self,
            assume xLTy : !order_sup (x, y),
            assume yLTz : !order_sup (y, z),
            prove !order_sup (x, z)
         <2>1 prove !equal (x, !sup (x, !sup (y, z)))
           by
             hypothesis xLTy, yLTz
             property sup_right_substitution_rule, equal_transitive
             definition of order_sup
         <2>2 prove !equal (x, !sup (!sup (x, y), z))
           by step <2>1
              property sup_is_associative, equal_transitive, equal_symmetric
         <2>9 qed
           by step <2>2
              hypothesis xLTy
               property equal_symmetric, equal_transitive,
                        sup_left_substitution_rule
               definition of order_sup
       <1>2 qed.
     ;

  (** any element bigger than two elements is bigger than their supremum *)
  theorem order_sup_is_supremum: all x y i in Self,
    !order_sup(i, x) -> !order_sup(i, y) ->
      !order_sup(i, !sup(x, y))
    proof:
      <1>1 assume x in Self,
           assume y in Self,
           assume i in Self,
           assume H1: !order_sup(i, x),
           assume H2: !order_sup(i, y),
           prove !order_sup(i, !sup(x, y))
        <2>1 prove !equal(i, !sup(!sup(i, x), y))
          by
           hypothesis H1, H2
           property sup_left_substitution_rule,
                    equal_symmetric, equal_transitive
          definition of order_sup
        <2>9 qed
          by step <2>1
             property sup_is_associative, equal_transitive
             definition of order_sup
      <1>2 qed.
    ;

end
;;

(** lattices have an inf and sup operation which induce a partial order *)

species Lattice inherits Meet_semi_lattice, Join_semi_lattice =

  (** the first absorbtion law *)
   property inf_absorbes_sup: all x y in Self,
     !equal(x, !sup(x, !inf(x, y)));

   (** the second absorbtion law *)
   property sup_absorbes_inf: all x y in Self,
     !equal(x, !inf(x, !sup(x, y)));

   (** in a lattice there is only one ordering *)
   theorem order_inf_refines_order_sup: all x y in Self,
     !order_sup(y, x) -> !order_inf(x, y)
     proof:
       (* x = x v y ; x ^ y = x ^ (x v y) = x *)
       <1>1 assume x in Self,
            assume y in Self,
            assume H: !order_sup(y, x),
            notation s = !sup (x, y),
            prove !order_inf(x, y)
            <2>1 prove !equal(!inf(x, y), x)
                 <3>1 prove !equal(y, !sup(x, y))
                      by hypothesis H
                         property sup_commutes, equal_transitive
                         definition of order_sup
                 <3>2 prove !equal(!inf(x, !sup(x, y)), x)
                      by property sup_absorbes_inf, equal_symmetric
                 <3>3 prove !equal(!inf(x, y), !inf(x, !sup(x, y)))
                      by step <3>1
                      property inf_right_substitution_rule
                 <3>f qed by step <3>3, <3>2
                          property equal_transitive
            <2>z qed by step <2>1
                        property equal_symmetric
                        definition of order_inf
       <1>2 qed.
     ;

  (** in a lattice there is only one ordering *)
   theorem order_sup_refines_order_inf: all x y in Self,
     (* x = x ^ y ; x v y = (x ^ y) v x = x v (x ^ y) = x *) 
     !order_inf (y, x) -> !order_sup (x, y)
     proof:
       <1>1 assume x in Self,
            assume y in Self,
            assume H: !order_inf (y, x),
            prove !order_sup (x, y)
         <2>1 prove !equal (!sup (x, y), !sup (x, !inf (x, y)))
           by hypothesis H
              property inf_commutes, equal_transitive,
                sup_right_substitution_rule
              definition of order_inf
         <2>2 qed by
               step <2>1
               property equal_transitive, equal_symmetric, inf_absorbes_sup
               definition of order_sup
       <1>2 qed.
     ;

(*
     proof:
       (* [rr]: Wow! I couldn't guess this until I performed the latter *)
       (* forget it if you have a small computer ! *)
       by property
            !inf_commutes, !inf_absorbes_sup, !sup_right_substitution_rule,
            !equal_symmetric, !equal_transitive
          definition of !order_inf, !order_sup
     ;
*)

end
;;

(** Modular lattices *)
species Modular_lattice inherits Lattice =

(** a generalization of ditributivity  *)
property modular_law: all x y z in Self,
  !order_inf(x, y) -> !equal(!inf(!sup(x, y), !sup(x, z)),
                            !inf(y, !sup(!inf(x, y), z)));

end
;;

-- The doc ``Every distribute lattice is modular'' was
-- just before the inherits keyword: need to insert it into the species
-- documentation instead.

(** Distributive lattices
    Every distribute lattice is modular.
 *)
species Distributive_lattice

  inherits Lattice, Modular_lattice =
  property sup_left_distributes : all x y z in Self,
    !equal(!sup(x, !inf(y, z)), !inf(!sup(x, y), !sup(x, z)));

  theorem sup_right_distributes : all x y z in Self,
    !equal(!sup(!inf(x, y), z), !inf(!sup(x, z), !sup(y, z)))
    proof:
      (* [rr]: Wow my second proof *)
      <1>1 assume x in Self,
           assume y in Self,
           assume z in Self,
           prove      !equal(!sup(!inf(x, y), z), !inf(!sup(x, z), !sup(y, z)))
           <2>1 prove !equal(!sup(z, !inf(x, y)), !inf(!sup(z, x), !sup(z, y)))
                by property sup_left_distributes
           <2>2 prove !equal(!sup(!inf(x, y), z), !sup(z, !inf(x, y)))
                by property sup_commutes
           <2>3 prove !equal(!sup(x, z), !sup(z, x)) by property sup_commutes
           <2>4 prove !equal(!sup(y, z), !sup(z, y)) by property sup_commutes
           <2>5 prove !equal(!inf(!sup(x, z), !sup(y, z)),
                             !inf(!sup(z, x), !sup(y, z)))
                by step <2>3
                   property inf_left_substitution_rule
           <2>6 prove !equal(!inf(!sup(z, x), !sup(y, z)),
                             !inf(!sup(z, x), !sup(z, y)))
                by step <2>4
                   property inf_right_substitution_rule
           <2>7 prove !equal(!inf(!sup(x, z), !sup(y, z)),
                             !inf(!sup(z, x), !sup(z, y)))
                by step <2>5, <2>6
                   property equal_transitive
           <2>9 qed by step <2>1, <2>2, <2>7
                       property equal_transitive, equal_symmetric

      <1>2 qed.
    ;

  property inf_left_distributes : all x y z in Self,
    !equal(!inf(x, !sup(y, z)), !sup(!inf(x, y), !inf(x, z)));
  theorem inf_right_distributes : all x y z in Self,
    !equal(!inf(!sup(x, y), z), !sup(!inf(x, z), !inf(y, z)))
    proof:
      (* [rr]: see sup_right_distributes above *)
      (* should be easy but still fails on time limit !
       by !inf_left_distributes, !inf_commutes,
          !sup_left_substitution_rule, !sup_right_substitution_rule,
          !equal_transitive, !equal_symmetric;
       *)
       <1>1 assume x in Self,
            assume y in Self,
            assume z in Self,
           prove !equal (!inf (!sup (x, y), z), !sup (!inf (x, z), !inf (y, z)))
           <2>1 prove !equal (!inf (z, !sup (x, y)),
                              !sup (!inf (z, x), !inf (z, y)))
                by property inf_left_distributes
           <2>2 prove !equal (!inf (!sup (x, y), z), !inf (z, !sup (x, y))) 
                by property inf_commutes 
           <2>3 prove !equal (!inf (x, z), !inf (z, x)) by property inf_commutes
           <2>4 prove !equal (!inf (y, z), !inf (z, y)) by property inf_commutes
           <2>5 prove !equal (!sup (!inf (x, z), !inf (y, z)),
                              !sup (!inf (z, x), !inf (y, z))) 
                by step <2>3 property !sup_left_substitution_rule
           <2>6 prove !equal (!sup (!inf (z, x), !inf (y, z)),
                              !sup (!inf (z, x), !inf (z, y))) 
                by step <2>4 property !sup_right_substitution_rule
           <2>7 prove !equal (!sup (!inf (x, z), !inf (y, z)),
                              !sup (!inf (z, x), !inf (z, y)))
                by step <2>5, <2>6 property equal_transitive
           <2>9 qed by step <2>1, <2>2, <2>7
                    property !equal_transitive, !equal_symmetric
      <1>2 qed.
;

  (** a distributive lattice is always modular *)
  (* [rr]: shouldn't this be simplified ? *)
  proof of modular_law =
    <1>1 assume x in Self,
         assume y in Self,
         assume z in Self,
         assume H: !order_inf(x, y),
         prove !equal(!inf(y, !sup(!inf(x, y), z)),
                      !sup(x, !inf(y, z)))
         <2>0 prove !equal(x, !inf(x, y))
              by hypothesis H definition of order_inf
         <2>1 prove !equal(!inf(y, !sup(!inf(x, y), z)),
                           !sup(!inf(y, !inf(x, y)), !inf(y, z)))
              by property inf_left_distributes
         <2>2 prove !equal(!inf(y, !inf(x, y)), !inf(y, x))
              by step <2>0
                 property inf_right_substitution_rule, equal_symmetric
         <2>3 prove !equal(!sup(!inf(y, !inf(x, y)), !inf(y, z)),
                           !sup(!inf(y, x), !inf(y, z)))
              by step <2>2
                 property sup_left_substitution_rule
         <2>4 prove !equal(!sup(!inf(y, x), !inf(y, z)),
                           !sup(x, !inf(y, z)))
              <3>0 prove !equal(!inf(y, x), x)
                   by step <2>0
                      property inf_commutes,
                               equal_symmetric, equal_transitive
              <3>2 qed by step <3>0
                          property sup_left_substitution_rule
         <2>f qed by step <2>1, <2>3, <2>4 property equal_transitive
    <1>2 qed by
           step <1>1
           property sup_left_distributes, equal_transitive, equal_symmetric
  ;

end
;;

(**
A meet semi lattice with an upper bound as neutral element for infimum.
That is a meet semi lattice with a monoid structure.
*)
species Meet_semi_lattice_with_max inherits Meet_semi_lattice =
  signature max : Self;
  property max_is_right_neutral: all x in Self,
    !equal(!inf(x, !max), x);
  theorem max_is_left_neutral: all x in Self,
    !equal(!inf(!max, x), x)
    proof:
    by property max_is_right_neutral, inf_commutes, equal_transitive
    ;
  let is_max(x) = !equal(x, !max);
end
;;

(**
A meet semi lattice with a lower bound.
That is a meet semi lattice with an absorbant element
*)
species Meet_semi_lattice_with_min inherits Meet_semi_lattice =
  signature min : Self;
  property min_right_absorbes: all x in Self,
    !equal(!inf(x, !min), !min);
  theorem min_left_absorbes: all x in Self,
    !equal(!inf(!min, x), !min)
    proof:
    by property min_right_absorbes, inf_commutes, equal_transitive
    ;

end
;;

(**
A join semi lattice with a lower bound as neutral element for supremum.
That is a join semi lattice with a monoid structure.
*)
species Join_semi_lattice_with_min inherits Join_semi_lattice =
  signature min : Self;
  property min_is_right_neutral: all x in Self,
    !equal(!sup(x, !min), x);
  theorem min_is_left_neutral: all x in Self,
    !equal(!sup(!min, x), x)
    proof:
      by property min_is_right_neutral, sup_commutes, equal_transitive
  ;

  let is_min(x) = Self!equal(x, Self!min)
  ;

end
;;

(**
A join semi lattice with an upper bound.
That is a join semi lattice with an absorbant element
*)
species Join_semi_lattice_with_max inherits Join_semi_lattice =
  signature max : Self;
  property max_right_absorbes: all x in Self,
    !equal(!sup(x, !max), !max);
  theorem max_left_absorbes: all x in Self,
    !equal(!sup(!max, x), !max)
    proof:
    by property max_right_absorbes, sup_commutes, equal_transitive
    ;

end
;;

(** These are commonly named lattices *)
species Bounded_lattice
  inherits Lattice,
           Meet_semi_lattice_with_min,
           Meet_semi_lattice_with_max,
           Join_semi_lattice_with_min,
           Join_semi_lattice_with_max =

  (** absorption laws enable to prove that being absorbant for one law
      is being neutral for the other *)
  proof of max_right_absorbes =
    <1>1 assume x in Self,
         prove !equal(!sup(x, !max), !max)
         <2>1 prove !equal(!max, !inf(!max, !sup(!max, x)))
              by property sup_absorbes_inf
         <2>2 prove !equal(!inf(!max, !sup(!max, x)), !sup(!max, x))
              by property max_is_left_neutral
         <2>3 prove !equal(!max, !sup(!max, x))
              by step <2>1, <2>2
                 property equal_transitive
         <2>f qed
            by step <2>3
               property sup_commutes, equal_symmetric, equal_transitive
    <1>2 qed.
   ;

  (** absorption laws enable to prove that being absorbant for one law
      is being neutral for the other *)
  proof of min_right_absorbes =
    (* [rr]: fails on size limit !
       Should be the same than max_right_absorbes which looks trivial.
       Did I forgot something ?
    by !min_is_left_neutral,
       !inf_absorbes_sup,
       !inf_commutes,
       !equal_reflexive, !equal_transitive
    *)
    <1>1 assume x in Self,
         prove !equal (!inf (x, !min), !min)
         <2>1 prove !equal (!min, !sup (!min, !inf (!min, x)))
              by property inf_absorbes_sup
         <2>2 prove !equal (!sup (!min, !inf (!min, x)), !inf (!min, x))
              by property min_is_left_neutral
         <2>3 prove !equal (!min, !inf (!min, x))
              by step <2>1, <2>2 property equal_transitive
         <2>f qed
            by step <2>3
               property inf_commutes, equal_symmetric, equal_transitive
    <1>2 qed.
    ;
end
;;

(** An ordering is total whenever two elements are always comparable *)
species Ordered_set inherits Partial_order =

  property total_order: all x y in Self, Self!leq(x, y) \/ Self!leq(y, x);

  let equal(x, y) = and_b(Self!leq(x, y), Self!leq(y, x));

  proof of equal_reflexive =
    by property total_order definition of equal
  ;

  proof of equal_symmetric =
    by definition of equal
  ;

  proof of equal_transitive =
    by property leq_transitive definition of equal
  ;

  let lt(x, y) = not_b (Self!leq(y, x));
  proof of lt_is_not_leq =
    by property total_order definition of lt, different, equal;

  proof of lt_is_not_leq =
    by property total_order definition of lt, different, equal ;

  proof of lt_is_irreflexive =
    by property leq_reflexive, equal_reflexive definition of lt ;

end
;;

(**
   Sometimes it is convenient to define lattices from partial ordering
*)
species Partially_ordered_set_as_meet_semi_lattice
  inherits Meet_semi_lattice,
           (* partial ordering takes precedence *)
           Partial_order =

  (** we define lattice ordering from normal ordering *)
  let order_inf(x, y) = !leq(x, y);

  proof of order_inf_is_reflexive =
    by property leq_reflexive definition of order_inf;

  proof of order_inf_is_antisymmetric =
    by property leq_antisymmetric definition of order_inf;

  proof of order_inf_is_transitive =
    by property leq_transitive
       definition of order_inf;

  property inf_is_smaller: all x y in Self,
    !leq(!inf(x, y), x) /\ !leq(!inf(x, y), y) ;

  property leq_defines_infimum: all x y i in Self,
    !leq(i, x) -> !leq(i, y) -> !leq(i, !inf(x, y));

  proof of order_inf_is_infimum =
    by property leq_defines_infimum
       definition of order_inf
  ;

  proof of inf_idempotent =
    <1>1 assume x in Self,
         assume y in Self,
         assume H: !equal(x, y),
         prove !equal(x, !inf(x, y))
         <2>1 prove !leq(x, y) by hypothesis H property leq_reflexive
         <2>2 prove !leq(x, x) by property leq_reflexive, equal_reflexive
         <2>3 prove !leq(x, !inf(x, y))
              by step <2>2, <2>1 property leq_defines_infimum
         <2>4 prove !leq(!inf(x, y), x) by property inf_is_smaller
         <2>f qed by step <2>4, <2>3 property leq_antisymmetric
    <1>f qed.
  ;

  (** details left as exercice for the reader *)
  proof of inf_commutes =
    by property leq_defines_infimum, leq_antisymmetric, inf_is_smaller
  ;

  (** associativity is always tricky *)
  proof of inf_is_associative =
    <1>1 assume x in Self,
         assume y in Self,
         assume z in Self,
         prove !equal(!inf(x, !inf(y, z)), !inf(!inf(x, y), z))
         <2>1 prove !leq(!inf(!inf(x, y), z), !inf(x, !inf(y, z)))
              <3>1 prove !leq(!inf(!inf(x, y), z), x)
                   by property inf_is_smaller, leq_transitive
              <3>2 prove !leq(!inf(!inf(x, y), z), !inf(y, z))
                   <4>1 prove !leq(!inf(!inf(x, y), z), y)
                        by property inf_is_smaller, leq_transitive
                   <4>2 prove !leq(!inf(!inf(x, y), z), z)
                        by property inf_is_smaller
                   <4>f qed by step <4>1, <4>2 property leq_defines_infimum
              <3>f qed by step <3>1, <3>2 property leq_defines_infimum
         <2>2 prove !leq (!inf (x, !inf (y, z)), !inf (!inf(x, y), z))
              <3>1 prove !leq (!inf(x, !inf(y, z)), z)
                   by property inf_is_smaller, leq_transitive
              <3>2 prove !leq (!inf (x, !inf (y, z)), !inf (x, y))
                   <4>1 prove !leq (!inf (x, !inf (y, z)), y)
                        by property inf_is_smaller, leq_transitive
                   <4>2 prove !leq (!inf (x, !inf (y, z)), x)
                        by property inf_is_smaller
                   <4>f qed by step <4>1, <4>2 property leq_defines_infimum
              <3>f qed by step <3>1, <3>2 property leq_defines_infimum
         <2>f qed by step <2>1, <2>2 property leq_antisymmetric
    <1>f qed by step <1>1 property equal_symmetric
  ;

end
;;

species Partially_ordered_set_as_join_semi_lattice
  inherits Join_semi_lattice,
           (* partial ordering takes precedence *)
           Partial_order =

  (** we define lattice ordering from normal ordering *)
  let order_sup(x, y) = !geq(x, y);

  proof of order_sup_is_reflexive =
    by property geq_reflexive
       definition of order_sup;

  proof of order_sup_is_antisymmetric =
    by property geq_antisymmetric definition of order_sup;

  proof of order_sup_is_transitive =
    by property geq_transitive definition of order_sup;

  (**  a supremum should be bigger than its arguments *)
  property sup_is_bigger: all x y in Self,
    !geq(!sup(x, y), x) /\ !geq(!sup(x, y), y)  ;

  (** Anything bigger than a supremum is bigger than the supremum  *)
  property geq_defines_supremum: all x y s in Self,
    !geq(s, x) -> !geq(s, y) -> !geq(s, !sup(x, y));

  (**  We relate to lattice notions *)
  proof of order_sup_is_supremum =
    by property geq_defines_supremum definition of order_sup;

  proof of sup_idempotent =
    <1>1 assume x in Self,
         assume y in Self,
         assume H: !equal(x, y),
         prove !equal(x, !sup(x, y))
         <2>1 prove !geq(x, y)
                by hypothesis H property geq_reflexive
         <2>2 prove !geq(x, x)
                by property geq_reflexive, equal_reflexive
         <2>3 prove !geq(x, !sup(x, y))
                by step <2>2, <2>1 property geq_defines_supremum
         <2>4 prove !geq(!sup(x, y), x)
                by property sup_is_bigger
         <2>f qed
            by step <2>4, <2>3 property geq_antisymmetric
    <1>f qed.
  ;

  (** details left as exercice for the reader *)
  proof of sup_commutes =
    by property geq_defines_supremum, geq_antisymmetric, sup_is_bigger
  ;

  (** associativity is always tricky *)
  proof of sup_is_associative =
    <1>1 assume x in Self,
         assume y in Self,
         assume z in Self,
         prove !equal(!sup(x, !sup(y, z)), !sup(!sup(x, y), z))
         <2>1 prove !geq(!sup(!sup(x, y), z), !sup(x, !sup(y, z)))
              <3>1 prove !geq(!sup(!sup(x, y), z), x)
                   by property sup_is_bigger, geq_transitive
              <3>2 prove !geq(!sup(!sup(x, y), z), !sup(y, z))
                   <4>1 prove !geq(!sup(!sup(x, y), z), y)
                        by property sup_is_bigger, geq_transitive
                   <4>2 prove !geq(!sup(!sup(x, y), z), z)
                        by property sup_is_bigger
                   <4>f qed by step <4>1, <4>2 property geq_defines_supremum
              <3>f qed by step <3>1, <3>2 property geq_defines_supremum
         <2>2 prove !geq (!sup (x, !sup (y, z)), !sup (!sup (x, y), z))
              <3>1 prove !geq (!sup (x, !sup (y, z)), z)
                   by property sup_is_bigger, geq_transitive
              <3>2 prove !geq (!sup (x, !sup (y, z)), !sup (x, y))
                   <4>1 prove !geq (!sup (x, !sup (y, z)), y)
                        by property sup_is_bigger, geq_transitive
                   <4>2 prove !geq (!sup (x, !sup (y, z)), x)
                        by property sup_is_bigger
                   <4>f qed by step <4>1, <4>2 property geq_defines_supremum
              <3>f qed by step <3>1, <3>2 property geq_defines_supremum
         <2>f qed by step <2>1, <2>2 property geq_antisymmetric
    <1>f qed by step <1>1 property equal_symmetric
  ;

end
;;

species Partially_ordered_set_as_lattice
  inherits Lattice,
           Partially_ordered_set_as_meet_semi_lattice,
           Partially_ordered_set_as_join_semi_lattice =

  proof of order_inf_refines_order_sup =
    by definition of order_inf, order_sup, geq
  ;

  proof of order_sup_refines_order_inf =
    by definition of order_inf, order_sup, geq
  ;

  proof of sup_absorbes_inf =
    <1>1 assume x in Self,
         assume y in Self,
         prove !equal(!inf(x, !sup(x, y)), x)
         <2>1 prove !leq(!inf(x, !sup(x, y)), x)
              by property inf_is_smaller
         <2>2 prove !leq(x, !inf(x, !sup(x, y)))
              <3>1 prove !leq(x, !sup(x, y))
                   by property sup_is_bigger
                      definition of geq
              <3>f qed
                   by step <3>1
                      property leq_reflexive, leq_defines_infimum,
                               equal_reflexive
         <2>f qed
            by step <2>1, <2>2 property leq_antisymmetric
    <1>f qed
       by step <1>1 property equal_symmetric
  ;

  proof of inf_absorbes_sup =
    (* [rr]: damned prover this should work !
    by !inf_is_smaller, !sup_is_bigger, !geq_reflexive, !equal_reflexive,
       !geq_defines_supremum def !geq ;
     *)
    <1>1 assume x in Self,
         assume y in Self,
         prove !equal(!sup(x, !inf(x, y)), x)
         <2>1 prove !geq(!sup(x, !inf(x, y)), x)
              by property sup_is_bigger
         <2>2 prove !geq(x, !sup(x, !inf(x, y)))
              <3>1 prove !geq(x, !inf(x, y))
                   by property inf_is_smaller
                      definition of geq
              <3>f qed
                 by step <3>1
                    property geq_reflexive, geq_defines_supremum,
                             equal_reflexive
         <2>f qed
            by step <2>1, <2>2
               property geq_antisymmetric
    <1>f qed
       by step <1>1
          property equal_symmetric
  ;

end
;;

(**
   Ordered meet semi lattices have a complete ordering which refines that
   of the semi lattice structure.
 *)
species Ordered_meet_semi_lattice inherits Meet_semi_lattice, Ordered_set =

  property leq_refines_order_inf : all x y in Self,
    !order_inf(x, y) -> !leq(x, y);

end
;;

(**
 We view an ordered set as a meet semi lattice
*)
species Ordered_set_as_meet_semi_lattice
  inherits Ordered_meet_semi_lattice =

  let inf(x, y) = if !leq(x, y) then x else y ;

  proof of leq_refines_order_inf =
   by property leq_reflexive
      definition of inf, order_inf
  ;

  proof of inf_left_substitution_rule =
    by property equal_reflexive, equal_symmetric,
                leq_reflexive, leq_transitive
       definition of inf
  ;

  proof of inf_idempotent =
    by property equal_reflexive
       definition of inf
  ;

  proof of inf_is_associative =
    by property equal_reflexive, leq_transitive, total_order
       definition of inf
  ;

  theorem order_inf_refines_leq: all x y in Self,
    !leq(x, y) -> !order_inf(x, y)
    proof:
      by property total_order, total_order, leq_antisymmetric
         definition of inf, order_inf
  ;

  proof of inf_commutes =
   <1>1 assume x in Self,
        assume y in Self,
        prove !equal(!inf(x, y), !inf(y, x))
        <2>1 assume Hxy: !leq(x, y),
             prove !equal(!inf(x, y), !inf(y, x))
             <3>1 prove !equal(x, !inf(x, y))
                  by hypothesis Hxy
                     property equal_reflexive
                     definition of inf
             <3>2 prove !equal(x, !inf(y, x))
                  <4>1 assume Hyx: !leq(y, x),
                       prove !equal(x, !inf(y, x))
                       <5>1 prove !equal(x, y)
                            by hypothesis Hxy, Hyx
                               property leq_antisymmetric
                        <5>2 prove !equal(y, !inf(y, x))
                             by hypothesis Hyx
                                property equal_reflexive
                                definition of inf
                        <5>f qed
                             by step <5>1, <5>2
                                property equal_transitive
                  <4>2 assume H: ~(!leq(y, x)),
                        prove !equal(x, !inf(y, x))
                        by hypothesis H
                           property equal_reflexive
                           definition of inf
                  <4>f qed by step <4>1, <4>2
             <3>f qed
                by step <3>1, <3>2
                   property equal_symmetric, equal_transitive
        <2>2 assume Hyx: !leq(y, x),
             prove !equal(!inf(x, y), !inf(y, x))
             (* [rr]: could do as <2>1 above, but zenon is wiser *)
             by hypothesis Hyx
                property equal_reflexive, leq_antisymmetric
                definition of inf
        <2>f qed
           by step <2>1, <2>2
              property total_order
   <1>2 qed.
  ;

end
;;


(**
   Ordered join semi lattices have a complete ordering which refines that
   of the join semi lattice structure.
 *)
species Ordered_join_semi_lattice inherits Join_semi_lattice, Ordered_set =

  property geq_refines_order_sup : all x y in Self,
    !order_sup(x, y) -> !geq(x, y)
  ;

end
;;

(**
 We view an ordered set as a join semi lattice
*)

species Ordered_set_as_join_semi_lattice inherits Ordered_join_semi_lattice =

  let sup(x, y) = if !geq(x, y) then x else y ;

  proof of sup_idempotent =
    by property equal_reflexive
       definition of sup
  ;

  proof of geq_refines_order_sup =
    by property geq_reflexive
       definition of sup, order_sup
  ;

  proof of sup_commutes =
    by property equal_reflexive, leq_antisymmetric, total_order
       definition of sup, geq
  ;

  proof of sup_is_associative =
    by property equal_reflexive, leq_transitive, total_order
       definition of sup, geq
  ;

  proof of sup_left_substitution_rule =
    by property equal_reflexive, equal_symmetric,
       leq_reflexive, leq_transitive
       definition of sup, geq
  ;

end
;;

(** here we complete the partial ordering of the lattice *)
species Ordered_lattice
  inherits Ordered_meet_semi_lattice,
           Ordered_join_semi_lattice,
           Lattice =

end
;;

(** a toitally ordered set may be viewed as a lattice *)
species Ordered_set_as_lattice
  inherits Ordered_set_as_meet_semi_lattice,
           Ordered_set_as_join_semi_lattice,
           Ordered_lattice =

  (** absorption laws are a mess !*)
  proof of sup_absorbes_inf =
    <1>1 assume x in Self,
         assume y in Self,
         prove !equal(x, !inf(x, !sup(x, y)))
         <2>1 assume H: !leq(x, y),
              prove !equal(x, !inf(x, !sup(x, y)))
              <3>1 prove !equal(y, !sup(x, y))
                   <4>1 prove !geq(y, x)
                        by hypothesis H
                           definition of geq
                   <4>2 prove !equal(!sup(y, x), y)
                        by step <4>1
                           property equal_reflexive
                           definition of sup
                   <4>f qed
                      by step <4>2
                         property sup_commutes,
                                  equal_symmetric, equal_transitive
              <3>2 prove !equal(x, !inf(x, y))
                   by hypothesis H
                      property equal_reflexive
                      definition of inf
              <3>3 prove !equal(!inf(x, !sup(x, y)),
                                !inf(x, y))
(* [rr]: loops?    by step <3>1 property !inf_substitution_rule, !equal_symmetric *)
                   by step <3>1
                      property inf_right_substitution_rule, equal_symmetric
              <3>f qed
                 by step <3>3, <3>2
                    property equal_symmetric, equal_transitive
         <2>2 assume H: !leq(y, x),
              prove !equal(x, !inf(x, !sup(x, y)))
              <3>1 prove !geq(x, y)
                   by hypothesis H
                      definition of geq
              <3>2 prove !equal(x, !sup(x, y))
                   by step <3>1
                      property equal_reflexive
                      definition of sup
              <3>3 prove !equal(!inf(x, !sup(x, y)),
                                !inf(x, x))
                   by step <3>2
                      property inf_right_substitution_rule, equal_symmetric
              <3>f qed
                 by step <3>2, <3>3
                    property inf_idempotent,
                             equal_symmetric, equal_transitive
         <2>f qed
            by step <2>1, <2>2
               property total_order
    <1>f qed.

   ;

   (* [rr]: see above *)
   proof of inf_absorbes_sup =
    <1>1 assume x in Self,
         assume y in Self,
         prove !equal (x, !sup (x, !inf (x, y)))
         <2>1 assume H: !leq (x, y),
              prove !equal (x, !sup (x, !inf (x, y)))
              <3>1 prove !equal (x, !inf (x, y))
                   by hypothesis H property equal_reflexive definition of inf
              <3>2 prove !equal (!sup (x, !inf (x, y)),
                                 !sup (x, x))
                   by step <3>1
                      property sup_right_substitution_rule, equal_symmetric
              <3>f qed by step <3>2
                          property sup_idempotent, equal_reflexive,
                          equal_symmetric, equal_transitive
         <2>2 assume H: !leq (y, x),
              prove !equal (x, !sup (x, !inf (x, y)))
              <3>2 prove !equal (!sup (x, y), !sup (x, !inf (x, y)))
                   <4>1 prove !equal (y, !inf (y, x))
                        by hypothesis H property equal_reflexive
                        definition of inf
                   <4>2 prove !equal(y, !inf(x, y))
                        by step <4>1 property inf_commutes,
                           equal_transitive, equal_symmetric
                   <4>f qed by step <4>2 property sup_right_substitution_rule
              <3>3 prove !equal (!sup (x, y), x)
                   by hypothesis H property equal_reflexive
                      definition of sup, geq
              <3>f qed by step <3>2,  <3>3
                       property equal_symmetric, equal_transitive
         <2>f qed by step <2>1, <2>2 property total_order
    <1>f qed.
    ;

end
;;
