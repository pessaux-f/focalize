(***********************************************************************)
(*                                                                     *)
(*                        FoCaLize compiler                            *)
(*                                                                     *)
(*            William Bartlett                                         *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                                                                     *)
(*                      ENSIIE - LIP6  -  INRIA Rocquencourt           *)
(*                                                                     *)
(*  Copyright 2007 LIP6 and INRIA                                      *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: wellfounded.fcl,v 1.15 2011-05-25 13:40:46 maarek Exp $ *)

(* Definition (import) of the notion of wellfoundedness.  Since this notion
   is not defineable in FoCaLize, this library is a toolbox for reasoning
   with wellfoundedness inside FoCaLize, without resorting to low level Coq
   proofs. *)

use "basics";;
use "orders";;
open "basics";;
open "orders";;
coq_require "wellfounded_externals";;


let well_wrapper =
  internal ('a -> 'a -> bool) -> prop
  external
    | caml -> {* () *}
    | coq -> {* (fun f =>  well_founded (fun x y => Is_true (f x y))) *}
;;

species PartialWellOrder =

  inherit Partial_order;

  (** The predicate of Wellfoundedness
   * @param r the relation that is said to be well founded
   *
   * note: this is an import of Coq's notion of wellfoundedness
   * which is based on the accessibility predicate.
   *)
(*   logical let wellfounded = *)
(*     internal (Self -> Self -> bool) -> prop *)
(*     external *)
(*     | caml -> {* () *} *)
(*     | coq -> {* wellfounded_externals.wellfounded abst_T *} *)
(*   ; *)

  logical let wellfounded (f : Self -> Self -> bool) =
    well_wrapper (f)
  ;

  property wellfounded_lt: wellfounded(!lt);

end
;;



species WellOrder =

  inherit PartialWellOrder, Ordered_set;

end
;;

(*
  [rr]: this looks highly experimental!
        Nothing is proved.
        Do not use beyond this point.
*)

(** Well founded order over integers *)
let int_wf (x : int, y : int) : bool = abs0x (x) <0x abs0x (y)
;;

species RelativeIntegers =

  inherit WellOrder;

  representation = int;

  let element = 0;

  let equal(x, y)= (x = y);

  proof of equal_reflexive = by definition of equal ;
  proof of equal_symmetric = by definition of equal ;
  proof of equal_transitive = by definition of equal ;

  signature lowerbound: Self;

  let leq (x, y) = lowerbound <=0x y && x <=0x y;

  let lt (x, y) = lowerbound <0x y && x <0x y;

  proof of wellfounded_lt = assumed (* TODO import proof from Coq. *);

end
;;

species InverseImage (A is PartialWellOrder) =

  inherit PartialWellOrder;

  signature meazure: Self -> A;

  property compatibility_lt_Alt_meazure: all x y : Self,
    lt (x, y) -> A!lt (meazure (x), meazure (y));

  proof of wellfounded_lt = assumed (* TODO import proof from Coq. *);

end
;;



species Subrelation (A is PartialWellOrder) =

  inherit InverseImage (A);

  representation = A;

  let meazure (x : Self) : A = x;

end
;;


(* [rr]: this is redundant with products.fcl *)

species CartesianProduct (A is Basic_object, B is Basic_object) =

  inherit Basic_object;

  representation = A * B;

  let pair (a : A, b : B) : Self = (a, b);

  let fst (x : Self) = match x with | (a , _) -> a ;
  let snd (x : Self) = match x with | (_ , b) -> b ;

end
;;

(* [rr]: different orderings are defined generically for polynomials *)
species LexicographicProduct (A is PartialWellOrder, B is PartialWellOrder) =

  inherit CartesianProduct (A, B), PartialWellOrder;

  let lt (x, y) =
    match (x, y) with
    | ((xA, xB), (yA, yB)) ->
        A!lt (xA, yA) || (A!equal (xA, yA) && B!lt (xB, yB)) ;

  proof of wellfounded_lt = assumed;

end
;;


species RelationalProduct
  (A is PartialWellOrder,
   B is PartialWellOrder,
   C is LexicographicProduct (A, B)) =

  inherit Subrelation (C);

  let lt (x, y) =
    A!lt (C!fst (x), C!fst (y)) &&
    B!lt (C!snd (x), C!snd (y)) ;

  proof of compatibility_lt_Alt_meazure = assumed;

end
;;
