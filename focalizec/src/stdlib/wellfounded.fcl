(***********************************************************************)
(*                                                                     *)
(*                        FoCaL compiler                               *)
(*            William Bartlett                                         *)
(*                      ENSIIE - LIP6  -  INRIA Rocquencourt           *)
(*                                                                     *)
(*  Copyright 2007 LIP6 and INRIA                                      *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: wellfounded.fcl,v 1.4 2008-09-11 09:26:21 pessaux Exp $ *)

(* Definition (import) of the notion of wellfoundedness.
   Since this notion is not defineable in Focal, this library is a veritable
   toolbox for reasoning with it inside Focal without resorting to low level
   Coq proofs. *)

use "basics";;
use "sets_orders";;
open "basics";;
open "sets_orders";;
coq_require "wellfounded_externals";;



species PartialWellOrder inherits Partial_order =
  (** The predicate of Wellfoundedness
   * @param r the relation that is said to be well founded
   *
   * note: this is an import of Coq's notion of wellfoundedness
   * which is based on the accessibility predicate.
   *)
  logical let wellfounded =
    internal (Self -> Self -> bool) -> prop
    external
    | caml -> {* () *}
    | coq -> {* wellfounded_externals.wellfounded abst_T *}
  ;

  property wellfounded_lt: wellfounded(lt);
end;;



species WellOrder inherits PartialWellOrder, Ordered_set =
end;;



species RelativeIntegers inherits WellOrder =
  rep = int;

  let element = 0;
  let equal = int_eq;

  proof of equal_reflexive = assumed {* *} ;
  proof of equal_transitive = assumed {* *} ;

  signature lowerbound: Self;

  let leq(x, y) = and_b (int_leq (lowerbound, y), int_leq (x, y)) ;

  let lt(x, y) = and_b (int_leq (lowerbound, y), int_lt (x, y)) ;

  proof of wellfounded_lt = assumed {* TODO import proof from Coq. *} ;
end;;

species InverseImage(A is PartialWellOrder) inherits PartialWellOrder =
  signature meazure: Self -> A;

  property compatibility_lt_Alt_meazure: all x y in Self,
    lt(x, y) -> A!lt(meazure(x), meazure(y));

  proof of wellfounded_lt = assumed {* TODO import proof from Coq. *} ;
end;;



species Subrelation (A is PartialWellOrder) inherits InverseImage (A) =
  rep = A;

  let meazure(x in Self) in A = x;
end;;



species CartesianProduct (A is Basic_object, B is Basic_object)
inherits Basic_object =
  rep = A * B;

  let pair(a in A, b in B) in Self = (a, b);

  let fst (x in Self) = match x with | (a , _) -> a ;
  let snd (x in Self) = match x with | (_ , b) -> b ;
end;;

species LexicographicProduct (A is PartialWellOrder, B is PartialWellOrder)
inherits CartesianProduct (A, B), PartialWellOrder =
  let lt(x, y) =
    match (x, y) with
    | ((xA, xB), (yA, yB)) ->
        or_b (A!lt (xA, yA), and_b (A!equal (xA, yA), B!lt (xB, yB))) ;

  proof of wellfounded_lt = assumed {* *} ;
end;;


species RelationalProduct
  (A is PartialWellOrder,
   B is PartialWellOrder,
   C is LexicographicProduct (A, B))
inherits Subrelation (C) =
  let lt (x, y) =
    and_b (A!lt (C!fst (x), C!fst (y)),
           B!lt (C!snd (x), C!snd (y))) ;

  proof of compatibility_lt_Alt_meazure = assumed {* *} ;
end;;
