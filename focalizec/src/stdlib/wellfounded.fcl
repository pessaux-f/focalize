(***********************************************************************)
(*                                                                     *)
(*                        FoCaLize compiler                            *)
(*                                                                     *)
(*            William Bartlett                                         *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                                                                     *)
(*                      ENSIIE - LIP6  -  INRIA Rocquencourt           *)
(*                                                                     *)
(*  Copyright 2007 LIP6 and INRIA                                      *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: wellfounded.fcl,v 1.12 2009-06-16 10:09:31 rr Exp $ *)

(* Definition (import) of the notion of wellfoundedness.  Since this notion
   is not defineable in FoCaLize, this library is a toolbox for reasoning
   with wellfoundedness inside FoCaLize, without resorting to low level Coq
   proofs. *)

use "basics";;
use "sets_orders";;
open "basics";;
open "sets_orders";;
coq_require "wellfounded_externals";;

species PartialWellOrder =

  inherit Partial_order;

  (** The predicate of Wellfoundedness
   * @param r the relation that is said to be well founded
   *
   * note: this is an import of Coq's notion of wellfoundedness
   * which is based on the accessibility predicate.
   *)
(*   logical let wellfounded = *)
(*     internal (Self -> Self -> bool) -> prop *)
(*     external *)
(*     | caml -> {* () *} *)
(*     | coq -> {* wellfounded_externals.wellfounded abst_T *} *)
(*   ; *)

  logical let wellfounded =
    internal (Self -> Self -> bool) -> prop
    external
    | caml -> {* () *}
    | coq -> {* fun (r: abst_T -> abst_T -> bool) => 
                 well_founded (fun (x y: abst_T) => Is_true (r x y)) *}
  ;

  property wellfounded_lt: wellfounded(!lt);

end
;;



species WellOrder =

  inherit PartialWellOrder, Ordered_set;

end
;;

(* 
  [rr]: this looks highly experimental! 
        Nothing is proved. 
        Do not use beyond this point.
*)

(** Well founded order over integers *)
let int_wf (x in int, y in int) in bool = abs0x (x) <0x abs0x (y)
;;

species RelativeIntegers =

  inherit WellOrder;

  representation = int;

  let element = 0;

  let equal(x, y)= (x = y);

  proof of equal_reflexive = by definition of equal ;
  proof of equal_symmetric = by definition of equal ;
  proof of equal_transitive = by definition of equal ;

  signature lowerbound: Self;

  let leq (x, y) = lowerbound <=0x y && x <=0x y;

  let lt (x, y) = lowerbound <0x y && x <0x y;

  proof of wellfounded_lt = assumed {* TODO import proof from Coq. *} ;

end
;;

species InverseImage (A is PartialWellOrder) =

  inherit PartialWellOrder;

  signature meazure: Self -> A;

  property compatibility_lt_Alt_meazure: all x y in Self,
    lt (x, y) -> A!lt (meazure (x), meazure (y));

  proof of wellfounded_lt = assumed {* TODO import proof from Coq. *} ;

end
;;



species Subrelation (A is PartialWellOrder) =

  inherit InverseImage (A);

  representation = A;

  let meazure (x in Self) in A = x;
end
;;


(* [rr]: this is redundant with products.fcl *)

species CartesianProduct (A is Basic_object, B is Basic_object) =

  inherit Basic_object;

  representation = A * B;

  let pair (a in A, b in B) in Self = (a, b);

  let fst (x in Self) = match x with | (a , _) -> a ;
  let snd (x in Self) = match x with | (_ , b) -> b ;

end
;;

(* [rr]: different orderings are defined generically for polynomials *)
species LexicographicProduct (A is PartialWellOrder, B is PartialWellOrder) =

  inherit CartesianProduct (A, B), PartialWellOrder;

  let lt (x, y) =
    match (x, y) with
    | ((xA, xB), (yA, yB)) ->
        A!lt (xA, yA) || (A!equal (xA, yA) && B!lt (xB, yB)) ;

  proof of wellfounded_lt = assumed {* *} ;

end
;;


species RelationalProduct
  (A is PartialWellOrder,
   B is PartialWellOrder,
   C is LexicographicProduct (A, B)) =

  inherit Subrelation (C);

  let lt (x, y) =
    A!lt (C!fst (x), C!fst (y))
    && B!lt (C!snd (x), C!snd (y)) ;

  proof of compatibility_lt_Alt_meazure = assumed {* *} ;

end
;;
