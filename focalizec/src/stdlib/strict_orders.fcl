(***********************************************************************)
(*                                                                     *)
(*                        FoCaLize compiler                            *)
(*                                                                     *)
(*            Renaud Rioboo                                            *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                                                                     *)
(*                               LIP6  -  INRIA Rocquencourt           *)
(*                                                                     *)
(*  Copyright 2007, 2008 LIP6 and INRIA                                *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: strict_orders.fcl,v 1.13 2011-05-25 14:43:16 maarek Exp $ *)

open "basics";;
open "sets";;

(**
   Strict orderings.
   There are various definitions of strict orderings and some authors
   define strict quasi orderings which are used in econometrics and
   so called preference logic.

 *)

(** A strict partial order is an irreflexive and transitive relation, As a
   consequence it is also asymetric. Sometimes called a strict quasi-order *)

 species Strict_partial_order =

  inherit Anti_setoid;

  signature lt: Self -> Self -> bool;

  property lt_is_irreflexive: all x : Self, ~(!lt(x, x));

  property lt_is_transitive: all x y z : Self,
    !lt(x, y) -> !lt(y, z) -> !lt(x, z);

  theorem lt_is_asymetric: all x y : Self, !lt(x, y) -> ~(!lt(y, x))
    proof =
      <1>1 assume x : Self, y : Self,
           hypothesis H: !lt(x, y),
           prove ~(!lt(y, x))
           <2>1 hypothesis F: !lt(y, x),
                prove !lt(x, x) by hypothesis H, F property !lt_is_transitive
           <2>f qed by step <2>1 property !lt_is_irreflexive
      <1>f conclude
  ;


  (** gt is obtained by duality from lt, sometimes called a (strict)
  preference *)

  let gt(x, y) = !lt(y, x);

  theorem gt_is_lt: all x y : Self,
    !gt(x, y) <-> !lt(y, x)
    proof = by definition of gt;

  theorem gt_is_irreflexive: all x : Self, ~(gt(x, x))
    proof = by property gt_is_lt, !lt_is_irreflexive;

  (** Large ordering is defined from strict ordering *)
  let leq(x, y) = !lt(x, y) || syntactic_equal(x, y);

  theorem lt_refines_leq: all x y : Self, !lt(x, y) -> !leq(x, y)
    proof = assumed ; (* ASSUMED by definition of leq; *)

  theorem leq_reflexive : all x : Self, !leq(x, x)
    proof = assumed ; (* ASSUMED by definition of leq; *)

  theorem leq_antisymmetric: all x y : Self,
    !leq(x, y) -> !leq(y, x) -> !equal(x, y)
    proof =
      <1>1 assume x : Self, y : Self,
           hypothesis H_xy : !leq(x, y), hypothesis  H_yx: !leq(y, x),
           prove !equal(x, y)
           <2>1 hypothesis HH_xy : !lt(x, y) /\ !lt(y, x),
                prove !equal(x, y)
                by hypothesis HH_xy
                   property !lt_is_transitive, !lt_is_irreflexive
           <2>2 hypothesis HH_xy: !lt(x, y) /\ syntactic_equal(y, x),
                prove !equal(x, y)
                assumed (* ASSUMED by hypothesis HH_xy property !equal_reflexive, !equal_symmetric *)
           <2>3 hypothesis HH_xy: syntactic_equal(x, y) /\ !lt(y, x),
                prove !equal(x, y) assumed (* ASSUMED by hypothesis HH_xy property equal_reflexive *)
           <2>4 hypothesis HH_xy: syntactic_equal(x, y) /\ syntactic_equal(y, x),
                prove !equal(x, y) assumed (* ASSUMED by hypothesis HH_xy property !equal_reflexive *)
           <2>5 qed assumed (* ASSUMED by step <2>1, <2>2, <2>3, <2>4
                    ASSUMED   hypothesis H_xy, H_yx
                    ASSUMED   definition of leq *)
      <1>f qed conclude
  ;

  theorem leq_transitive: all x y z : Self,
    !leq(x, y) -> !leq(y, z) -> !leq(x, z)
    proof =
      <1>1 assume x : Self, y : Self, z : Self,
           hypothesis  H_xy: !leq(x, y), hypothesis  H_yz: !leq(y, z),
           prove !leq(x, z)
           <2>1 hypothesis  H: (!lt(x, y) /\ !lt(y, z)),
                prove !lt(x, z)
                by hypothesis H property !lt_is_transitive
           <2>2 hypothesis  H: (!lt(x, y) /\ syntactic_equal(y, z)),
                prove !lt(x, z)
                assumed (* ASSUMED by hypothesis H *)
           <2>3 hypothesis  H: (syntactic_equal(x, y) /\ !lt(y, z)),
                prove !lt(x, z)
                assumed (* ASSUMED by hypothesis H *)
           <2>4 hypothesis  H: (syntactic_equal(x, y) /\ syntactic_equal(y, z)),
                prove !equal(x, z)
                assumed (* ASSUMED by hypothesis H property !equal_transitive, !equal_reflexive *)
           <2>f qed assumed (* ASSUMED by step <2>1, <2>2, <2>3, <2>4
                       hypothesis H_xy, H_yz
                       definition of leq *)
      <1>f qed conclude
  ;

end
;;

(**
   Here we specify that incomparability is difference

 *)
species Strict_order =

  inherit Strict_partial_order;

  (** Strict comparability is difference, this is sometimes called weakly
   connected *)

  let different(x, y) = !lt(x, y) || !lt(y, x);

  proof of different_is_symmetric = by definition of different;

  proof of different_is_irreflexive =
    by property !lt_is_irreflexive definition of different;



end
;;

species Syntactical_setoid =

  inherit Setoid;

  property equal_is_syntactic: all x y : Self, !equal(x, y ) -> x = y;

  proof of equal_symmetric = assumed; (* ASSUMED by property !equal_reflexive, !equal_is_syntactic; *)

  proof of equal_transitive = assumed; (* ASSUMED by property !equal_reflexive, !equal_is_syntactic; *)


end;;

(** Restoring compatibility between strict and large ordering *)
species Strictly_ordered_set =
  (** Here we cannot inherit from Ordered_set because lt is defined there *)

  inherit Syntactical_setoid, Strict_order;

  theorem leq_from_lt: all x y : Self,
    !leq(x, y) <-> (!lt(x, y) \/ syntactic_equal(x, y))
    proof = assumed; (* ASSUMED by definition of leq; *)

  (** An ordering is total if the &leq; relation is complete *)
  property total_order: all x y : Self,
    !leq(x, y) \/ leq(y, x);

  proof of different_is_complete = assumed (*
ASSUMED    by property leq_from_lt, !different_is_not_same,
ASSUMED                !total_order,
ASSUMED                !lt_is_irreflexive, !lt_is_transitive
ASSUMED       definition of different *)
  ;
  proof of same_is_not_different = by property different_is_not_same;

  theorem different_is_syntactic: all x y : Self, ~(x = y) -> different(x, y)
    proof =
    <1>1 assume x : Self, y : Self,
         hypothesis  D_xy: ~(x = y),
         prove !different(x, y)
         <3>1 hypothesis  L_xy: !leq(x, y),
              prove !lt(x, y)
              assumed (* ASSUMED by hypothesis D_xy, L_xy
ASSUMED                 property leq_from_lt, lt_is_irreflexive *)
         <3>2 hypothesis  L_yx: !leq(y, x),
              prove !lt(y, x)
              assumed (* ASSUMED by hypothesis L_yx, D_xy
ASSUMED                 property leq_from_lt, lt_is_irreflexive *)
         <3>f qed assumed (* ASSUMED by step <3>1, <3>2
ASSUMED                     property different_is_symmetric, !total_order
ASSUMED                     definition of different *)
    <1>f qed assumed (* ASSUMED conclude *);

  proof of equal_is_syntactic = assumed;
(* ASSUMED    by property different_is_syntactic, different_is_not_same; *)

end
;;
