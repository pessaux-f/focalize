external type int = | caml -> "int" ;;
external type unit = | caml -> "unit" ;;
external type float = | caml -> "float" ;;
external type char = | caml -> "char" ;;
external type string = | caml -> "string" ;;
external type bool = | caml -> "bool" ;;
external type list ('a) = | caml -> "'a list" ;;

external value foc_error : string -> 'a =
  | caml -> "Focvasives.foc_error"
  | coq -> "foc_error"
;;

let and_b (x, y) =
   match (x, y) with
   | (true, true) -> true
   | (false, false) -> false
   | (_ , _) -> false    (* Beware the space before the , !!! *)
;;

let or_b (x, y) =
   match (x, y) with
   | (true, _) -> true
   | (_ , true) -> true  (* Beware the space before the , !!! *)
   | (_ , _) -> false    (* Beware the space before the , !!! *)
;;

let not_b (x) in bool =
   match x with
   | true -> false
   | false -> true
;;

let xor_b (x, y) =
   or_b (and_b (x, not_b (y)), and_b (not_b (x), y))
;;

(* Operations on pairs. *)
let crp (x, y) = (x, y) ;;
let first (x) = match x with | (v, _ ) -> v ;;
let scnd (x) = match x with | (_ , v) -> v ;;

external value string_of_int : int -> string =
  | caml -> "Focvasives.string_of_int" ;;
external value int_of_string : string -> int =
  | caml -> "Focvasives.int_of_string" ;;



external value print_int : int -> unit = | caml -> "Focvasives.int_print" ;;

(* Operations on integers. *)
external value int_mod : int -> int -> int = | caml -> "Focvasives.int_mod" ;;
external value int_eq : int -> int -> bool =
  | caml -> "Focvasives.int_eq"
  | coq -> "int_eq" ;;
external value int_div : int -> int -> int = | caml -> "Focvasives.int_div" ;;
external value int_lt : int -> int -> bool =
  | caml -> "Focvasives.int_lt"
  | coq -> "int_lt" ;;
external value int_leq : int -> int -> bool =
  | caml -> "Focvasives.int_leq"
  | coq -> "int_leq" ;;
external value int_geq : int -> int -> bool =
  | caml -> "Focvasives.int_geq"
  | coq -> "int_geq" ;;
external value int_gt : int -> int -> bool =
  | caml -> "Focvasives.int_gt"
  | coq -> "int_gt" ;;
external value phys_eq : 'a ->'a -> bool =
  | caml -> "Focvasives.base_equal" ;;
external value base_eq : 'a -> 'a -> bool =
  | caml -> "Focvasives.base_eq"
  | coq -> "beq" ;;

theorem beq_refl : all x in 'a, base_eq (x, x) proof: assumed ;;
theorem beq_symm: all x y in 'a, base_eq (x, y) -> base_eq (y, x)
  proof: assumed ;;
theorem beq_trans: all x y z in 'a, base_eq (x, y) -> base_eq (y, z) ->
  base_eq (x, z)
proof: assumed ;;

theorem int_le_not_gt :
  all x y in int, int_leq (x, y) -> not (int_gt (x, y))
  proof:
    coq proof
   {* Intros x y; Unfold __g_int_leq __g_int_gt.
   Elim (Z_le_dec x y).
   Intros H.
   Intros b; Clear b.
   Elim (Z_gt_dec x y).
   Intros H1; Absurd `x > y`.
   Apply Zle_not_gt; Trivial.
   Trivial.
   Compute; Trivial.
   Compute; Trivial. *)
    intros x y; unfold __g_int_leq, __g_int_gt in |- *.
    elim (Z_le_dec x y).
    intros H.
    intros b; clear b.
  elim (Z_gt_dec x y).
  intros H1; absurd (x > y)%Z.
  apply Zle_not_gt; trivial.
  trivial.
  compute in |- *; trivial.
  compute in |- *; trivial. *}
;;

theorem int_lt_le_trans :
  all x y z in int, int_lt (x, y) -> int_leq (y, z) -> int_lt (x, z)
proof:
  coq proof
  {* intros x y z.
     unfold __g_int_lt, __g_int_leq in |- *.
     elim (Z_lt_dec x y).
     elim (Z_le_dec y z).
     intros Hle Hlt foo bar; clear foo bar.
     elim (Z_lt_dec x z).
     intros H; compute in |- *; trivial.
     intros H; absurd (x < z)%Z; trivial.
     apply (Zlt_le_trans x y z); trivial.
     intros b a H Habs; compute in |- *; contradiction.
     intros b H; compute in H; contradiction. *}
;;

theorem int_lt_le_trans :
  all x y z in int, int_lt (x, y) -> int_leq (y, z) -> int_lt (x, z)
proof:
  coq proof
  {* intros x y z.
     unfold __g_int_lt, __g_int_leq in |- *.
     elim (Z_lt_dec x y).
     elim (Z_le_dec y z).
     intros Hle Hlt foo bar; clear foo bar.
     elim (Z_lt_dec x z).
     intros H; compute in |- *; trivial.
     intros H; absurd (x < z)%Z; trivial.
     apply (Zlt_le_trans x y z); trivial.
     intros b a H Habs; compute in |- *; contradiction.
     intros b H; compute in H; contradiction. *}
;;

theorem int_le_refl :
  all x y in int, base_eq (x, y) -> int_leq (x, y) proof: assumed ;;

theorem int_le_antisymm:
  all x y in int, int_leq (x, y) -> int_leq (y, x) -> base_eq (x, y)
proof:
  coq proof
  {* intros x y.
     unfold __g_int_leq in |- *.
     elim (Z_le_dec x y); elim (Z_le_dec y x).
     intros H1 H2.
     intros b c; clear b c.
     replace x with y.
     eapply beq_refl.
     apply Zle_antisym; trivial.
     intros b a H; clear H a.
     compute in |- *; intros Habs; eapply False_ind; trivial.
     intros a b Habs H; clear H a; compute in Habs; eapply False_ind; trivial.
     intros a b Habs H; clear H a; compute in Habs; eapply False_ind; trivial.
*} ;;

theorem int_le_trans:
  all x y z in int,  #int_leq(x, y) -> #int_leq (y, z) -> #int_leq(x, z)
proof:
  coq proof
  {* unfold __g_int_leq in |- *; intros x y z H1 H2.
     apply dec_IsTrue. cut (x <= y)%Z. cut (y <= z)%Z.
     eauto with zarith.
     eapply IsTrue_dec. apply H2.
     eapply IsTrue_dec; apply H1. *}
;;

theorem int_lt_irrefl :
  all x y in int, int_lt (x, y) -> not base_eq (x, y)
proof: assumed ;;

external value pred : int -> int =
  | caml -> "Focvasives.pred" | coq -> "pred" ;;
external value int_opp : int -> int =
  | caml -> "Focvasives.int_opposite" | coq -> "int_opp" ;;
external value int_plus : int -> int -> int =
  | caml -> "Focvasives.int_plus" | coq -> "int_plus" ;;

theorem int_0_plus: all x y in int,
  #base_eq (x, 0) -> #base_eq (#int_plus (x, y), y)
proof:
  coq proof
  {* unfold __g_int_plus, __g_base_eq_ in |- *; intros x y Hxz;
     apply EQ_base_eq; replace x with 0%Z; eauto with zarith.
     symmetry  in |- *.
     apply decidable.
     apply Z_eq_dec. assumption. *}
;;

theorem int_lt_le_S:
  all x y in int, #int_lt (x, y) -> #int_leq (#int_plus (x, 1), y)
proof:
  coq proof
  {* unfold __g_int_lt, __g_int_leq, __g_int_plus in |- *; intros x y Hlt;
     apply dec_IsTrue; fold (Zsucc x) in |- *; apply Zlt_le_succ;
     trivial. exact (IsTrue_dec Hlt). *}
;;

theorem int_plus_assoc: all x y z in int,
  #base_eq (#int_plus (#int_plus (x, y), z), #int_plus (x, #int_plus (y, z)))
proof:
  coq proof
    {* unfold __g_int_plus, __g_base_eq_ in |- *; intros x y z;
       apply EQ_base_eq; auto with zarith. *}
;;

theorem int_plus_commute: all x y  in int,
  #base_eq (#int_plus (x, y), #int_plus (y, x))
proof:
  coq proof {*
    unfold __g_int_plus, __g_base_eq_ in |- *; intros x y; apply EQ_base_eq;
    auto with zarith. *}
;;

theorem int_plus_plus:  all x y z t in int,
  #base_eq (x, y) ->
    #base_eq (z, t) -> #base_eq (#int_plus (x, z), #int_plus (y, t))
proof:
  coq proof
  {* unfold __g_int_plus, __g_base_eq_ in |- *; intros x y z t H1 H2;
     apply EQ_base_eq; replace y with x. replace t with z. reflexivity.
     apply decidable. apply Z_eq_dec. assumption.
     apply decidable. apply Z_eq_dec. assumption. *}
;;

theorem int_le_plus_plus: all x y z t in int,
  #int_leq (x, y) -> #int_leq (z, t) ->
    #int_leq (#int_plus (x, z), #int_plus (y, t))
proof:
   coq proof
     {* unfold __g_int_plus, __g_int_leq in |- *; intros x y z t H1 H2;
        apply dec_IsTrue; apply Zplus_le_compat;
        [ exact (IsTrue_dec H1) | exact (IsTrue_dec H2) ]. *}
;;

let succ(x) = #int_plus (x, 1) ;;
external value int_mult : int -> int -> int =
  | caml -> "Focvasives.int_mult"
  | coq -> "int_mult"
;;
external value int_minus : int -> int -> int =
  | caml -> "Focvasives.int_minus"
  | coq -> "int_moins"
;;
external value int_max : int -> int -> int =
  | caml -> "Focvasives.int_max"
  | coq -> "max"
;;
external value int_min : int -> int -> int =
  | caml -> "Focvasives.int_min"
  | coq -> "min"
;;

theorem int_min_le: all x y z in int,
  (#int_leq (z, x) and #int_leq (z, y)) -> #int_leq (z, #int_min (x, y))
proof:
   coq proof
     {* intros x y z H; elim H; intros H1 H2; clear H;
        unfold __g_int_min in |- *; elim (Z_lt_dec x y);
        intros H; trivial. *}
;;

theorem int_min_le2: all x y z in int,
  #int_leq (z, #int_min (x, y)) -> (#int_leq (z, x) and #int_leq (z, y))
proof:
   coq proof
   {*
   intros x y z; unfold __g_int_min in |- *.
   case (Z_lt_dec x y); intros H1 H2; split; trivial.
   apply int_le_trans with x; trivial.
   unfold __g_int_leq in |- *; apply dec_IsTrue; apply Zlt_le_weak; trivial.
   apply int_le_trans with y; trivial.
   unfold __g_int_leq in |- *; apply dec_IsTrue.
   elim (Zle_or_lt y x); trivial.   intros Habs; absurd (x < y)%Z; trivial.
 *}
;;

theorem int_plus_minus: all x y z in int,
  #base_eq (#int_plus (x, y), z) -> #base_eq (y, #int_minus (z, x))
proof:
   coq proof
   {*
   intros x y z; unfold __g_int_plus, __g_int_minus, __g_base_eq_ in |- *;
   intros H; apply EQ_base_eq; apply Zplus_minus_eq;
   symmetry  in |- *; apply (decidable _ _ _ (Z_eq_dec (x + y) z) H).
 *}
 ;;

theorem int_minus_plus: all x y z in int,
 #base_eq (#int_minus (x, y), z) -> #base_eq (x, #int_plus (y, z))
proof:
   coq proof
   {*
   intros x y z; unfold __g_int_plus, __g_int_minus, __g_base_eq_ in |- *;
   intros H; apply EQ_base_eq; rewrite <- (Zplus_minus y x);
   apply Zplus_eq_compat; trivial; apply decidable. apply Z_eq_dec. assumption.
   *}
;;

(* String operations. *)
(* Concatenation. *)
external value sc : string -> string -> string =
  | caml -> "Focvasives.str_cat" ;;
external value str_lt : string -> string -> bool =
  | caml -> "Focvasives.str_lt" ;;
external value print_string : string -> unit =
  | caml -> "Focvasives.str_print" ;;
let print_newline (x in unit) = print_string ("\n") ;;


(*                                                                       *)
(*  A basic object is a normal blurb on which we do some things          *)
(*  This is the root of the species' hierarchy                           *)
(*                                                                       *)
species Basic_object =
  (* Generic print function. *)
  let print (x in Self) = "<abst>" ;
  (* Generic parse function. *)
  let parse (x in string) in Self = #foc_error ("not parsable") ;


(* .......... SNIPED .......... *)

end ;;
