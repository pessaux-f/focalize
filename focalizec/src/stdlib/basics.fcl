(***********************************************************************)
(*                                                                     *)
(*                        FoCaLize compiler                            *)
(*                                                                     *)
(*            Renaud Rioboo                                            *)
(*            Virgile Prevosto                                         *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                               LIP6  -  INRIA Rocquencourt           *)
(*                                                                     *)
(*  Copyright 2007 LIP6 and INRIA                                      *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: basics.fcl,v 1.34 2008-10-31 09:50:09 weis Exp $ *)

(** {3 The very basic definitions for focalize code} *)

(** [basics.fcl] contents:
    - built-in or (almost) mandatory type definitions,
    - built-in or (almost) mandatory data definitions. *)

(** {6 Type definitions} *)

type int =
  internal (* Internal#int *)
  external
  | caml -> {* int *}
  | coq -> {* Z *}
;;

type unit =
  internal (* Internal#unit *)
  | ()
  external
  | caml -> {* unit *}
  | coq -> {* coq_builtins.bi__unit *}  (* FoCaLize's Coq definition of builtin. *)

and () =
  | caml -> {* () *}
  | coq -> {* coq_builtins.Void *}
;;

type float =
  internal (* Internal#float *)
  external
  | caml -> {* float *}
  | coq -> {* R *}  (* From the Reals module. *)
;;

type char =
  internal (* Internal#char *)
  external
  | caml -> {* char *}
  | coq -> {* ascii *}
;;

type string =
  internal (* Internal#string *)
  external
  | caml -> {* string *}
  | coq -> {* string *}  (* From the Ascii module. *)
;;

type bool =
  internal (* Internal#bool *)
  | True
  | False
  external
  | caml -> {* bool *}
  | coq -> {* bool *}  (* Builtin of Coq *)

and True =
  | caml -> {* true *}
  | coq -> {* True *}

and False =
  | caml -> {* false *}
  | coq -> {* False *}
;;

(** Note that is it impossible to alias the type of propositions [prop__t] to
   Coq [Prop] here, since "prop" is a keyword of FoCaLize, hence this makes a
   crude syntax error. However, "Prop" is not available for OCaml programs, so
   we can safely hard-define it in coq_builtins.v. *)

type list ('a) =
  internal
  | []
  | ( :: ) ('a, list ('a))
  external
  | caml -> {* 'a list *}
  | coq -> {* (list __var_a) *} (* From the List module. *)

and [] =
  | caml -> {* [] *}
  | coq -> {* nil *}

and ( :: ) =
  | caml -> {* ( :: ) *}
  | coq -> {* cons *}
;;

(** {6 Basic operations on basic types} *)

let foc_error =
  internal string -> 'a
  external
  | caml -> {* Ml_builtins.bi__foc_error *}
  | coq -> {* coq_builtins.foc_error *}
;;

(** Operations on booleans. *)
let ( && ) =
  internal bool -> bool -> bool
  external
  | caml -> {* Ml_builtins.bi__and_b *}
  | coq -> {* coq_builtins.bi__and_b *}
;;

let ( || ) =
  internal bool -> bool -> bool
  external
  | caml -> {* Ml_builtins.bi__or_b *}
  | coq -> {* coq_builtins.bi__or_b *}
;;

let ( ~| ) =
  internal bool -> bool
  external
  | caml -> {* Ml_builtins.bi__not_b *}
  | coq -> {* coq_builtins.bi__not_b *}
;;

let ( |<>| ) =
  internal bool -> bool -> bool
  external
  | caml -> {* Ml_builtins.bi__xor_b *}
  | coq -> {* coq_builtins.bi__xor_b *}
;;

let and_b = ( && );;
let or_b = ( || );;
let not_b = ( ~| );;
let xor_b = ( |<>| );;

(** Operations on pairs. *)
let pair (x, y) = (x, y) ;;
let fst (x) =
  match x with
  | (v, _) -> v
;;

let snd (x) =
  match x with
  | (_, v) -> v
;;

(* For compatibility only: should be removed ? *)
let crp = pair;;
let first = fst;;
let scnd = snd;;

(** Basic printing. *)
let print_int =
  internal int -> unit
  external
  | caml -> {* Ml_builtins.bi__int_print *}
  | coq -> {* fun (x : int__t) => coq_builtins.Void *}
;;

let print_newline =
  internal unit -> unit
  external
  | caml -> {* Ml_builtins.bi__int_print *}
  | coq -> {* fun (x : unit__t) => coq_builtins.Void *}
;;

let string_of_int =
  internal int -> string
  external
  | caml -> {* Ml_builtins.bi__string_of_int *}
  | coq -> {* fun (x : int__t) => coq_builtins.___a_string *}
;;

let int_of_string =
  internal string -> int
  external
  | caml -> {* Ml_builtins.bi__int_of_string *}
  | coq -> {* fun (x : string__t) => 42 *}
;;

(** Operations on strings. *)

(* Concatenation. *)
let ( ^ ) =
  internal string -> string -> string
  external
  | caml -> {* Ml_builtins.bi__str_cat *}
  | coq -> {* fun (x : string__t) (y : string__t) => coq_builtins.___a_string *}
;;

(* For compatibility only: should be removed ? *)
let sc = ( ^ );;

let ( <^ ) =
  internal string -> string -> bool
  external
  | caml -> {* Ml_builtins.bi__str_lt *}
  | coq -> {* fun (x : string__t) (y : string__t) => true *}
;;

(* For compatibility only: should be removed ? *)
let str_lt = ( <^ );;

let print_string =
  internal string -> unit
  external
  | caml -> {* Ml_builtins.bi__str_print *}
  | coq -> {* fun (x : string__t) => coq_builtins.Void *}
;;

(** Operations on integers. *)

let int_mod =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_mod *}
  | coq -> {* coq_builtins.bi__int_mod *}
;;

let int_eq =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_eq *}
  | coq -> {* coq_builtins.bi__int_eq *}
;;

let ( =0x ) = int_eq;;

let int_lt =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_lt *}
  | coq -> {* coq_builtins.bi__int_lt *}
;;

let ( <0x ) = int_lt;;

let int_leq =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_leq *}
  | coq -> {* coq_builtins.bi__int_leq *}
;;

let ( <=0x ) = int_leq;;

let int_geq =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_geq *}
  | coq -> {* coq_builtins.bi__int_geq *}
;;

let ( >=0x ) = int_geq;;

let int_gt =
  internal  int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_gt *}
  | coq -> {* coq_builtins.bi__int_gt *}
;;

let ( >0x ) = int_gt;;

let pred =
  internal int -> int
  external
  | caml -> {* pred *}
  | coq -> {*  coq_builtins.bi__int_pred *}
;;

let int_opp =
  internal int -> int
  external
  | caml -> {* Ml_builtins.bi__int_opposite *}
  | coq -> {* coq_builtins.bi__int_opposite *}
;;

let ( ~0x ) = int_opp;;

let int_plus =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_plus *}
  | coq -> {* coq_builtins.bi__int_plus *}
;;

let ( + ) (x, y) = int_plus (x, y) ;;

let succ (x in int) in int = int_plus (x, 1) ;;

let int_mult =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_mult *}
  | coq -> {* coq_builtins.bi__int_mult *}
;;

let ( * ) = int_mult;;

let int_minus =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_minus *}
  | coq -> {* coq_builtins.bi__int_minus *}
;;

let ( - ) = int_minus;;

let int_max =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_max *}
  | coq -> {* coq_builtins.bi__int_max *}
;;

let int_min =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_min *}
  | coq -> {* coq_builtins.bi__int_min *}
;;

let int_div =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_div *}
  | coq -> {* coq_builtins.bi__int_div *}
;;

let ( % ) = int_div;;

(** Polymorphic equalities. *)

let physical_equal =
  internal 'a ->'a -> bool
  external
  | caml -> {* Ml_builtins.bi__base_equal *}
  | coq -> {* coq_builtins.bi__base_eq __var_a *}
    (* Wrong, but don't know how to do better. *)
;;

let ( == ) = physical_equal
;;

(* For compatibility only: should be removed ? *)
let phys_eq = physical_equal
;;

let syntactic_equal =
  internal  'a -> 'a -> bool
  external
  | caml -> {* Ml_builtins.bi__base_eq *}
  | coq -> {* coq_builtins.bi__base_eq __var_a *}
;;

let ( = ) = syntactic_equal;;

(* For compatibility only: should be removed ? *)
let base_eq = syntactic_equal;;

(** Theorems on comparisons. *)

theorem beq_refl : all x in 'a, base_eq (x, x)
  (* x = x *)
  proof: assumed {* Import trusted external code. *} ;;
theorem beq_symm : all x y in 'a,
  (* x = y -> y = x *)
  base_eq (x, y) -> base_eq (y, x)
  proof: assumed {* Import trusted external code. *} ;;
theorem beq_trans :
  all x y z in 'a, base_eq (x, y) -> base_eq (y, z) -> base_eq (x, z)
  proof: assumed {* Import trusted external code. *} ;;

theorem int_le_not_gt :
  all x y in int, int_leq (x, y) -> ~ (int_gt (x, y))
  proof:
    coq proof {*
      intros x y; unfold int_leq, int_gt in |- *.
      unfold bi__int_leq , bi__int_gt.
      elim (Z_le_dec x y).
      intros H.
      intros b; clear b.
      elim (Z_gt_dec x y).
      intros H1; absurd (x > y)%Z.
      apply Zle_not_gt; trivial.
      trivial.
      compute in |- *; trivial.
      compute in |- *; trivial.
      Qed.
    *}
;;

theorem int_lt_le_trans :
  all x y z in int, int_lt (x, y) -> int_leq (y, z) -> int_lt (x, z)
  proof:
    coq proof {*
      intros x y z.
      unfold int_lt, int_leq, bi__int_lt, bi__int_leq in |- *.
      elim (Z_lt_dec x y).
      elim (Z_le_dec y z).
      intros Hle Hlt foo bar; clear foo bar.
      elim (Z_lt_dec x z).
      intros H; compute in |- *; trivial.
      intros H; absurd (x < z)%Z; trivial.
      apply (Zlt_le_trans x y z); trivial.
      intros b a H Habs; compute in |- *; contradiction.
      intros b H; compute in H; contradiction.
      Qed.
    *}
;;

theorem int_le_refl :
  all x y in int, base_eq (x, y) -> int_leq (x, y)
  proof: assumed {* Import trusted external code. *}
;;

theorem int_le_antisymm:
  all x y in int, int_leq (x, y) -> int_leq (y, x) -> base_eq (x, y)
  proof:
    coq proof {*
      intros x y.
      unfold int_leq, bi__int_leq in |- *.
      elim (Z_le_dec x y); elim (Z_le_dec y x).
      intros H1 H2.
      intros b c; clear b c.
      replace x with y.
      eapply beq_refl.
      apply Zle_antisym; trivial.
      intros b a H; clear H a.
      compute in |- *; intros Habs; eapply False_ind; trivial.
      intros a b Habs H; clear H a; compute in Habs; eapply False_ind; trivial.
      intros a b Habs H; clear H a; compute in Habs; eapply False_ind; trivial.
      Qed.
    *}
;;

theorem int_le_trans:
  all x y z in int,  #int_leq(x, y) -> #int_leq (y, z) -> #int_leq(x, z)
  proof:
    coq proof {*
      unfold int_leq, bi__int_leq in |- *; intros x y z H1 H2.
      apply dec_IsTrue. cut (x <= y)%Z. cut (y <= z)%Z.
      eauto with zarith.
      eapply IsTrue_dec. apply H2.
      eapply IsTrue_dec; apply H1.
      Qed.
    *}
;;

theorem int_lt_irrefl :
  all x y in int, int_lt (x, y) -> ~ base_eq (x, y)
  proof: assumed {* Import trusted external code. *}
;;

(** Theorems on integer operations. *)

theorem int_0_plus: all x y in int,
  #base_eq (x, 0) -> #base_eq (#int_plus (x, y), y)
  proof:
    coq proof {*
      unfold int_plus, bi__int_plus in |- *; intros x y Hxz;
      unfold base_eq;
      apply EQ_base_eq; replace x with 0%Z; eauto with zarith.
      symmetry  in |- *.
      apply decidable.
      apply Z_eq_dec. assumption.
      Qed.
    *}
;;

theorem int_lt_le_S:
  all x y in int, #int_lt (x, y) -> #int_leq (#int_plus (x, 1), y)
  proof:
    coq proof {*
      unfold int_lt, int_leq, int_plus in |- *; intros x y Hlt;
      unfold bi__int_lt, bi__int_leq, bi__int_plus;
      apply dec_IsTrue; fold (Zsucc x) in |- *; apply Zlt_le_succ;
      trivial. exact (IsTrue_dec Hlt).
      Qed.
    *}
;;

theorem int_plus_assoc: all x y z in int,
  #base_eq (#int_plus (#int_plus (x, y), z), #int_plus (x, #int_plus (y, z)))
  proof:
    coq proof {*
      unfold int_plus in |- *; intros x y z;
      unfold base_eq;
      apply EQ_base_eq; auto with zarith.
      Qed.
    *}
;;

theorem int_plus_commute: all x y  in int,
  (* x + y = y + x *)
  #base_eq (#int_plus (x, y), #int_plus (y, x))
  proof:
    coq proof {*
      unfold int_plus in |- *; intros x y;
      unfold base_eq;
      apply EQ_base_eq;
      auto with zarith.
      Qed.
    *}
;;

theorem int_plus_plus:  all x y z t in int,
  #base_eq (x, y) -> #base_eq (z, t) ->
  #base_eq (#int_plus (x, z), #int_plus (y, t))
  proof:
    coq proof {*
      unfold int_plus in |- *; intros x y z t H1 H2;
      unfold base_eq;
      apply EQ_base_eq; replace y with x. replace t with z. reflexivity.
      apply decidable. apply Z_eq_dec. assumption.
      apply decidable. apply Z_eq_dec. assumption.
      Qed.
    *}
;;

theorem int_le_plus_plus: all x y z t in int,
  #int_leq (x, y) -> #int_leq (z, t) ->
  #int_leq (#int_plus (x, z), #int_plus (y, t))
  proof:
    coq proof {*
      unfold int_plus, int_leq in |- *; intros x y z t H1 H2;
      unfold bi__int_leq, bi__int_plus, bi__int_plus;
      apply dec_IsTrue; apply Zplus_le_compat;
      [ exact (IsTrue_dec H1) | exact (IsTrue_dec H2) ].
      Qed.
    *}
;;

theorem int_min_le: all x y z in int,
  (#int_leq (z, x) /\ #int_leq (z, y)) -> #int_leq (z, #int_min (x, y))
  proof:
    coq proof {*
      intros x y z H; elim H; intros H1 H2; clear H;
      unfold int_min in |- *;
      unfold bi__int_min;
      elim (Z_lt_dec x y);
      intros H; trivial.
      Qed.
    *}
;;

(*** ??? ********* *)
theorem int_min_le2: all x y z in int,
  #int_leq (z, #int_min (x, y)) -> (#int_leq (z, x) /\ #int_leq (z, y))
  proof:
    coq proof {*
      intros x y z; unfold int_min in |- *.
      unfold bi__int_min.
      case (Z_lt_dec x y); intros H1 H2; split; trivial.
      apply int_le_trans with x; trivial.
      unfold int_leq in |- *;
      unfold int_leq, bi__int_leq;
      apply dec_IsTrue; apply Zlt_le_weak; trivial.
      apply int_le_trans with y; trivial.
      unfold int_leq in |- *; unfold bi__int_leq; apply dec_IsTrue.
      elim (Zle_or_lt y x); trivial.   intros Habs; absurd (x < y)%Z; trivial.
      Qed.
    *}
;;

theorem int_plus_minus: all x y z in int,
  (*   x + y = z -> y = z - x *)
  #base_eq (#int_plus (x, y), z) -> #base_eq (y, #int_minus (z, x))
  proof:
    coq proof {*
      intros x y z; unfold int_plus, int_minus, base_eq in |- *;
      intros H;
      unfold bi__int_minus;
      apply EQ_base_eq; apply Zplus_minus_eq;
      symmetry  in |- *; apply (decidable _ _ _ (Z_eq_dec (x + y) z) H).
      Qed.
    *}
;;

theorem int_minus_plus: all x y z in int,
  (*   x - y = z -> x = y + z *)
  #base_eq (#int_minus (x, y), z) -> #base_eq (x, #int_plus (y, z))
  proof:
    coq proof {*
      intros x y z; unfold int_plus, int_minus, base_eq in |- *;
      intros H;
      unfold bi__int_minus;
      apply EQ_base_eq; rewrite <- (Zplus_minus y x);
      apply Zplus_eq_compat; trivial; apply decidable. apply Z_eq_dec. assumption.
      Qed.
    *}
;;

(** {3 Species} *)

(** A [Basic_object] value is a normal blurb on which we do some things.
    This is the root of the species' hierarchy. *)

species Basic_object =
  (* Generic print function. *)
  let print (_x in Self) = "<abst>" ;
  (* Generic parse function. *)
  let parse (_x in string) in Self = #foc_error ("not parsable") ;
end
;;


(* .......... SNIPED .......... *)

type partiel ('a) =
  | Failed
  | Unfailed ('a)
;;


let is_failed (x) =
  match x with
  | Failed -> true
  | Unfailed (_) -> false
;;

let non_failed (x) =
  match x with
  | Failed -> foc_error("partial function")
  | Unfailed (a) -> a
;;

(* .......... SNIPED .......... *)
