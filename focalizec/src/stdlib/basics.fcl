(***********************************************************************)
(*                                                                     *)
(*                        FoCaLize compiler                            *)
(*                                                                     *)
(*            Renaud Rioboo                                            *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                                                                     *)
(*                               LIP6  -  INRIA Rocquencourt           *)
(*                                                                     *)
(*  Copyright 2007 - 2009 LIP6 and INRIA                               *)
(*            2012 ENSTA ParisTech                                     *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(** {3 The very basic definitions for focalize code} *)

(** [basics.fcl] contents:
    - built-in or (almost) mandatory type definitions,
    - built-in or (almost) mandatory data definitions,
    - basic properties and theorems on those types and data. *)

(** {6 Type definitions} *)

type int =
  internal (* Internal#int *)
  external
  | caml -> {* int *}
  | coq -> {* Z *}
;;

type unit =
  internal (* Internal#unit *)
  | ()
  external
  | caml -> {* unit *}
  | coq -> {* coq_builtins.bi__unit *}  (* FoCaLize's Coq definition of builtin. *)

  with () =
  | caml -> {* () *}
  | coq -> {* coq_builtins.Void *}
;;

type float =
  internal (* Internal#float *)
  external
  | caml -> {* float *}
  | coq -> {* R *}  (* From the Reals module. *)
;;

type char =
  internal (* Internal#char *)
  external
  | caml -> {* char *}
  | coq -> {* ascii *}
;;

type string =
  internal (* Internal#string *)
  external
  | caml -> {* string *}
  | coq -> {* string *}  (* From the Ascii module. *)
;;

type bool =
  internal (* Internal#bool *)
  | True
  | False
  external
  | caml -> {* bool *}
  (* Uggly hack to insert the induction principles below the type definition.
     We just alias the principles coming from the List module of Coq. *)
  | coq -> {* bool.
              Definition bool__t_ind := bool_ind.
              Definition bool__t_rect := bool_rect.
              Definition bool__t_rec := bool_rec
           *}  (* Builtin of Coq *)

  with True =
  | caml -> {* true *}
  | coq -> {* true *}

  and False =
  | caml -> {* false *}
  | coq -> {* false *}
;;

(** Note that it is impossible to alias the type of propositions [prop__t] to
   Coq [Prop] here, since "prop" is a keyword in FoCaLiZe, hence this makes a
   crude syntax error. However, "Prop" is not available for OCaml programs, so
   we can safely hard-define it in coq_builtins.v. *)

type list ('a) =
  internal
  | []
  | ( :: ) ('a, list ('a))
  external
  | caml -> {* 'a list *}
  (* Uggly hack to insert the induction principles below the type definition.
     We just alias the principles coming from the List module of Coq.
     Was bug #53. *)
  | coq -> {* (List.list __var_a).
              Definition list__t_ind := list_ind.
              Definition list__t_rect := list_rect.
              Definition list__t_rec := list_rec *}

  with [] =
  | caml -> {* [] *}
  | coq -> {* List.nil *}

  and ( :: ) =
  | caml -> {* ( :: ) *}
  | coq -> {* List.cons *}
;;

(** {6 Basic operations on basic types} *)

(** {7 Operations on booleans} *)
let ( && ) =
  internal bool -> bool -> bool
  external
  | caml -> {* Ml_builtins.bi__and_b *}
  | coq -> {* coq_builtins.bi__and_b *}
;;


let ( || ) =
  internal bool -> bool -> bool
  external
  | caml -> {* Ml_builtins.bi__or_b *}
  | coq -> {* coq_builtins.bi__or_b *}
;;


let ( ~~ ) =
  internal bool -> bool
  external
  | caml -> {* Ml_builtins.bi__not_b *}
  | coq -> {* coq_builtins.bi__not_b *}
;;


let ( |<>| ) =
  internal bool -> bool -> bool
  external
  | caml -> {* Ml_builtins.bi__xor_b *}
  | coq -> {* coq_builtins.bi__xor_b *}
;;


(** {7 Operations on pairs} *)
let pair (x, y) = (x, y) ;;


let fst (x) =
  match x with
  | (v, _) -> v
;;


let snd (x) =
  match x with
  | (_, v) -> v
;;

(** {7 Operations on strings} *)

(* Concatenation. *)
let ( ^ ) =
  internal string -> string -> string
  external
  | caml -> {* Ml_builtins.bi__string_concat *}
  | coq -> {* String.append *}
;;


let ( <^ ) =
  internal string -> string -> bool
  external
  | caml -> {* Ml_builtins.bi__string_lt *}
  | coq -> {* fun (x : string__t) (y : string__t) => true *}
;;

(** {7 Operations on integers} *)

(** {8 Comparisons on integers} *)
let ( =0x ) =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_eq *}
  | coq -> {* coq_builtins.bi__int_eq *}
;;


let ( <0x ) =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_lt *}
  | coq -> {* coq_builtins.bi__int_lt *}
;;


let ( <=0x ) =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_leq *}
  | coq -> {* coq_builtins.bi__int_leq *}
;;


let ( >=0x ) =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_geq *}
  | coq -> {* coq_builtins.bi__int_geq *}
;;


let ( >0x ) =
  internal  int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_gt *}
  | coq -> {* coq_builtins.bi__int_gt *}
;;


(** {8 Arithmetic operations for integers} *)
let ( + ) =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_plus *}
  | coq -> {* coq_builtins.bi__int_plus *}
;;


let ( - ) =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_minus *}
  | coq -> {* coq_builtins.bi__int_minus *}
;;


let ( ~0x ) =
  internal int -> int
  external
  | caml -> {* Ml_builtins.bi__int_opposite *}
  | coq -> {* coq_builtins.bi__int_opposite *}
;;


let ( * ) =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_mult *}
  | coq -> {* coq_builtins.bi__int_mult *}
;;


(** Euclidian division quotient. *)
let ( / ) =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_div *}
  | coq -> {* coq_builtins.bi__int_div *}
;;


(** Euclidian division rest. *)
let ( % ) =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_mod *}
  | coq -> {* coq_builtins.bi__int_mod *}
;;


(** Successor. *)
let succ0x (x : int) : int = x + 1 ;;


(** Predecessor. *)
let pred0x (x : int) : int = x - 1 ;;


(** Maximum and minimum of two integer values. *)
let max0x =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_max *}
  | coq -> {* coq_builtins.bi__int_max *}
;;


let min0x =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_min *}
  | coq -> {* coq_builtins.bi__int_min *}
;;


(** Absolute value for integers. *)
let abs0x =
  internal int -> int
  external
  | caml -> {* Ml_builtins.bi__int_abs *}
  | coq -> {* coq_builtins.bi__int_abs *}
;;


(** String convertions for integers. [Unsure] *)
let string_of_int =
  internal int -> string
  external
  | caml -> {* Ml_builtins.bi__string_of_int *}
  | coq -> {* fun (x : int__t) => "42"%string *}
;;


let int_of_string =
  internal string -> int
  external
  | caml -> {* Ml_builtins.bi__int_of_string *}
  | coq -> {* fun (x : string__t) => 42 *}
;;


(** {7 Polymorphic equalities} *)

(** {8 Syntactical equality} *)

(** A polymorphic predicate to test equality of obects
    (two objects are consider equal if and only if they are provably
    equivalent, i.e. if and only if they have the same
    semantical meaning, e.g. two character strings with the same character
    contents). *)
let ( = ) =
  internal 'a -> 'a -> bool
  external
  | caml -> {* Ml_builtins.bi__syntactic_equal *}
  | coq -> {* coq_builtins.bi__syntactic_equal _ *}
;;


let syntactic_equal = ( = ) ;;


(** {7 Basic printing operations} *)
let print_int =
  internal int -> unit
  external
  | caml -> {* Ml_builtins.bi__print_int *}
  | coq -> {* fun (x : int__t) => coq_builtins.Void *}
;;


let print_newline =
  internal unit -> unit
  external
  | caml -> {* Ml_builtins.bi__print_newline *}
  | coq -> {* fun (x : unit__t) => coq_builtins.Void *}
;;


let print_string =
  internal string -> unit
  external
  | caml -> {* Ml_builtins.bi__print_string *}
  | coq -> {* fun (x : string__t) => coq_builtins.Void *}
;;


(** {6 Basic theorems and properties} *)

(** {7 Theorems on comparisons} *)

(** {8 Polymorphic syntactic equality fundamental theorem} *)

(** The polymorphic syntactic equality is an equivalence relation. *)
theorem beq_refl :
  all x : 'a, x = x
  proof = coq proof {* apply syntactic_equal_refl. Qed. *} ;;


theorem beq_symm :
  all x y : 'a, x = y -> y = x
  proof = coq proof {* apply syntactic_equal_sym. Qed. *} ;;


theorem beq_trans :
  all x y z : 'a, x = y -> y = z -> x = z
  proof = coq proof {* apply syntactic_equal_trans. Qed. *} ;;


(** {8 Integer comparisons fundamental properties} *)
theorem int_gt_lt_swap :
  all x y : int, (x >0x y) -> (y <0x x)
  proof =
    coq proof {*
    intros x y. unfold _gt_0x, _lt_0x. unfold bi__int_gt, bi__int_lt.
    elim Z_gt_dec. intros. elim Z_lt_dec. intro. compute. trivial. intro.
    compute. auto with zarith. intro. intro. elim Z_lt_dec. intro. compute.
    trivial. intro. compute. auto with zarith. Qed.
    *}
;;


theorem int_lt_gt_swap :
  all x y : int, (x <0x y) -> (y >0x x)
  proof =
    coq proof {*
    intros x y. unfold _lt_0x, _gt_0x. unfold bi__int_lt, bi__int_gt.
    elim Z_lt_dec. intros. elim Z_gt_dec. intros. compute. trivial. intro.
    compute. auto with zarith. intros. elim Z_gt_dec. intro. compute. trivial.
    intro. compute. auto with zarith. Qed.
    *}
;;


theorem int_ge_le_swap :
  all x y : int , (x >=0x y) -> (y <=0x x)
  proof =
    coq proof {*
    intros x y. unfold _gt__equal_0x, _lt__equal_0x.
    unfold bi__int_geq, bi__int_leq. elim Z_ge_dec. intros. elim Z_le_dec.
    intro. compute. trivial. intros. compute. auto with zarith. intros.
    elim Z_le_dec. intro. compute. trivial. intro. compute. auto with zarith.
    Qed.
    *}
;;


theorem int_le_ge_swap :
  all x y : int , (x <=0x y) -> (y >=0x x)
  proof =
    coq proof {*
    intros x y. unfold _lt__equal_0x, _gt__equal_0x, bi__int_leq, bi__int_geq.
    elim (Z_le_dec x y). intros. elim (Z_ge_dec y x). intro. auto. intro. auto.
    compute. compute in H. apply Zle_not_gt in a. apply Zgt_not_le in a.
    exact a. clear a. apply Znot_le_gt. apply Zlt_not_le. apply Znot_ge_lt.
    exact b. intros. elim (Z_ge_dec y x). intro. compute. auto. intro. compute.
    compute in H. exact H. Qed.
    *}
;;


theorem int_le_not_lt :
  all x y : int, (x <=0x y) -> ~ (y <0x x)
  proof =
    coq proof {*
    intros x y. unfold _lt__equal_0x, _lt_0x. unfold bi__int_leq, bi__int_lt.
    elim Z_le_dec. intros. elim Z_lt_dec. intros. compute. intro.
    auto with zarith. intro. compute. trivial. intros. elim Z_lt_dec. intro.
    compute. auto with zarith. intro. compute. auto with zarith. Qed.
    *}
;;


theorem int_lt_not_le :
  all x y : int, (x <0x y) -> ~ (y <=0x x)
  proof =
    coq proof {*
    intros x y. unfold _lt_0x, _lt__equal_0x. unfold bi__int_lt, bi__int_leq.
    elim Z_lt_dec. intros. elim Z_le_dec. intro. compute. auto with zarith.
    intro. auto with zarith. intros. elim Z_le_dec. auto with zarith.
    auto with zarith. Qed.
    *}
;;


theorem int_lt_not_gt :
  all x y : int, (x <0x y) -> ~ (x >0x y)
  proof =
    coq proof {*
    intros x y. unfold _lt_0x, _gt_0x. unfold bi__int_lt, bi__int_gt.
    elim (Z_lt_dec x y). intro. simpl. intro. elim (Z_gt_dec x y).
    simpl. intros. intro. auto with zarith. intro. simpl. auto with zarith.
    intros. auto with zarith. Qed.
    *}
;;


theorem int_le_not_gt :
  all x y : int, (x <=0x y) -> ~ (x >0x y)
  proof =
    coq proof {*
    intros x y; unfold _lt__equal_0x, _gt_0x  in |- *.
    unfold bi__int_leq , bi__int_gt. elim (Z_le_dec x y). intros H.
    intros b; clear b. elim (Z_gt_dec x y). intros H1; absurd (x > y)%Z.
    apply Zle_not_gt; trivial. trivial.
    compute in |- *; trivial. compute in |- *; trivial. Qed.
    *}
;;


theorem int_gt_not_le :
  all x y : int, (x >0x y) -> ~ (x <=0x y)
  proof =
    coq proof {*
    intros x y. unfold _gt_0x, _lt__equal_0x. unfold bi__int_gt, bi__int_leq.
    elim Z_gt_dec. intros. elim Z_le_dec. intro. compute. auto with zarith.
    intro. compute. auto with zarith. intros. elim Z_le_dec. auto with zarith.
    intro. auto with zarith. Qed.
    *}
;;


theorem int_not_ge_lt :
  all x y : int, ~ (x >=0x y) -> (x <0x y)
  proof =
    coq proof {*
    intros x y. unfold _gt__equal_0x, _lt_0x. unfold bi__int_geq, bi__int_lt.
    elim Z_ge_dec. intros. elim Z_lt_dec. intro. compute. trivial. intro.
    compute. compute in H. auto with zarith. intros. elim Z_lt_dec. intro.
    compute. trivial. intro. compute. compute in H. auto with zarith. Qed.
    *}
;;


theorem int_not_lt_ge :
  all x y : int, ~ (x <0x y) -> (x >=0x y)
  proof =
    coq proof {*
    intros x y. unfold _lt_0x, _gt__equal_0x. unfold bi__int_lt, bi__int_geq.
    elim Z_lt_dec. intros. elim Z_ge_dec. intro.
    compute. trivial. intro. compute. compute in H. auto with zarith.
    intro. intro. elim Z_ge_dec. intro. compute. trivial. intro. compute.
    auto with zarith. Qed.
    *}
;;


theorem int_not_gt_le :
  all x y : int, ~ (x >0x y) -> (x <=0x y)
  proof =
    coq proof {*
    intros x y. unfold _gt_0x, _lt__equal_0x. unfold bi__int_gt, bi__int_leq.
    elim Z_gt_dec. intro.  intro. elim Z_le_dec. intro. compute. trivial.
    intro. compute. compute in H. apply Zgt_not_le in a. auto with zarith.
    intro. intro. elim Z_le_dec. intro. compute. trivial. intro. compute.
    auto with zarith. Qed.
    *}
;;


theorem int_not_le_gt :
  all x y : int, ~ (x <=0x y) -> (x >0x y)
  proof =
    coq proof {*
    intros x y. unfold _lt__equal_0x, _gt_0x. unfold bi__int_leq, bi__int_gt.
    elim Z_le_dec. intros. elim Z_gt_dec. intro. compute. trivial. intro.
    compute. compute in H. auto with zarith. intros. elim Z_gt_dec. intro.
    compute. trivial. intro. compute. compute in H. auto with zarith. Qed.
    *}
;;


theorem int_lt_le_trans :
  all x y z : int,  x <0x y -> y <=0x z -> x <0x z
  proof =
    coq proof {*
    intros x y z. unfold _lt_0x, _lt__equal_0x, bi__int_lt, bi__int_leq in |- *.
    elim (Z_lt_dec x y). elim (Z_le_dec y z).
    intros Hle Hlt foo bar; clear foo bar.
    elim (Z_lt_dec x z). intros H; compute in |- *; trivial.
    intros H; absurd (x < z)%Z; trivial. apply (Zlt_le_trans x y z); trivial.
    intros b a H Habs; compute in |- *; contradiction.
    intros b H; compute in H; contradiction. Qed.
    *}
;;


theorem int_le_refl :
  all x y : int, x = y -> x <=0x y
  proof =
    coq proof {*
    intros x y. unfold _lt__equal_0x. unfold bi__int_leq. unfold _equal_.
    elim Z_le_dec. intro. intro. compute. trivial. intros. compute.
    apply Znot_le_gt in b.
    apply zenon_syntactic_equal with (S := int__t) (x := x) (y := y).
    intros. apply zenon_focal_eqdec. intro. apply Zgt_not_le in b.
    auto with zarith. trivial. Qed.
    *}
;;


theorem int_le_antisymm:
  all x y : int, x <=0x y -> y <=0x x -> x = y
  proof =
    coq proof {*
    intros x y.
    unfold _lt__equal_0x, bi__int_leq in |- *.
    elim (Z_le_dec x y); elim (Z_le_dec y x).
    intros H1 H2. intros b c; clear b c. replace x with y.
    eapply beq_refl. apply Zle_antisym; trivial.
    intros b a H; clear H a.
    compute in |- *; intros Habs; eapply False_ind; trivial.
    intros a b Habs H; clear H a; compute in Habs; eapply False_ind; trivial.
    intros a b Habs H; clear H a; compute in Habs; eapply False_ind; trivial.
    Qed.
    *}
;;

theorem int_le_trans:
  all x y z : int, x <=0x y -> y <=0x z -> x <=0x z
  proof =
    coq proof {*
    unfold _lt__equal_0x, bi__int_leq in |- *; intros x y z H1 H2.
    apply dec_IsTrue. cut (x <= y)%Z. cut (y <= z)%Z.
    eauto with zarith. eapply IsTrue_dec. apply H2.
    eapply IsTrue_dec; apply H1. Qed.
    *}
;;


theorem int_lt_irrefl :
  all x y : int, x <0x y -> ~ x = y
  proof =
    coq proof {*
    intros x y. unfold _lt_0x. unfold bi__int_lt. elim Z_lt_dec. intros.
    compute in H. intro. unfold _equal_ in H0.
    apply zenon_syntactic_equal with (S := int__t) (x := x) (y := y).
    intro. apply zenon_focal_eqdec. auto with zarith. apply Zlt_not_eq.
    trivial. trivial. intro. compute. intros. trivial. Qed.
    *}
;;


theorem int_gt_or_le :
  all x y : int, (x >0x y) \/ (x <=0x y)
  proof =
    coq proof {*
    intros x y. unfold _gt_0x, _lt__equal_0x. unfold bi__int_leq, bi__int_gt.
    elim (Z_gt_dec x y). intro H. elim (Z_le_dec x y). intro. compute.
    auto. intro. compute. auto. intro. elim (Z_le_dec x y). intro. compute.
    right. auto. intro. compute. absurd (~ x > y). auto. auto. Qed.
    *}
;;


theorem int_gt_implies_ge :
  all x y : int, x >0x y -> x >=0x y
  proof =
    coq proof {*
    intros x y. unfold _gt_0x, _gt__equal_0x. unfold bi__int_gt, bi__int_geq.
    elim (Z_gt_dec x y). intros. compute in H. elim (Z_ge_dec x y). intros.
    compute. auto. intro. compute. apply Znot_ge_lt in b. auto with zarith.
    intros. compute in H. elim (Z_ge_dec x y). intro. compute. auto. intro.
    compute. assumption. Qed.
    *}
;;


theorem int_diff_ge_is_pos : all x y : int, x >=0x y -> x - y >=0x 0
proof =
  (* Heavy use of doc:
       coq_8_4_stdlib/Coq.ZArith.Zorder.html
       coq_8_4_stdlib/Coq.ZArith.BinInt.html *)
    coq proof {*
    intros x y. unfold _gt_0x, _gt__equal_0x, _dash_.
    unfold bi__int_gt, bi__int_geq, bi__int_minus. elim (Z_ge_dec x y).
    intros. compute in H. elim (Z_ge_dec (x - y) 0). intros. compute. auto.
    intros. compute. apply Zge_le in a.  (* n <= m -> m >= n *)
    elim b. apply Zle_ge. apply Zle_minus_le_0.  (* m <= n -> 0 <= n - m *)
    assumption. intro. intro. elim (Z_ge_dec (x - y) 0). intros. compute.
    auto. intros. compute. compute in H. assumption. Qed.
    *}
;;


(** {7 Theorems for integer operations} *)
theorem int_0_plus:
  all x y : int, x = 0 -> x + y = y
  proof =
    coq proof {*
      unfold bi__int_plus in |- *; intros x y Hxz;
      unfold _equal_, syntactic_equal;
      apply EQ_syntactic_equal; replace x with 0%Z; eauto with zarith.
      symmetry  in |- *. apply decidable. apply Z_eq_dec. assumption. Qed.
    *}
;;


theorem int_lt_le_S:
  all x y : int, x <0x y -> x + 1 <=0x y
  proof =
    coq proof {*
      unfold _lt_0x, _lt__equal_0x, _plus_ in |- *; intros x y Hlt;
      unfold bi__int_lt, bi__int_leq, bi__int_plus;
      apply dec_IsTrue; fold (Zsucc x) in |- *; apply Zlt_le_succ;
      trivial. exact (IsTrue_dec Hlt). Qed.
    *}
;;


theorem int_plus_assoc:
  all x y z : int, (x + y) + z = x + (y + z)
  proof =
    coq proof {*
      intros x y z; unfold _equal_, syntactic_equal;
      apply EQ_syntactic_equal; auto with zarith. Qed.
    *}
;;


theorem int_plus_commute:
  all x y  : int, x + y = y + x
  proof =
    coq proof {*
      intros x y; unfold _equal_, syntactic_equal; apply EQ_syntactic_equal;
      auto with zarith. Qed.
    *}
;;


theorem int_plus_plus:
  all x y z t : int,
  x = y -> z = t -> x + z = y + t
  proof =
    coq proof {*
      intros x y z t H1 H2;
      unfold _equal_;
      apply EQ_syntactic_equal; replace y with x. replace t with z. reflexivity.
      apply decidable. apply Z_eq_dec. assumption.
      apply decidable. apply Z_eq_dec. assumption. Qed.
    *}
;;


theorem int_le_plus_plus:
  all x y z t : int, x <=0x y -> z <=0x t -> x + z <=0x y + t
  proof =
    coq proof {*
      unfold _plus_, _lt__equal_0x in |- *; intros x y z t H1 H2;
      unfold bi__int_leq, bi__int_plus, bi__int_plus;
      apply dec_IsTrue; apply Zplus_le_compat;
      [ exact (IsTrue_dec H1) | exact (IsTrue_dec H2) ]. Qed.
    *}
;;


theorem int_min_le:
  all x y z : int, (z <=0x x /\ z <=0x y) -> z <=0x min0x (x, y)
  proof =
    coq proof {*
      intros x y z H; elim H; intros H1 H2; clear H;
      unfold min0x in |- *; unfold bi__int_min; elim (Z_lt_dec x y);
      intros H; trivial. Qed.
    *}
;;


theorem int_min_le2:
  all x y z : int, z <=0x min0x (x, y) -> (z <=0x x /\ z <=0x y)
  proof =
    coq proof {*
      intros x y z; unfold min0x in |- *.
      unfold bi__int_min.
      case (Z_lt_dec x y); intros H1 H2; split; trivial.
      apply int_le_trans with x; trivial. unfold _lt__equal_0x, bi__int_leq;
      apply dec_IsTrue; apply Zlt_le_weak; trivial.
      apply int_le_trans with y; trivial.
      unfold _lt__equal_0x, bi__int_leq; apply dec_IsTrue.
      elim (Zle_or_lt y x); trivial.   intros Habs; absurd (x < y)%Z; trivial.
      Qed.
    *}
;;


theorem int_plus_minus: all x y z : int,
  x + y = z -> (y = z - x)
  proof =
    coq proof {*
      intros x y z; unfold syntactic_equal in |- *;
      intros H;
      unfold bi__int_minus, _equal_, syntactic_equal;
      apply EQ_syntactic_equal; apply Zplus_minus_eq;
      symmetry  in |- *; apply (decidable _ _ _ (Z_eq_dec (x + y) z) H). Qed.
    *}
;;


theorem int_minus_plus:
  all x y z : int,
  x - y = z -> x = y + z
  proof =
    coq proof {*
      intros x y z; unfold syntactic_equal in |- *;
      intros H;
      unfold bi__int_minus, _equal_, syntactic_equal;
      apply EQ_syntactic_equal; rewrite <- (Zplus_minus y x);
      apply Zplus_eq_compat; trivial; apply decidable. apply Z_eq_dec. assumption.      Qed.
    *}
;;


(** {3 Basic species definitions} *)
let focalize_error =
  internal string -> 'a
  external
  | caml -> {* Ml_builtins.bi__focalize_error *}
  | coq -> {* coq_builtins.focalize_error *}
;;


(** A [Basic_object] value is a normal blurb on which we do some things.
    This is the root of the species' hierarchy. *)
species Basic_object =
  (* Generic print function. *)
  let print (_x : Self) = "<abst>" ;
  (* Generic parse function. *)
  let parse (_x : string) : Self = #focalize_error ("not parsable") ;
end
;;


(** Embed a FoCaLiZe function of type 'a -> 'a -> bool into a *property* that
    it is a well-founded order. This is *not* a theorem ! This is a somewhat
    of logical let indeed. *)
let well_wrapper =
  internal ('a -> 'a -> bool) -> prop
  external
  | caml -> {* () *}
  | coq -> {* (fun f => well_founded (fun x y => Is_true (f x y))) *}
;;


(* .......... SNIPED .......... *)

type partiel ('a) =
   | Failed
   | Unfailed ('a)
;;


let is_failed (x) =
  match x with
  | Failed -> true
  | Unfailed (_) -> false
;;


let non_failed (x) =
  match x with
  | Failed -> focalize_error ("partial function")
  | Unfailed (a) -> a
;;

(* .......... SNIPED .......... *)
