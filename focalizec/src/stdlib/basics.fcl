(** The very basic definitions for focalize code:
    built-in or (almost) mandatory type definitions;
    built-in or (almost) mandatory data definitions.
*)

type int =
  internal (* Internal#int *)
  external
  | caml -> {* int *}
  | coq -> {* Z *}
  | "c" -> {* int with
              equality(int_equal) =
                @inline int int_equal(int x, int y)
                 { return (x == y); }@ *}
;;

type unit =
  internal (* Internal#unit *)
  | ()
  external
  | caml -> {* unit *}
  | coq -> {* coq_builtins.bi__unit *} 
     (* FoCaLize's Coq definition of builtin. *)
  | "c" -> {* void* with
              equality = @inline int unit_equal*}

and () =
  | caml -> {* () *}
  | coq -> {* coq_builtins.Null *}
  | "c" -> {* mk_foc_unit *}
;;

type float =
  internal (* Internal#float *)
  external
  | caml -> {* float *}
  | coq -> {* R *}  (* From the Reals module. *)
  | "c" -> {* foc_float *}
;;

type char =
  internal (* Internal#char *)
  external
  | caml -> {* char *}
  | coq -> {* ascii *}
  | "c" -> {* foc_char *}
;;

type string =
  internal (* Internal#string *)
  external
  | caml -> {* string *}
  | coq -> {* string *}  (* From the Ascii module. *)
  | "c" -> {* foc_string *}
;;

type bool =
  internal (* Internal#bool *)
  | True
  | False
  external
  | caml -> {* bool *}
  | coq -> {* bool *}  (* Builtin of Coq *)
  | "c" -> {* foc_bool *}

and True =
  | caml -> {* true *}
  | coq -> {* True *}
  | "c" -> {* mk_foc_true *}

and False =
  | caml -> {* false *}
  | coq -> {* False *}
  | "c" -> {* mk_foc_false *}
;;

type list ('a) =
  internal
  | []
  | ( :: ) (*Cons*) ('a, list ('a))
  external
  | caml -> {* 'a list *}
  | coq -> {* (list __var_a) *} (* From the List module. *)
  | "c" -> {* foc_list *}

and [] =
  | caml -> {* [] *}
  | coq -> {* nil *}
  | "c" -> {* mk_foc_nil *}

and ( :: ) (*Cons*) =
  | caml -> {* ( :: ) *}
  | coq -> {* cons *}
  | "c"-> {* mk_foc_cons *}
;;

let foc_error =
  internal string -> 'a
  external
   | caml -> {* Ml_builtins.foc_error *}
   | coq -> {* foc_error *}
   | "c" -> {* c_builtins_foc_error *}
;;

let and_b (x, y) =
  match (x, y) with
  | (true, true) -> true
  | (false, false) -> false
  | (_, _) -> false
;;

let or_b (x, y) =
   match (x, y) with
   | (true, _) -> true
   | (_, true) -> true
   | (_, _) -> false
;;

let not_b (x) in bool =
  match x with
  | true -> false
  | false -> true
;;

let xor_b (x, y) =
  or_b (and_b (x, not_b (y)), and_b (not_b (x), y))
;;

(* Operations on pairs. *)
let crp (x, y) = (x, y) ;;
let first (x) = match x with | (v, _ ) -> v ;;
let scnd (x) = match x with | (_, v) -> v ;;

(* Operations on integers. *)
let string_of_int =
  internal int -> string
  external
  | caml -> {* Ml_builtins.string_of_int *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_string_of_int *}
;;

let int_of_string =
  internal string -> int
  external
  | caml -> {* Ml_builtins.int_of_string *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_int_of_string *}
;;

let print_int =
  internal int -> unit
  external
  | caml -> {* Ml_builtins.int_print *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_print_int *}
;;

let int_mod =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.int_mod *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_int_mod *}
;;

let int_eq =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.int_eq *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_int_eq *}
;;

let int_div =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.int_div *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_int_div *}
;;

let int_lt =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.int_lt *}
  | coq -> {* int_lt *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_int_lt *}
;;

let int_leq =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.int_leq *}
  | coq -> {* int_leq *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_int_leq *}
;;

let int_geq =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.int_geq *}
  | coq -> {* int_geq *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_int_geq *}
;;

let int_gt =
  internal  int -> int -> bool
  external
  | caml -> {* Ml_builtins.int_gt *}
  | coq -> {* int_gt *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_int_gt *}
;;

let phys_eq =
  internal 'a ->'a -> bool
  external
  | caml -> {* Ml_builtins.base_equal *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_phys_eq *}
;;

let base_eq =
  internal  'a -> 'a -> bool
  external
  | caml -> {* Ml_builtins.base_eq *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_base_eq *}
;;

let ( = ) (x, y) = base_eq (x, y) ;;
let ( && ) (x, y) = and_b (x, y) ;;
let ( || ) (x, y) = or_b (x, y) ;;

theorem beq_refl : all x in 'a, base_eq (x, x)
  proof: assumed {* Import trusted external code. *} ;;
theorem beq_symm: all x y in 'a, base_eq (x, y) -> base_eq (y, x)
  proof: assumed {* Import trusted external code. *} ;;
theorem beq_trans: all x y z in 'a, base_eq (x, y) -> base_eq (y, z) ->
  base_eq (x, z)
proof: assumed {* Import trusted external code. *} ;;

theorem int_le_not_gt :
  all x y in int, int_leq (x, y) -> ~ (int_gt (x, y))
  proof:
    coq proof
   {* Intros x y; Unfold __g_int_leq __g_int_gt.
   Elim (Z_le_dec x y).
   Intros H.
   Intros b; Clear b.
   Elim (Z_gt_dec x y).
   Intros H1; Absurd `x > y`.
   Apply Zle_not_gt; Trivial.
   Trivial.
   Compute; Trivial.
   Compute; Trivial. *)
    intros x y; unfold __g_int_leq, __g_int_gt in |- *.
    elim (Z_le_dec x y).
    intros H.
    intros b; clear b.
  elim (Z_gt_dec x y).
  intros H1; absurd (x > y)%Z.
  apply Zle_not_gt; trivial.
  trivial.
  compute in |- *; trivial.
  compute in |- *; trivial. *}
;;

theorem int_lt_le_trans :
  all x y z in int, int_lt (x, y) -> int_leq (y, z) -> int_lt (x, z)
proof:
  coq proof
  {* intros x y z.
     unfold __g_int_lt, __g_int_leq in |- *.
     elim (Z_lt_dec x y).
     elim (Z_le_dec y z).
     intros Hle Hlt foo bar; clear foo bar.
     elim (Z_lt_dec x z).
     intros H; compute in |- *; trivial.
     intros H; absurd (x < z)%Z; trivial.
     apply (Zlt_le_trans x y z); trivial.
     intros b a H Habs; compute in |- *; contradiction.
     intros b H; compute in H; contradiction. *}
;;

theorem int_lt_le_trans :
  all x y z in int, int_lt (x, y) -> int_leq (y, z) -> int_lt (x, z)
proof:
  coq proof
  {* intros x y z.
     unfold __g_int_lt, __g_int_leq in |- *.
     elim (Z_lt_dec x y).
     elim (Z_le_dec y z).
     intros Hle Hlt foo bar; clear foo bar.
     elim (Z_lt_dec x z).
     intros H; compute in |- *; trivial.
     intros H; absurd (x < z)%Z; trivial.
     apply (Zlt_le_trans x y z); trivial.
     intros b a H Habs; compute in |- *; contradiction.
     intros b H; compute in H; contradiction. *}
;;

theorem int_le_refl :
  all x y in int, base_eq (x, y) -> int_leq (x, y)
  proof: assumed {* Import trusted external code. *} ;;

theorem int_le_antisymm:
  all x y in int, int_leq (x, y) -> int_leq (y, x) -> base_eq (x, y)
proof:
  coq proof
  {* intros x y.
     unfold __g_int_leq in |- *.
     elim (Z_le_dec x y); elim (Z_le_dec y x).
     intros H1 H2.
     intros b c; clear b c.
     replace x with y.
     eapply beq_refl.
     apply Zle_antisym; trivial.
     intros b a H; clear H a.
     compute in |- *; intros Habs; eapply False_ind; trivial.
     intros a b Habs H; clear H a; compute in Habs; eapply False_ind; trivial.
     intros a b Habs H; clear H a; compute in Habs; eapply False_ind; trivial.
  *}
;;

theorem int_le_trans:
  all x y z in int,  #int_leq(x, y) -> #int_leq (y, z) -> #int_leq(x, z)
proof:
  coq proof
  {* unfold __g_int_leq in |- *; intros x y z H1 H2.
     apply dec_IsTrue. cut (x <= y)%Z. cut (y <= z)%Z.
     eauto with zarith.
     eapply IsTrue_dec. apply H2.
     eapply IsTrue_dec; apply H1.
  *}
;;

theorem int_lt_irrefl :
  all x y in int, int_lt (x, y) -> ~ base_eq (x, y)
proof: assumed {* Import trusted external code. *} ;;

let pred =
  internal int -> int
  external
  | caml -> {* Ml_builtins.pred *}
  | coq -> {* coq_builtins.bi__int_pred *}
  | "c" -> {* c_builtins_pred *}
;;

let int_opp =
  internal  int -> int
  external
  | caml -> {* Ml_builtins.int_opposite *}
  | coq -> {* coq_builtins.bi__int_opposite *}
  | "c" -> {* c_builtins_int_opp *}
;;

let int_plus =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.int_plus *}
  | coq -> {* coq_builtins.bi__int_plus *}
  | "c" -> {* c_builtins_int_plus *}
;;

let ( + ) (x, y) = int_plus (x, y) ;;


theorem int_0_plus: all x y in int,
  #base_eq (x, 0) -> #base_eq (#int_plus (x, y), y)
proof:
  coq proof
  {* unfold __g_int_plus, __g_base_eq_ in |- *; intros x y Hxz;
     apply EQ_base_eq; replace x with 0%Z; eauto with zarith.
     symmetry  in |- *.
     apply decidable.
     apply Z_eq_dec. assumption. *}
;;

theorem int_lt_le_S:
  all x y in int, #int_lt (x, y) -> #int_leq (#int_plus (x, 1), y)
proof:
  coq proof
  {* unfold __g_int_lt, __g_int_leq, __g_int_plus in |- *; intros x y Hlt;
     apply dec_IsTrue; fold (Zsucc x) in |- *; apply Zlt_le_succ;
     trivial. exact (IsTrue_dec Hlt). *}
;;

theorem int_plus_assoc: all x y z in int,
  #base_eq (#int_plus (#int_plus (x, y), z), #int_plus (x, #int_plus (y, z)))
proof:
  coq proof
    {* unfold __g_int_plus, __g_base_eq_ in |- *; intros x y z;
       apply EQ_base_eq; auto with zarith. *}
;;

theorem int_plus_commute: all x y  in int,
  #base_eq (#int_plus (x, y), #int_plus (y, x))
proof:
  coq proof {*
    unfold __g_int_plus, __g_base_eq_ in |- *; intros x y; apply EQ_base_eq;
    auto with zarith. *}
;;

theorem int_plus_plus:  all x y z t in int,
  #base_eq (x, y) ->
    #base_eq (z, t) -> #base_eq (#int_plus (x, z), #int_plus (y, t))
proof:
  coq proof
  {* unfold __g_int_plus, __g_base_eq_ in |- *; intros x y z t H1 H2;
     apply EQ_base_eq; replace y with x. replace t with z. reflexivity.
     apply decidable. apply Z_eq_dec. assumption.
     apply decidable. apply Z_eq_dec. assumption. *}
;;

theorem int_le_plus_plus: all x y z t in int,
  #int_leq (x, y) -> #int_leq (z, t) ->
    #int_leq (#int_plus (x, z), #int_plus (y, t))
proof:
   coq proof
     {* unfold __g_int_plus, __g_int_leq in |- *; intros x y z t H1 H2;
        apply dec_IsTrue; apply Zplus_le_compat;
        [ exact (IsTrue_dec H1) | exact (IsTrue_dec H2) ]. *}
;;

let succ(x) = #int_plus (x, 1) ;;
let int_mult =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.int_mult *}
  | coq -> {* coq_builtins.bi__int_mult *}
  | "c" -> {* c_builtins_int_mult *}
;;

let int_minus =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.int_minus *}
  | coq -> {* coq_builtins.bi__int_minus *}
  | "c" -> {* c_builtins_int_minus *}
;;

let int_max =
  internal  int -> int -> int
  external
  | caml -> {* Ml_builtins.int_max *}
  | coq -> {* coq_builtins.bi__int_max *}
  | "c" -> {* c_builtins_int_max *}
;;

let int_min =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.int_min *}
  | coq -> {* coq_builtins.bi__int_min *}
  | "c" -> {* c_builtins_int_min *}
;;

theorem int_min_le: all x y z in int,
  (#int_leq (z, x) /\ #int_leq (z, y)) -> #int_leq (z, #int_min (x, y))
proof:
   coq proof
     {* intros x y z H; elim H; intros H1 H2; clear H;
        unfold __g_int_min in |- *; elim (Z_lt_dec x y);
        intros H; trivial. *}
;;

theorem int_min_le2: all x y z in int,
  #int_leq (z, #int_min (x, y)) -> (#int_leq (z, x) /\ #int_leq (z, y))
proof:
   coq proof
   {*
   intros x y z; unfold __g_int_min in |- *.
   case (Z_lt_dec x y); intros H1 H2; split; trivial.
   apply int_le_trans with x; trivial.
   unfold __g_int_leq in |- *; apply dec_IsTrue; apply Zlt_le_weak; trivial.
   apply int_le_trans with y; trivial.
   unfold __g_int_leq in |- *; apply dec_IsTrue.
   elim (Zle_or_lt y x); trivial.   intros Habs; absurd (x < y)%Z; trivial.
 *}
;;

theorem int_plus_minus: all x y z in int,
  #base_eq (#int_plus (x, y), z) -> #base_eq (y, #int_minus (z, x))
proof:
   coq proof
   {*
   intros x y z; unfold __g_int_plus, __g_int_minus, __g_base_eq_ in |- *;
   intros H; apply EQ_base_eq; apply Zplus_minus_eq;
   symmetry  in |- *; apply (decidable _ _ _ (Z_eq_dec (x + y) z) H).
 *}
 ;;

theorem int_minus_plus: all x y z in int,
 #base_eq (#int_minus (x, y), z) -> #base_eq (x, #int_plus (y, z))
proof:
   coq proof
   {*
   intros x y z; unfold __g_int_plus, __g_int_minus, __g_base_eq_ in |- *;
   intros H; apply EQ_base_eq; rewrite <- (Zplus_minus y x);
   apply Zplus_eq_compat; trivial; apply decidable. apply Z_eq_dec. assumption.
   *}
;;

(* String operations. *)

(* Concatenation. *)
let sc =
  internal  string -> string -> string
  external
  | caml -> {* Ml_builtins.str_cat *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_sc *}
;;

let ( ^ ) (x, y) = sc (x, y) ;;

let str_lt =
  internal string -> string -> bool
  external
  | caml -> {* Ml_builtins.str_lt *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_str_lt *}
;;

let print_string =
  internal string -> unit
  external
  | caml -> {* Ml_builtins.str_print *}
  | coq -> {* [Unsure] *}
  | "c" -> {* c_builtins_print_string *}
;;

let print_newline (x in unit) = print_string ("\n") ;;


(*                                                                       *)
(*  A basic object is a normal blurb on which we do some things          *)
(*  This is the root of the species' hierarchy                           *)
(*                                                                       *)
species Basic_object =
  (* Generic print function. *)
  let print (x in Self) = "<abst>" ;
  (* Generic parse function. *)
  let parse (x in string) in Self = #foc_error ("not parsable") ;
end ;;


(* .......... SNIPED .......... *)

type partiel ('a) =
  | Failed
  | Unfailed ('a)
;;


let is_failed (x) = match x with | Failed -> true | Unfailed (_) -> false ;;

let non_failed (x) =
   match x with
   | Failed -> foc_error("partial function")
   | Unfailed (a) -> a
;;

(* .......... SNIPED .......... *)

