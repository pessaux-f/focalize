(***********************************************************************)
(*                                                                     *)
(*                        FoCaLize compiler                            *)
(*                                                                     *)
(*            Renaud Rioboo                                            *)
(*            Virgile Prevosto                                         *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                                                                     *)
(*                               LIP6  -  INRIA Rocquencourt           *)
(*                                                                     *)
(*  Copyright 2007, 2008 LIP6 and INRIA                                      *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: basics.fcl,v 1.49 2008-12-01 12:24:49 weis Exp $ *)

(** {3 The very basic definitions for focalize code} *)

(** [basics.fcl] contents:
    - built-in or (almost) mandatory type definitions,
    - built-in or (almost) mandatory data definitions,
    - basic properties and theorems on those types and data. *)

(** {6 Type definitions} *)

type int =
  internal (* Internal#int *)
  external
  | caml -> {* int *}
  | coq -> {* Z *}
;;

type unit =
  internal (* Internal#unit *)
  | ()
  external
  | caml -> {* unit *}
  | coq -> {* coq_builtins.bi__unit *}  (* FoCaLize's Coq definition of builtin. *)

and () =
  | caml -> {* () *}
  | coq -> {* coq_builtins.Void *}
;;

type float =
  internal (* Internal#float *)
  external
  | caml -> {* float *}
  | coq -> {* R *}  (* From the Reals module. *)
;;

type char =
  internal (* Internal#char *)
  external
  | caml -> {* char *}
  | coq -> {* ascii *}
;;

type string =
  internal (* Internal#string *)
  external
  | caml -> {* string *}
  | coq -> {* string *}  (* From the Ascii module. *)
;;

type bool =
  internal (* Internal#bool *)
  | True
  | False
  external
  | caml -> {* bool *}
  | coq -> {* bool *}  (* Builtin of Coq *)

and True =
  | caml -> {* true *}
  | coq -> {* True *}

and False =
  | caml -> {* false *}
  | coq -> {* False *}
;;

(** Note that is it impossible to alias the type of propositions [prop__t] to
   Coq [Prop] here, since "prop" is a keyword of FoCaLize, hence this makes a
   crude syntax error. However, "Prop" is not available for OCaml programs, so
   we can safely hard-define it in coq_builtins.v. *)

type list ('a) =
  internal
  | []
  | ( :: ) ('a, list ('a))
  external
  | caml -> {* 'a list *}
  | coq -> {* (list __var_a) *} (* From the List module. *)

and [] =
  | caml -> {* [] *}
  | coq -> {* List.nil *}

and ( :: ) =
  | caml -> {* ( :: ) *}
  | coq -> {* List.cons *}
;;

(** {6 Basic operations on basic types} *)

let focalize_error =
  internal string -> 'a
  external
  | caml -> {* Ml_builtins.bi__focalize_error *}
  | coq -> {* coq_builtins.focalize_error *}
;;

(** {7 Operations on booleans} *)
let ( && ) =
  internal bool -> bool -> bool
  external
  | caml -> {* Ml_builtins.bi__and_b *}
  | coq -> {* coq_builtins.bi__and_b *}
;;

let ( || ) =
  internal bool -> bool -> bool
  external
  | caml -> {* Ml_builtins.bi__or_b *}
  | coq -> {* coq_builtins.bi__or_b *}
;;

let ( ~| ) =
  internal bool -> bool
  external
  | caml -> {* Ml_builtins.bi__not_b *}
  | coq -> {* coq_builtins.bi__not_b *}
;;

let ( |<>| ) =
  internal bool -> bool -> bool
  external
  | caml -> {* Ml_builtins.bi__xor_b *}
  | coq -> {* coq_builtins.bi__xor_b *}
;;

(* For compatibility only: should be removed ? *)
let and_b = ( && );;
let or_b = ( || );;
let not_b = ( ~| );;
let xor_b = ( |<>| );;

(** {7 Operations on pairs} *)
let pair (x, y) = (x, y);;

let fst (x) =
  match x with
  | (v, _) -> v
;;

let snd (x) =
  match x with
  | (_, v) -> v
;;

(** {7 Operations on strings} *)

(* Concatenation. *)
let ( ^ ) =
  internal string -> string -> string
  external
  | caml -> {* Ml_builtins.bi__string_concat *}
  | coq -> {* fun (x : string__t) (y : string__t) => coq_builtins.___a_string *}
;;

let ( <^ ) =
  internal string -> string -> bool
  external
  | caml -> {* Ml_builtins.bi__string_lt *}
  | coq -> {* fun (x : string__t) (y : string__t) => true *}
;;

(** {7 Operations on integers} *)

(** {8 Comparisons on integers} *)

let ( =0x ) =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_eq *}
  | coq -> {* coq_builtins.bi__int_eq *}
;;

let int_eq = ( =0x );;

(* FIXME should work
let ( <0x ) =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_lt *}
  | coq -> {* coq_builtins.bi__int_lt *}
;;

let int_lt = ( <0x );;
*)

let int_lt =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_lt *}
  | coq -> {* coq_builtins.bi__int_lt *}
;;

let ( <0x ) = int_lt;;

(* FIXME should work
let ( <=0x ) =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_leq *}
  | coq -> {* coq_builtins.bi__int_leq *}
;;

let int_leq = ( <=0x );;
*)

let int_leq =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_leq *}
  | coq -> {* coq_builtins.bi__int_leq *}
;;

let ( <=0x ) = int_leq;;

(* FIXME should work
let ( >=0x ) =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_geq *}
  | coq -> {* coq_builtins.bi__int_geq *}
;;

let int_geq = ( >=0x );;

and does not. *)

let int_geq =
  internal int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_geq *}
  | coq -> {* coq_builtins.bi__int_geq *}
;;

let ( >=0x ) = int_geq;;

(* FIXME should work
let ( >0x ) =
  internal  int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_gt *}
  | coq -> {* coq_builtins.bi__int_gt *}
;;

let int_gt = ( >0x );;

and does not. *)

let int_gt =
  internal  int -> int -> bool
  external
  | caml -> {* Ml_builtins.bi__int_gt *}
  | coq -> {* coq_builtins.bi__int_gt *}
;;

let ( >0x ) = int_gt;;

(** {8 Arithmetic operations for integers} *)

(* FIXME should work

let ( + ) =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_plus *}
  | coq -> {* coq_builtins.bi__int_plus *}
;;

let int_plus = ( + );;

and does not. *)

let int_plus =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_plus *}
  | coq -> {* coq_builtins.bi__int_plus *}
;;

let ( + ) = int_plus;;

let ( - ) =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_minus *}
  | coq -> {* coq_builtins.bi__int_minus *}
;;

let int_minus = ( - );;

let ( ~0x ) =
  internal int -> int
  external
  | caml -> {* Ml_builtins.bi__int_opposite *}
  | coq -> {* coq_builtins.bi__int_opposite *}
;;

let int_opp = ( ~0x );;

let ( * ) =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_mult *}
  | coq -> {* coq_builtins.bi__int_mult *}
;;

let int_mult = ( * );;

let ( / ) =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_div *}
  | coq -> {* coq_builtins.bi__int_div *}
;;

let int_div = ( / );;

let ( % ) =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_mod *}
  | coq -> {* coq_builtins.bi__int_mod *}
;;

let int_mod = ( % );;

(* FIXME should work
let succ (x in int) in int = x + 1;;
*)

let succ (x in int) in int = int_plus (x, 1);;

let pred =
  internal int -> int
  external
  | caml -> {* pred *}
  | coq -> {*  coq_builtins.bi__int_pred *}
;;

(* FIXME should work
let pred (x in int) in int = x - 1
;;
*)

let int_max =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_max *}
  | coq -> {* coq_builtins.bi__int_max *}
;;

let int_min =
  internal int -> int -> int
  external
  | caml -> {* Ml_builtins.bi__int_min *}
  | coq -> {* coq_builtins.bi__int_min *}
;;

(** {7 Polymorphic equalities} *)

(** {8 Physical identity} *)

(** A polymorphic predicate to test identity of objects
 (two objects are considered identical if and only if they are the
  same object, e.g. the two objects are stored at the same address in the
  computer memory). *)

let physical_equal =
  internal 'a -> 'a -> bool
  external
  | caml -> {* Ml_builtins.bi__base_physical_equal *}
  | coq -> {* coq_builtins.bi__base_eq __var_a *}
    (* Wrong, but don't know how to do better. *)
;;

let ( == ) = physical_equal
;;

(* For compatibility only: should be removed ? *)
let phys_eq = physical_equal
;;

(** {8 Syntactical equality} *)

(** A polymorphic predicate to test equality of obects
    (two objects are consider equal if and only if they are provably
    equivalent, i.e. if and only if they have the same
    semantical meaning, e.g. two character strings with the same character
    contents). *)

(* FIXME should work

let ( = ) =
  internal 'a -> 'a -> bool
  external
  | caml -> {* Ml_builtins.bi__base_syntactic_equal *}
  | coq -> {* coq_builtins.bi__base_eq __var_a *}
;;

let syntactic_equal = ( = );;

and does not. *)

let syntactic_equal =
  internal 'a -> 'a -> bool
  external
  | caml -> {* Ml_builtins.bi__base_syntactic_equal *}
  | coq -> {* coq_builtins.bi__base_eq __var_a *}
;;

let ( = ) = syntactic_equal;;

(* For compatibility only: should be removed ? *)
let base_eq = syntactic_equal;;

(** {7 Basic printing operations} *)
let print_int =
  internal int -> unit
  external
  | caml -> {* Ml_builtins.bi__int_print *}
  | coq -> {* fun (x : int__t) => coq_builtins.Void *}
;;

let print_newline =
  internal unit -> unit
  external
  | caml -> {* Ml_builtins.bi__int_print *}
  | coq -> {* fun (x : unit__t) => coq_builtins.Void *}
;;

let string_of_int =
  internal int -> string
  external
  | caml -> {* Ml_builtins.bi__string_of_int *}
  | coq -> {* fun (x : int__t) => coq_builtins.___a_string *}
;;

let int_of_string =
  internal string -> int
  external
  | caml -> {* Ml_builtins.bi__int_of_string *}
  | coq -> {* fun (x : string__t) => 42 *}
;;

let print_string =
  internal string -> unit
  external
  | caml -> {* Ml_builtins.bi__string_print *}
  | coq -> {* fun (x : string__t) => coq_builtins.Void *}
;;

(** {6 Basic theorems and properties} *)

(** {7 Theorems on comparisons} *)

(** {8 Polymorphic syntactic equality fundamental theorem} *)

(** The polymorphic syntactic equality is an equivalence relation. *)

theorem beq_refl :
  all x in 'a, x = x
  proof = assumed {* Import trusted external code. *} ;;

theorem beq_symm :
  all x y in 'a, x = y -> y = x
  proof = assumed {* Import trusted external code. *} ;;

theorem beq_trans :
  all x y z in 'a, x = y -> y = z -> x = z
  proof = assumed {* Import trusted external code. *} ;;

(** {8 Integer comparisons fundamental properties} *)

theorem int_le_not_gt :
  all x y in int, int_leq (x, y) -> ~ (int_gt (x, y))
  proof =
    coq proof {*
      intros x y; unfold int_leq, int_gt in |- *.
      unfold bi__int_leq , bi__int_gt.
      elim (Z_le_dec x y).
      intros H.
      intros b; clear b.
      elim (Z_gt_dec x y).
      intros H1; absurd (x > y)%Z.
      apply Zle_not_gt; trivial.
      trivial.
      compute in |- *; trivial.
      compute in |- *; trivial.
      Qed.
    *}
;;

theorem int_lt_le_trans :
  all x y z in int, int_lt (x, y) -> int_leq (y, z) -> int_lt (x, z)
  proof =
    coq proof {*
      intros x y z.
      unfold int_lt, int_leq, bi__int_lt, bi__int_leq in |- *.
      elim (Z_lt_dec x y).
      elim (Z_le_dec y z).
      intros Hle Hlt foo bar; clear foo bar.
      elim (Z_lt_dec x z).
      intros H; compute in |- *; trivial.
      intros H; absurd (x < z)%Z; trivial.
      apply (Zlt_le_trans x y z); trivial.
      intros b a H Habs; compute in |- *; contradiction.
      intros b H; compute in H; contradiction.
      Qed.
    *}
;;

theorem int_le_refl :
  all x y in int, x = y -> x <=0x y
  proof = assumed {* Import trusted external code. *}
;;

theorem int_le_antisymm:
  all x y in int, int_leq (x, y) -> int_leq (y, x) -> x = y
  proof =
    coq proof {*
      intros x y.
      unfold int_leq, bi__int_leq in |- *.
      elim (Z_le_dec x y); elim (Z_le_dec y x).
      intros H1 H2.
      intros b c; clear b c.
      replace x with y.
      eapply beq_refl.
      apply Zle_antisym; trivial.
      intros b a H; clear H a.
      compute in |- *; intros Habs; eapply False_ind; trivial.
      intros a b Habs H; clear H a; compute in Habs; eapply False_ind; trivial.
      intros a b Habs H; clear H a; compute in Habs; eapply False_ind; trivial.
      Qed.
    *}
;;

theorem int_le_trans:
  all x y z in int,  #int_leq(x, y) -> #int_leq (y, z) -> #int_leq(x, z)
  proof =
    coq proof {*
      unfold int_leq, bi__int_leq in |- *; intros x y z H1 H2.
      apply dec_IsTrue. cut (x <= y)%Z. cut (y <= z)%Z.
      eauto with zarith.
      eapply IsTrue_dec. apply H2.
      eapply IsTrue_dec; apply H1.
      Qed.
    *}
;;

theorem int_lt_irrefl :
  all x y in int, x <0x y -> ~ x = y
  proof = assumed {* Import trusted external code. *}
;;

(** {7 Theorems for integer operations} *)

theorem int_0_plus:
  all x y in int, x = 0 -> x + y = y
  proof =
    coq proof {*
      unfold int_plus, bi__int_plus in |- *; intros x y Hxz;
      unfold base_eq, _eq_, syntactic_equal;
      apply EQ_base_eq; replace x with 0%Z; eauto with zarith.
      symmetry  in |- *.
      apply decidable.
      apply Z_eq_dec. assumption.
      Qed.
    *}
;;

theorem int_lt_le_S:
  all x y in int, #int_lt (x, y) -> #int_leq (#int_plus (x, 1), y)
  proof =
    coq proof {*
      unfold int_lt, int_leq, int_plus in |- *; intros x y Hlt;
      unfold bi__int_lt, bi__int_leq, bi__int_plus;
      apply dec_IsTrue; fold (Zsucc x) in |- *; apply Zlt_le_succ;
      trivial. exact (IsTrue_dec Hlt).
      Qed.
    *}
;;

theorem int_plus_assoc:
  all x y z in int, (* (x + y) + z = x + (y + z) *)
  #base_eq ((x + y) + z, x + (y + z))
  proof =
    coq proof {*
      unfold int_plus in |- *; intros x y z;
      unfold base_eq, syntactic_equal;
      apply EQ_base_eq; auto with zarith.
      Qed.
    *}
;;

theorem int_plus_commute:
  all x y  in int, (* x + y = y + x *)
  #base_eq (x + y, y + x)
  proof =
    coq proof {*
      unfold int_plus in |- *; intros x y;
      unfold base_eq, syntactic_equal;
      apply EQ_base_eq;
      auto with zarith.
      Qed.
    *}
;;

theorem int_plus_plus:
  all x y z t in int,
  x = y -> z = t ->
  #base_eq (x + z, y + t)
  proof =
    coq proof {*
      unfold int_plus in |- *; intros x y z t H1 H2;
      unfold base_eq, syntactic_equal;
      apply EQ_base_eq; replace y with x. replace t with z. reflexivity.
      apply decidable. apply Z_eq_dec. assumption.
      apply decidable. apply Z_eq_dec. assumption.
      Qed.
    *}
;;

theorem int_le_plus_plus:
  all x y z t in int,
  #int_leq (x, y) -> #int_leq (z, t) ->
  #int_leq (x + z, y + t)
  proof =
    coq proof {*
      unfold int_plus, int_leq in |- *; intros x y z t H1 H2;
      unfold bi__int_leq, bi__int_plus, bi__int_plus;
      apply dec_IsTrue; apply Zplus_le_compat;
      [ exact (IsTrue_dec H1) | exact (IsTrue_dec H2) ].
      Qed.
    *}
;;

theorem int_min_le:
  all x y z in int,
  (#int_leq (z, x) /\ #int_leq (z, y)) -> #int_leq (z, #int_min (x, y))
  proof =
    coq proof {*
      intros x y z H; elim H; intros H1 H2; clear H;
      unfold int_min in |- *;
      unfold bi__int_min;
      elim (Z_lt_dec x y);
      intros H; trivial.
      Qed.
    *}
;;

(*** ??? ********* *)
theorem int_min_le2:
  all x y z in int,
  #int_leq (z, #int_min (x, y)) -> (#int_leq (z, x) /\ #int_leq (z, y))
  proof =
    coq proof {*
      intros x y z; unfold int_min in |- *.
      unfold bi__int_min.
      case (Z_lt_dec x y); intros H1 H2; split; trivial.
      apply int_le_trans with x; trivial.
      unfold int_leq in |- *;
      unfold int_leq, bi__int_leq;
      apply dec_IsTrue; apply Zlt_le_weak; trivial.
      apply int_le_trans with y; trivial.
      unfold int_leq in |- *; unfold bi__int_leq; apply dec_IsTrue.
      elim (Zle_or_lt y x); trivial.   intros Habs; absurd (x < y)%Z; trivial.
      Qed.
    *}
;;

theorem int_plus_minus: all x y z in int,
  (*   x + y = z -> y = z - x *)
  x + y = z -> #base_eq (y, z - x)
  proof =
    coq proof {*
      intros x y z; unfold int_plus, int_minus, base_eq, syntactic_equal in |- *;
      intros H;
      unfold bi__int_minus;
      apply EQ_base_eq; apply Zplus_minus_eq;
      symmetry  in |- *; apply (decidable _ _ _ (Z_eq_dec (x + y) z) H).
      Qed.
    *}
;;

theorem int_minus_plus:
  all x y z in int,
  (*   x - y = z -> x = y + z *)
  x - y = z -> #base_eq (x, y + z)
  proof =
    coq proof {*
      intros x y z; unfold int_plus, int_minus, base_eq, syntactic_equal in |- *;
      intros H;
      unfold bi__int_minus;
      apply EQ_base_eq; rewrite <- (Zplus_minus y x);
      apply Zplus_eq_compat; trivial; apply decidable. apply Z_eq_dec. assumption.
      Qed.
    *}
;;

(** {3 Basic species definitions} *)

(** A [Basic_object] value is a normal blurb on which we do some things.
    This is the root of the species' hierarchy. *)

species Basic_object =
  (* Generic print function. *)
  let print (_x in Self) = "<abst>" ;
  (* Generic parse function. *)
  let parse (_x in string) in Self = #focalize_error ("not parsable") ;
end
;;


(* .......... SNIPED .......... *)

type partiel ('a) =
  | Failed
  | Unfailed ('a)
;;


let is_failed (x) =
  match x with
  | Failed -> true
  | Unfailed (_) -> false
;;

let non_failed (x) =
  match x with
  | Failed -> focalize_error ("partial function")
  | Unfailed (a) -> a
;;

(* .......... SNIPED .......... *)
