type int =
  internal
  external
  | caml -> "int"
  | coq -> "Z"
;;
type unit =
  internal
  external
  | caml -> "unit"
;;
type float =
  internal
  external
  | caml -> "float"
;;
type char =
  internal
  external
  | caml -> "char"
;;
type string =
  internal
  external
  | caml -> "string"
  | coq -> "Focvasives_coq.coq_string"  (* Temporary dirty string. *)
;;
type bool =
  internal
  external
  | caml -> "bool"
  | coq -> "bool"  (* Builtin of Coq *)
;;

type list ('a) =
  internal
  | Nil
  | Cons ('a, list ('a))
  external
  | caml -> "'a list"

and Nil =
  | caml -> "[]"

and Cons =
  | caml -> "( :: )"
;;

let foc_error =
   internal string -> 'a
   external
    | caml -> "Focvasives.foc_error"
    | coq -> "foc_error"
;;

let and_b (x, y) =
   match (x, y) with
   | (true, true) -> true
   | (false, false) -> false
   | (_, _) -> false
;;

let or_b (x, y) =
   match (x, y) with
   | (true, _) -> true
   | (_, true) -> true
   | (_, _) -> false
;;

let not_b (x) in bool =
   match x with
   | true -> false
   | false -> true
;;

let xor_b (x, y) =
   or_b (and_b (x, not_b (y)), and_b (not_b (x), y))
;;

(* Operations on pairs. *)
let crp (x, y) = (x, y) ;;
let first (x) = match x with | (v, _ ) -> v ;;
let scnd (x) = match x with | (_, v) -> v ;;

let string_of_int =
  internal int -> string
  external
  | caml -> "Focvasives.string_of_int" ;;
let int_of_string =
  internal string -> int
  external
  | caml -> "Focvasives.int_of_string" ;;
let print_int =
  internal int -> unit
  external
  | caml -> "Focvasives.int_print" ;;

(* Operations on integers. *)
let int_mod =
  internal int -> int -> int
  external
  | caml -> "Focvasives.int_mod" ;;
let int_eq =
  internal int -> int -> bool
  external
  | caml -> "Focvasives.int_eq"
  | coq -> "int_eq" ;;
let int_div =
  internal int -> int -> int
  external
   | caml -> "Focvasives.int_div" ;;
let int_lt =
  internal int -> int -> bool
  external
  | caml -> "Focvasives.int_lt"
  | coq -> "int_lt" ;;
let int_leq =
  internal int -> int -> bool
  external
  | caml -> "Focvasives.int_leq"
  | coq -> "int_leq" ;;
let int_geq =
  internal int -> int -> bool
  external
  | caml -> "Focvasives.int_geq"
  | coq -> "int_geq" ;;
let int_gt =
  internal  int -> int -> bool
  external
  | caml -> "Focvasives.int_gt"
  | coq -> "int_gt" ;;
let phys_eq =
  internal 'a ->'a -> bool
  external
    | caml -> "Focvasives.base_equal" ;;
let base_eq =
  internal  'a -> 'a -> bool
  external
  | caml -> "Focvasives.base_eq"
  | coq -> "beq" ;;

theorem beq_refl : all x in 'a, base_eq (x, x) proof: assumed ;;
theorem beq_symm: all x y in 'a, base_eq (x, y) -> base_eq (y, x)
  proof: assumed ;;
theorem beq_trans: all x y z in 'a, base_eq (x, y) -> base_eq (y, z) ->
  base_eq (x, z)
proof: assumed ;;

theorem int_le_not_gt :
  all x y in int, int_leq (x, y) -> not (int_gt (x, y))
  proof:
    coq proof
   {* Intros x y; Unfold __g_int_leq __g_int_gt.
   Elim (Z_le_dec x y).
   Intros H.
   Intros b; Clear b.
   Elim (Z_gt_dec x y).
   Intros H1; Absurd `x > y`.
   Apply Zle_not_gt; Trivial.
   Trivial.
   Compute; Trivial.
   Compute; Trivial. *)
    intros x y; unfold __g_int_leq, __g_int_gt in |- *.
    elim (Z_le_dec x y).
    intros H.
    intros b; clear b.
  elim (Z_gt_dec x y).
  intros H1; absurd (x > y)%Z.
  apply Zle_not_gt; trivial.
  trivial.
  compute in |- *; trivial.
  compute in |- *; trivial. *}
;;

theorem int_lt_le_trans :
  all x y z in int, int_lt (x, y) -> int_leq (y, z) -> int_lt (x, z)
proof:
  coq proof
  {* intros x y z.
     unfold __g_int_lt, __g_int_leq in |- *.
     elim (Z_lt_dec x y).
     elim (Z_le_dec y z).
     intros Hle Hlt foo bar; clear foo bar.
     elim (Z_lt_dec x z).
     intros H; compute in |- *; trivial.
     intros H; absurd (x < z)%Z; trivial.
     apply (Zlt_le_trans x y z); trivial.
     intros b a H Habs; compute in |- *; contradiction.
     intros b H; compute in H; contradiction. *}
;;

theorem int_lt_le_trans :
  all x y z in int, int_lt (x, y) -> int_leq (y, z) -> int_lt (x, z)
proof:
  coq proof
  {* intros x y z.
     unfold __g_int_lt, __g_int_leq in |- *.
     elim (Z_lt_dec x y).
     elim (Z_le_dec y z).
     intros Hle Hlt foo bar; clear foo bar.
     elim (Z_lt_dec x z).
     intros H; compute in |- *; trivial.
     intros H; absurd (x < z)%Z; trivial.
     apply (Zlt_le_trans x y z); trivial.
     intros b a H Habs; compute in |- *; contradiction.
     intros b H; compute in H; contradiction. *}
;;

theorem int_le_refl :
  all x y in int, base_eq (x, y) -> int_leq (x, y) proof: assumed ;;

theorem int_le_antisymm:
  all x y in int, int_leq (x, y) -> int_leq (y, x) -> base_eq (x, y)
proof:
  coq proof
  {* intros x y.
     unfold __g_int_leq in |- *.
     elim (Z_le_dec x y); elim (Z_le_dec y x).
     intros H1 H2.
     intros b c; clear b c.
     replace x with y.
     eapply beq_refl.
     apply Zle_antisym; trivial.
     intros b a H; clear H a.
     compute in |- *; intros Habs; eapply False_ind; trivial.
     intros a b Habs H; clear H a; compute in Habs; eapply False_ind; trivial.
     intros a b Habs H; clear H a; compute in Habs; eapply False_ind; trivial.
*} ;;

theorem int_le_trans:
  all x y z in int,  #int_leq(x, y) -> #int_leq (y, z) -> #int_leq(x, z)
proof:
  coq proof
  {* unfold __g_int_leq in |- *; intros x y z H1 H2.
     apply dec_IsTrue. cut (x <= y)%Z. cut (y <= z)%Z.
     eauto with zarith.
     eapply IsTrue_dec. apply H2.
     eapply IsTrue_dec; apply H1. *}
;;

theorem int_lt_irrefl :
  all x y in int, int_lt (x, y) -> not base_eq (x, y)
proof: assumed ;;

let pred =
  internal int -> int
  external
  | caml -> "Focvasives.pred" | coq -> "pred" ;;
let int_opp =
  internal  int -> int
  external
  | caml -> "Focvasives.int_opposite" | coq -> "int_opp" ;;
let int_plus =
  internal int -> int -> int
  external
  | caml -> "Focvasives.int_plus" | coq -> "int_plus" ;;

theorem int_0_plus: all x y in int,
  #base_eq (x, 0) -> #base_eq (#int_plus (x, y), y)
proof:
  coq proof
  {* unfold __g_int_plus, __g_base_eq_ in |- *; intros x y Hxz;
     apply EQ_base_eq; replace x with 0%Z; eauto with zarith.
     symmetry  in |- *.
     apply decidable.
     apply Z_eq_dec. assumption. *}
;;

theorem int_lt_le_S:
  all x y in int, #int_lt (x, y) -> #int_leq (#int_plus (x, 1), y)
proof:
  coq proof
  {* unfold __g_int_lt, __g_int_leq, __g_int_plus in |- *; intros x y Hlt;
     apply dec_IsTrue; fold (Zsucc x) in |- *; apply Zlt_le_succ;
     trivial. exact (IsTrue_dec Hlt). *}
;;

theorem int_plus_assoc: all x y z in int,
  #base_eq (#int_plus (#int_plus (x, y), z), #int_plus (x, #int_plus (y, z)))
proof:
  coq proof
    {* unfold __g_int_plus, __g_base_eq_ in |- *; intros x y z;
       apply EQ_base_eq; auto with zarith. *}
;;

theorem int_plus_commute: all x y  in int,
  #base_eq (#int_plus (x, y), #int_plus (y, x))
proof:
  coq proof {*
    unfold __g_int_plus, __g_base_eq_ in |- *; intros x y; apply EQ_base_eq;
    auto with zarith. *}
;;

theorem int_plus_plus:  all x y z t in int,
  #base_eq (x, y) ->
    #base_eq (z, t) -> #base_eq (#int_plus (x, z), #int_plus (y, t))
proof:
  coq proof
  {* unfold __g_int_plus, __g_base_eq_ in |- *; intros x y z t H1 H2;
     apply EQ_base_eq; replace y with x. replace t with z. reflexivity.
     apply decidable. apply Z_eq_dec. assumption.
     apply decidable. apply Z_eq_dec. assumption. *}
;;

theorem int_le_plus_plus: all x y z t in int,
  #int_leq (x, y) -> #int_leq (z, t) ->
    #int_leq (#int_plus (x, z), #int_plus (y, t))
proof:
   coq proof
     {* unfold __g_int_plus, __g_int_leq in |- *; intros x y z t H1 H2;
        apply dec_IsTrue; apply Zplus_le_compat;
        [ exact (IsTrue_dec H1) | exact (IsTrue_dec H2) ]. *}
;;

let succ(x) = #int_plus (x, 1) ;;
let int_mult =
  internal int -> int -> int
  external
  | caml -> "Focvasives.int_mult"
  | coq -> "int_mult" ;;
let int_minus =
  internal int -> int -> int
  external
  | caml -> "Focvasives.int_minus"
  | coq -> "int_moins" ;;
let int_max =
  internal  int -> int -> int
  external
  | caml -> "Focvasives.int_max"
  | coq -> "max"
;;
let int_min =
  internal int -> int -> int
  external
  | caml -> "Focvasives.int_min"
  | coq -> "min" ;;

theorem int_min_le: all x y z in int,
  (#int_leq (z, x) and #int_leq (z, y)) -> #int_leq (z, #int_min (x, y))
proof:
   coq proof
     {* intros x y z H; elim H; intros H1 H2; clear H;
        unfold __g_int_min in |- *; elim (Z_lt_dec x y);
        intros H; trivial. *}
;;

theorem int_min_le2: all x y z in int,
  #int_leq (z, #int_min (x, y)) -> (#int_leq (z, x) and #int_leq (z, y))
proof:
   coq proof
   {*
   intros x y z; unfold __g_int_min in |- *.
   case (Z_lt_dec x y); intros H1 H2; split; trivial.
   apply int_le_trans with x; trivial.
   unfold __g_int_leq in |- *; apply dec_IsTrue; apply Zlt_le_weak; trivial.
   apply int_le_trans with y; trivial.
   unfold __g_int_leq in |- *; apply dec_IsTrue.
   elim (Zle_or_lt y x); trivial.   intros Habs; absurd (x < y)%Z; trivial.
 *}
;;

theorem int_plus_minus: all x y z in int,
  #base_eq (#int_plus (x, y), z) -> #base_eq (y, #int_minus (z, x))
proof:
   coq proof
   {*
   intros x y z; unfold __g_int_plus, __g_int_minus, __g_base_eq_ in |- *;
   intros H; apply EQ_base_eq; apply Zplus_minus_eq;
   symmetry  in |- *; apply (decidable _ _ _ (Z_eq_dec (x + y) z) H).
 *}
 ;;

theorem int_minus_plus: all x y z in int,
 #base_eq (#int_minus (x, y), z) -> #base_eq (x, #int_plus (y, z))
proof:
   coq proof
   {*
   intros x y z; unfold __g_int_plus, __g_int_minus, __g_base_eq_ in |- *;
   intros H; apply EQ_base_eq; rewrite <- (Zplus_minus y x);
   apply Zplus_eq_compat; trivial; apply decidable. apply Z_eq_dec. assumption.
   *}
;;

(* String operations. *)
(* Concatenation. *)
let sc =
  internal  string -> string -> string
  external
  | caml -> "Focvasives.str_cat" ;;
let str_lt =
  internal string -> string -> bool
  external
  | caml -> "Focvasives.str_lt" ;;
let print_string =
  internal string -> unit
  external
  | caml -> "Focvasives.str_print" ;;
let print_newline (x in unit) = print_string ("\n") ;;


(*                                                                       *)
(*  A basic object is a normal blurb on which we do some things          *)
(*  This is the root of the species' hierarchy                           *)
(*                                                                       *)
species Basic_object =
  (* Generic print function. *)
  let print (x in Self) = "<abst>" ;
  (* Generic parse function. *)
  let parse (x in string) in Self = #foc_error ("not parsable") ;
end ;;


(* .......... SNIPED .......... *)

type partiel ('a) =
  | Failed
  | Unfailed ('a)
;;


let is_failed (x) = match x with | Failed -> true | Unfailed (_) -> false ;;

let non_failed (x) =
   match x with
   | Failed -> foc_error("partial function")
   | Unfailed (a) -> a
;;

(* .......... SNIPED .......... *)

