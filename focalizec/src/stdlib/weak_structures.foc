(**                                                                      
 @title FoC Project. Basic algebra.                       
 @author The FoC project
We define here some weak notions such as rings with no subtraction.

*)

use "basics" ;;
use "sets_orders" ;;
use "iterators" ;;
use "additive_law" ;;
use "multiplicative_law" ;;
open "basics" ;;
open "sets_orders" ;;
open "iterators" ;;
open "additive_law" ;;
open "multiplicative_law" ;;
coq_require "weak_structures_externals" ;;

(** we have an element 1 and an additive law *)
species Unitary_additive_monoid inherits 
  Additive_monoid, Setoid_with_one =
end ;;

(* species unitary_monoid_as_binop(m is unitary_additive_monoid) *)
(*    inherits binop(m) = *)
(*    let binop(x, y) = m!plus(x, y); *)
(*    let value = m!zero;  *)
(* end *)

(** 
   here we give a monoid morphism between natural numbers 
   and an arbitrary monoid. Still need to state its properties.
 *)
species Embed_naturals
     (M is Unitary_additive_monoid,
      Nat is Dichotomic_system,
      Bins is Binop (M),
      Dicho is Dichotomy (Nat, M, Bins))
  inherits Basic_object =
  let of_nat (n) = Dicho!dichot (M!one, n) ;
end ;;

(** A semi ring has +,*,1,0 is sometimes called a rig *)
species Semi_ring inherits Unitary_additive_monoid, Monoid = 
  property mult_left_distributes_on_plus: all x y z in Self,
    !equal (!mult (x, !plus (y, z)), !plus (!mult (x, y), !mult (x, z))) ;

  property mult_right_distributes_on_plus: all x y z in Self,
    !equal (!mult (!plus (x, y), z), !plus (!mult (x, z), !mult (y, z))) ;

  property zero_left_absorbes: all x in Self,
    !equal (!mult (!zero, x), !zero) ;
  
  property zero_right_absorbes: all x in Self,
    !equal (!mult (x, !zero), !zero) ;
end ;;


(** a left semi module has the same properties as a vector space, 
   but on a semi_ring
*)
species Left_semi_module (A is Semi_ring) 
  inherits Additive_monoid =
  (** @mathml <times/> 
      scalar multiplication *)
  signature mult : A -> Self -> Self ;

  (** note that !plus and a!plus are commutative ! *)
  property mult_right_distributes_on_plus : all x y in A, all z in Self,
    !equal (!mult (A!plus (x, y), z), !plus (!mult (x, z), !mult (y, z))) ;
 

  property mult_left_distributes_on_plus: all x in A, all y z in Self,
    !equal (!mult (x, !plus (y, z)), !plus (!mult (x, y), !mult (x, z))) ;

  property one_is_left_neutral: all x in Self, !equal (!mult (A!one, x), x) ;

 (** (b.(c.x)=(b.c).x *)
 property mult_assoc: all b c in A, all x in Self,
    !equal (!mult (b, !mult (c, x)), !mult (A!mult (b, c), x)) ;        

(* [rr] : not true on general semi modules *)
(*
  property zero_left_absorbes: all x in self,
    !equal (!mult(a!zero,x),!zero);
  
  property zero_right_absorbes: all x in a,
    !equal (!mult(x,!zero),!zero);
*)
end ;;

(** a commutative semi_ring is a semi_module on itself *)
species Commutative_semi_ring
  inherits Commutative_monoid, Semi_ring, Left_semi_module (Self) =
   proof of one_is_right_neutral = 
     by property one_is_left_neutral, mult_commutes, equal_transitive ;

   proof of mult_right_distributes_on_plus = 
     <1>1 assume x in Self,
          assume y in Self,
          assume z in Self,
          prove !equal (!mult (!plus (x, y), z),
                       !plus (!mult (x, z), !mult (y, z)))
          <2>1 prove !equal (!mult (!plus (x, y), z),
                            !mult (z, !plus (x, y)))
               by property mult_commutes
          <2>2 prove !equal (!mult (z, !plus (x, y)),
                            !plus (!mult (z, x), !mult (z, y)))
               by property mult_left_distributes_on_plus
          <2>3 prove !equal (!plus (!mult (z, x), !mult (z, y)),
                            !plus (!mult (x, z), !mult (y, z)))
               <3>1 prove !equal (!mult (z, x), !mult (x, z))
                    by property mult_commutes
               <3>2 prove !equal (!mult (z, y), !mult (y, z))
                    by property mult_commutes
               <3>2 qed by step <3>1, <3>2 property plus_substitution_rule
          <2>f qed by step <2>1, <2>2, <2>3 property equal_transitive
     <1>f qed.
   ;

   proof of zero_right_absorbes =
     by property zero_left_absorbes, mult_commutes, equal_transitive ;
end ;;


species Semi_algebra (R is Commutative_semi_ring) 
  inherits Semi_ring =
   signature module_mult : R -> Self -> Self ;
   let lift (x) = Self!module_mult (x, Self!one) ;
   property lift_one : !equal (!lift (R!one), !one) ;
   property lift_additive: all x y in R,
     !equal (!plus (!lift (x), !lift (y)), !lift (R!plus (x, y))) ;
   property module_mult_compat: all x in R, all y in Self,
     !equal (!module_mult (x, y), !mult (!lift (x), y)) ;
   property lift_in_center: all x in R, all y in Self,
     !equal (!mult (!lift (x), y), !mult (y, !lift (x))) ;
   theorem lift_is_ring_morphism: all x y a b in R,
      !equal (!lift (R!plus (R!mult (a, x), R!mult (b, y))),
              !plus (!mult (!lift (a), !lift (x)),
                     !mult (!lift (b), !lift (y))))
      proof: assumed ;
end ;;



species Commutative_semi_algebra(R is Commutative_semi_ring)
  inherits Semi_algebra (R), Commutative_semi_ring =
  proof of lift_in_center = by property mult_commutes ;
end ;;


(** in a integral_semi_ring one can divide. if xy=0 then x=0 or y=0.
 *)
species Integral_semi_ring inherits Regular_monoid, Commutative_semi_ring =
  let is_zero (x) = !equal (x, !zero) ;
end ;;


(** torsion_free_semi_module has the following property: 
  a*m = 0 implies a = 0 \/ m = 0, so that we can define an  
  external division
 *)
species Torsion_free_semi_module (R is Integral_semi_ring)
  inherits Left_semi_module (R) =
   signature exquo : Self -> R-> partiel (Self) ;

  (** external division *)
  property exquo_divides: all x y in Self, all a in R,
    basics#is_failed (!exquo (x, a))
    \/
    !equal (y, basics#non_failed (!exquo (x, a))) -> !equal (x, !mult (a, y)) ;

  (** ax=ay implies x=y.  *)
   property mult_is_left_regular: all x in R, all y z in Self,
    !equal (!mult (x, y), !mult (x, z)) ->
      ~ (R!equal (x, R!zero)) -> !equal (y, z) ;


(*   property mult_is_regular: all x in r, all y z in self, *)
(*     ~(r!equal (x,r!zero)) -> !equal (!mult(x,y),!mult(x,z)) -> !equal (y,z); *)

  (** ax=0 -&gt; x=0 or a=0.*)
  property mult_is_integral: all x in Self, all a in R,
    !equal (!mult (a, x), Self!zero) ->
      (R!equal (a, R!zero) \/ !equal (x, Self!zero)) ;

end ;;

species Torsion_free_semi_algebra(R is Integral_semi_ring)
  inherits Commutative_semi_algebra (R)=
   signature module_exquo : Self -> R -> partiel (Self) ;
   property module_exquo_divides: all a in R, all x y in Self,
     basics#is_failed (!module_exquo (x, a))
       \/
     (!equal (y, basics#non_failed (!module_exquo (x, a))) ->  
       !equal (!module_mult (a, y), x)) ;
  (** ax=ay implies x=y.  *)
   property module_mult_is_regular: all x in R, all y z in Self,
    ~ (R!equal (x, R!zero)) -> 
      !equal (!module_mult (x, y), !module_mult (x, z)) -> !equal (y, z) ;

  (** ax=0 -&gt; x=0 or a=0.*)
   property module_mult_is_integral: all x in Self, all a in R,
    !equal (!module_mult (a, x), Self!zero) ->
      (R!equal (a, R!zero) \/ !equal (x, Self!zero)) ;

   let module_recip(a) = Self!module_exquo (Self!one, a) ;
   theorem module_recip_is_inverse: all a in R,
     basics#is_failed (!module_recip (a))
     \/
     !is_one (!mult (!lift (a), basics#non_failed (!module_recip (a))))
     proof: assumed ;
end ;;


(** division may raise an error *)
species Division_semi_module (R is Semi_ring) 
  inherits Left_semi_module (R) =
    signature div : Self -> R -> Self ;
    property div_divides : all x y in Self, all z in R,
     !equal (y, !div (x, z)) -> !equal (x, !mult (z, y)) ;
end ;;


(** factorisation is unique up to units and order *)
species Factorial_semi_ring inherits Factorization_monoid, Integral_semi_ring = 
end ;;


(** extension of gcds to semi_module
 *)
species Factorial_semi_module(R is Integral_semi_ring)
  inherits Torsion_free_semi_module (R) =
   signature gcd : Self -> R -> R ;
   property gcd_divides: all x in Self, all y z in R,
     R!equal (z, !gcd (x, y)) -> 
       (~ (basics#is_failed (!exquo (x, z))) 
       /\ 
       ~ (basics#is_failed (R!exquo (y, z)))) ;

   property divisor_is_multiple_of_gcd: all x in Self, all y d in R,
     ~ (basics#is_failed (!exquo (x, d))) ->
       ~ (basics#is_failed (R!exquo (y, d))) -> 
         ~ (basics#is_failed (R!exquo (d, !gcd (x, y)))) ;
end ;;


species Factorial_semi_algebra (R is Factorial_semi_ring)
  inherits Torsion_free_semi_algebra (R) =
   signature module_gcd : Self -> R -> R ;
end ;;


(** types for euclidean division *)
(* this is a translation of records! needs to be improved *)
type quo_rem_result ('a) =
  internal
  external
  | caml -> "'a Weak_structures_externals.quo_rem_result"
  | coq -> "weak_structures_externals.quo_rem_result __var_a"
;;

let cr_qrr =
  internal 'a -> 'a -> quo_rem_result ('a)
  external
  | caml -> "Weak_structures_externals.cr_qrr"
  | coq -> "weak_structures_externals.cr_qrr _"
;;

let quot =
  internal quo_rem_result ('a) -> 'a
  external
  | caml -> "Weak_structures_externals.qrr_quot"
  | coq -> "weak_structures_externals.qrr_quot _"
;;

let rema =
  internal quo_rem_result ('a) -> 'a
  external
  | caml -> "Weak_structures_externals.qrr_rema"
  | coq -> "weak_structures_externals.qrr_rema _"
;;


(** euclidean algorithm *)
species Euclidean_semi_ring inherits Factorial_semi_ring =
  signature quo_rem : Self -> Self -> quo_rem_result (Self) ;
  let quotient (x, y) = #quot (Self!quo_rem (x, y)) ;
  let remainder (x, y) = #rema (Self!quo_rem (x, y)) ;
  let rec gcd (x, y) = 
    if Self!is_zero (y) then x else Self!gcd (y, Self!remainder (x, y)) ;
  signature euclidean_ordering : Self -> Self -> prop ;
  property euclidean_order_is_antisymmetric:
    all x y in Self,
      !is_zero (x) \/ !is_zero (y) \/ 
      (!euclidean_ordering (x, y) -> ~ (!euclidean_ordering (y, x))) ;
  property euclidean_ordering_is_transitive:
    all x y z in Self,
      ~ (!is_zero (x)) -> ~ (!is_zero (y)) -> ~ (!is_zero (z)) ->
        !euclidean_ordering (x, y) -> !euclidean_ordering (y, z) ->
          !euclidean_ordering (x, z) ;
 property euclidean_ordering_is_irreflexive: all x in Self,
   ~ (!is_zero (x)) -> ~ (!euclidean_ordering (x, x)) ;
 theorem euclidean_relation: all x y in Self,
   !is_zero (y)
   \/
   !equal (x, !plus (!mult (!quotient (x, y), y), !remainder (x, y)))
   proof : assumed ;
 property remainder_is_smaller: all x y z in Self,
   !is_zero (y)
   \/
   (!equal (z, !remainder (x, y)) -> 
     (!is_zero (z) \/ !euclidean_ordering (z, y))) ;
 let exquo (x, y) =
    if Self!is_zero (y) then basics#Failed
    else
      let qr = Self!quo_rem (x, y) in
      if Self!is_zero (#rema (qr))
      then basics#Unfailed (#quot (qr))
      else basics#Failed ;
  proof of exquo_divides = 
    (** SNIPPED by definition of exquo *)
    assumed ;
  proof of gcd_divides = 
    (** SNIPPED by euclidean_relation, euclidean_ordering *)
    assumed ;
  proof of divisor_is_multiple_of_gcd =
    (** SNIPPED by euclidean_relation, euclidean_ordering *)
    assumed ;
end ;;

(* glurp, thats enough for now, though some people define semi fields *)
type bezout_res ('a) =
 internal
 external
  | caml -> "'a Weak_structures_externals.bezout_res"
  | coq -> "weak_structures_externals.bezout_res __var_a"
;;
let cr_br =
  internal 'a -> 'a -> 'a -> bezout_res ('a)
  external
  | caml -> "Weak_structures_externals.cr_br"
  | coq -> "weak_structures_externals.cr_br"
;; 
let gcd =
  internal bezout_res ('a) -> 'a
  external
  | caml -> "Weak_structures_externals.br_gcd"
  | coq -> "weak_structures_externals.br_gcd"
;;
let coef1 =
  internal bezout_res ('a) -> 'a
  external
  | caml -> "Weak_structures_externals.br_coef1"
  | coq -> "weak_structures_externals.br_coef1"
;;
let coef2 =
  internal bezout_res ('a) -> 'a
  external
  | caml -> "Weak_structures_externals.br_coef2"
  | coq -> "weak_structures_externals.br_coef2"
;;

