#NAME dk_list.

(; Polymorphic lists ;)
list : cc.uT -> cc.uT.
List := A : cc.uT => cc.eT (list A).

(; Constructors ;)
nil : A : cc.uT -> List A.
cons : A : cc.uT -> cc.eT A -> List A -> List A.

(; Case distinction ;)
match : A : cc.uT ->
        P : (List A -> cc.uT) ->
        cc.eT (P (nil A)) ->
        (a : cc.eT A -> l : List A -> cc.eT (P (cons A a l))) ->
        l : List A ->
        cc.eT (P l).

[A : cc.uT,
 P : List A -> cc.uT,
 Hnil : cc.eT (P (nil A)),
 Hcons : a : cc.eT A -> l : List A -> cc.eT (P (cons A a l))]
    match A P Hnil Hcons (nil A) --> Hnil

[A : cc.uT,
 P : List A -> cc.uT,
 Hnil : cc.eT (P (nil A)),
 Hcons : a : cc.eT A -> l : List A -> cc.eT (P (cons A a l)),
 a : cc.eT A,
 l : List A]
    match A P Hnil Hcons (cons A a l) --> Hcons a l.

(; Non dependant case distinction ;)
simple_match : A : cc.uT ->
               return : cc.uT ->
               cc.eT return ->
               (cc.eT A -> List A -> cc.eT return) ->
               List A ->
               cc.eT return
             :=
               A : cc.uT =>
               return : cc.uT =>
               match A (_x : List A => return).

match__nil : A : cc.uT ->
             List A ->
             return : cc.uT ->
             cc.eT return ->
             cc.eT return ->
             cc.eT return.
[ A : cc.uT, ret : cc.uT, ncase : cc.eT ret, ccase : cc.eT ret ]
    match__nil A (nil A) ret ncase ccase --> ncase
[ A : cc.uT, a : cc.eT A, l : List A, ret : cc.uT, ncase : cc.eT ret, ccase : cc.eT ret ]
    match__nil A (cons A a l) ret ncase ccase --> ccase.

match__cons : A : cc.uT ->
              List A ->
              return : cc.uT ->
              (cc.eT A -> List A -> cc.eT return) ->
              cc.eT return ->
              cc.eT return.
[ A : cc.uT, l : List A, ret : cc.uT, ncase : cc.eT ret, ccase : cc.eT A -> List A -> cc.eT ret ]
    match__cons A l ret ccase ncase --> simple_match A ret ncase ccase l.

(; Append ;)
append : A : cc.uT -> List A -> List A -> List A.
[ A : cc.uT, l2 : List A ]
    append A (nil A) l2 --> l2
[ A : cc.uT, a1 : cc.eT A, l1 : List A, l2 : List A ]
    append A (cons A a1 l1) l2 --> cons A a1 (append A l1 l2)
[ A : cc.uT, l1 : List A, l2 : List A, l3 : List A]
    append A l1 (append A l2 l3) --> append A (append A l1 l2) l3.

(; Map ;)
map : A : cc.uT ->
      B : cc.uT ->
      (cc.eT A -> cc.eT B) -> List A -> List B.
[A : cc.uT,
 B : cc.uT,
 f : cc.eT A -> cc.eT B] map A B f (nil A) --> nil B
[A : cc.uT,
 B : cc.uT,
 f : cc.eT A -> cc.eT B,
 a : cc.eT A,
 l : cc.eT (list A)] map A B f (cons A a l) --> cons B (f a) (map A B f l)
[A : cc.uT,
 B : cc.uT,
 C : cc.uT,
 f : cc.eT A -> cc.eT B,
 g : cc.eT B -> cc.eT C,
 l : cc.eT (list A)] map B C g (map A B f l) --> map A C (x : cc.eT A => g (f x)) l.

mem : A : cc.uT ->
      (cc.eT A -> cc.eT A -> cc.eT dk_bool.bool) ->
      cc.eT A ->
      List A ->
      cc.eT dk_bool.bool.
[ A : cc.uT, eq : cc.eT A -> cc.eT A -> cc.eT dk_bool.bool, a : cc.eT A ]
    mem A eq a (nil A) --> dk_bool.false
[ A : cc.uT, eq : cc.eT A -> cc.eT A -> cc.eT dk_bool.bool, a1 : cc.eT A, a2 : cc.eT A, l : cc.eT (list A) ]
    mem A eq a1 (cons A a2 l) --> dk_bool.or (eq a1 a2) (mem A eq a1 l).



map_id :
  B : cc.uT ->
  l : cc.eT (list B) ->
  dk_logic.eP (dk_logic.equal (list B) (map B B (x : cc.eT B => x) l) l).
[B : cc.uT]
    map_id B (nil B) --> dk_logic.refl (list B) (nil B)
[A : cc.uT,
 a : cc.eT A,
 l : cc.eT (list A)]
    map_id A (cons A a l)
      -->
    dk_logic.equal_congr
      (list A)
      (list A)
      (cons A a)
      (map A A (x : cc.eT A => x) l)
      l
        (map_id A l).


dlist : A : cc.uT -> cc.eT A -> cc.uT.
dnil : A : cc.uT -> a : cc.eT A -> cc.eT (dlist A a).
dcons : A : cc.uT ->
        a : cc.eT A ->
        f : (cc.eT (dlist A a) -> cc.uT) ->
        l : cc.eT (dlist A a) ->
        cc.eT (f l) ->
        cc.eT (dlist A a).
