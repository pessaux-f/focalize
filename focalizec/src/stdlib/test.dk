#NAME test
#IMPORT cc
#IMPORT dk_bool
#IMPORT dk_logic

unit : cc.uT.
void : cc.eT unit.

dTuple : A : cc.uT -> (cc.eT A -> cc.uT) -> cc.uT
  :=
         A : cc.uT =>
         B : (cc.eT A -> cc.uT) =>
         cc.Pi_TTT cc.uuT (C : cc.uT =>
                           cc.Arrow
                           (cc.Pi_TTT A (a : cc.eT A =>
                           cc.Arrow (B a) C))
                           C)
.

dcpl : A : cc.uT -> B : (cc.eT A -> cc.uT) -> a : cc.eT A -> cc.eT (B a) -> cc.eT (dTuple A B)
  :=
       A : cc.uT =>
       B : (cc.eT A -> cc.uT) =>
       a : cc.eT A =>
       b : cc.eT (B a) =>
       C : cc.uT =>
       f : (a : cc.eT A -> cc.eT (B a) -> cc.eT C) =>
       f a b.

dfst : A : cc.uT -> B : (cc.eT A -> cc.uT) -> cc.eT (dTuple A B) -> cc.eT A :=
       A : cc.uT => B : (cc.eT A -> cc.uT) => t : cc.eT (dTuple A B) => t A (a : cc.eT A => b : cc.eT (B a) => a).

Tuple : A : cc.uT -> B : cc.uT -> cc.uT := A : cc.uT => B : cc.uT => dTuple A (a : cc.eT A => B).

cpl : A : cc.uT -> B : cc.uT -> a : cc.eT A -> b : cc.eT B -> cc.eT (Tuple A B)
   := A : cc.uT => B : cc.uT => a : cc.eT A => b : cc.eT B => dcpl A (a : cc.eT A => B) a b.

method : cc.uT.
method_deps : cc.eT method -> cc.uT.

method_type : m : cc.eT method -> d : cc.eT (method_deps m) -> cc.uT.

rep : cc.eT method.
new_cmeth : (cc.uT -> cc.uT) -> cc.eT method.
new_lmeth : m : cc.eT method -> (r : cc.eT (method_deps m) -> cc.eT (method_type m r) -> cc.uT) -> cc.eT method.

new_meth : k : cc.uT -> t : (cc.eT k -> cc.uT) -> cc.eT method.

[] method_deps rep --> unit
[t : cc.uT -> cc.uT] method_deps (new_cmeth t) --> cc.uuT
[m : cc.eT method,
 phi : (r : cc.eT (method_deps m) -> cc.eT (method_type m r) -> cc.uT)]
    method_deps (new_lmeth m phi) --> dTuple (method_deps m) (method_type m)
[k : cc.uT,
 t : cc.eT k -> cc.uT] method_deps (new_meth k t) --> k.

[void : cc.eT unit] method_type rep void --> cc.uuT
[rep : cc.uT,
 t : cc.uT -> cc.uT]
    method_type (new_cmeth t) rep --> t rep
[m : cc.eT method,
 phi : (r : cc.eT (method_deps m) -> cc.eT (method_type m r) -> cc.uT),
 d : cc.eT (dTuple (method_deps m) (method_type m))]
    method_type (new_lmeth m phi) d --> d cc.uuT phi
[k : cc.uT,
 t : cc.eT k -> cc.uT,
 d : cc.eT k] method_type (new_meth k t) d --> t d.

(; eq : cc.eT method := new_cmeth (rep : cc.uT => ;)
(;        cc.Arrow rep (cc.Arrow rep dk_bool.bool)). ;)

(; eq : cc.eT method := new_lmeth rep (void : cc.eT unit => Self : cc.uT => cc.Arrow Self (cc.Arrow Self dk_bool.bool)). ;)

eq : cc.eT method := new_meth cc.uuT (r : cc.uT => cc.Arrow r (cc.Arrow r dk_bool.bool)). 

refl : cc.eT method :=
     new_meth (dTuple cc.uuT (method_type eq))
              (d : cc.eT (dTuple cc.uuT (method_type eq)) =>
               d cc.uuT
                 (Self : cc.uT => local_eq : cc.eT (method_type eq Self) => dk_logic.eeP
                     (dk_logic.forall Self (x : cc.eT Self => dk_logic.ebP (local_eq x x))))).

x : cc.eT (method_type refl (dcpl cc.uuT (method_type eq) dk_bool.bool dk_bool.eqv)).

diff : cc.eT method := new_meth cc.uuT (r : cc.uT => cc.Arrow r (cc.Arrow r dk_bool.bool)).

diff_def_aux_1 : cc.uT -> cc.uT :=
 (Self : cc.uT => Tuple (method_type eq Self) (method_type diff Self)).
diff_def_aux_2 : cc.uT := dTuple cc.uuT diff_def_aux_1.

diff_def : cc.eT method :=
  new_meth diff_def_aux_2
           (d : cc.eT diff_def_aux_2 =>
              d
                cc.uuT
                (Self : cc.uT =>
                 d : cc.eT (diff_def_aux_1 Self) =>
                    d
                      cc.uuT
                      (local_eq : cc.eT (method_type eq Self) =>
                       local_diff : cc.eT (method_type diff Self) => dk_logic.eeP
                          (dk_logic.forall
                             Self
                             (x : cc.eT Self =>
                               dk_logic.forall
                                 Self
                                 (y : cc.eT Self => dk_logic.ebP
                                   (dk_bool.xor
                                     (local_eq x y)
                                     (local_diff x y)))))))).




class : cc.uT := dTuple method (m : cc.eT method => dTuple (method_deps m) (method_type m)).
