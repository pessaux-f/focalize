(***********************************************************************)
(*                                                                     *)
(*                        FoCaL compiler                               *)
(*            Renaud Rioboo                                            *)
(*            Virgile Prevosto                                         *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                               LIP6   -  INRIA Rocquencourt          *)
(*                                                                     *)
(*  Copyright 2007 LIP6 and INRIA                                      *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: iterators.fcl,v 1.5 2008-11-21 16:54:34 pessaux Exp $ *)

(** Basic techniques to iterate a process including very simple numbers. *)


use "sets" ;;
open "sets" ;;

use "constants" ;;
open "constants" ;;

use "integers" ;;
open "integers" ;;


species Binop (S is Setoid) inherits basics#Basic_object =
  signature binop : S -> S -> S ;
  property binop_substitution_rule: all x_1 x_2 y_1 y_2 in S,
    S!equal(x_1, x_2) -> S!equal(y_1, y_2) -> 
      S!equal(!binop(x_1, y_1), !binop(x_2, y_2));
end ;;

(**
   Iteration of an arbitrary binary operation. This is not intended to be
   effectively used in the library but can be used to specify functions.
 *)

species Iteration (Nat is Ordered_Enumeration_system, S is Setoid,
                   F_binary is Binop(S), zero in S) =
   rep = basics#unit ;
   let rec iterate (x in S, n in Nat) in S =
     if Nat!equal (n, Nat!start) then zero
     else F_binary!binop (x, !iterate (x, Nat!predecessor (n)))
   termination proof: order Nat!lt on n
     assumed {* *};

   theorem iterate_spec_base: all x in S,
     S!equal(!iterate(x, Nat!start), zero)
     proof: assumed {* [rr]: to do *};

   theorem iterate_spec_ind: all x in S, all n in Nat,
     S!equal(!iterate(x, Nat!successor(n)),
	     F_binary!binop(x, !iterate(x, n)))
     proof: assumed {* [rr]: to do *};

end ;;



(* [Usure] : j'ai remplacé la doc par un simple commentaire
   By a dichotomic system we mean a structure that could be obtained with
   0, 1, multiplication by two and successor.
*)

species Dichotomic_system
  inherits Setoid_with_zero, Enumeration_system, Setoid_with_one =

  let start = !zero ;

  (** on is the successor of 0 *)
  property one_successes_zero: !equal (!successor (!zero), !one) ;

  (** multiplication by two *)
  signature mult2 : Self -> Self ;
  (** compatibility with equality *)
  property mult2_substitution_rule: all n m in Self,
   !equal (n, m) -> !equal (!mult2 (n), !mult2 (m)) ;

  property zero_fixes_mult2: !equal (!mult2 (!zero), !zero) ;
  property mult2_is_injective: all n m in Self,
   !equal (!mult2 (n), !mult2 (m)) -> !equal (n, m) ;

  (* we can check if an element is even *)
  signature is_even : Self -> basics#bool ;
  property is_even_substitution_rule: all n m in Self,
   !is_even (n) -> !equal (n, m) -> !is_even (m) ;
  (* [rr]: this may be a theorem *)
  property zero_is_even: !is_even (!zero) ;

  (* we can check if an element is odd *)
  signature is_odd : Self -> basics#bool ;
  property is_odd_substitution_rule: all n m in Self,
   !is_odd (n) -> !equal (n, m) -> !is_odd (m) ;
  (* [rr]: this may be a theorem *)
  property one_is_odd: !is_odd (!one) ;
  (* any number is odd or even *)
  property even_odd_complete: all n in Self, !is_odd (n) \/ !is_even (n) ;

  property mult2_produces_even: all n in Self, !is_even (!mult2 (n)) ;
  (** division by two almost inverses multiplication by two *)
  signature div2 : Self -> Self ;
  property div2_inverses_even: all n in Self,
   !is_even (n) -> !equal (!mult2 (!div2 (n)), n) ;
  property div2_inverses_odd: all n in Self,
   !is_odd (n) -> !equal (!successor (!mult2 (!div2 (n))), n) ;

  property successor_of_odd_is_even: all n in Self,
   !is_odd (n) -> !is_even (!successor (n)) ;
  property successor_of_even_is_odd: all n in Self,
   !is_even (n) -> !is_odd (!successor (n)) ;

  theorem zero_images_by_div2: all n in Self, !equal (!div2 (n), !zero) ->
   (!equal (n, !zero) \/ !equal (n, !one))
  proof: assumed {* Because todo *} ;

(*    (\** an induction principle for dichotomy *\)  *)
(*   theorem dichotomic_principle: all p in (Self -> Prop), *)
(*     p(!zero) -> *)
(*       (all n in Self, (p(n) -> (p(!mult2(n)) /\ p(!successor(!mult2(n)))))) -> *)
(*          (all n in Self, p(n)) *)
(*     proof: assumed {* Because todo *} *)
(*     ; *)

end ;;



(**
   A species to perform dichotomy.
   The result is the same than that of iteration only if operation f is
   associative
*)
species Dichotomy (Nat is Dichotomic_system,
                   S is Setoid,
                   Bins is Binop(S),
                   stop in S)
  inherits basics#Basic_object =
  rep = basics#unit ;

   (** f(x,f(...f(x,stop))) *)
  let rec dichot (x in S, n in Nat) in S =
     let n_2 = Nat!div2 (n) in
     if Nat!equal (n_2, Nat!zero)
     then
       if Nat!equal (n, Nat!zero)
       then stop
       else (* we know n is 1 *)
         Bins!binop (x, stop)
     else
       let e = !dichot(x, n_2) in
       if Nat!is_odd (n)
       then Bins!binop (x, Bins!binop (e, e))
       else (* we know it is even *)
         Bins!binop (e, e) ;
end ;;

