(***********************************************************************)
(*                                                                     *)
(*                        FoCaLize compiler                            *)
(*                                                                     *)
(*            Renaud Rioboo                                            *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                                                                     *)
(*                               LIP6   -  INRIA Rocquencourt          *)
(*                                                                     *)
(*  Copyright 2007, 2008 LIP6 and INRIA                                *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: small_integers.fcl,v 1.12 2009-06-06 16:43:18 weis Exp $ *)

(** We want here to provide abstract definitions for what is usually called
   integers. That is natural numbers, and integers. The problem is that. *)
use "basics";;
open "basics";;

(* use "iterators";; *)
(* open "iterators";; *)

use "sets";;
open "sets";;

use "integers";;
open "integers";;

use "weak_structures";;
open "weak_structures";;

use "randoms";;
open "randoms";;

(**
   small_numbers can be converted to int
   (from the implementation/runtime system
 *)
species Small_numbers_system =

  inherit Partial_set;

  signature of_int : int -> Self;
  signature to_int : Self -> int;

end
;;

(** Very simple small integers we simply give definitions *)
species Basic_small_nats =

  inherit Small_numbers_system;

  representation = int;

  let zero in Self = 0;
  let is_zero (x in Self) = x = 0;
  let one in Self = 1;
  (** We check overflow by testing signs @mathml <plus/> *)
  let plus (m in Self, n in Self) in Self  =
     let r = m + n in
     if m <=0x 0 then
       if n <=0x 0 then
         (* sum of negative is negative *)
         if r <=0x 0 then r
         else focalize_error ("small integer Overflow")
       else (* negative and positive don't produce overflow *)
         r
     else (* x > 0 *)
       if n >0x 0 then
         (* sum of positive is positive *)
         if r >0x 0 then r
         else focalize_error ("small integer Overflow")
       else (* positive and negative don't produce overflow *)
         r
     ;
  (** We check overflow by testing signs.
      This is incomplete !
      @mathml <mult/> *)
  let mult (m in Self, n in Self) in Self =
     let r = m * n in
     if m <0x 0 then
       if n <=0x 0 then
         (* product of negatives is positive *)
         if r >=0x 0 then r
         else focalize_error ("small integer Overflow")
       else
         (* product of negative and positive is negative *)
         if r <=0x 0 then r
         else focalize_error ("small integer Overflow")
     else (* x > 0 *)
       if n >0x 0 then
         (* sum of positives is positive *)
         if r >0x 0 then r
         else focalize_error ("small integer Overflow")
       else
         (* product of positive and negative is negative *)
         if r <=0x 0 then r
         else focalize_error ("small integer Overflow")
     ;

  let equal (x in Self, y in Self) = x = y;
  proof of equal_reflexive = by definition of equal;
  proof of equal_symmetric = by definition of equal;
  proof of equal_transitive = by definition of equal;
--  proof of equal_from_leq = assumed {* Because toto *};
  let is_one (x in Self) = x = 1;
  let leq (x in Self, y in Self) = x <=0x y;
  (* declared in basic_object *)
  let parse (x) = int_of_string (x);
  let print (x) = string_of_int (x);
  let quo_rem (m in Self, n in Self) in quo_rem_result (Self) =
    if n = 0
    then focalize_error ("Small Numbers: division by zero")
    else weak_structures#cr_qrr (m / n, m % n);

  logical let euclidean_ordering (n in Self, m in Self) =
    if n >0x 0 then
      if m >0x 0 then n <0x m else n <0x (~0x m)
    else
      if m >0x 0 then ( ~0x n) <0x m else (~0x n) <0x (~0x m);
end
;;

species Basic_small_ints =

  inherit Basic_small_nats;

  let opposite (x in Self) in Self = 0 - x;
  let sign (x in Self) =
    if x <0x 0 then -1
    else
     if x >0x 0 then 1 else 0;

end
;;

species Small_naturals =

  inherit Natural_number_system, Basic_small_nats;

  proof of is_zero_spec = by definition of zero, is_zero, equal;
  proof of is_one_spec = by definition of one, is_one, equal;
  let random (x) = randoms#random_int (x);
  let seed (x) = randoms#random_seed (x);
  let to_int (n in Self) in int = n;
  let of_int (n in int) in Self =
     if n <0x 0
     then !failed ("small_naturals!of_int: naturals are positive")
     else n;
  let minus (n, m) =
     let r = n - m in
     if r <0x 0 then
       !failed ("small_naturals!minus: can't substract")
     else r;

  proof of leq_reflexive = assumed {* Because todo *};
  proof of leq_antisymmetric = assumed {* Because todo *};
  proof of leq_transitive = assumed {* Because todo *};
  proof of equal_from_leq = assumed {* *};
  proof of total_order = assumed {* Because todo *};
  proof of plus_right_substitution_rule = assumed {* Because todo *};
  proof of plus_is_associative = assumed {* Because todo *};
  proof of plus_commutes = assumed {* Because todo *};
  proof of plus_is_left_regular = assumed {* Because toto *};
  proof of zero_is_neutral = assumed {* Because toto *};
  proof of leq_absorbes_add = assumed {* Because toto *};
  proof of sup_absorbes_add = assumed {* Because toto *};
  proof of add_right_distributes_on_sup = assumed {* Because toto *};
  proof of add_left_distributes_on_sup = assumed {* Because toto *};
  proof of inf_absorbes_add = assumed {* Because toto *};
  proof of add_right_distributes_on_inf = assumed {* Because toto *};
  proof of add_left_distributes_on_inf = assumed {* Because toto *};
  proof of order_compatible_with_plus = assumed {* Because toto *};
  proof of zero_left_absorbes = assumed {* Because toto *};
  proof of mult_is_integral = assumed {* Because toto *};
  proof of mult_is_left_regular = assumed {* Because toto *};
  proof of mult_commutes = assumed {* Because toto *};
  proof of mult_left_substitution_rule = assumed {* Because toto *};
  proof of mult_assoc = assumed {* Because toto *};
  proof of mult_left_distributes_on_plus = assumed {* Because toto *};
  (*[rr]: needs check *)
  proof of mult_right_distributes_on_plus = assumed {* Because toto *};
  proof of one_is_left_neutral = assumed {* Because toto *};
  proof of minus_right_substitution_rule = assumed {* Because toto *};
  proof of minus_left_substitution_rule = assumed {* Because toto *};
  proof of minus_is_well_defined = assumed {* Because toto *};
  proof of euclidean_ordering_is_transitive = assumed {* Because toto *};
  proof of euclidean_order_is_antisymmetric = assumed {* Because toto *};
  proof of euclidean_ordering_is_irreflexive = assumed {* Because toto *};
  proof of remainder_is_smaller = assumed {* Because toto *};
  (* [rr]: this one might be generic *)
  proof of order_compatible_with_cancellation = assumed {* Because toto *};

end
;;

collection Foc_small_naturals =
  implement Small_naturals;
end
;;

species Small_integers =

  inherit Integer_system, Basic_small_ints;

  let to_int (n in Self) in int = n;
  let of_int (n in int) in Self = n;

  proof of is_zero_spec = by definition of zero, is_zero, equal;
  proof of is_one_spec = by definition of one, is_one, equal;
  proof of leq_reflexive = assumed {* Because toto *};
  proof of leq_antisymmetric = assumed {* Because toto *};
  proof of leq_transitive = assumed {* Because toto *};
  proof of equal_from_leq = assumed {* *};
  proof of total_order = assumed {* Because toto *};
  proof of plus_right_substitution_rule = assumed {* Because toto *};
  proof of plus_is_associative = assumed {* Because toto *};
  proof of plus_commutes = assumed {* Because toto *};
  proof of plus_is_left_regular = assumed {* Because toto *};
  proof of zero_is_neutral = assumed {* Because toto *};
  proof of opposite_is_opposite = assumed {* Because toto *};

  proof of order_compatible_with_plus = assumed {* Because toto *};
  proof of zero_left_absorbes = assumed {* Because toto *};
  proof of mult_is_integral = assumed {* Because toto *};
  proof of mult_is_regular = assumed {* Because toto *};
  proof of mult_commutes = assumed {* Because toto *};
  proof of mult_left_substitution_rule = assumed {* Because toto *};
  proof of mult_compat_with_order = assumed {* Because toto *};
  proof of mult_assoc = assumed {* Because toto *};
  proof of mult_left_distributes_on_plus = assumed {* Because toto *};
  (*[rr]: needs check *)
  proof of mult_right_distributes_on_plus = assumed {* Because toto *};
  proof of one_is_left_neutral = assumed {* Because toto *};

  proof of euclidean_ordering_is_transitive = assumed {* Because toto *};
  proof of euclidean_order_is_antisymmetric = assumed {* Because toto *};
  proof of euclidean_ordering_is_irreflexive = assumed {* Because toto *};
  proof of remainder_is_smaller = assumed {* Because toto *};

end
;;

collection Foc_small_integers =
  implement Small_integers;
end
;;
