(***********************************************************************)
(*                                                                     *)
(*                FoCaLize compiler                                    *)
(*                                                                     *)
(*            Renaud Rioboo                                            *)
(*            Virgile Prevosto                                         *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                               LIP6   -  INRIA Rocquencourt          *)
(*                                                                     *)
(*  Copyright 2007 LIP6 and INRIA                                      *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: weak_structures.fcl,v 1.9 2009-03-19 21:35:51 rr Exp $ *)

(** We define here some weak notions such as rings with no subtraction. *)

use "basics";;
use "constants";;
use "additive_law" ;;
use "multiplicative_law" ;;
open "basics";;
open "additive_law" ;;
open "multiplicative_law" ;;
open "constants";;
coq_require "weak_structures_externals" ;;

(** we have an element 1 and an additive law *)
species Unitary_additive_monoid inherits 
  Additive_monoid, Setoid_with_one =
end ;;

(* species unitary_monoid_as_binop(m is unitary_additive_monoid) *)
(*    inherits binop(m) = *)
(*    let binop(x, y) = m!plus(x, y); *)
(*    let value = m!zero;  *)
(* end *)

(** 
   here we give a monoid morphism between natural numbers 
   and an arbitrary monoid. Still need to state its properties.
 *)
(* species Embed_naturals *)
(*      (M is Unitary_additive_monoid, *)
(*       Nat is Dichotomic_system, *)
(*       Bins is Binop (M), *)
(*       Dicho is Dichotomy (Nat, M, Bins)) *)
(*   inherits Basic_object = *)
(*   let of_nat (n) = Dicho!dichot (M!one, n) ; *)
(* end ;; *)

(** A semi ring has +,*,1,0 is sometimes called a rig *)
species Semi_ring inherits Unitary_additive_monoid, Monoid = 
  property mult_left_distributes_on_plus: all x y z in Self,
    !equal (!mult (x, !plus (y, z)), !plus (!mult (x, y), !mult (x, z))) ;

  property mult_right_distributes_on_plus: all x y z in Self,
    !equal (!mult (!plus (x, y), z), !plus (!mult (x, z), !mult (y, z))) ;

  property zero_left_absorbes: all x in Self,
    !equal (!mult (!zero, x), !zero) ;
  
  property zero_right_absorbes: all x in Self,
    !equal (!mult (x, !zero), !zero) ;
end ;;


(** a left semi module has the same properties as a vector space, 
   but on a semi_ring
*)
species Left_semi_module (A is Semi_ring) 
  inherits Additive_monoid =
  (** @mathml <times/> 
      scalar multiplication *)
  signature mult : A -> Self -> Self ;

  (** compatibility with equality *)
  property mult_left_substitution_rule : all a b in A, all x in Self,
    A!equal (a, b) -> (!equal (!mult (a, x), !mult (b, x))) ;

  (** note that !plus and a!plus are commutative ! *)
  property mult_right_distributes_on_plus : all x y in A, all z in Self,
    !equal (!mult (A!plus (x, y), z), !plus (!mult (x, z), !mult (y, z))) ;
 

  property mult_left_distributes_on_plus: all x in A, all y z in Self,
    !equal (!mult (x, !plus (y, z)), !plus (!mult (x, y), !mult (x, z))) ;

  property one_is_left_neutral: all x in Self, !equal (!mult (A!one, x), x) ;

  (** (b.(c.x)=(b.c).x *)
  property mult_assoc: all b c in A, all x in Self,
    !equal (!mult (b, !mult (c, x)), !mult (A!mult (b, c), x)) ;        

(* [rr] : not true on general semi modules *)
(*
  property zero_left_absorbes: all x in self,
    !equal (!mult(a!zero,x),!zero);
  
  property zero_right_absorbes: all x in a,
    !equal (!mult(x,!zero),!zero);
*)
end ;;

species Left_regular_semi_module(A is Semi_ring)
  inherits Regular_additive_monoid,
           Left_semi_module(A) =

  theorem zero_left_absorbes: all x in Self,
    !equal (!mult (A!zero, x), !zero)
    proof =
    <1>1 assume x in Self,
         prove !equal (!mult (A!zero, x), !zero)
      <2>2 prove !equal (!mult (A!plus (A!zero, A!one), x), x)
           by property A!zero_is_neutral, !mult_left_substitution_rule,
                       A!equal_transitive,
                       !one_is_left_neutral, !equal_transitive
      <2>3 prove !equal (!mult (A!plus (A!zero, A!one), x),
                         !plus (!mult (A!zero, x), !mult (A!one, x)))
           by property mult_right_distributes_on_plus
      <2>4 prove !equal (!plus (!mult (A!zero, x), x), x)
           by step <2>2, <2>3 
              property plus_right_substitution_rule, !one_is_left_neutral,
                       equal_symmetric, equal_transitive
      <2>5 prove !equal (!plus (!mult (A!zero, x), x),
			 !plus (!zero, x))
           by step <2>4
           property !zero_is_neutral, equal_transitive, equal_symmetric
      <2>f qed by step <2>5 property plus_is_regular
    <1>2 conclude
;

end;;

(** a commutative semi_ring is a semi_module on itself *)
species Commutative_semi_ring
  inherits Commutative_monoid_with_absorbant, 
           Semi_ring, 
           Left_semi_module(Self) =
   proof of one_is_right_neutral = 
     by property one_is_left_neutral, mult_commutes, equal_transitive ;

   proof of mult_right_distributes_on_plus =
     <1>1 assume x in Self,
          assume y in Self,
          assume z in Self,
          prove !equal (!mult (!plus (x, y), z),
                       !plus (!mult (x, z), !mult (y, z)))
          <2>1 prove !equal (!mult (!plus (x, y), z),
                            !mult (z, !plus (x, y)))
               by property mult_commutes
          <2>2 prove !equal (!mult (z, !plus (x, y)),
                            !plus (!mult (z, x), !mult (z, y)))
               by property mult_left_distributes_on_plus
          <2>3 prove !equal (!plus (!mult (z, x), !mult (z, y)),
                            !plus (!mult (x, z), !mult (y, z)))
               <3>1 prove !equal (!mult (z, x), !mult (x, z))
                    by property mult_commutes
               <3>2 prove !equal (!mult (z, y), !mult (y, z))
                    by property mult_commutes
               <3>2 qed by step <3>1, <3>2 property plus_substitution_rule
          <2>f qed by step <2>1, <2>2, <2>3 property equal_transitive
     <1>f conclude
   ;

   proof of zero_right_absorbes =
     by property zero_left_absorbes, mult_commutes, equal_transitive ;
end ;;


species Semi_algebra (R is Commutative_semi_ring) 
  inherits Semi_ring =
   signature module_mult : R -> Self -> Self ;
   let lift (x) = Self!module_mult (x, Self!one) ;
   property lift_one : !equal (!lift (R!one), !one) ;
   property lift_additive: all x y in R,
     !equal (!plus (!lift (x), !lift (y)), !lift (R!plus (x, y))) ;
   property module_mult_compat: all x in R, all y in Self,
     !equal (!module_mult (x, y), !mult (!lift (x), y)) ;
   property lift_in_center: all x in R, all y in Self,
     !equal (!mult (!lift (x), y), !mult (y, !lift (x))) ;
   theorem lift_is_ring_morphism: all x y a b in R,
      !equal (!lift (R!plus (R!mult (a, x), R!mult (b, y))),
              !plus (!mult (!lift (a), !lift (x)),
                     !mult (!lift (b), !lift (y))))
      proof = assumed {* Because todo *} ;
end ;;



species Commutative_semi_algebra(R is Commutative_semi_ring)
  inherits Semi_algebra (R), Commutative_semi_ring =
  proof of lift_in_center = by property mult_commutes ;
end ;;



(** torsion_free_semi_module has the following property: 
  a*m = 0 implies a = 0 \/ m = 0, so that we can define an  
  external division
 *)
species Torsion_free_semi_module (R is Semi_ring)
  inherits Left_semi_module (R) =
   signature exquo : Self -> R-> partiel (Self) ;

  (** external division *)
  property exquo_divides: all x y in Self, all a in R,
    (basics#is_failed (!exquo (x, a)))
    \/
    (!equal
     (y, basics#non_failed (!exquo (x, a))) -> !equal (x, !mult (a, y))) ;

  (** ax=ay implies x=y.  *)
   property mult_is_left_regular: all x in R, all y z in Self,
    !equal (!mult (x, y), !mult (x, z)) ->
      ~ (R!equal (x, R!zero)) -> !equal (y, z) ;


(*   property mult_is_regular: all x in r, all y z in self, *)
(*     ~(r!equal (x,r!zero)) -> !equal (!mult(x,y),!mult(x,z)) -> !equal (y,z); *)

  (** ax=0 -&gt; x=0 or a=0.*)
  property mult_is_integral: all x in Self, all a in R,
    !equal (!mult (a, x), Self!zero) ->
      (R!equal (a, R!zero) \/ !equal (x, Self!zero)) ;

end ;;

(** 
   in an Integral_semi_ring one can divide. if xy=0 then x=0 or y=0.
 *)
species Integral_semi_ring 
  inherits Regular_monoid, 
           Commutative_semi_ring,
           Torsion_free_semi_module(Self) =
(*   let is_zero (x) = !equal (x, !zero); *)

(*   proof of is_zero_spec = by property !equal_symmetric definition of is_zero; *)

  theorem divides_is_additive: all x y z in Self,
    !divides(x, y) -> !divides(x, z) -> !divides(x, !plus(y, z))
   (* [rr]: should be a property *)
    proof = assumed {* *};

  theorem one_is_not_zero: ~(!is_zero(!one))
  (* [rr]: should be a property *)
  proof = assumed {* *};


end ;;

species Torsion_free_semi_algebra(R is Integral_semi_ring)
  inherits Commutative_semi_algebra (R)=
   signature module_exquo : Self -> R -> partiel (Self) ;
   property module_exquo_divides: all a in R, all x y in Self,
     basics#is_failed (!module_exquo (x, a))
       \/
     (!equal (y, basics#non_failed (!module_exquo (x, a))) ->  
       !equal (!module_mult (a, y), x)) ;
  (** ax=ay implies x=y.  *)
   property module_mult_is_regular: all x in R, all y z in Self,
    ~ (R!equal (x, R!zero)) -> 
      !equal (!module_mult (x, y), !module_mult (x, z)) -> !equal (y, z) ;

  (** ax=0 -&gt; x=0 or a=0.*)
   property module_mult_is_integral: all x in Self, all a in R,
    !equal (!module_mult (a, x), Self!zero) ->
      (R!equal (a, R!zero) \/ !equal (x, Self!zero)) ;

   let module_recip(a) = Self!module_exquo (Self!one, a) ;
   theorem module_recip_is_inverse: all a in R,
     basics#is_failed (!module_recip (a))
     \/
     !is_one (!mult (!lift (a), basics#non_failed (!module_recip (a))))
     proof = assumed {* Because todo *} ;
end ;;


(** division may raise an error *)
species Division_semi_module (R is Semi_ring) 
  inherits Left_semi_module (R) =
    signature div : Self -> R -> Self ;
    property div_divides : all x y in Self, all z in R,
     !equal (y, !div (x, z)) -> !equal (x, !mult (z, y)) ;
end ;;


(** factorisation is unique up to units and order *)
species Factorial_semi_ring inherits Factorization_monoid, Integral_semi_ring = 
end ;;


(** extension of gcds to semi_module
 *)
species Factorial_semi_module(R is Integral_semi_ring)
  inherits Torsion_free_semi_module (R) =
   signature gcd : Self -> R -> R ;
   property gcd_divides: all x in Self, all y z in R,
     R!equal (z, !gcd (x, y)) -> 
       (~ (basics#is_failed (!exquo (x, z))) 
       /\ 
       ~ (basics#is_failed (R!exquo (y, z)))) ;

   property divisor_is_multiple_of_gcd: all x in Self, all y d in R,
     ~ (basics#is_failed (!exquo (x, d))) ->
       ~ (basics#is_failed (R!exquo (y, d))) -> 
         ~ (basics#is_failed (R!exquo (d, !gcd (x, y)))) ;
end ;;


species Factorial_semi_algebra (R is Factorial_semi_ring)
  inherits Torsion_free_semi_algebra (R) =
   signature module_gcd : Self -> R -> R ;
end ;;


(** types for euclidean division *)
(* this is a translation of records! needs to be improved *)
type quo_rem_result ('a) =
  internal
  external
  | caml -> {* 'a Weak_structures_externals.quo_rem_result *}
  | coq -> {* weak_structures_externals.quo_rem_result __var_a *}
;;

let cr_qrr =
  internal 'a -> 'a -> quo_rem_result ('a)
  external
  | caml -> {* Weak_structures_externals.cr_qrr *}
  | coq -> {* weak_structures_externals.cr_qrr _ *}
;;

let quot =
  internal quo_rem_result ('a) -> 'a
  external
  | caml -> {* Weak_structures_externals.qrr_quot *}
  | coq -> {* weak_structures_externals.qrr_quot _ *}
;;

let rema =
  internal quo_rem_result ('a) -> 'a
  external
  | caml -> {* Weak_structures_externals.qrr_rema *}
  | coq -> {* weak_structures_externals.qrr_rema _ *}
;;


(** euclidean algorithm *)
species Euclidean_semi_ring inherits Factorial_semi_ring =
  signature quo_rem : Self -> Self -> quo_rem_result (Self) ;
  let quotient (x, y) = #quot (Self!quo_rem (x, y)) ;
  let remainder (x, y) = #rema (Self!quo_rem (x, y)) ;

  let rec gcd (x, y) = 
    if Self!is_zero (y) then x else Self!gcd (y, Self!remainder (x, y)) ;
  (* termination proof =
      order euclidean_ordering on y
      by property well_founded_euclidean_ordering, remainder_is_smaller ; *)

  signature euclidean_ordering : Self -> Self -> prop ;

  property euclidean_order_is_antisymmetric:
    all x y in Self,
      !is_zero (x) \/ !is_zero (y) \/ 
      (!euclidean_ordering (x, y) -> ~ (!euclidean_ordering (y, x))) ;
  property euclidean_ordering_is_transitive:
    all x y z in Self,
      ~ (!is_zero (x)) -> ~ (!is_zero (y)) -> ~ (!is_zero (z)) ->
        !euclidean_ordering (x, y) -> !euclidean_ordering (y, z) ->
          !euclidean_ordering (x, z) ;
 property euclidean_ordering_is_irreflexive: all x in Self,
   (!is_zero (x)) \/ ~ (!euclidean_ordering (x, x)) ;

 theorem euclidean_relation: all x y in Self,
   !is_zero (y)
   \/
   !equal (x, !plus (!mult (!quotient (x, y), y), !remainder (x, y)))
   proof = assumed {* Because todo *} ;

 property remainder_is_smaller: all x y z in Self,
   !is_zero (y)
   \/
   (!equal (z, !remainder (x, y)) -> 
     (!is_zero (z) \/ !euclidean_ordering (z, y))) ;

   (** Unicity of Euclidean relation *)
   theorem euclidean_characterisation: all a b q r in Self,
     !equal(a, !plus(!mult(b, q), r)) ->
        (~(!is_zero(b))) -> 
          (!is_zero(r) \/ !euclidean_ordering(r, b)) ->
             (!equal(q, !quotient(a, b)) /\ !equal(r, !remainder(a, b)))
     (* [rr]: this should be a property *)
     proof = assumed {* *};

   theorem zero_remainder_divides: all x y in Self,
     ~(!is_zero(y)) -> !is_zero(!remainder(x, y)) -> !divides(y, x)
     proof =
       <1>1 assume x in Self, assume y in Self,
            assume H_0: ~(!is_zero(y)),
            assume H_r: !is_zero(!remainder(x, y)),
            prove !divides(y, x)
            <2>1 prove !equal(x, !mult(!quotient(x, y), y))
                 <3>1 prove !equal(x,
				   !plus(!mult(!quotient(x, y), y),
					 !zero))
                      <4>1 prove !equal(x,
					!plus(!mult(!quotient(x, y), y),
					      !remainder(x, y)))
                           by hypothesis H_0 property !euclidean_relation
                      <4>2 prove !equal(!remainder(x, y), !zero)
                           by hypothesis H_r
                              property !is_zero_spec, !equal_symmetric
                      <4>f qed by step <4>1, <4>2
                                  property !plus_right_substitution_rule,
                                           !equal_transitive
                 <3>f qed by step <3>1
                             property !zero_is_neutral, !equal_transitive
            <2>2 prove !divides(y, !mult(!quotient(x, y), y))
                 by property !divides_reverses_mult
            <2>f qed by step <2>1, <2>2
                        property !equal_symmetric,
                                 !divides_transitive, !divides_extends_equal
       <1>f conclude
     ;

   (** Units are extremal *)
   theorem one_is_euclidean_minimal: all x in Self,
     ~(!is_zero(x)) -> !euclidean_ordering(!one, x)
     proof = assumed {* *};

   theorem remainder_left_substitution_rule: all x y z in Self,
     !equal(x, y) -> ~(!is_zero(z)) ->
       !equal(!remainder(x, z), !remainder(y, z))
     proof = assumed {* Needs check *}
  ;

   theorem zero_remainder_is_zero: all x in Self,
     !is_zero(x) \/ !is_zero(!remainder(!zero, x))
     proof =
     <1>1 assume x in Self,
          assume H: ~(!is_zero(x)),
          prove !is_zero(!remainder(!zero, x))
          <2>1 prove !equal(!zero, !plus(!mult(x, !zero), !zero))
               <3>1 prove !equal(!mult(x, !zero), !zero)
                    by property !zero_right_absorbes
               (* [rr]: zenon has problems with substitution rules! *)
               <3>2 prove !equal(!plus(!mult(x, !zero), !zero),
				 !plus(!zero, !zero))
                    by step <3>1 property !plus_left_substitution_rule
               <3>f qed by step <3>2
                           property !zero_is_neutral,
                                    !equal_symmetric, !equal_transitive
          <2>2 prove !equal(!zero, !remainder(!zero, x))
               by step <2>1 hypothesis H
                  property !zero_checks_to_zero, !euclidean_characterisation
          <2>f qed by step <2>2 property !is_zero_spec
     <1>f conclude
     ;
 


 let exquo (x, y) =
    if Self!is_zero (y) then basics#Failed
    else
      let qr = Self!quo_rem (x, y) in
      if Self!is_zero (#rema (qr))
      then basics#Unfailed (#quot (qr))
      else basics#Failed ;
  proof of exquo_divides = 
    definition of exquo
    assumed {* To do ? *} ;
  proof of gcd_divides = 
    property euclidean_relation, euclidean_ordering
    assumed {* To do ? *} ;
  proof of divisor_is_multiple_of_gcd =
    property euclidean_relation, euclidean_ordering
    assumed {* To do ? *} ;
end ;;

(* glurp, thats enough for now, though some people define semi fields *)
type bezout_res ('a) =
 internal
 external
  | caml -> {* 'a Weak_structures_externals.bezout_res *}
  | coq -> {* weak_structures_externals.bezout_res __var_a *}
;;
let cr_br =
  internal 'a -> 'a -> 'a -> bezout_res ('a)
  external
  | caml -> {* Weak_structures_externals.cr_br *}
  | coq -> {* weak_structures_externals.cr_br __var_a *}
;; 
let gcd =
  internal bezout_res ('a) -> 'a
  external
  | caml -> {* Weak_structures_externals.br_gcd *}
  | coq -> {* weak_structures_externals.br_gcd __var_a *}
;;
let coef1 =
  internal bezout_res ('a) -> 'a
  external
  | caml -> {* Weak_structures_externals.br_coef1 *}
  | coq -> {* weak_structures_externals.br_coef1 __var_a *}
;;
let coef2 =
  internal bezout_res ('a) -> 'a
  external
  | caml -> {* Weak_structures_externals.br_coef2 *}
  | coq -> {* weak_structures_externals.br_coef2 __var_a *}
;;
