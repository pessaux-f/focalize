(***********************************************************************)
(*                                                                     *)
(*                        FoCaLiZe compiler                            *)
(*                                                                     *)
(*            Renaud Rioboo                                            *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                                                                     *)
(*                               LIP6   -  INRIA Rocquencourt          *)
(*                                                                     *)
(*  Copyright 2007 LIP6 and INRIA                                      *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: distributed_polys.fcl,v 1.10 2012-03-01 14:36:09 pessaux Exp $ *)

(**
  @title Distributed polynomials
  @author The FoCaLiZe Project

   Distributed polynomials over arbitrary rings
        with arbitrary orderings on the variables
*)


(** will be the carrier for a polynomial rinbg
   with coefficients using carrier 'r and degree 'd *)
type distributed_representation ('r, 'd) =
  | Null
  | NonNull ('r, 'd, distributed_representation ('r, 'd))
;;

(* (\**  *)
(*        index_sum is the finite sums of direct products. *)
(* *\)  *)

open "basics" ;;
open "additive_law" ;;
open "polys_abstract" ;;
open "constants" ;;

(**
   I am not the sure of the correct name,
   nor if it has some sense in the literature.
   This is a kind of finite support functions from I to E.
 *)
species Indexed_set (D is Ordered_set_with_zero,
         C is Zero_check_set) =
  inherit Setoid_with_zero;
  (**
     [rr]:
     in order to further verify invariants, we need to state that
        the empty list is a valid rep
     and
        if y is a valid rep,
        if t is non null in m and
        if d is bigger than the degree of y
        then #Cons ((t*d), y) is a valid rep

   *)
  representation = distributed_representation (C, D);


  (** the zero polynomial *)
  let zero = Null ;

  (** a family of embeddings from C to Self *)
  let monomial (x : C, d : D) : Self =
    if C!is_zero (x) then zero else NonNull (x, d, Null) ;

  (** the leading coefficient of a polynomial is 0 on 0 *)
  let leading_coefficient (x : Self) = match x with
    | Null -> C!zero
    | NonNull (m, _, _) -> m ;

  (** Usually degree is not specified on 0 *)
  let degree (x : Self) = match x with
    | Null -> D!zero
    | NonNull (_, d, _) -> d ;

  let rec length_poly (p) =
     match p with
     | Null -> 0
     | NonNull(_, _, pp) ->
        length_poly(pp) + 1
  termination proof = structural p ;

  let length_pair
   ( c : distributed_representation(C, D) * distributed_representation(C, D) )
     = match c with
       | (p1, p2) -> length_poly (p1) + length_poly (p2)
  ;


   theorem length_pair_left_lt: all p1 p2: distributed_representation(C, D),
     all c1: C, all d1: D,
       length_pair((p1, p2)) < length_pair((NonNull(c1, d1, p1), p2))
     proof =
       <1>1  assume p1 p2: distributed_representation(C, D),
             assume c1: C, assume d1: D,
             prove
               length_pair((p1, p2)) < length_pair((NonNull(c1, d1, p1), p2))
            <2>0 prove length_poly(NonNull(c1, d1, p1)) = length_poly(p1) + 1
                 by definition of length_poly
                    type distributed_representation
            <2>1 prove length_poly(p1) < length_poly(NonNull(c1, d1, p1))
                 (***
                 /\
                /  \
               / !! \
                ----
                    Should be the FCL proof below but congruence sucks in Coq.
                    Instead, let's inline the hacked Coq proof script.
                 by definition of length_poly property int_succ_lt
                    type distributed_representation
                 *** *)
                 coq proof definition of length_poly property int_succ_lt
                     {*
                   assert (zenon_L1_ : (~(match p1 with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end = (abst_length_poly p1))) -> False).
                   do 0 intro. intros zenon_H2.
                   assert (zenon_H3: (~(match p1 with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end = match p1 with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end))). destruct p1; simpl; auto.
                   apply zenon_H3. apply refl_equal.
                   (* end of lemma zenon_L1_ *)
                   apply NNPP. intro zenon_G.
                   generalize (basics.int_succ_lt match p1 with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end). zenon_intro zenon_H4.
                   cut ((Is_true (basics._lt_ match p1 with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end (basics._plus_ match p1 with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end 1))) = (Is_true (basics._lt_ (abst_length_poly p1) (abst_length_poly (@ NonNull _p_C_T _p_D_T c1 d1 p1))))).
                   intro zenon_D_pnotp.
                   apply zenon_G.
                   try rewrite <- zenon_D_pnotp.
                   exact zenon_H4.
                   cut (((basics._lt_ match p1 with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end (basics._plus_ match p1 with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end 1)) = (basics._lt_ (abst_length_poly p1) (abst_length_poly (@ NonNull _p_C_T _p_D_T c1 d1 p1))))); [idtac | apply NNPP; zenon_intro zenon_H5].
                   congruence.
                   cut (((basics._plus_ match p1 with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end 1) = (abst_length_poly (@ NonNull _p_C_T _p_D_T c1 d1 p1)))); [idtac | apply NNPP; zenon_intro zenon_H6].
                   cut ((match p1 with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end = (abst_length_poly p1))); [idtac | apply NNPP; zenon_intro zenon_H2].
                   generalize zenon_H5; simpl.
                   unfold basics.int__t.
                   congruence.
                   apply (zenon_L1_); trivial.
                   assert (zenon_H7: (~((basics._plus_ match p1 with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end 1) = match (@ NonNull _p_C_T _p_D_T c1 d1 p1) with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end))). exact zenon_H6.
                   apply (zenon_induct_match_redex_s (~((basics._plus_ match p1 with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end 1) = match (@ NonNull _p_C_T _p_D_T c1 d1 p1) with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end)) zenon_H7); [ zenon_intro zenon_H8; idtac ].
                   cut ((1 = 1)); [idtac | apply NNPP; zenon_intro zenon_H9].
                   cut ((match p1 with | Null => 0 | NonNull _ _ pp => (basics._plus_ (abst_length_poly pp) 1) end = (abst_length_poly p1))); [idtac | apply NNPP; zenon_intro zenon_H2].
                   generalize zenon_H8; simpl.
                   unfold basics.int__t.
                   congruence.
                   apply (zenon_L1_); trivial.
                   apply zenon_H9. apply refl_equal.
                   Qed. *}

            <2>2 prove
                    (length_poly(p1) + length_poly(p2))
                    <
                    (length_poly(NonNull(c1, d1, p1)) + length_poly(p2))
                 by property int_add_lt
                    step <2>1
             <2>f qed by step <2>2 definition of length_pair
       <1>f conclude
     ;

   theorem length_pair_right_lt: all p1 p2: distributed_representation(C, D),
     all c2: C, all d2: D,
       length_pair((p1, p2)) < length_pair((p1, NonNull(c2, d2, p2)))
     proof =
       <1>1  assume  p1 p2 : distributed_representation(C, D),
             assume c2: C, assume d2: D,
             prove
               length_pair((p1, p2)) < length_pair((p1, NonNull(c2, d2, p2)))
              <2>1 prove
              length_pair((p2, p1)) < length_pair((NonNull(c2, d2, p2), p1))
                  by property length_pair_left_lt
              <2>2 prove length_pair((p1, p2)) = length_pair((p2, p1))
                  by definition of length_pair property int_plus_commute
              <2>3 prove length_pair((NonNull(c2, d2, p2), p1)) = length_pair((p1, NonNull(c2, d2, p2)))
                   by definition of length_pair property int_plus_commute
              <2>f qed by step <2>1, <2>2, <2>3
     <1>f conclude
;

theorem int_lt_trans: all n m p : int,
    n < m -> m < p -> n < p
proof =
 assumed
;

  theorem length_pair_left_right_lt:
     all p1 p2: distributed_representation(C, D),
       all c1  c2: C, all d1 d2: D,
         length_pair((p1, p2)) < length_pair((NonNull(c1, d1, p1), NonNull(c2, d2, p2)))
     proof =
     by property length_pair_right_lt, length_pair_left_lt, int_lt_trans
     ;


  (* theorem length_poly_decreases: all p: distributed_representation(C, D), *)
  (*   all c: C, all d: D, *)
  (*    length_poly(p) < length_poly(NonNull(c, d, p) ) *)
  (*    proof = assumed *)
  (*   ; *)


theorem length_poly_pos: all p : distributed_representation(C, D),
    0 <= length_poly (p)
proof =
<1>1 prove  0 <= length_poly (Null)
by definition of length_poly
   property int_le_refl
   type distributed_representation
<1>2 assume pp :  distributed_representation(C, D),
(* Induction hypothesis. *)
hypothesis Hind: 0 <= length_poly (pp) ,
assume c : C,
assume d : D,
(* Recursive case. *)
prove 0 <= length_poly(NonNull(c, d, pp))
by definition of length_poly
   property add_pos, one_pos hypothesis Hind
   type distributed_representation
<1>3 qed by step <1>1, <1>2 type distributed_representation
;


theorem length_pair_measure:
all s1 s2 : distributed_representation(C, D),
0 <= !length_pair ((s1, s2))
proof = by definition of length_pair
           property  add_pos, length_poly_pos
;


  let to_rep(x: Self): distributed_representation(C, D) = x;

  let rec correct_cons(c, d, pp)= match pp with
    | Null -> ((D!geq(d, D!zero) && C!different(c, C!zero)))
    | NonNull(cc, dd, qq) ->
      (D!gt(d, dd) &&
        C!different(c, C!zero) &&
          correct_cons(cc, dd, qq))
  termination proof = structural pp ;

  let correct_rep(p: distributed_representation(C, D)) =
     match p with
     | Null -> true
     | NonNull(c, d, pp) ->
        correct_cons(c, d, pp) ;

theorem rep_invariant : all p: Self, correct_rep (to_rep(p))
proof = assumed
;

  theorem my_total_order: all x: D, all y: D,
    D!lt (x, y) \/ D!gt (x, y) \/ D!equal (x, y)
    proof = assumed;


  theorem my_zero_is_mim: all d: D, D!geq(d, D!zero)
    proof = assumed ; (* by property D!zero_minimal, D!geq_is_leq; *)

  theorem monomial_correct: all c: C, all d: D,
    correct_rep(to_rep(monomial(c, d)))
    proof =
      <1>1 assume c: C, assume d: D,
           prove correct_rep(to_rep(monomial(c, d)))
           <2>1 hypothesis H_0: C!is_zero(c),
                prove correct_rep(zero)
                by hypothesis H_0
                   definition of correct_rep, to_rep, zero
                   type distributed_representation
           <2>2 hypothesis H_1: ~ (C!is_zero(c)),
                prove correct_rep(NonNull(c, d, Null))
                <2>1 prove C!different(c, C!zero)
                     by property C!is_zero_spec, C!same_is_not_different
                        hypothesis H_1
                <2>2 prove D!geq(d, D!zero)
                     by property my_zero_is_mim
                <2>f qed by step <2>1, <2>2
                            definition of correct_rep, to_rep, correct_cons
                            type distributed_representation
           <2>f qed by step <2>1, <2>2
                       definition of monomial, correct_rep, to_rep
     <1>f conclude ;

  (** Equality is recursion of equalities in C and D *)
  let rec equal (x, y) =
    match x with
    | Null -> (
        match y with
        | Null -> true
        | NonNull (_, _, _) -> false)
    | NonNull (cx, dx, xx) -> (
        match y with
        | Null -> false
        | NonNull (cy, dy, yy) ->
          (* Check degrees first for efficiency reasons. *)
          D!equal (dx, dy) && C!equal (cx, cy) && equal (xx, yy)
        )
  termination proof = structural x ;

  proof of equal_reflexive =
    <1>1 prove equal(Null, Null)
        by type distributed_representation definition of equal
    <1>2 prove all x: Self, all cx: C, all dx: D,
            equal (x, x) -> equal (NonNull (cx, dx, x), NonNull (cx, dx, x))
         by definition of equal
            type distributed_representation
            property C!equal_reflexive, D!equal_reflexive
    <1>3 prove all x: distributed_representation (C, D), !equal(x, x)
         by step <1>1, <1>2 type distributed_representation
    <1>f conclude ;

  logical let equal_symmetry_prop(x: Self): prop =
     all y: Self, equal (x, y) -> equal (y, x) ;

  proof of equal_symmetric =
    <1>1 prove equal_symmetry_prop (Null)
         <2>1 assume y: Self,
              hypothesis H: equal (Null, y),
              prove equal (y, Null)
              by definition of equal
                 type distributed_representation
                 property equal_reflexive
     hypothesis H
          <2>f qed by step <2>1 definition of equal_symmetry_prop
    <1>2 prove all x: Self, all cx: C, all dx: D,
         equal_symmetry_prop (x) -> equal_symmetry_prop (NonNull (cx, dx, x))
         <2>1 assume x: distributed_representation (C, D),
              assume cx: C, assume dx: D,
        hypothesis Ind: equal_symmetry_prop (x),
        prove equal_symmetry_prop (NonNull (cx, dx, x))
               <3>1 prove all y: distributed_representation (C, D),
                   equal (NonNull(cx, dx, x), y) -> equal(y, NonNull(cx, dx, x))
                   <4>1 prove equal (NonNull (cx, dx, x), Null) ->
                          equal (Null, NonNull (cx, dx, x))
                        <5>1 prove ~ (equal (NonNull (cx, dx, x), Null))
                             by definition of equal
                                type distributed_representation
                        <5>f conclude
                   <4>2 prove all cy: C, all dy: D,
                              all y: distributed_representation(C, D),
                        equal (NonNull (cx, dx, x), NonNull (cy, dy, y)) ->
                         equal (NonNull (cy, dy, y), NonNull (cx, dx, x))
                        <5>1 assume cy: C, dy: D, y: Self,
                             hypothesis H: equal(NonNull (cx, dx, x),
                                                 NonNull (cy, dy, y)),
                             prove equal(NonNull(cy, dy, y), NonNull(cx, dx, x))
                             <6>1 prove C!equal (cx, cy)
                                  by hypothesis H definition of equal
                                     type distributed_representation
                             <6>2 prove D!equal (dx, dy)
                                  by hypothesis H definition of equal
                                     type distributed_representation
                             <6>3 prove equal (x, y)
                                  by hypothesis H definition of equal
                                     type distributed_representation
                             <6>11 prove C!equal (cy, cx)
                                   by step <6>1 property C!equal_symmetric
                             <6>22 prove D!equal (dy, dx)
                                   by step <6>2 property D!equal_symmetric
                             <6>33 prove equal (y, x)
                                   by step <6>3 hypothesis Ind
                                      definition of equal_symmetry_prop
                             <6>f qed by step <6>11, <6>22, <6>33
                                      definition of equal
                                      type distributed_representation
                        <5>f conclude
                   <4>f qed by step <4>1, <4>2 type distributed_representation
              <3>f qed by step <3>1 definition of equal_symmetry_prop
         <2>f conclude
    <1>3 prove all x: distributed_representation(C, D), equal_symmetry_prop(x)
   by step<1>1, <1>2 type distributed_representation
    <1>f qed by step <1>3
         definition of equal_symmetry_prop ;

  proof of equal_transitive =
    property D!equal_transitive, C!equal_transitive
    assumed (* type distributed_representation; should soon work with Zenon*);

  let reductum (p: Self) : Self =
    match p with
    | Null -> zero
    | NonNull(_, _, r) -> r ;



  (* theorem correct_reductum: all x: Self, correct_rep(from_rep(x)) -> *)
  (*   correct_rep(reductum(x)) *)
  (*   proof = *)
  (*     assumed; *)
      (* <1>B prove corect_rep(Nulll) -> corect_rep(reductum(Null)) *)
      (*     assumed *)
      (* <1>I prove all c: C, all d: D, all x: Self, *)
      (*      correct_rep(x) -> correct_rep(reductum(x)) -> *)
      (*        correct_rep(NonNull(c, d, x)) ->  *)
      (*          correct_rep(reductum(NonNull(c, d, x))) *)
      (*      assume c: C, assume d: D, assume x: Self, *)
      (*      assume I: correct_rep(x) -> correct_rep(reductum(x)), *)
      (*      assume H: correct_rep(NonNull(c, d, x) *)
      (*      prove correct_rep(reductum(NonNull(c, d, x))) *)
      (*      <2>1 prove correct_rep(x) *)
      (*           by hypothesis H  *)
      (*              definition of reductum, correct_rep *)
      (*              type distributed_representation *)
      (*      <2>f qed by step <2>1  *)
      (*                  definition of reductum  *)
      (*                  type distributed_representation *)
      (* <1>f qed by step <1>I, <1>B, type distributed_representation; *)

  let output =
    let rec my_out(p, c, d, v) =
      match p with
      | Null -> C!print (c) ^ "*" ^ v ^ "**" ^ D!print (d)
      | NonNull (cc, dd, pp) ->
          C!print (c) ^ "*" ^ v ^ "**" ^ D!print (d) ^ "+"  ^
          my_out (pp, cc, dd, v)
    termination proof = structural p
    in function p -> function v -> match p with
    | Null -> "0"
    | NonNull (cp, dp, rp) -> my_out (rp, cp, dp, v) ;

  let print (p) = output (p, "?") ;

end ;;

open "rings_fields" ;;

(** The free commutative monoid generated my monomials (m, i) *)
species Indexed_sum (D is Monomial_ordering, M is Additive_group) =
  inherit Formal_indexed_sum (M, D), Indexed_set (D, M);

  proof of monomial_is_non_null =
    by property zero_checks_to_zero definition of monomial ;



theorem  monomial_left_substitution_rule : all x y : M , all i : D,
    M!equal (x, y) -> (!equal (!monomial (x, i), !monomial (y, i)))
proof =
           <1>1 assume x y: M, assume i: D ,
                hypothesis H :  M!equal (x, y),
                prove !equal (!monomial (x, i), !monomial (y, i))
             <2>1 hypothesis H_0: M!is_zero(x),
                  prove !equal (!monomial (x, i), !monomial (y, i))
                  by definition of monomial
                     hypothesis H, H_0
                     property M!is_zero_substitution_rule, equal_reflexive
             <2>2 hypothesis H_1: ~ (M!is_zero(x)),
                  prove !equal (!monomial (x, i), !monomial (y, i))
                  <3>1 hypothesis H_2:  M!is_zero(y),
                   prove !equal (!monomial (x, i), !monomial (y, i))
                     <4>1 prove M!is_zero(x)
                          by property M!is_zero_substitution_rule
                             hypothesis H_2, H
                      <4>f qed by step <4>1 hypothesis H_1
                  <3>2 hypothesis H_3: ~ ( M!is_zero(y)),
                   prove !equal (!monomial (x, i), !monomial (y, i))
                   by definition of monomial, equal
                     property equal_reflexive, M!equal_reflexive,
                     D!equal_reflexive
                     hypothesis H_1, H_3, H
                     type distributed_representation
                   <3>f conclude
              <2>f conclude
           <1>f conclude
;

  proof of leading_coefficient_is_non_null =
  <1>1 assume p: Self,
  hypothesis H : ~(!is_zero (p)),
  notation c1 = leading_coefficient(p),
  notation d1 = degree(p),
  notation p1 = reductum(p),
  prove ~(M!is_zero (!leading_coefficient (p)))
     <2>0 prove correct_rep(p)
          by property rep_invariant definition of to_rep
     <2>2 prove p = NonNull(c1, d1, p1)
          assumed
     <2>3 prove ~ (M!is_zero (c1))
        by definition of correct_rep, correct_cons, to_rep
        property M!same_is_not_different, M!is_zero_spec, M!equal_symmetric
        step <2>0, <2>2
        type distributed_representation
     <2>f qed by step <2>3 definition of c1
  <1>f conclude
;


  proof of degree_is_additive = assumed ;



  proof of reductum_has_smaller_degree =
  <1>1 assume p: Self,
  hypothesis H1 : ~ is_zero(p),
  hypothesis H2 : ~ is_zero(reductum(p)),
  notation c1 = leading_coefficient(p),
  notation c2 = leading_coefficient((reductum(p))),
  notation d1 = degree(p),
  notation d2 = degree(reductum(p)),
  notation p2 = reductum(reductum(p)),
  prove  D!lt( degree(reductum(p)), degree(p))
    <2>0 prove NonNull(c1, d1, reductum(p)) = p
      assumed (*by definition of is_zero, zero, equal, reductum, degree, leading_coefficient, c1, d1
      hypothesis H1
      type distributed_representation*)
    <2>1 prove reductum(p) = NonNull(c2, d2, p2)
      assumed (*by definition of  is_zero, zero, equal, reductum, degree, leading_coefficient, c2, d2, p2
      hypothesis H2
      type distributed_representation*)
     <2>3 prove correct_rep(p)
      by property rep_invariant definition of to_rep
     <2>2 prove D!lt(d2, d1)
        by property D!gt_is_lt
        definition of correct_rep, correct_cons, to_rep
        step <2>0, <2>1, <2>3
        type distributed_representation
     <2>f qed by definition of c1, d1, c2, d2, p2
              step <2>2
  <1>f conclude
;

  theorem correct_rep_conses: all cp: M, all dp: D, all p: distributed_representation(M, D),
     correct_rep(NonNull(cp, dp, p)) -> correct_rep(p)
     proof =
     <1>1 assume cp: M, assume dp: D, assume p: distributed_representation(M, D),
          hypothesis H: correct_rep(NonNull(cp, dp, p)),
          prove correct_rep(p)
          <2>1 prove correct_cons(cp, dp, p)
               by hypothesis H definition of correct_rep
                  type distributed_representation
          <2>2 prove all q: distributed_representation(M, D),
                 (q = p) -> correct_rep(q)
               <3>1 prove (Null = p) -> correct_rep(Null)
                    by definition of correct_rep type distributed_representation
               <3>2 assume cq: M, dq: D, q: distributed_representation(M, D),
                    hypothesis H_i: (q = p) -> correct_rep(q),
                    hypothesis HH: NonNull(cq, dq, q) = p,
                    prove correct_rep(NonNull(cq, dq, q))
                    <4>1 prove correct_cons(cq, dq, q)
                         <5>1 prove correct_cons(cp, dp, NonNull(cq, dq, q))
                              by hypothesis HH step <2>1
                         <5>f qed by step <5>1 definition of correct_cons
                                  type distributed_representation
                    <4>f qed by step <4>1 definition of correct_rep
                             type distributed_representation
               <3>f qed by step <3>1, <3>2 type distributed_representation
          <2>f qed  by step <2>2
     <1>f conclude
  ;

  theorem reductum_correct: all p: Self,
    correct_rep(to_rep(p)) -> correct_rep(to_rep(reductum(p)))
  proof =
  <1>1 prove correct_rep(Null) -> correct_rep(reductum(Null))
       by definition of correct_rep, reductum, zero
          type distributed_representation
  <1>2 assume cp: M, assume dp: D, assume p: Self,
       hypothesis H_i: correct_rep(p) -> correct_rep(reductum(p)),
       hypothesis H: correct_rep(NonNull(cp, dp, p)),
       prove correct_rep(reductum(NonNull(cp, dp, p)))
       <2>1 prove correct_rep(p)
            by hypothesis H property correct_rep_conses
       <2>f qed by step <2>1 definition of reductum
            type distributed_representation
  <1>3 prove all p: distributed_representation(M, D),
          correct_rep(p) -> correct_rep(reductum(p))
       by step <1>1, <1>2
          type distributed_representation
  <1>f qed by step <1>3 definition of to_rep
  ;

  proof of reductum_of_zero_is_zero =
    by definition of zero, reductum
       type distributed_representation
       property equal_reflexive ;

  proof of monomial_has_degree =
    by definition of monomial, degree
    type distributed_representation
    property D!equal_reflexive ;

  proof of reductum_is_reductum = assumed ;

  proof of monomial_has_coefficient =
    by definition of monomial, leading_coefficient
    type distributed_representation
    property M!equal_reflexive ;



(*   local let rec p (a) = *)
(*     match a with  *)
(*       #Nil -> "" *)
(*     | #Cons (mon, l) ->  *)
(*        let other = self!p (l) :           *)
(*        let coef : m = #first (mon) in let dg : i = #scnd (mon) in *)
(*        let print_mon = *)
(*           #sc (m!print (coef), *)
(*               #sc ("* x**", *)
(*           i!print (dg))) *)
(*        in      *)
(*        if #base_eq (l, #Nil) then print_mon else *)
(*          #sc ("(", #sc (print_mon, #sc ("+", other ))) *)
(*     end; *)
(*   let print (a) = self!p (a); *)


  let rec my_plus(c:(Self * Self)) = match c with
  | (s_1, s_2) ->
  match s_1 with
  | Null -> s_2
  | NonNull (m1, d1, ss_1) -> match s_2 with
    | Null -> s_1
    | NonNull (m2, d2, ss_2) ->
      if D!lt (d1, d2)
      then (* d1 < d2*)
        NonNull (m2, d2, !my_plus ((s_1, ss_2)))
      else
        if D!lt (d2, d1)
        then (* d2 < d1 *)
          NonNull (m1, d1, !my_plus ((ss_1, s_2)))
        else (* d2 = d1 total order *)
          let m = M!plus (m1, m2) in
          if M!is_zero (m)
          then !my_plus ((ss_1, ss_2))
          else NonNull (m, d1, !my_plus ((ss_1, ss_2)))
    termination proof =  measure length_pair on c
    <1>1 prove all c: (Self * Self), all s_1 s_2: Self, all m1 m2: M,
               all d1 d2: D, all ss_1 ss_2: Self,
               ((s_1, s_2) = c) -> NonNull (m1, d1, ss_1) = s_1 ->
                  (NonNull (m2, d2, ss_2) = s_2) ->
                   D!lt (d1, d2) ->
                     !length_pair ((s_1, ss_2)) < !length_pair (c)
         by property length_pair_right_lt
   <1>2 prove all c: (Self * Self), all s_1 s_2: Self, all m1 m2: M,
               all d1 d2: D, all ss_1 ss_2: Self,
               ((s_1, s_2) = c) -> NonNull (m1, d1, ss_1) = s_1 ->
                  (NonNull (m2, d2, ss_2) = s_2) ->
                    (D!lt (d1, d2) = false) ->
                      D!lt (d2, d1) ->
                         !length_pair ((ss_1, s_2)) < !length_pair (c)
         by property length_pair_left_lt
    <1>3 prove all c: (Self * Self), all s_1 s_2: Self, all m1 m2: M,
               all d1 d2: D, all ss_1 ss_2: Self,
               all m: M,
               ((s_1, s_2) = c) -> NonNull (m1, d1, ss_1) = s_1 ->
                  (NonNull (m2, d2, ss_2) = s_2) ->
                    (D!lt (d1, d2) = false) ->
                      (D!lt (d2, d1) = false) ->
                        M!plus (m1, m2)= m ->
                         M!is_zero (m) ->
                          !length_pair ((ss_1, ss_2)) < !length_pair (c)
         by property length_pair_left_right_lt
    <1>4 prove all c: (Self * Self), all s_1 s_2: Self, all m1 m2: M,
               all d1 d2: D, all ss_1 ss_2: Self,
               all m: M,
               ((s_1, s_2) = c) -> NonNull (m1, d1, ss_1) = s_1 ->
                  (NonNull (m2, d2, ss_2) = s_2) ->
                    (D!lt (d1, d2) = false) ->
                      (D!lt (d2, d1) = false) ->
                        (M!plus (m1, m2)= m) ->
                         (M!is_zero (m)= false) ->
                         !length_pair ((ss_1, ss_2)) < !length_pair (c)
         by property length_pair_left_right_lt
     <1>5 prove all c : Self * Self, 0 <= !length_pair (c)
          by property length_pair_measure
     <1>e qed coq proof {* wf_qed *}
    ;


  let plus (s_1: Self, s_2: Self): Self = my_plus((s_1, s_2))
  ;




  proof of monomial_is_additive =
    <1>1 assume x y: M, assume i: D ,
         prove !equal (!plus (!monomial (x, i), !monomial (y, i)),
                       !monomial (M!plus (x, y), i))
      <2>1 hypothesis H_0: M!is_zero(x),
           prove !equal (!plus (!monomial (x, i), !monomial (y, i)),
                         !monomial (M!plus (x, y), i))
        <3>0 prove M!equal(x, M!zero)
        by property M!is_zero_spec, M!equal_symmetric hypothesis H_0
        <3>1 prove equal(monomial(x, i), zero)
        by definition of monomial property equal_reflexive hypothesis H_0
        <3>2 prove
             !equal (!plus (!monomial (x, i), !monomial (y, i)),
                     !monomial (y, i))
             by property equal_transitive, zero_is_neutral,
                plus_left_substitution_rule step <3>1
          <3>3 prove !equal (!monomial (M!plus (x, y), i), !monomial (y, i))
               by property equal_transitive, M!zero_is_neutral,
               M!plus_left_substitution_rule,  monomial_left_substitution_rule
               step <3>0
          <3>f qed by property equal_symmetric, equal_transitive step <3>2, <3>3
      <2>2 hypothesis H_1: ~ (M!is_zero(x)),
           prove !equal (!plus (!monomial (x, i), !monomial (y, i)),
                         !monomial (M!plus (x, y), i))
        <3>1 hypothesis H_2: M!is_zero(y),
             prove !equal (!plus (!monomial (x, i), !monomial (y, i)),
                           !monomial (M!plus (x, y), i))
          <4>0 prove M!equal(y, M!zero)
               by property M!is_zero_spec, M!equal_symmetric hypothesis H_2
          <4>1 prove equal(monomial(y, i), zero)
             by definition of monomial property equal_reflexive hypothesis H_2
             <4>2 prove !equal (!plus (!monomial (x, i), !monomial (y, i)),
                                !monomial (x, i))
                  by property equal_transitive, zero_is_neutral,
                    plus_right_substitution_rule step <4>1
            <4>3 prove !equal (!monomial (M!plus (x, y), i), !monomial (x, i))
                 by property equal_transitive, M!zero_is_neutral,
                   M!plus_right_substitution_rule,
                   monomial_left_substitution_rule step <4>0
            <4>f qed by property equal_symmetric, equal_transitive
                     step <4>2, <4>3
          <3>2 hypothesis H_3: ~( M!is_zero(y)),
               hypothesis Hyp: ~ (D!lt(i, i)),
               prove !equal (!plus (!monomial (x, i), !monomial (y, i)),
                             !monomial (M!plus (x, y), i))
               by definition of monomial, plus, my_plus, zero
                  property equal_reflexive
                  hypothesis H_1, H_3,  Hyp
                  type distributed_representation
         <3>f qed by step <3>1, <3>2 property D!lt_is_irreflexive
    <2>f qed by step <2>1, <2>2
  <1>f conclude
 ;

  logical let plus_invariant_property(p) = all q: Self,
     correct_rep(to_rep(p)) -> correct_rep(to_rep(q)) ->
       correct_rep(to_rep(plus(p, q)));

  theorem plus_preserve_invariant: all p_1: Self, plus_invariant_property(p_1)
    proof =
      <1>1 prove plus_invariant_property (Null)
           <2>1 prove correct_rep(to_rep (Null))
                by definition of correct_rep, to_rep
                   type distributed_representation
           <2>2 assume q: distributed_representation(M, D),
                hypothesis H: correct_rep (to_rep (q)),
                prove correct_rep(to_rep (plus (Null, q)))
                by hypothesis H
                   definition of correct_rep, to_rep, plus, my_plus
                   type distributed_representation
           <2>f qed by step <2>1, <2>2 definition of plus_invariant_property
      <1>2 prove all p: distributed_representation (M, D),
                 all cp: M, all dp: D,
                   plus_invariant_property (p) ->
                     plus_invariant_property (NonNull (cp, dp, p))
           <2>1 assume p: distributed_representation (M, D),
                assume cp: M, assume dp: D,
                hypothesis H_pip: plus_invariant_property (p),
                prove plus_invariant_property (NonNull (cp, dp, p))
                <3>1 prove all q: distributed_representation(M, D),
                             correct_rep(to_rep (NonNull (cp, dp, p))) ->
                             correct_rep (to_rep (q)) ->
                             correct_rep(to_rep(plus(NonNull(cp, dp, p), q)))
                     <4>1 hypothesis H_pcr:
                                correct_rep(to_rep(NonNull(cp, dp, p))),
                          prove all q: distributed_representation(M, D),
                            correct_rep(to_rep(q)) ->
                              correct_rep(to_rep(plus(NonNull(cp, dp, p), q)))
                          <5>1 prove  correct_rep(to_rep(Null)) ->
                               correct_rep(to_rep(plus(NonNull(cp, dp, p), Null)))
                               <6>1 prove correct_rep(to_rep(Null))
                                    by definition of correct_rep, to_rep
                                    type distributed_representation
                               <6>2 prove
                                     correct_rep(to_rep(plus(NonNull(cp, dp, p),
                                                             Null)))
                                     by hypothesis H_pcr
                                     definition of plus, my_plus, correct_rep, to_rep
                                     type distributed_representation
                               <6>f qed by step <6>1, <6>2
                                             type distributed_representation
                           <5>2 prove all q: distributed_representation(M, D),
                                (correct_rep(to_rep(q)) ->
                                correct_rep(to_rep(plus(NonNull(cp, dp, p), q)))) ->
                                (all cq: M, all dq: D,
                                correct_rep(to_rep(NonNull(cq, dq, q))) ->
                                correct_rep(to_rep(plus(NonNull(cp, dp, p),
                                                        NonNull(cq, dq, q)))))
                                 <6>1 assume q: distributed_representation(M, D),
                                      hypothesis H_ind_q:
                            correct_rep(to_rep(q)) ->
                              correct_rep(to_rep(plus(NonNull(cp, dp, p), q))),
                                      prove all cq: M, all dq: D,
                                         correct_rep(to_rep(NonNull(cq, dq, q))) ->
                                           correct_rep(to_rep(plus(NonNull(cp, dp, p),
                                                                   NonNull(cq, dq, q))))
                                      <7>1 assume cq: M, assume dq: D,
                                           hypothesis H_nqcr:
                                               correct_rep(to_rep(NonNull(cq, dq, q))),
                                           notation s =
                                                  plus(NonNull(cp, dp, p),
                                                       NonNull(cq, dq, q)),
                                           prove correct_rep(to_rep(
                                                  plus(NonNull(cp, dp, p),
                                                       NonNull(cq, dq, q))))
                                           <8>1 hypothesis Dpq: D!lt(dp, dq),
                                                prove correct_rep(s)
                                                <9>1 prove correct_rep(NonNull(cq, dq, plus(NonNull(cp, dp, p), q)))
                                                      <10>1 prove correct_rep(plus(NonNull(cp, dp, p), q))
                                                            assumed
                                                      <10>f qed assumed
                                                 <9>f qed by hypothesis Dpq
                                                      step <9>1
                                                      definition of s, plus, my_plus
                                                      type distributed_representation
                                            <8>2 hypothesis Dpq: ~ D!lt(dp, dq),
                                                 prove  correct_rep(s)
                                                 <9>1 hypothesis Dqp: D!lt(dq, dp),
                                                      prove correct_rep(s)
                                                      <10>1 prove correct_rep(NonNull(cp, dp, plus(p, NonNull(cq, dq, q))))
                                                            <11>1 notation ss = plus(p, NonNull(cq, dq, q)),
                                                                  prove correct_cons(cp, dp, plus(p, NonNull(cq, dq, q)))
                                                                  <12>1 prove all r: distributed_representation(M, D),
                                                                          (r = ss) -> correct_cons(cp, dp, r)
                                                                          <13>1 hypothesis Sn: Null = ss,
                                                                                 prove correct_cons(cp, dp, Null)
                                                                                assumed
                                                                          <13>2 assume cr: M, assume dr: D, assume rr: distributed_representation(M, D),
                                                                                hypothesis Snn: NonNull(cr, dr, rr) = ss,
                                                                                hypothesis H_i: (rr = ss) -> correct_cons(cp, dp, rr),
                                                                                prove correct_cons(cp, dp, NonNull(cr, dr, rr))
                                                                                assumed
                                                                         <13>f qed by step <13>1, <13>2
                                                                               type distributed_representation
                                                                  <12>f qed by step <12>1
                                                                        definition of ss
                                                            <11>f qed by step <11>1
                                                                  definition of correct_rep
                                                                  type distributed_representation
                                                      <10>f qed by step <10>1
                                                            hypothesis Dpq, Dqp
                                                            definition of s, plus, my_plus
                                                            type distributed_representation
                                                 <9>2 hypothesis Dqp: ~ D!lt(dq, dp),
                                                       prove correct_rep(s)
                                                      assumed
                                                  <9>f conclude
                                             <8>f qed by step <8>1, <8>2
                                                      definition of s, to_rep
                                      <7>f conclude
                                  <6>f conclude

                           <5>f qed by step <5>1, <5>2
                                    type distributed_representation
                     <4>f conclude
                <3>f qed by step <3>1
                            definition of plus_invariant_property
                            type distributed_representation
           <2>f conclude
      <1>3 prove all p: distributed_representation(M, D),
     plus_invariant_property(p)
           by step <1>1, <1>2 type distributed_representation
      <1>f conclude
    ;


  let swap (c: distributed_representation (M,D) * distributed_representation (M, D)) : distributed_representation (M,D) * distributed_representation (M,D) =
  match c with
   | (x, y) ->  (y, x)
  ;

  logical let my_plus_commutes_prop (c: distributed_representation (M,D) * distributed_representation (M,D)) : prop =
  equal(my_plus(c), my_plus(swap(c)));


(*
theorem functional_induction_my_plus_derived:
all pred : distributed_representation (M,D) * distributed_representation (M,D) -> bool,
  ((pred((Null, Null))) /\
  (all c1 : M, all d1 : D, all p1 : distributed_representation (M,D),
    pred((Null, NonNull(c1,d1,p1)))) /\
  (all c1 : M, all d1 : D, all p1 : distributed_representation (M,D),
    pred((NonNull(c1,d1,p1), Null))) /\
  (all c1  c2 : M, all d1  d2 : D,
   all pp1  pp2 : distributed_representation (M,D),
   D!lt (d1, d2) -> pred((NonNull(c1,d1,pp1),pp2)) ->
       pred((NonNull(c1,d1,pp1), NonNull(c2,d2,pp2)))) /\
  (all c1  c2 : M, all d1  d2 : D,
   all pp1  pp2 : distributed_representation (M,D),
   D!gt(d1,d2) -> pred((pp1, NonNull(c2,d2,pp2))) ->
       pred((NonNull(c1,d1,pp1), NonNull(c2,d2,pp2)))) /\
  (all c1  c2 : M, all d1  d2 : D,
   all pp1  pp2 : distributed_representation (M,D),
   D!equal(d1,d2) -> M!is_zero (M!plus (c1, c2)) -> pred((pp1, pp2)) ->
       pred((NonNull(c1,d1,pp1), NonNull(c2,d2,pp2)))) /\
  (all c1  c2 : M, all d1  d2 : D,
   all pp1  pp2 : distributed_representation (M,D),
   D!equal(d1,d2) -> ~ (M!is_zero (M!plus (c1, c2))) -> pred((pp1, pp2)) ->
       pred((NonNull(c1,d1,pp1), NonNull(c2,d2,pp2))))
   )
   ->
   all c: distributed_representation (M,D) * distributed_representation (M,D),
   pred(c)
proof = assumed
;
*)

  logical let plus_commutes_prop (c1: distributed_representation (M,D), c2 :  distributed_representation (M,D)) : prop =
  equal(plus(c1,c2), plus(c2,c1));

theorem functional_induction_plus_inst1:
  ((plus_commutes_prop(Null, Null)) /\
  (all c1 : M, all d1 : D, all p1 : distributed_representation (M,D),
    plus_commutes_prop(Null, NonNull(c1,d1,p1))) /\
  (all c1 : M, all d1 : D, all p1 : distributed_representation (M,D),
   plus_commutes_prop(NonNull(c1,d1,p1), Null)) /\
  (all c1  c2 : M, all d1  d2 : D,
   all pp1  pp2 : distributed_representation (M,D),
   D!lt (d1, d2) -> plus_commutes_prop(NonNull(c1,d1,pp1),pp2) ->
       plus_commutes_prop(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2))) /\
  (all c1  c2 : M, all d1  d2 : D,
   all pp1  pp2 : distributed_representation (M,D),
   ~ D!lt (d1, d2) -> D!lt(d2,d1) -> plus_commutes_prop(pp1, NonNull(c2,d2,pp2)) ->
       plus_commutes_prop(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2))) /\
  (all c1  c2 : M, all d1  d2 : D,
   all pp1  pp2 : distributed_representation (M,D),
   ~ D!lt (d1, d2) -> ~ D!lt(d2,d1) ->
   M!is_zero (M!plus (c1, c2)) -> plus_commutes_prop(pp1, pp2) ->
       plus_commutes_prop(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2))) /\
  (all c1  c2 : M, all d1  d2 : D,
   all pp1  pp2 : distributed_representation (M,D),
   ~ D!lt (d1, d2) -> ~ D!lt(d2,d1) ->
   ~ (M!is_zero (M!plus (c1, c2))) -> plus_commutes_prop(pp1, pp2) ->
       plus_commutes_prop(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2))
   ))
   ->
   all c1: distributed_representation (M,D), all c2 : distributed_representation (M,D),
   plus_commutes_prop(c1, c2)
proof =  coq proof definition of plus, my_plus, plus_commutes_prop
       {*
Proof.
unfold plus; unfold plus_commutes_prop; unfold my_plus; unfold Termination_my_plus_namespace.Indexed_sum__my_plus.
do 8 intro.
assert
 (forall
    c : distributed_representation__t _p_M_T _p_D_T *
        distributed_representation__t _p_M_T _p_D_T,
  Is_true
    (abst_equal
       (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt _p_M_plus
          _p_M_is_zero abst_length_pair c)
       (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt _p_M_plus
          _p_M_is_zero abst_length_pair (snd c, fst c)))).
 intros.
 decompose [and] H.
 apply Termination_my_plus_namespace.my_plus_ind.
 
intros; case_eq s_2.
intro Hs_2; simpl.
rewrite Termination_my_plus_namespace.my_plus_equation in H0.
rewrite Termination_my_plus_namespace.my_plus_equation;  assumption.

intros m1 d1 d Hs_2; simpl.
replace (Is_true
     (abst_equal (NonNull _p_M_T _p_D_T m1 d1 d)
        (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
           _p_M_plus _p_M_is_zero abst_length_pair
           (NonNull _p_M_T _p_D_T m1 d1 d, Null _p_M_T _p_D_T)))) 
  with
  (Is_true
     (abst_equal 
       (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
           _p_M_plus _p_M_is_zero abst_length_pair
           (Null _p_M_T _p_D_T , NonNull _p_M_T _p_D_T m1 d1 d))
        (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
           _p_M_plus _p_M_is_zero abst_length_pair
           (NonNull _p_M_T _p_D_T m1 d1 d, Null _p_M_T _p_D_T)))).
simpl; apply H2.
rewrite Termination_my_plus_namespace.my_plus_equation; auto.

intros; simpl; rewrite e1.
replace (    Is_true
     (abst_equal 
        (NonNull _p_M_T _p_D_T m1 d1 ss_1)
        (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
           _p_M_plus _p_M_is_zero abst_length_pair
           (Null _p_M_T _p_D_T, NonNull _p_M_T _p_D_T m1 d1 ss_1)))
)
with
(
   Is_true
     (abst_equal 
       (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
           _p_M_plus _p_M_is_zero abst_length_pair
           (NonNull _p_M_T _p_D_T m1 d1 ss_1, Null _p_M_T _p_D_T ))
        (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
           _p_M_plus _p_M_is_zero abst_length_pair
           (Null _p_M_T _p_D_T, NonNull _p_M_T _p_D_T m1 d1 ss_1)))  
).
apply H1.
rewrite Termination_my_plus_namespace.my_plus_equation; auto.

intros; simpl.
replace 
(NonNull _p_M_T _p_D_T m2 d2
           (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
              _p_M_plus _p_M_is_zero abst_length_pair 
              (s_1, ss_2)))
with
       (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
           _p_M_plus _p_M_is_zero abst_length_pair
           (NonNull _p_M_T _p_D_T m1 d1 ss_1,
           NonNull _p_M_T _p_D_T m2 d2 ss_2)).
apply H3.
exact (EqTrue_is_true _ e3).

rewrite e1 in H6;  assumption.

rewrite Termination_my_plus_namespace.my_plus_equation; rewrite e3; 
rewrite e1; auto.

intros; simpl.
replace (NonNull _p_M_T _p_D_T m1 d1
           (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
              _p_M_plus _p_M_is_zero abst_length_pair 
              (ss_1, s_2)))
with
      (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
           _p_M_plus _p_M_is_zero abst_length_pair
           (NonNull _p_M_T _p_D_T m1 d1 ss_1,
           NonNull _p_M_T _p_D_T m2 d2 ss_2)).
apply H4.
apply (IsTrue_eq_false2 _ e3).

apply (EqTrue_is_true _ e4).

rewrite e2 in H6;    exact H6.

rewrite Termination_my_plus_namespace.my_plus_equation.
rewrite e3; rewrite e4;   rewrite e2;   auto.

intros; simpl.
replace (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
           _p_M_plus _p_M_is_zero abst_length_pair 
           (ss_1, ss_2)) with
(Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
           _p_M_plus _p_M_is_zero abst_length_pair
           (NonNull _p_M_T _p_D_T m1 d1 ss_1,
           NonNull _p_M_T _p_D_T m2 d2 ss_2)).
apply H5.
apply (IsTrue_eq_false2 _ e3).
apply (IsTrue_eq_false2 _ e4).
apply (EqTrue_is_true _ e5).

simpl in H6;    exact H6.

rewrite Termination_my_plus_namespace.my_plus_equation.
rewrite e3; rewrite e4; replace (_p_M_plus m1 m2) with m  by auto.
rewrite e5;   auto.

intros; simpl.
replace (NonNull _p_M_T _p_D_T m d1
           (Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
              _p_M_plus _p_M_is_zero abst_length_pair 
              (ss_1, ss_2))) with
(Termination_my_plus_namespace.my_plus _p_D_T _p_M_T _p_D_lt
           _p_M_plus _p_M_is_zero abst_length_pair
           (NonNull _p_M_T _p_D_T m1 d1 ss_1,
           NonNull _p_M_T _p_D_T m2 d2 ss_2)).
simpl; apply H7.

apply (IsTrue_eq_false2 _ e3).
apply (IsTrue_eq_false2 _ e4).
apply (IsTrue_eq_false2 _ e5).

simpl in H6;    exact H6.

rewrite Termination_my_plus_namespace.my_plus_equation;  rewrite e3; rewrite e4.
replace (_p_M_plus m1 m2) with m  by auto.
rewrite e5;   auto.

intros; apply H0.
Qed. *}
;


proof of plus_commutes =
  <1>1 prove plus_commutes_prop(Null, Null)
       by definition of plus, plus_commutes_prop, swap property equal_reflexive

  <1>2 assume c1 : M,
       assume d1 : D,
       assume p1 : distributed_representation (M,D),
       prove plus_commutes_prop(Null, NonNull(c1,d1,p1))
       by definition of plus_commutes_prop, plus, my_plus
           type distributed_representation property equal_reflexive

  <1>3 assume c1 : M,
       assume d1 : D,
       assume p1 : distributed_representation (M,D),
       prove plus_commutes_prop(NonNull(c1,d1,p1), Null)
       by definition of plus, plus_commutes_prop, my_plus
          property equal_symmetric step <1>2

  <1>4 assume c1  c2 : M,
       assume d1  d2 : D,
       assume pp1  pp2 : distributed_representation (M,D),
       hypothesis H1 : D!lt (d1, d2),
       hypothesis Hrec1 : plus_commutes_prop(NonNull(c1,d1,pp1),pp2),
       prove plus_commutes_prop(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2) )
         <3>1 prove ~ (D!lt (d2, d1))
              by hypothesis H1 property  D!lt_is_asymetric
         <3>2 prove plus(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2)) =
              NonNull(c2, d2, plus(NonNull(c1,d1,pp1), pp2))
              by definition of plus, my_plus hypothesis H1
                 type  distributed_representation
         <3>3 prove plus(NonNull(c2,d2,pp2), NonNull(c1,d1,pp1)) = NonNull(c2, d2, plus(pp2, NonNull(c1,d1,pp1)))
              by step <3>1 hypothesis H1 definition of plus, my_plus
              type  distributed_representation
         <3>5 prove plus_commutes_prop(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2) )
              by definition of  equal, plus_commutes_prop, plus
              step <3>2, <3>3 property M!equal_reflexive, D!equal_reflexive
              type distributed_representation hypothesis Hrec1
         <3>f conclude 

   <1>5 assume c1  c2 : M,
        assume d1  d2 : D,
        assume pp1  pp2 : distributed_representation (M,D),
        hypothesis NH1 : ~(D!lt(d1, d2)),
        hypothesis H2 : D!lt (d2, d1),
        hypothesis Hrec2 : plus_commutes_prop(pp1, NonNull(c2,d2,pp2)),
        prove plus_commutes_prop(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2) )
         <3>2 prove plus(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2)) =
              NonNull(c1, d1, plus(pp1, NonNull(c2,d2,pp2)))
              by definition of plus, my_plus hypothesis NH1, H2
                 type  distributed_representation
         <3>3 prove plus( NonNull(c2,d2,pp2), NonNull(c1,d1,pp1)) = NonNull(c1, d1, plus(NonNull(c2,d2,pp2), pp1))
              by  hypothesis NH1, H2 definition of plus, my_plus,  plus_commutes_prop
                 type  distributed_representation
         <3>5 prove plus_commutes_prop(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2))
              by definition of plus_commutes_prop, equal
              step <3>2, <3>3 property M!equal_reflexive, D!equal_reflexive
              hypothesis Hrec2 type distributed_representation
         <3>f conclude 

   <1>6 assume c1  c2 : M,
        assume d1  d2 : D,
        assume pp1  pp2 : distributed_representation (M,D),
        hypothesis NH1 : ~(D!lt(d1, d2)),
        hypothesis NH2 : ~(D!lt (d2, d1)),
        hypothesis Hyp1 :  M!is_zero (M!plus (c1, c2)),
        hypothesis Hrec3 : plus_commutes_prop(pp1, pp2),
        prove plus_commutes_prop(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2) )
         <3>1 prove plus(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2)) = plus(pp1, pp2)
                by definition of plus, my_plus
                   type distributed_representation
                   hypothesis NH1, NH2, Hyp1
         <3>5 prove  M!is_zero (M!plus (c2, c1))
                 by hypothesis Hyp1 property M!plus_commutes, M!is_zero_substitution_rule
         <3>2 prove plus(NonNull(c2,d2,pp2), NonNull(c1,d1,pp1))= plus(pp2, pp1)
                 by definition of my_plus, plus
                    type distributed_representation
                    hypothesis NH1, NH2 step  <3>5
         <3>3 prove plus_commutes_prop(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2))
             by definition of plus_commutes_prop
             step <3>1,<3>2  hypothesis Hrec3
         <3>f conclude 

   <1>7 assume c1  c2 : M,
        assume d1  d2 : D,
        assume pp1  pp2 : distributed_representation (M,D),
        hypothesis NH1 : ~(D!lt(d1, d2)),
        hypothesis NH2 : ~(D!lt (d2, d1)),
        hypothesis Hyp2 :  ~ (M!is_zero (M!plus (c1, c2))),
        hypothesis Hrec3 : plus_commutes_prop(pp1, pp2),
        prove plus_commutes_prop(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2) )
         <3>3 prove D!equal (d1, d2)
              by property  my_total_order, D!gt_is_lt, D!lt_is_asymetric hypothesis NH1, NH2
         <3>9 prove M!equal(M!plus(c1, c2), M!plus(c2, c1))
            by property M!plus_commutes
         <3>8 prove ~ ( M!is_zero (M!plus (c2, c1)))
            by property M!is_zero_substitution_rule step <3>9 hypothesis Hyp2
         <3>1 prove plus(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2) ) = NonNull(M!plus(c1, c2), d1, plus(pp1, pp2))
            by definition of my_plus, plus hypothesis NH1, NH2, Hyp2
               type distributed_representation
          <3>2 prove plus(NonNull(c2,d2,pp2), NonNull(c1,d1,pp1)) = NonNull(M!plus(c2, c1), d2, plus(pp2, pp1))
            by definition of my_plus, plus
               type distributed_representation hypothesis NH1, NH2, Hyp2
               step <3>8
          <3>5 prove plus_commutes_prop(NonNull(c1,d1,pp1), NonNull(c2,d2,pp2) )
            by step <3>1, <3>2, <3>9 
               definition of plus_commutes_prop, equal 
               step <3>3  type distributed_representation hypothesis Hrec3
         <3>f conclude
    <1>f qed by step <1>1, <1>2, <1>3, <1>4, <1>5, <1>6, <1>7 
            type distributed_representation
            definition of  plus_commutes_prop
            property functional_induction_plus_inst1;


  proof of plus_is_associative = assumed;
  proof of plus_right_substitution_rule = assumed;
  proof of zero_is_neutral =
   <1>1 prove all x: Self, !equal(!plus(!zero, x), x)
        by definition of zero, plus, my_plus
           property equal_reflexive
           type distributed_representation
   <1>2 prove all x: Self, !equal(!plus(x, !zero), x)
        by step <1>1 property !plus_commutes, equal_transitive
   <1>f conclude;
  proof of opposite_is_opposite = assumed;

end;;

(**
  Polynomials over a commutative ring in distributed representation
 *)
species Distributed_polynomials_commutative_ring
    (R is Commutative_ring, D is Monomial_ordering) =
  inherit Formal_polynomials_commutative_ring (R, D),
          Indexed_sum (D, R);

   (** returns cX^d p *)
   let rec monomial_multiply (c : R, d : D, p : Self) : Self = match p with
     | Null -> Null
     | NonNull (cp, dp, pp) ->
         let r = R!mult (c, cp) in
         if R!is_zero (r)
         then !monomial_multiply (c, d, pp)
         else NonNull (r, D!plus (d, dp), monomial_multiply (c, d, pp))
   termination proof = structural p ;

   let module_mult (c, p) = !monomial_multiply (c, D!zero, p);

   let rec mult (p, q) = match p with
     | Null -> zero
     | NonNull (cp, dp, pp) ->
         !plus (!monomial_multiply (cp, dp, q),
               !mult (pp, q))
   termination proof = structural p ;



   proof of module_mult_compat =
   assumed ;


   proof of mult_left_substitution_rule = assumed;
   proof of mult_commutes = assumed;
   proof of mult_assoc = assumed;
   proof of mult_left_distributes_on_plus = assumed;

(*            parse_poly_uni (r, d) *)
(*  (\* from V. Ruffie, to let every implementation of algebre_indexee recognize *)
(*     polynomials written `a la Maple` *)
(*  *\) *)
(*   let read_monomial (d) = *)
(*      !generator (d); *)

(*   let read_cst (c)= *)
(*      !lift (c); *)

(*   let read_deg (s)= *)
(*      d!parse (s); *)

(*   let read_coeff (s)= *)
(*      r!parse (s); *)

(*   local let map_times (p, ql) = *)
(*      let f (x, r) =  *)
(*               let c = #first (x) in  *)
(*               let d = #scnd (x) in  *)
(*         self!fmecg (r, c, d, p) *)
(*      in lists_foc#fold_right (f, ql, #Nil); *)

(*   local let rec i_output (liste : self, *)
(*          coef : r, *)
(*          deg : d, *)
(*          v_name : string) : string =  *)
(*     let p_name = *)
(*        if #base_eq (v_name, "") *)
(*        then "" *)
(*        else #sc (v_name, "**") *)
(*     in *)
(*     match liste with *)
(*     | #Nil ->   *)
(*         #sc (r!print (coef), *)
(*             #sc ("*", *)
(*         #sc (p_name, d!print (deg)))) *)
(*     | #Cons (a, l) ->  *)
(*         #sc ("(" , *)
(*             #sc (r!print (coef), *)
(*         #sc ("*", *)
(*             #sc (p_name, *)
(*         #sc (d!print (deg), *)
(*             #sc (")+", *)
(*         !i_output (l, *)
(*           #first (a), *)
(*           #scnd (a), *)
(*           v_name))))))) *)
(*     end; *)

(*   let output (x : self, c : string)= *)
(*       match x with *)
(*         #Nil -> "0" *)
(*       | #Cons (a, l) ->  *)
(*         !i_output (l, #first (a), #scnd (a), c) *)
(*       end; *)
(*   let print (x) = self!output (x, "_?"); *)
(*   let generator (n) =  *)
(*      let under_un = r!one in *)
(*      #Cons (#crp (under_un, n), #Nil); *)

(*   proof of plus_is_left_regular =assumed; *)

(*   let one = #Cons (#crp (r!one, d!zero), #Nil); *)

(*   let module_mult = fun rr ->  *)
(*     let rm (x, y) = r!mult (x, y) in *)
(*     let pol_map (f, p) = self!map_under (f, p) in *)
(*     let cstm (x) = rm (rr, x) in  *)
(*     fun p -> pol_map (cstm, p); *)
(*   proof of lift_additive = assumed ; *)
(*   proof of lift_one = assumed ; *)
(*   proof of module_mult_compat = assumed ; *)
(*   (\** fmecg : f multiply exponent coefficient g **\)   *)
(*   (\** fmecg (P, a, n, Q) = P + aX^n Q            **\) *)
(*   let fmecg : (self -> r -> d -> self -> self ) = *)
(*      (\* (p : self, a, n, q : self) : self = *\) *)
(*      let rm (x, y) = r!mult (x, y) in *)
(*      let rp (x, y) = r!plus (x, y) in *)
(*      let is_zero (x) = r!is_zero (x) in *)
(*      let dpl (x, y) = d!plus (x, y) in *)
(*      let dlt (x, y) = d!lt (x, y) in *)
(*      let rec f_map (p, a, n, q) = *)
(*        match q with *)
(*          #Nil -> p *)
(*        | #Cons (x, qq) -> *)
(*            let cq = #first (x) in let dq = #scnd (x) in *)
(*            let dqn = dpl (n, dq) in (\*dqn degre de aX^n Q*\) *)
(*            match p with *)
(*              #Nil ->  *)
(*                let res = rm (a, cq) in *)
(*                if is_zero (res) then  *)
(*                  f_map (#Nil, a, n, qq) else *)
(*                  #Cons (#crp (res, dqn), f_map (#Nil, a, n, qq)) *)
(*            |#Cons (y, pp) -> *)
(*                let cp = #first (y) in let dp = #scnd (y) in *)
(*                if dlt (dqn, dp) then *)
(*                  #Cons (y, f_map (pp, a, n, q)) *)
(*                else *)
(*                  if dlt (dp, dqn)  *)
(*                  then  *)
(*            let res = rm (a, cq) in *)
(*                    if is_zero (res) then f_map (p, a, n, qq) *)
(*                    else #Cons (#crp (res, dqn), f_map (p, a, n, qq)) *)
(*                  else  *)
(*            let res = rp (cp, rm (a, cq)) in *)
(*                    if is_zero (res) then f_map (pp, a, n, qq) *)
(*                    else #Cons (#crp (res, dp), f_map (pp, a, n, qq)) *)
(*            end *)
(*        end *)
(*      in  *)
(*      fun p -> fun a -> fun n -> fun q -> f_map (p, a, n, q); *)

(*      proof of fmecg_combines = assumed; *)

(*      let mult_naive (p, q) = *)
(*         if d!lt (!degree (p), !degree (q))  *)
(*           (\*#int_lt (#length (q), #length (p))*\) *)
(*         then self!map_times (p, q) *)
(*         else self!map_times (q, p); *)

(*      let mult (p, q) = !mult_naive (p, q); *)
(*      proof of one_is_left_neutral = assumed; *)
(*      proof of mult_assoc = assumed ; *)
(*      proof of mult_commutes = assumed ; *)
(*      proof of mult_left_distributes_on_plus = assumed ; *)
(*      proof of mult_left_substitution_rule = assumed; *)
(*      proof of mult_right_substitution_rule = assumed; *)

(*      let spol (p, q) =  *)
(*        let degree (p) = self!degree (p) in *)
(*        let sup (a, b) = d!sup (a, b) in *)
(*        let mm (a, p) = self!module_mult (a, p) in *)
(*        let dmin (a, b) = d!minus (a, b) in *)
(*        let dpl (a, b) = d!plus (a, b) in *)
(*        let opposite (a) = r!opposite (a) in *)
(*        let lc (q) = self!leading_coefficient (q) in *)
(*        let red (q) = self!reductum (q) in *)
(*        let fmecg = self!fmecg in         *)
(*        let dp = degree (p) in *)
(*        let dq = degree (q) in *)
(*        let m = sup (dp, dq) in *)
(*        let ddp = dmin (m, dp) in *)
(*        let ddq = dmin (m, dq) in *)
(*        let foo (x) =  *)
(*           let c = #first (x) in  *)
(*           let d = #scnd (x) in  *)
(*           #crp (c, dpl (d, ddp))  *)
(*        in *)
(*          fmecg (#map (foo, mm (lc (q), red (p))), opposite (lc (p)), ddq, red (q)); *)

(* to be finished *)

end;;

(**
  Distributed polynomials over an integral domain
*)
species Distributed_polynomials_integral_domain
  (R is Integral_domain, D is Monomial_ordering) =
  inherit Formal_polynomials_integral_domain (R, D),
          Distributed_polynomials_commutative_ring (R, D);
(*     local let rec add_shift (pp, a, n, qq) =  *)
(*       let rm (x, y) = rng!mult (x, y) in *)
(*       let rp (x, y) = rng!plus (x, y) in *)
(*       let dpl (x, y) = deg!plus (x, y) in *)
(*       let dlt (x, y) = deg!lt (x, y) in *)
(*       let deq (x, y) = deg!equal (x, y) in *)
(*       let is_zero (x) = rng!is_zero (x) in *)
(*       match pp with *)
(*       | #Nil ->  *)
(*                 let foo (x) = let v = #first (x) in let d = #scnd (x) in *)
(*           #crp (rm (a, v), dpl (d, n))  in #map (foo, qq) *)
(*       | #Cons (x, p) -> *)
(*           match qq with  *)
(*           | #Nil -> pp *)
(*           | #Cons (y, q) -> *)
(*               let vp = #first (x) in let dp = #scnd (x) in *)
(*               let vq = #first (y) in let dq = #scnd (y) in *)
(*               let dd = dpl (n, dq) in *)
(*               if deq (dd, dp)  *)
(*               then *)
(*                 let vv = rp (vp, rm (a, vq)) in *)
(*           if is_zero (vv)  *)
(*           then self!add_shift (p, a, n, q)  *)
(*           else #Cons (#crp(vv, dd), self!add_shift (p, a, n, q)) *)
(*               else *)
(*                 if dlt (dp, dd) *)
(*         then #Cons (#crp (rm (a, vq), dd), self!add_shift (pp, a, n, q)) *)
(*         else #Cons (x, self!add_shift (p, a, n, qq)) *)
(*           end *)
(*       end; *)
(*    local let rec map_quo (pp in self , r, res in self) = *)
(*      let rd (a, b) = rng!exquo (a, b) in *)
(*      match pp with *)
(*        #Nil -> #Unfailed (#rev (res)) *)
(*      | #Cons (x, p) -> *)
(*          let v = #first (x) in let d = #scnd (x) in *)
(*          match rd (v, r) with *)
(*          | #Failed -> #Failed *)
(*          | #Unfailed (nv) -> self!map_quo (p, r, #Cons (#crp (nv, d), res)) *)
(*          end *)
(*      end; *)
(*    let module_mult (r, p) = *)
(*      let is_zero (r) = rng!is_zero (r) in *)
(*      let rm (a, b) = rng!mult (a, b) in *)
(*      if is_zero (r)  *)
(*      then #Nil  *)
(*      else let foo (x) = let c = #first (x) in let d = #scnd (x) in  *)
(*                        #crp (rm (r, c), d) *)
(*           in #map (foo, p); *)

(*    (\** assumes c <> 0*\) *)
(*    let rec monomial_multiply (c : R, d : D, p : Self) : Self = match p with *)
(*      | Null -> Null *)
(*      | NonNull (cp, dp, pp) -> *)
(*          NonNull (R!mult (c, cp), D!plus (d, dp), monomial_multiply (c, d, pp)); *)

(*    let module_exquo (p, r) =  *)
(*      if rng!is_zero (r) then #Failed else self!map_quo (p, r, #Nil); *)

   proof of lift_is_injective = assumed ;
(*    proof of module_exquo_divides = assumed ; *)
   proof of mult_is_integral = assumed ;
   proof of module_mult_is_integral = assumed ;

   let module_exquo =
     let ( /_r ) (c_1, c_2) = R!exquo(c_1, c_2) in
     let ( +_p ) (p_1, p_2) = plus(p_1, p_2) in
     let rec m_equo(p, c, res) = match p with
       | Null -> Unfailed(res)
       | NonNull(cp, dp, rp) ->
           let r = cp /_r c in
           if is_failed(r) then Failed
           else m_equo(rp, c, res +_p monomial(non_failed(r), dp))
     termination proof = structural p
     in
     function p -> function c -> m_equo(p, c, zero);

   proof of module_exquo_divides = assumed;

   let exquo =
     let ( <_d )(d_1, d_2) = D!lt(d_1, d_2) in
     let ( -_d )(d_1, d_2) = D!minus(d_1, d_2) in
     let ( /_r )(r_1, r_2) = R!exquo(r_1, r_2) in
     (*[rr]: exact quotient of p by cqX^dq+rq with |rq| < dq *)
     let rec my_equo(p, cq, dq, rq) =
       match p with
       | Null -> Unfailed (Null)
       | NonNull (cp, dp, rp) ->
           let s = D!sup (dp, dq) in
           if ( dp <_d s) then Failed
           else (* dp = s *)
             if ( s <_d dp ) then focalize_error("exquo: bad ordering")
             else
               let delta = dp -_d dq in
               if ( delta <_d D!zero)
               then focalize_error("exquo: negative difference")
               else
                 let coeff = cp /_r cq in
                 if is_failed(coeff) then
                   Failed
                 else
                   let first_mon = monomial(non_failed(coeff), delta) in
                   let res = my_equo(rp, cq, dq, rq) in
                   if is_failed(res) then Failed
                   else Unfailed(plus(first_mon,
                                      non_failed(res)))
     termination proof = structural p
     in
     function p -> function q ->
       match q with
       | Null -> Failed
       | NonNull(cq, dq, rq) ->
           let res = my_equo(p, cq, dq, rq) in
           if is_failed(res) then Failed
           else
             let rres = non_failed(res) in
             if ~~ (!equal(p, !mult(rres, q)))
             then focalize_error("division check")
             else res ;

   proof of exquo_divides = assumed;

(*    let exquo = *)
(*      let degree (p) = self!degree (p) in *)
(*      let lc (p) = self!leading_coefficient (p) in *)
(*      let rdiv (a, b) = rng!exquo (a, b) in *)
(*      let is_zero (x) = rng!is_zero (x) in *)
(*      let opp (p) = rng!opposite (p) in *)
(*      (\* let int_minus (x, y) = non_failed (int_coll.minus (x, y)) in *\) *)
(*      let rec e_quo (p : self, cq, dq, q : self , res : self) : partiel (self) = *)
(*        let dp = degree (p) in *)
(*        let cp = lc (p) in *)
(*        if is_zero (cp) then *)
(*          #Unfailed (#rev (res))  *)
(*        else *)
(*          if deg!lt (dp, dq) then #Failed *)
(*          else *)
(*            let delta = deg!minus (dp, dq) in *)
(*              let co = rdiv (cp, cq) in *)
(*              if #is_failed (co) then #Failed *)
(*              else  *)
(*                let cco = #non_failed (co) in *)
(*                let r = self!fmecg (self!reductum (p), opp (cco), delta, q) in *)
(*                e_quo (r, cq, dq, q, #Cons (#crp (cco, delta), res)) in *)
(*      fun p -> fun q  -> *)
(*        match q with *)
(*         | #Nil -> #Failed *)
(*         | #Cons (m, q) ->  *)
(*           let cq = #first (m) in let dq = #scnd (m) in e_quo (p, cq, dq, q, #Nil) *)
(*        end ; *)
(*    proof of exquo_divides = assumed; *)
end;;

species Distributed_polynomials_Domain
      (R is Integral_domain, D is Monomial_ordering) =
  inherit Torsion_free_algebra (R),
          Integral_domain,
          Distributed_polynomials_commutative_ring (R, D);

end;;
