(***********************************************************************)
(*                                                                     *)
(*                        FoCaLize compiler                            *)
(*                                                                     *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                                                                     *)
(*                               LIP6  -  INRIA Rocquencourt           *)
(*                                                                     *)
(*  Copyright 2007 LIP6 and INRIA                                      *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: access_control.fcl,v 1.17 2009-06-26 22:59:57 weis Exp $ *)

(**
   @title Implementation of access control models
   @author Florent Anseaume, Jean Baron, Philippe Berthelin, Florian Brecht,
   @author Lionel Habib, Melanie Jacquel, Andrea-Diane Kadja,
   @author Charles Morisset, Francois Pessaux, Diane Pipon
 *)

open "basics";;
open "sets_orders";;
open "ensembles_finis";;

(** Framework *)

(** Set_of is a stub species inheriting Ensembles_finis *)
species Set_of (A is Setoid) =

  inherit Ensembles_finis (A);

  (** for_all(E, P) is true iff for any x in E, P(x) is true *)
  signature for_all : Self -> (A -> bool) -> bool;

  (**
     If two sets set1 and set2 are equal and if x belongs to set1
     then x belongs to set2
   *)
  property equal_prop :
    all set1 set2 : Self, all x : A,
      equal (set1, set2) ->
        est_element (x, set1) ->
          est_element (x, set2);

  (** If x1 belongs to the singleton {x2} then x1 = x2 *)
  property singleton_prop :
    all x1 x2 : A,
      est_element (x1, singleton (x2)) ->
        A!equal (x1, x2);

end;;

(** The security parameter of an access control policy *)
species Rho =

 inherit Setoid;

end;;

(** The species representing the subjects of an access control policy *)
species Subjects =

  inherit Setoid;

end;;

(** The species representing the objects of an access control policy *)
species Objects =

  inherit Setoid;

end;;

(** The usually considered access modes *)
species Access_mode =

  inherit Setoid;

  (** The read access mode *)
  signature read : Self;

  (** The write access mode *)
  signature write : Self;

end;;

(** An access is a triple Subject x Object x Access mode *)
species Access (S is Subjects, O is Objects, M is Access_mode) =

  inherit Setoid;

  (** Allows to create an access *)
  signature create : S -> O -> M -> Self;

  (** Returns the subject involved in the given access *)
  signature get_s : Self -> S;

  (** Returns the object involved in the given access *)
  signature get_o : Self -> O;

  (** Returns the access mode involved in the given access *)
  signature get_m : Self -> M;

  (**
     If two accesses (s1,o1,m1) and (s2,o2,m2) are equal
     then s1 = s2 and o1 = o2 and m1 = m2
   *)
  property access_equal :
    all s1 s2 : S, all o1 o2 : O, all m1 m2 : M,
      equal (create (s1, o1, m1), create (s2, o2, m2)) ->
        (S!equal (s1, s2) /\ O!equal (o1, o2) /\ M!equal (m1, m2));

end;;

(** A state contains at least the set of current accesses *)
species States (Rh is Rho, S is Subjects, O is Objects, M is Access_mode,
                A is Access (S, O, M), S_a is Set_of (A)) =

  inherit Setoid;

  (** Returns the set of current accesses *)
  signature lambda : Self -> S_a;

  (** Add an access to the set of current accesses of the given state *)
  signature add : Self -> A -> Self;

  (** Delete an access from the set of current accesses of the given state *)
  signature del : Self -> A -> Self;

  (**
     If two states are equal then they have the same set of current accesses
   *)
  property lambda_prop :
    all st1 st2 : Self,
      equal (st1, st2) ->
        S_a!equal (lambda (st1), lambda (st2));

  property add_prop :
    all st1 st2 : Self, all s1 : S, all o1 : O, all m1 : M,
      equal (add (st1, A!create (s1, o1, m1)), st2) ->
        S_a!equal (lambda (st2),
                   S_a!union (lambda (st1),
                              S_a!singleton (A!create (s1, o1, m1))));

  (**
     &Lambda;(st1) &cup; {(s1,o1,m1)} = &Lambda;(st2) &rarr;
     (s1,o1,m1) &isin; &Lambda;(st2)
   *)
  property add_mem :
    all st1 st2 : Self, all s1 : S, all o1 : O, all m1 : M,
      equal (add (st1, A!create (s1, o1, m1)), st2) ->
        S_a!est_element (A!create (s1, o1, m1), lambda (st2));

  (** a1 &isin; &Lambda;(st1) \ {(s1,o1,m1)} &rarr; a1 &isin; &Lambda;(st1) *)
  property del_prop :
    all st1 : Self, all a1 : A, all s1 : S, all o1 : O, all m1 : M,
      S_a!est_element (a1, lambda (del (st1, A!create (s1, o1, m1)))) ->
        S_a!est_element (a1, lambda (st1));

  (**
     &Lambda;(st1) \ {(s1,o1,m1)} = &Lambda;(st2) &rarr;
     {(s1,o1,m1)} &notin; &Lambda;(st2)
   *)
  property del_mem :
    all st1 st2 : Self, all s1 : S, all o1 : O, all m1 : M,
      equal(del (st1, A!create (s1, o1, m1)), st2) ->
        ~ S_a!est_element (A!create (s1, o1, m1), lambda (st2));

end;;

(** An access control policy defines a security predicate *)
species Policy (Rh is Rho, S is Subjects, O is Objects, M is Access_mode,
                A is Access (S, O, M), S_a is Set_of (A)) =

  inherit States (Rh, S, O, M, A, S_a);

  (** Security predicate of an access control policy *)
  signature omega : Self -> prop;

  (**
     If two states st1 and st2 are equal and if st1 satisfies the security
     predicate then st2 satisfies the security predicate
   *)
  property secure_state :
    all st1 st2 : Self,
      equal (st1, st2) ->
        omega (st1) ->
          omega (st2);

end;;

(** The species representing the requests of an access control policy *)
species Requests =

  inherit Setoid;

end;;

(** The decisions that can be answered by a reference monitor *)
species Decisions =

  inherit Setoid;

  (** The decision yes *)
  signature yes : Self;

  (** The decision no *)
  signature no : Self;

  (** A decision is either yes or no *)
  property yes_is_not_no :
    all x : Self,
      ~ (equal (x, yes) /\ equal(x, no));

end;;

(**
   The species representing the semantics of requests of an access control
   model
 *)
species Semantics_requests (Rh is Rho,
                            S is Subjects, O is Objects, M is Access_mode,
                            A is Access (S, O, M), S_a is Set_of (A),
                            R is Requests) =

  inherit States (Rh, S, O, M, A, S_a);

  (** The predicate defining the semantics of requests *)
  signature sem_req : R -> Self -> prop;

end;;

(**
   An access control model regroups the concepts present in an access
   control policy (the security predicate) and in the semantics of requests
 *)
species Models (Rh is Rho, S is Subjects, O is Objects, M is Access_mode,
                A is Access (S, O, M), S_a is Set_of (A),
                R is Requests,
                D is Decisions) =

  inherit
    Policy (Rh, S, O, M, A, S_a),
    Semantics_requests(Rh, S, O, M, A, S_a, R);

  (** (d1,st1) = (d2,st2) &rarr; d1 = d2 *)
  property left_substitution :
    all d1 d2 : D, all st1 st2 : Self,
    (d1, st1) = (d2, st2) ->
      D!equal (d1, d2);

  (** (d1,st1) = (d2,st2) &rarr; st1 = st2 *)
  property right_substitution :
    all d1 d2 : D, all st1 st2 : Self,
    (d1, st1) = (d2, st2) ->
      equal (st1, st2);

end;;

(**
   The usually considered requests :
   - &lang; +,s,o,m &rang; : the subject s asks to get an access over the
     object o according to the access mode m
   - &lang; -,s,o,m &rang; : the subject s asks to release an access over the
     object o according to the access mode m
 *)
species Requests_gal(S is Subjects, O is Objects, M is Access_mode) =

  inherit Requests;

  (** Returns the subject involved in the given request *)
  signature get_s : Self -> S;

  (** Returns the object involved in the given request *)
  signature get_o : Self -> O;

  (** Returns the access mode involved in the given request *)
  signature get_m : Self -> M;

  (**
     Returns true if the given request is a "get an access" request,
     false otherwise
   *)
  signature is_get : Self -> bool;

  (**
     Returns true if the given request is a "release an access" request,
     false otherwise
   *)
  signature is_rel : Self -> bool;

  (**
     A request is either a "get an access" or a "release an access" request
   *)
  property get_or_rel :
    all x : Self,
      is_get (x) \/ is_rel (x);

  property get_is_not_rel :
    all x : Self,
      ~ (is_get (x) /\ is_rel (x));

end;;

(** Semantics of requests &lang; +,s,o,m &rang; and &lang; -,s,o,m &rang; *)
species Semantics_requests_gal(Rh is Rho,
                               S is Subjects, O is Objects, M is Access_mode,
                               A is Access (S, O, M), S_a is Set_of (A),
                               R is Requests_gal (S, O, M)) =

  inherit Semantics_requests (Rh, S, O, M, A, S_a, R);

  (** Semantics of request &lang; +,s,o,m &rang; *)
  logical let sem_req_get (r1, st1) =
    R!is_get (r1) ->
      S_a!est_element (A!create (R!get_s(r1), R!get_o(r1), R!get_m(r1)),
                       lambda (st1));

  (** Semantics of request &lang; -,s,o,m &rang; *)
  logical let sem_req_rel (r1, st1) =
     R!is_rel (r1) ->
       ~ S_a!est_element (A!create (R!get_s(r1), R!get_o(r1), R!get_m(r1)),
                          lambda (st1));

  (** Semantics of both requests *)
  logical let sem_req (r1, st1) =
     sem_req_get (r1, st1) /\ sem_req_rel (r1, st1);

end;;

(** Bell & LaPadula (BLP) *)

(** The security parameter of the BLP model is a lattice *)
species Rho_blp =

  inherit Rho, Lattice;

end;;

(**
   A BLP state contains security information given by two functions f_s and f_o
 *)
species States_blp (Rh is Rho_blp,
                    S is Subjects, O is Objects, M is Access_mode,
                    A is Access (S, O, M), S_a is Set_of (A)) =

  inherit States (Rh, S, O, M, A, S_a);

  (** Returns the level of security of the given subject *)
  signature f_s : Self -> S -> Rh;

  (** Returns the level of security of the given object *)
  signature f_o : Self -> O -> Rh;

end;;

(** Definition of the BLP security predicate *)
species Policy_blp (Rh is Rho_blp,
                    S is Subjects, O is Objects, M is Access_mode,
                    A is Access (S, O, M), S_a is Set_of (A)) =

  inherit
    States_blp (Rh, S, O, M, A, S_a),
    Policy (Rh, S, O, M, A, S_a);

  (** (s,o,read) &isin; &Lambda;(st) &rarr; f_o(o) &le; f_s(s) *)
  logical let mac (st : Self) =
     all a1 : A,
       S_a!est_element (a1, lambda (st)) ->
         M!equal (A!get_m (a1), M!read) ->
           Rh!order_inf (f_o (st, A!get_o (a1)),
                         f_s (st, A!get_s (a1)));

  (**
     (s,o1,read) &isin; &Lambda;(st) &and;
     (s,o2,write) &isin; &Lambda;(st) &rarr;
     f_o(o1) &le; f_o(o2)
   *)
  logical let mac_star (st : Self) =
     all a1 a2 : A,
       S_a!est_element (a1, lambda (st)) ->
         S_a!est_element (a2, lambda (st)) ->
           M!equal (A!get_m (a1), M!read) ->
             M!equal (A!get_m (a2), M!write) ->
               S!equal (A!get_s (a1), A!get_s (a2)) ->
                 Rh!order_inf (f_o (st, A!get_o (a1)),
                               f_o (st, A!get_o (a2)));
  (**
     The BLP security predicate is the conjunction of the properties
     mac and mac_star
   *)
  logical let omega (st : Self) =
     mac (st) /\ mac_star (st);

end;;

(** Definition of the BLP transition function (reference monitor) *)
species Models_blp (Rh is Rho_blp,
                    S is Subjects, O is Objects, M is Access_mode,
                    A is Access (S, O, M), S_a is Set_of (A),
                    R is Requests_gal (S, O, M),
                    D is Decisions) =

  inherit
    Policy_blp (Rh, S, O, M, A, S_a),
    Semantics_requests_gal (Rh, S, O, M, A, S_a, R),
    Models (Rh, S, O, M, A, S_a, R, D);

  (** BLP transition function *)
  let tau_blp (r1 : R, st1 : Self) =
     let s1 = R!get_s (r1) in
     let o1 = R!get_o (r1) in
     if R!is_get (r1) then
       if M!equal (M!read, R!get_m (r1)) then (* R = <+,s,o,read> *)
         if Rh!order_inf (f_o (st1, o1), f_s (st1, s1)) then
           if S_a!for_all (lambda (st1),
                          function a1 ->
                            let o2 = A!get_o (a1) in
                            M!different (M!write, A!get_m (a1)) ||
                            O!equal (o1, o2) ||
                            Rh!order_inf (f_o (st1, o1), f_o (st1, o2)))
           then (D!yes, add (st1, A!create (s1, o1, M!read)))
           else (D!no, st1) (* s is writing in a non higher object *)
         else (D!no, st1) (* s has a lower level of security than o *)
       else
         if M!equal (M!write, R!get_m (r1)) then  (* R = <+,s,o,write> *)
           if S_a!for_all (lambda (st1),
                          function a1 ->
                            let o2 = A!get_o (a1) in
                            M!different (M!read, A!get_m (a1)) ||
                            O!equal (o1, o2) ||
                            Rh!order_inf (f_o (st1, o2), f_o (st1, o1)))
           then (D!yes, add (st1, A!create (s1, o1, M!write)))
           else (D!no, st1) (* s is reading in a non lower object *)
         else (D!no, st1) (* R = <+,s,o,???> *)
     else (* R = <-,s,o,x> *)
          (D!yes, del (st1, A!create (s1, o1, R!get_m (r1))));

end;;

(** Role-Based Access Control (RBAC) *)

(** The species representing the users of the RBAC model *)
species Users =

  inherit Setoid;

end;;

(** The roles of an RBAC model are partially ordered *)
species Roles =

  inherit Partial_order;

end;;

(** The security parameter of the RBAC model is composed of users and roles *)
species Rho_rbac (U is Users, Ro is Roles) =

  inherit Rho;

end;;

(**
   An RBAC state contains security information given by :
   - A function user : Subjects &rarr; Users
   - A relation UA &sube; &weierp;(Users x Roles)
   - A relation PA &sube; &weierp;((Objects x Access_mode) x Roles)
   - A function roles : Subjects &rarr; &weierp;(Roles)
 *)
species States_rbac (U is Users, Ro is Roles, Rh is Rho_rbac (U, Ro),
                     S is Subjects, O is Objects, M is Access_mode,
                     A is Access (S, O, M), S_a is Set_of (A)) =

  inherit States (Rh, S, O, M, A, S_a);

  (** Returns the user associated with the given subject *)
  signature user : Self -> S -> U;

  (**
     Returns true if the given user and role belong to the relation UA,
     false otherwise
   *)
  signature ua : Self -> U -> Ro -> bool;

  (**
     Returns true if the given object, access mode and role belong to the
     relation PA, false otherwise
   *)
  signature pa : Self -> O -> M -> Ro -> bool;

  (**
     Returns true if the given role belongs to the given subject's active
     roles (function roles), false otherwise
   *)
  signature roles_s : Self -> S -> Ro -> bool;

  (**
     Returns true if a role satisfying two predicates is found,
     false otherwise
   *)
  signature exists_role : Self -> (Ro -> bool) -> (Ro -> bool) -> bool;

  signature exists_role_ua : Self -> (Ro -> bool) -> (Ro -> bool) -> bool;

  (**
     Add a relation between the given user and the given role to the
     given state's UA relation
   *)
  signature add_ua : Self -> U -> Ro -> Self;

  (**
     Remove a relation between the given user and the given role from the
     given state's UA relation
   *)
  signature rm_ua : Self -> U -> Ro -> Self;

  (**
     Add a relation between the given object, the given access mode and
     the given role to the given state's PA relation
   *)
  signature add_pa : Self -> O -> M -> Ro -> Self;

  (**
     Remove a relation between the given object, the given access mode and
     the given role from the given state's PA relation
   *)
  signature rm_pa : Self -> O -> M -> Ro -> Self;

  (**
     If the only difference between two states is their current accesses
     then they have the same relation UA
   *)
  property add_access_ua :
    all st1 st2 : Self, all s1 s2 : S, all o1 : O, all m1 : M,
      all ro1 : Ro,
        equal (st2, add (st1, A!create (s1, o1, m1))) ->
          ua (st1, user (st1, s2), ro1) ->
            ua (st2, user (st2, s2), ro1);

  property del_access_ua :
    all st1 st2 : Self, all s1 s2 : S, all o1 : O, all m1 : M,
      all ro1 : Ro,
        equal (st2, del (st1, A!create (s1, o1, m1))) ->
          ua (st1, user (st1, s2), ro1) ->
            ua (st2, user (st2, s2), ro1);

  (**
     If the only difference between two states is their current accesses
     then they have the same relation PA
   *)
  property add_access_pa :
    all st1 st2 : Self, all s1 : S, all o1 o2 : O, all m1 m2 : M,
      all ro1 : Ro,
        equal (st2, add (st1, A!create (s1, o1, m1))) ->
          pa (st1, o2, m2, ro1) ->
            pa (st2, o2, m2, ro1);

  property del_access_pa :
    all st1 st2 : Self, all s1 : S, all o1 o2 : O, all m1 m2 : M,
      all ro1 : Ro,
        equal (st2, del (st1, A!create (s1, o1, m1))) ->
          pa (st1, o2, m2, ro1) ->
            pa (st2, o2, m2, ro1);

  (**
     If the only difference between two states is their current accesses
     then they have the "same" function roles
   *)
  property add_access_roles_s_1 :
    all st1 st2 : Self, all s1 s2 : S, all o1 : O, all m1 : M,
      all ro1 : Ro,
        equal (st2, add (st1, A!create (s1, o1, m1))) ->
          roles_s (st1, s2, ro1) ->
            roles_s (st2, s2, ro1);

  property add_access_roles_s_2 :
    all st1 st2 : Self, all s1 s2 : S, all o1 : O, all m1 : M,
      all ro1 : Ro,
        equal (st2, add (st1, A!create (s1, o1, m1))) ->
          roles_s (st2, s2, ro1) ->
            roles_s (st1, s2, ro1);

  property del_access_roles_s_1 :
    all st1 st2 : Self, all s1 s2 : S, all o1 : O, all m1 : M,
      all ro1 : Ro,
        equal (st2, del (st1, A!create (s1, o1, m1))) ->
          roles_s (st1, s2, ro1) ->
            roles_s (st2, s2, ro1);

  property del_access_roles_s_2 :
    all st1 st2 : Self, all s1 s2 : S, all o1 : O, all m1 : M,
      all ro1 : Ro,
        equal (st2, del (st1, A!create (s1, o1, m1))) ->
          roles_s (st2, s2, ro1) ->
            roles_s (st1, s2, ro1);

  (**
     If the only difference between two states is their relation UA
     then they have the same current accesses
   *)
  property add_ua_access :
    all st1 st2 : Self, all u1 : U, all ro1 : Ro,
      equal (st2, add_ua (st1, u1, ro1)) ->
        S_a!equal (lambda (st1), lambda (st2));

  property rm_ua_access :
    all st1 st2 : Self, all u1 : U, all ro1 : Ro,
      equal (st2, rm_ua (st1, u1, ro1)) ->
        S_a!equal (lambda(st1), lambda (st2));

  (**
     If the only difference between two states is their relation PA
     then they have the same current accesses
   *)
  property add_pa_access :
    all st1 st2 : Self, all o1 : O, all m1 : M, all ro1 : Ro,
      equal (st2, add_pa (st1, o1, m1, ro1)) ->
        S_a!equal (lambda (st1), lambda (st2));

  property rm_pa_access :
    all st1 st2 : Self, all o1 : O, all m1 : M, all ro1 : Ro,
      equal (st2, rm_pa (st1, o1, m1, ro1)) ->
        S_a!equal (lambda (st1), lambda (st2));

  (**
     If state st2's relation UA is equal to state st1's relation UA
     plus a pair (u1,ro1) (UA_st2 = UA_st1 &cup; {(u1,ro1)}) then,
     If a pair belongs to state st1's relation UA then it belongs to
     state st2's relation UA
   *)
  property add_ua_ua :
    all st1 st2 : Self, all s1 : S, all u1 : U, all ro1 ro2 : Ro,
      equal (st2, add_ua (st1, u1, ro1)) ->
        ua (st1, user (st1, s1), ro2) ->
          ua (st2, user (st2, s1), ro2);

  (**
     If state st2's relation UA is equal to state st1's relation UA
     minus a pair (u1,ro1) (UA_st2 = UA_st1 \ {(u1,ro1)}) then,
     If a pair belongs to state st2's relation UA then it belongs to
     state st1's relation UA
   *)
  property rm_ua_ua :
    all st1 st2 : Self, all s1 : S, all u1 : U, all ro1 ro2 : Ro,
      equal (st2, rm_ua (st1, u1, ro1)) ->
        ua (st2, user (st2, s1), ro2) ->
          ua (st1, user (st1, s1), ro2);
  (**
     If the only difference between two states is their relation UA
     then they have the same relation PA
   *)
  property add_ua_pa :
    all st1 st2 : Self, all o1 : O, all m1 : M, all u1 : U,
      all ro1 ro2 : Ro,
        equal (st2, add_ua (st1, u1, ro1)) ->
          pa (st1, o1, m1, ro2) ->
            pa (st2, o1, m1, ro2);

  property rm_ua_pa :
    all st1 st2 : Self, all o1 : O, all m1 : M, all u1 : U,
      all ro1 ro2 : Ro,
        equal (st2, rm_ua (st1, u1, ro1)) ->
          pa (st1, o1, m1, ro2) ->
            pa (st2, o1, m1, ro2);

  (**
     If the only difference between two states is their relation UA
     then they have the "same" function roles
   *)
  property add_ua_roles_s_1 :
    all st1 st2 : Self, all s1 : S, all u1 : U, all ro1 ro2 : Ro,
      equal (st2, add_ua (st1, u1, ro1)) ->
        roles_s (st1, s1, ro2) ->
          roles_s (st2, s1, ro2);

  property add_ua_roles_s_2 :
    all st1 st2 : Self, all s1 : S, all u1 : U, all ro1 ro2 : Ro,
      equal (st2, add_ua (st1, u1, ro1)) ->
        roles_s (st2, s1, ro2) ->
          roles_s (st1, s1, ro2);

  property rm_ua_roles_s_1 :
    all st1 st2 : Self, all s1 : S, all u1 : U, all ro1 ro2 : Ro,
      equal (st2, rm_ua (st1, u1, ro1)) ->
        roles_s (st1, s1, ro2) ->
          roles_s (st2, s1, ro2);

  property rm_ua_roles_s_2 :
    all st1 st2 : Self, all s1 : S, all u1 : U, all ro1 ro2 : Ro,
      equal (st2, rm_ua (st1, u1, ro1)) ->
        roles_s (st2, s1, ro2) ->
          roles_s (st1, s1, ro2);

  (**
     If the only difference between two states is their relation PA
     then they have the same relation UA
   *)
  property add_pa_ua :
    all st1 st2 : Self, all s1 : S, all o1 : O, all m1 : M,
      all ro1 ro2 : Ro,
        equal (st2, add_pa (st1, o1, m1, ro1)) ->
          ua (st1, user (st1, s1), ro2) ->
            ua (st2, user (st2, s1), ro2);

  property rm_pa_ua :
    all st1 st2 : Self, all s1 : S, all o1 : O, all m1 : M,
      all ro1 ro2 : Ro,
        equal (st2, rm_pa (st1, o1, m1, ro1)) ->
          ua (st1, user (st1, s1), ro2) ->
            ua (st2, user (st2, s1), ro2);

  (**
     If state st2's relation PA is equal to state st1's relation PA
     plus a pair ((o1,m1),ro1) (PA_st2 = PA_st1 &cup; {((o1,m1),ro1)}) then,
     If a pair belongs to state st1's relation PA then it belongs to
     state st2's relation PA
   *)
  property add_pa_pa :
    all st1 st2 : Self, all o1 o2 : O, all m1 m2 : M, all ro1 ro2 : Ro,
      equal (st2, add_pa (st1, o1, m1, ro1)) ->
        pa (st1, o2, m2, ro2) ->
          pa (st2, o2, m2, ro2);

  (**
     If state st2's relation PA is equal to state st1's relation PA
     minus a pair ((o1,m1),ro1) (PA_st2 = PA_st1 \ {((o1,m1),ro1)}) then,
     If a pair belongs to state st2's relation PA then it belongs to
     state st1's relation PA
   *)
  property rm_pa_pa :
    all st1 st2 : Self, all o1 o2 : O, all m1 m2 : M, all ro1 ro2 : Ro,
      equal (st2, rm_pa (st1, o1, m1, ro1)) ->
        pa (st2, o2, m2, ro2) ->
          pa (st1, o2, m2, ro2);

  (**
     If the only difference between two states is their relation PA
     then they have the "same" function roles
   *)
  property add_pa_roles_s_1 :
    all st1 st2 : Self, all s1 : S, all o1 : O, all m1 : M,
      all ro1 ro2 : Ro,
        equal (st2, add_pa (st1, o1, m1, ro1)) ->
          roles_s (st1, s1, ro2) ->
            roles_s (st2, s1, ro2);

  property add_pa_roles_s_2 :
    all st1 st2 : Self, all s1 : S, all o1 : O, all m1 : M,
      all ro1 ro2 : Ro,
        equal (st2, add_pa (st1, o1, m1, ro1)) ->
          roles_s (st2, s1, ro2) ->
            roles_s (st1, s1, ro2);

  property rm_pa_roles_s_1 :
    all st1 st2 : Self, all s1 : S, all o1 : O, all m1 : M,
      all ro1 ro2 : Ro,
        equal (st2, rm_pa (st1, o1, m1, ro1)) ->
          roles_s (st1, s1, ro2) ->
            roles_s (st2, s1, ro2);

  property rm_pa_roles_s_2 :
    all st1 st2 : Self, all s1 : S, all o1 : O, all m1 : M,
      all ro1 ro2 : Ro,
        equal (st2, rm_pa (st1, o1, m1, ro1)) ->
          roles_s (st2, s1, ro2) ->
            roles_s (st1, s1, ro2);

end;;

(** Definition of the RBAC security predicate *)
species Policy_rbac (U is Users, Ro is Roles, Rh is Rho_rbac (U, Ro),
                     S is Subjects, O is Objects, M is Access_mode,
                     A is Access (S, O, M), S_a is Set_of (A)) =

  inherit
    States_rbac (U, Ro, Rh, S, O, M, A, S_a),
    Policy (Rh, S, O, M, A, S_a);

  (** The set of authorized roles for a given subject  *)
  logical let er (st : Self, sp : S, r1 : Ro) =
     ex r2 : Ro,
       Ro!leq (r1, r2) /\ ua (st, user (st, sp), r2);

  (** The set of authorized permissions for a given subject  *)
  logical let ep (st : Self, sp : S, op : O, mo : M) =
     ex r1 r2 : Ro,
       roles_s (st, sp, r1) /\ Ro!leq (r2, r1) /\ pa (st, op, mo, r2);

  (**
     If a role r has been activated by a subject sp
     then r belongs to sp's authorized roles
   *)
  logical let roles_er (st : Self) =
     all sp : S, all r : Ro,
       roles_s (st, sp, r) ->
         er (st, sp, r);
  (**
     If the access (sp,op,mo) belongs to the current accesses of state
     then the permission (op,mo) belongs to sp's authorized permissions
   *)
  logical let perm_ep (st : Self) =
     all sp : S, all op : O, all mo : M,
       S_a!est_element (A!create (sp, op, mo), lambda (st)) ->
         ep (st, sp, op, mo);

  (**
     The RBAC security predicate is the conjunction of the properties
     roles_er and perm_ep
   *)
  logical let omega (st : Self) =
     roles_er (st) /\ perm_ep (st);

  (**
     If s1 = s2, o1 = o2, m1 = m2 and if the permission (o1,m1) is authorized
     for s1 then the permission (o2,m2) is authorized for s2
   *)
  property ep_equal :
    all st : Self, all s1 s2 : S, all o1 o2 : O, all m1 m2 : M,
      S!equal (s1, s2) ->
        O!equal (o1, o2) ->
          M!equal (m1, m2) ->
            ep (st, s1, o1, m1) ->
              ep (st, s2, o2, m2);

  (** Specification of the function exists_role *)
  property exists_role_spec :
    all st : Self, all sp : S, all op : O, all mo : M,
      exists_role (st, roles_s (st, sp), pa (st, op, mo)) ->
        ex ro1 ro2 : Ro,
          roles_s (st, sp, ro1) /\
          Ro!equal (ro2, ro1) /\
          pa (st, op, mo, ro2);

  (** Specification of the function exists_role_ua *)
  property exists_role_ua_spec :
    all st : Self, all sp : S,
      exists_role_ua (st, roles_s (st, sp), ua (st, user (st, sp))) ->
        ex ro1 ro2 : Ro,
          roles_s (st, sp, ro1) /\
          Ro!equal (ro2, ro1) /\
          ua (st, user (st, sp), ro2);

  (** If the predicate exists_role is true then the property ep is satisfied *)
  theorem exists_role_ep :
    all st : Self, all sp : S, all op : O, all mo : M,
      exists_role (st, roles_s (st, sp), pa (st, op, mo)) ->
        ep (st, sp, op, mo)
    proof =
      by property Ro!leq_reflexive, exists_role_spec
         definition of ep;

(*   theorem exists_role_er :  *)
(*     all st : Self, all sp : S,  *)
(*       exists_role_ua (st, roles_s (st, sp), ua (st, user (st, sp))) ->  *)
(*      ex rop : Ro,  *)
(*        ua (st, user (st, sp), rop) ->  *)
(*          roles_s (st, sp, rop) ->  *)
(*            er (st, sp, rop) *)
(*     proof = *)
(*       by property Ro!leq_reflexive, exists_role_ua_spec  *)
(*          definition of er; *)

end;;

(**
   The administrative requests of the RBAC model :
   - &lang; +ua,s,u,r &rang; : the subject s asks to add to the relation UA
     a connection between the user u and the role r
   - &lang; -ua,s,u,r &rang; : the subject s asks to remove from the relation
     UA the connection between the user u and the role r
   - &lang; +pa,s,o,m,r &rang; : the subject s asks to add to the relation PA
     a connection between the permission (o,m) and the role r
   - &lang; -pa,s,o,m,r &rang; : the subject s asks to remove from the
     relation PA the connection between the permission (o,m) and the role r
 *)
species Requests_adm_rbac (S is Subjects, O is Objects, M is Access_mode,
                           U is Users, R is Roles) =

  inherit Requests;

  (** Returns the user involved in the given administrative request *)
  signature get_u : Self -> U;

  (** Returns the role involved in the given administrative request *)
  signature get_r : Self -> R;

  (**
     Returns true if the given administrative request is a "+ua" request,
     false otherwise
   *)
  signature is_add_ua : Self -> bool;

  (**
     Returns true if the given administrative request is a "-ua" request,
     false otherwise
   *)
  signature is_rm_ua : Self -> bool;

  (**
     Returns true if the given administrative request is a "+pa" request,
     false otherwise
   *)
  signature is_add_pa : Self -> bool;

  (**
     Returns true if the given administrative request is a "-pa" request,
     false otherwise
   *)
  signature is_rm_pa : Self -> bool;

  (**
     Properties stating that an administrative request is either a
     "+ua" or a "-ua" or a "+pa" or a "-pa" request
   *)
  property add_ua_then_not_rm_ua :
    all req : Self,
      is_rm_ua (req) ->
        ~ is_add_ua (req);

  property add_pa_then_not_ua :
    all req : Self,
      is_add_pa (req) ->
        ((~ is_add_ua (req)) /\ (~ is_rm_ua (req)));

  property rm_pa_then_not_add_pa_ua :
    all req : Self,
      is_rm_pa (req) ->
        ((~ is_add_pa (req)) /\ (~ is_add_ua (req)) /\ (~ is_rm_ua (req)));

end;;

(**
   The requests of the RBAC model are the general requests and
   the RBAC administrative requests
 *)
species Requests_rbac (S is Subjects, O is Objects, M is Access_mode,
                       U is Users, R is Roles) =

  inherit
    Requests_gal (S, O, M),
    Requests_adm_rbac (S, O, M, U, R);

end
;;

(** Definition of the RBAC transition function (reference monitor) *)
species Models_rbac (U is Users, Ro is Roles, Rh is Rho_rbac (U, Ro),
                     S is Subjects, O is Objects, M is Access_mode,
                     A is Access (S, O, M), S_a is Set_of (A),
                     Rr is Requests_rbac (S, O, M, U, Ro),
                     D is Decisions) =

  inherit
    Policy_rbac (U, Ro, Rh, S, O, M, A, S_a),
    Semantics_requests_gal (Rh, S, O, M, A, S_a, Rr),
    Models (Rh, S, O, M, A, S_a, Rr, D);

  (** RBAC transition function on accesses *)
  let tau_rbac_acc (r1 : Rr, st1 : Self) =
     let s1 = Rr!get_s (r1) in
     let o1 = Rr!get_o (r1) in
     let m1 = Rr!get_m (r1) in
     if Rr!is_get (r1) then
       (* if ep(st1, s1, o1, m1) then *)
       if exists_role (st1, roles_s (st1, s1), pa (st1, o1, m1))
       then (D!yes, add (st1, A!create (s1, o1, m1)))
       else (D!no, st1)
     else (D!yes, del (st1, A!create (s1, o1, m1)));

  let iter_ua (st1, u1, ro1, ap) =
     let sp = A!get_s (ap) in
     exists_role_ua (rm_ua (st1, u1, ro1),
                     roles_s (rm_ua (st1, u1, ro1), sp),
                     ua (rm_ua (st1, u1, ro1),
                         user (st1, sp)));

  let iter_pa (st1, o1, m1, ro1, ap) =
     let sp = A!get_s (ap) in
     let op = A!get_o (ap) in
     let mp = A!get_m (ap) in
     exists_role (rm_pa (st1, o1, m1, ro1),
                  roles_s (rm_pa (st1, o1, m1, ro1), sp),
                  pa (rm_pa (st1, o1, m1, ro1), op, mp));

  (** RBAC administrative transition function *)
  let tau_rbac_adm (r1 : Rr, st1 : Self) =
     if Rr!is_add_ua (r1) then
       let u1 = Rr!get_u (r1) in
       let ro1 = Rr!get_r (r1) in
          (D!yes, add_ua (st1, u1, ro1))
     else if Rr!is_rm_ua (r1) then
       let u1 = Rr!get_u (r1) in
       let ro1 = Rr!get_r (r1) in
       if S_a!for_all (lambda (st1), iter_ua (st1, u1, ro1))
       then (D!yes, rm_ua (st1, u1, ro1))
       else (D!no, st1)
     else if Rr!is_add_pa (r1) then
       let o1 = Rr!get_o (r1) in
       let m1 = Rr!get_m (r1) in
       let ro1 = Rr!get_r (r1) in
          (D!yes, add_pa (st1, o1, m1, ro1))
     else if Rr!is_rm_pa (r1) then
       let o1 = Rr!get_o (r1) in
       let m1 = Rr!get_m (r1) in
       let ro1 = Rr!get_r (r1) in
       if S_a!for_all (lambda (st1), iter_pa (st1, o1, m1, ro1))
       then (D!yes, rm_pa (st1, o1, m1, ro1))
       else (D!no, st1)
     else (D!no, st1);

  (** RBAC transition function *)
  let tau_rbac (r1 : Rr, st1 : Self) =
     if Rr!is_get (r1) || Rr!is_rel (r1)
     then tau_rbac_acc (r1, st1)
     else tau_rbac_adm (r1, st1);

  (** Problem ro1 ro2 *)
  property for_all_spec_ua_1 :
    all st1 st2 : Self, all u1 u2 : U, all ro1 ro2 : Ro,
      S_a!for_all (lambda (st1), iter_ua (st1, u1, ro1)) ->
        equal (st2, rm_ua (st1, u2, ro2)) ->
          S_a!for_all (lambda(st2), iter_ua (st2, u1, ro1));

  (** Problem ro1 ro2 *)
  property for_all_spec_ua_2 :
    all st1 : Self, all u1 u2 : U, all ro1 ro2 : Ro,
      S_a!for_all (lambda (st1), iter_ua (st1, u1, ro1)) ->
        ua (st1, u2, ro2);

  (** Specification of the function iter_pa *)
  property iter_pa_spec :
    all st1 : Self, all s1 : S, all o1 o2 : O, all m1 m2 : M,
      all ro1 : Ro,
        S_a!for_all (lambda (st1), iter_pa (st1, o1, m1, ro1)) ->
          S_a!est_element (A!create (s1, o2, m2), lambda (st1)) ->
            exists_role (rm_pa (st1, o1, m1, ro1),
                         roles_s (rm_pa (st1, o1, m1, ro1), s1),
                         pa (rm_pa (st1, o1, m1, ro1), o2, m2));

  (**
     If two states st1 and st2 are equal and if the predicate exists_role
     is true for st1 then it is also true for st2
   *)
  property equal_exists_role :
    all st1 st2 : Self, all s1 : S, all o1 : O, all m1 : M,
      equal (st1, st2) ->
        exists_role (st1, roles_s (st1, s1), pa (st1, o1, m1)) ->
          exists_role (st2, roles_s (st2, s1), pa (st2, o1, m1));

  theorem tau_rbac_acc_secure :
    all st1 st2 : Self, all r1 : Rr, all d1 : D,
      tau_rbac_acc (r1, st1) = (d1, st2) ->
        omega (st1) ->
          omega(st2)
    proof =
      <1>1 assume st1 st2 : Self, r1 : Rr, d1 : D,
           hypothesis H1: tau_rbac_acc (r1, st1) = (d1, st2),
                      H2: omega (st1),
           prove omega (st2)
        <2>2 hypothesis H3: Rr!is_get (r1),
             prove omega (st2)
          <3>1 hypothesis H7:
                 exists_role
                   (st1, roles_s (st1, Rr!get_s (r1)),
                    pa (st1, Rr!get_o (r1), Rr!get_m (r1))),
               prove omega (st2)
            <4>1 prove roles_er (st2)
              <5>1 assume s1 : S, ro1 : Ro,
                   hypothesis H5: roles_s (st2, s1, ro1),
                   prove er (st2, s1, ro1)
                <6>1 prove er (st1, s1, ro1)
                  <7>1 (* assume s1 : S, ro1 : Ro, *)
                       prove roles_s (st1, s1, ro1) ->
                             er (st1, s1, ro1)
                       by hypothesis H2
                          definition of omega, roles_er
                  <7>2 prove roles_s (st1, s1, ro1)
                    <8>1 prove equal (st2, add (st1, A!create (Rr!get_s (r1),
                                                               Rr!get_o (r1),
                                                               Rr!get_m (r1))))
                         by property (* beq_symm, *) right_substitution
                            hypothesis H3, H7, H1
                            definition of tau_rbac_acc
                    <8>f qed
                         by step <8>1
                            hypothesis H5
                            property add_access_roles_s_2
                  <7>f qed
                       by step <7>1, <7>2
                <6>2 assume ro2 : Ro,
                     prove ua (st1, user (st1, s1), ro2) ->
                           ua (st2, user (st2, s1), ro2)
                  <7>1 prove equal (st2, add (st1, A!create (Rr!get_s (r1),
                                                             Rr!get_o (r1),
                                                             Rr!get_m (r1))))
                         by property (* beq_symm, *) right_substitution
                            hypothesis H3, H7, H1
                            definition of tau_rbac_acc
                  <7>f qed
                       by step <7>1
                          property add_access_ua
                <6>f qed
                     by step <6>1, <6>2
                        definition of er
              <5>f qed
                   by step <5>1
                      definition of roles_er
            <4>2 prove perm_ep (st2)
              <5>1 assume s1 : S, o1 : O, m1 : M,
                   hypothesis H6:
                     S_a!est_element (A!create (s1, o1, m1), lambda (st2)),
                   prove ep (st2, s1, o1, m1)
                <6>1 prove ep (st1, s1, o1, m1)
                  <7>1 prove S_a!equal (lambda (st2),
                                        S_a!union
                                            (lambda (st1),
                                             S_a!singleton
                                                 (A!create (Rr!get_s (r1),
                                                            Rr!get_o (r1),
                                                            Rr!get_m (r1)))))
                    <8>1 prove equal (st2, add (st1, A!create (Rr!get_s (r1),
                                                               Rr!get_o (r1),
                                                               Rr!get_m (r1))))
                      <9>1 prove Rr!is_get (r1) ->
                                 exists_role (st1,
                                              roles_s (st1, Rr!get_s (r1)),
                                              pa (st1,
                                                  Rr!get_o (r1),
                                                  Rr!get_m (r1))) ->
                                 tau_rbac_acc (r1, st1) =
                                 (D!yes, add (st1, A!create (Rr!get_s (r1),
                                                             Rr!get_o (r1),
                                                             Rr!get_m (r1))))
                           by (* property beq_refl *)
                              definition of tau_rbac_acc
                      <9>2 prove exists_role (st1,
                                              roles_s(st1,
                                                      Rr!get_s (r1)),
                                              pa (st1,
                                                  Rr!get_o (r1),
                                                  Rr!get_m (r1))) ->
                                  tau_rbac_acc (r1, st1) =
                                  (D!yes, add(st1, A!create (Rr!get_s (r1),
                                                             Rr!get_o (r1),
                                                             Rr!get_m (r1))))

                           by step <9>1
                              hypothesis H3
                      <9>3 prove tau_rbac_acc (r1, st1) =
                                 (D!yes, add(st1, A!create (Rr!get_s (r1),
                                                            Rr!get_o (r1),
                                                            Rr!get_m (r1))))
                           by step <9>2
                              hypothesis H7
                      <9>4 prove (d1, st2) =
                                 (D!yes, add (st1, A!create (Rr!get_s (r1),
                                                             Rr!get_o (r1),
                                                             Rr!get_m (r1))))
                           by step <9>3
                              hypothesis H1
                              (* property beq_symm, beq_trans *)
                      <9>f qed
                           by step <9>4
                              property right_substitution
                    <8>f qed
                         by step <8>1
                            property add_prop, equal_symmetric
                  <7>2 prove S_a!est_element (A!create (s1, o1, m1),
                                              lambda (st1)) ->
                             ep (st1, s1, o1, m1)
                       by hypothesis H2
                          definition of omega, perm_ep
                  <7>3 hypothesis H10:
                         S_a!est_element (
                           A!create (s1, o1, m1),
                           S_a!singleton (
                             A!create (
                               Rr!get_s (r1), Rr!get_o (r1), Rr!get_m (r1)
                             )
                           )
                         ),
                        prove ep (st1, s1, o1, m1)
                    <8>1 prove ep(st1,
                                  Rr!get_s (r1),
                                  Rr!get_o (r1),
                                  Rr!get_m (r1))
                         by hypothesis H7
                            property exists_role_ep
                    <8>2 prove S!equal (s1, Rr!get_s (r1))
                         by hypothesis H10
                            property S_a!singleton_prop, A!access_equal
                    <8>3 prove O!equal (o1, Rr!get_o (r1))
                         by hypothesis H10
                            property S_a!singleton_prop, A!access_equal
                    <8>4 prove M!equal (m1, Rr!get_m (r1))
                         by hypothesis H10
                            property S_a!singleton_prop, A!access_equal
                    <8>f qed
                         by step <8>1, <8>2, <8>3, <8>4
                            property ep_equal,
                                     S!equal_symmetric,
                                     O!equal_symmetric,
                                     M!equal_symmetric
                  <7>4 prove S_a!est_element (A!create (s1, o1, m1),
                                              lambda (st2)) ->
                             S_a!est_element
                                 (A!create (s1, o1, m1),
                                  S_a!union
                                      (lambda(st1),
                                       S_a!singleton
                                           (A!create (Rr!get_s (r1),
                                                      Rr!get_o (r1),
                                                      Rr!get_m (r1)))))
                       by step <7>1
                          property S_a!equal_prop
                  <7>5 prove S_a!est_element
                                 (A!create (s1, o1, m1),
                                  S_a!union
                                      (lambda (st1),
                                       S_a!singleton
                                           (A!create (Rr!get_s (r1),
                                                      Rr!get_o (r1),
                                                      Rr!get_m (r1))))) ->
                             (S_a!est_element (A!create (s1, o1, m1),
                                               lambda (st1))
                              \/
                              S_a!est_element
                                  (A!create (s1, o1, m1),
                                   S_a!singleton
                                       (A!create (Rr!get_s (r1),
                                                  Rr!get_o (r1),
                                                  Rr!get_m (r1)))))
                       by property S_a!union_spec
                  <7>f qed
                       by step <7>1, <7>2, <7>3, <7>4, <7>5
                          hypothesis H6
                <6>2 assume ro1 : Ro,
                     prove roles_s (st1, s1, ro1) ->
                           roles_s (st2, s1, ro1)
                  <7>1 prove equal (st2, add (st1, A!create (Rr!get_s (r1),
                                                             Rr!get_o (r1),
                                                             Rr!get_m (r1))))
                       by hypothesis H3, H7, H1
                          property (* beq_symm, *) right_substitution
                          definition of tau_rbac_acc
                  <7>f qed
                       by step <7>1
                          property add_access_roles_s_1
                <6>3 assume ro2 : Ro,
                     prove pa (st1, o1, m1, ro2) ->
                           pa (st2, o1, m1, ro2)
                  <7>1 prove equal (st2, add (st1, A!create (Rr!get_s (r1),
                                                             Rr!get_o (r1),
                                                             Rr!get_m (r1))))
                       by hypothesis H3, H7, H1
                          property (* beq_symm, *) right_substitution
                          definition of tau_rbac_acc
                  <7>f qed
                       by step <7>1
                          property add_access_pa
                <6>f qed
                     by step <6>1, <6>2, <6>3
                        definition of ep
              <5>f qed
                   by step <5>1
                      definition of perm_ep
            <4>f qed
                 by step <4>1, <4>2
                    definition of omega
          <3>2 hypothesis H8:
                 ~ exists_role (
                     st1,
                     roles_s (st1, Rr!get_s (r1)),
                     pa (st1, Rr!get_o (r1), Rr!get_m (r1))
                   ),
               prove omega (st2)
            <4>1 prove equal (st1 , st2)
              <5>1 prove Rr!is_get (r1) ->
                         (~ exists_role (st1,
                                         roles_s (st1, Rr!get_s (r1)),
                                         pa(st1,
                                            Rr!get_o (r1),
                                            Rr!get_m (r1)))) ->
                         tau_rbac_acc (r1, st1) = (D!no, st1)
                   by (* property beq_refl *)
                      definition of tau_rbac_acc
              <5>2 prove (~ exists_role (st1,
                                         roles_s (st1, Rr!get_s (r1)),
                                         pa(st1,
                                            Rr!get_o (r1),
                                            Rr!get_m (r1)))) ->
                         tau_rbac_acc (r1, st1) = (D!no, st1)
                   by step <5>1
                      hypothesis H3
              <5>3 prove tau_rbac_acc (r1, st1) = (D!no, st1)
                   by step <5>2
                      hypothesis H8
              <5>4 prove (d1, st2) = (D!no, st1)
                   by step <5>3
                      hypothesis H1
                      (* property beq_symm, beq_trans *)
              <5>f qed
                   by step <5>4
                      property right_substitution, equal_symmetric
            <4>f qed
                 by step <4>1
                    hypothesis H2
                    property secure_state
          <3>f qed
               by step <3>1, <3>2
        <2>3 hypothesis H4: Rr!is_rel (r1),
             prove omega (st2)
          <3>1 prove roles_er (st2)
            <4>2 assume s1 : S, ro1 : Ro,
                 hypothesis H5: roles_s (st2, s1, ro1),
                 prove er (st2, s1, ro1)
              <5>1 prove er (st1, s1, ro1)
                <6>1 (* assume s1 : S, ro1 : Ro, *)
                     prove roles_s (st1, s1, ro1) ->
                           er (st1, s1, ro1)
                     by hypothesis H2
                        definition of omega, roles_er
                <6>2 prove roles_s (st1, s1, ro1)
                  <7>1 prove equal (st2, del (st1, A!create (Rr!get_s (r1),
                                                             Rr!get_o (r1),
                                                             Rr!get_m (r1))))
                       by hypothesis H1, H4
                          property (* beq_symm, *)
                                   right_substitution,
                                   Rr!get_is_not_rel
                          definition of tau_rbac_acc
                  <7>f qed
                       by step <7>1
                          hypothesis H5
                          property del_access_roles_s_2
                <6>f qed
                     by step <6>1, <6>2
              <5>2 assume ro2 : Ro,
                   prove ua (st1, user (st1, s1), ro2) ->
                         ua (st2, user (st2, s1), ro2)
                <6>1 prove equal (st2, del (st1, A!create (Rr!get_s (r1),
                                                           Rr!get_o (r1),
                                                           Rr!get_m (r1))))
                     by hypothesis H1, H4
                        property (* beq_symm, *)
                                 right_substitution,
                                 Rr!get_is_not_rel
                        definition of tau_rbac_acc
                <6>f qed
                     by step <6>1
                        property del_access_ua
              <5>f qed
                   by step <5>1, <5>2
                      definition of er
            <4>f qed
                 by step <4>2
                    definition of roles_er
          <3>2 prove perm_ep (st2)
            <4>1 assume s1 : S, o1 : O, m1 : M,
                 hypothesis H6:
                   S_a!est_element (A!create (s1, o1, m1), lambda (st2)),
                 prove ep (st2, s1, o1, m1)
              <5>1 prove ep(st1, s1, o1, m1)
                <6>1 (* assume s1 : S, o1 : O, m1 : M, *)
                     prove
                       S_a!est_element (
                         A!create (s1, o1, m1), lambda (st1)) ->
                       ep (st1, s1, o1, m1)
                     by hypothesis H2
                        definition of omega, perm_ep
                <6>2 prove S_a!est_element (A!create (s1, o1, m1),
                                            lambda (st1))
                  <7>1 prove S_a!sous_ensemble (lambda(st2), lambda(st1))
                    <8>1 prove equal(st2,
                                     del(st1,
                                         A!create (Rr!get_s (r1),
                                                   Rr!get_o (r1),
                                                   Rr!get_m (r1))))
                         by hypothesis H1, H4
                            property (* beq_symm, *)
                                     right_substitution,
                                     Rr!get_is_not_rel
                            definition of tau_rbac_acc
                    <8>2 assume acc : A,
                         prove S_a!est_element
                                   (acc,
                                    lambda
                                       (del (st1,
                                             A!create (Rr!get_s (r1),
                                                       Rr!get_o (r1),
                                                       Rr!get_m (r1))))) ->
                               S_a!est_element (acc, lambda (st1))
                         by property del_prop
                    <8>3 assume acc : A,
                         prove S_a!est_element (acc, lambda (st2)) ->
                               S_a!est_element (acc, lambda (st1))
                         by step <8>1, <8>2
                            property S_a!equal_prop, lambda_prop
                    <8>f qed
                         by step <8>3
                            property S_a!sous_ensemble_spec
                  <7>f qed
                       by step <7>1
                          hypothesis H6
                          property S_a!sous_ensemble_spec
                <6>f qed
                     by step <6>1, <6>2
              <5>2 assume ro1 : Ro,
                   prove roles_s (st1, s1, ro1) ->
                         roles_s (st2, s1, ro1)
                <6>1 prove equal (st2, del (st1, A!create (Rr!get_s (r1),
                                                           Rr!get_o (r1),
                                                           Rr!get_m (r1))))
                     by hypothesis H1, H4
                        property (* beq_symm, *)
                                 right_substitution,
                                 Rr!get_is_not_rel
                        definition of tau_rbac_acc
                <6>f qed
                     by step <6>1
                        property del_access_roles_s_1
              <5>3 assume ro2 : Ro,
                   prove pa (st1, o1, m1, ro2) ->
                         pa (st2, o1, m1, ro2)
                <6>1 prove equal (st2, del (st1, A!create (Rr!get_s (r1),
                                                           Rr!get_o (r1),
                                                           Rr!get_m (r1))))
                     by hypothesis H1, H4
                        property (* beq_symm, *)
                                 right_substitution,
                                 Rr!get_is_not_rel
                        definition of tau_rbac_acc
                <6>f qed
                     by step <6>1
                        property del_access_pa
              <5>f qed
                   by step <5>1, <5>2, <5>3
                      definition of ep
            <4>f qed
                 by step <4>1
                    definition of perm_ep
          <3>f qed
               by step <3>1, <3>2
                  definition of omega
        <2>f qed
             by step <2>2, <2>3
                property Rr!get_or_rel
      <1>f conclude
 ;

  theorem tau_rbac_acc_r_correct :
    all st1 st2 : Self, all r1 : Rr, all d1 : D,
      tau_rbac_acc (r1, st1) = (d1, st2) ->
        D!equal (d1, D!yes) ->
          sem_req (r1, st2)
    proof =
      <1>1 assume st1 st2 : Self, r1 : Rr, d1 : D,
           hypothesis H1: tau_rbac_acc (r1, st1) = (d1, st2),
           prove D!equal (d1, D!yes) ->
                 sem_req (r1, st2)
        <2>2 hypothesis H3: Rr!is_get (r1),
             prove D!equal (d1, D!yes) ->
                   sem_req (r1, st2)
          <3>1 hypothesis H7: exists_role(st1,
         roles_s (st1, Rr!get_s (r1)),
         pa (st1,
             Rr!get_o (r1),
             Rr!get_m (r1))),
               prove D!equal (d1, D!yes) ->
                     sem_req (r1, st2)
            <4>1 hypothesis H7b: D!equal (d1, D!yes),
                 prove sem_req (r1, st2)
              <5>1 prove sem_req_get (r1, st2)
                <6>1 prove Rr!is_get (r1) ->
                           S_a!est_element (A!create (Rr!get_s (r1),
                                                      Rr!get_o (r1),
                                                      Rr!get_m (r1)),
                                            lambda (st2))
                  <7>1 prove S_a!est_element (A!create (Rr!get_s (r1),
                                                        Rr!get_o (r1),
                                                        Rr!get_m (r1)),
                                              lambda (st2))
                    <8>1 prove equal (st2, add (st1, A!create (Rr!get_s (r1),
                                                               Rr!get_o (r1),
                                                               Rr!get_m (r1))))
                      <9>10 prove Rr!is_get (r1) ->
                                  exists_role (st1,
                                               roles_s (st1,
                                                        Rr!get_s (r1)),
                                               pa(st1,
                                                  Rr!get_o (r1),
                                                  Rr!get_m (r1))) ->
                                  tau_rbac_acc (r1, st1) =
                                  (D!yes, add (st1, A!create (Rr!get_s (r1),
                                                              Rr!get_o (r1),
                                                              Rr!get_m (r1))))
                            by (* property beq_refl *)
                               definition of tau_rbac_acc
                      <9>11 prove exists_role (st1,
                                               roles_s (st1,
                                                        Rr!get_s (r1)),
                                               pa(st1,
                                                  Rr!get_o (r1),
                                                   Rr!get_m (r1))) ->
                                  tau_rbac_acc (r1, st1) =
                                  (D!yes, add (st1, A!create (Rr!get_s (r1),
                                                              Rr!get_o (r1),
                                                              Rr!get_m (r1))))
                            by step <9>10
                               hypothesis H3
                      <9>1 prove tau_rbac_acc (r1, st1) =
                                 (D!yes, add (st1, A!create (Rr!get_s (r1),
                                                            Rr!get_o (r1),
                                                            Rr!get_m (r1))))
                           by step <9>11
                              hypothesis H7
                      <9>2 prove (d1, st2) =
                                 (D!yes, add (st1, A!create (Rr!get_s (r1),
                                                             Rr!get_o (r1),
                                                             Rr!get_m (r1))))
                           by step <9>1
                              hypothesis H1
                              (* property beq_symm, beq_trans *)
                      <9>f qed
                           by step <9>2
                              property right_substitution
                    <8>f qed
                         by step <8>1
                            property add_mem, equal_symmetric
                  <7>f qed
                       by step <7>1
                          hypothesis H3
                <6>f qed
                     by step <6>1
                        definition of sem_req_get
              <5>2 prove sem_req_rel (r1, st2)
                <6>1 prove Rr!is_rel (r1) ->
                           ~ S_a!est_element (A!create (Rr!get_s (r1),
                                                        Rr!get_o (r1),
                                                        Rr!get_m (r1)),
                                              lambda (st2))
                  <7>1 prove ~ Rr!is_rel (r1)
                       by hypothesis H3
                          property Rr!get_is_not_rel
                  <7>f qed
                       by step <7>1
                <6>f qed
                     by step <6>1
                        definition of sem_req_rel
              <5>f qed
                   by step <5>1, <5>2
                      definition of sem_req
            <4>f qed
                 by step <4>1
          <3>2 hypothesis H8: ~ exists_role (st1,
            roles_s (st1,
             Rr!get_s (r1)),
            pa(st1,
               Rr!get_o (r1),
               Rr!get_m (r1))),
               prove D!equal (d1, D!yes) ->
                     sem_req (r1, st2)
            <4>1 prove ~ D!equal (d1, D!yes)
              <5>10 prove Rr!is_get (r1) ->
                          (~ exists_role (st1,
                                          roles_s (st1, Rr!get_s (r1)),
                                          pa(st1,
                                             Rr!get_o (r1),
                                             Rr!get_m (r1)))) ->
                          tau_rbac_acc (r1, st1) = (D!no, st1)
                    by (* property beq_refl *)
                       definition of tau_rbac_acc
              <5>11 prove (~ exists_role (st1,
                                          roles_s (st1, Rr!get_s (r1)),
                                          pa(st1,
                                             Rr!get_o (r1),
                                             Rr!get_m (r1)))) ->
                          tau_rbac_acc (r1, st1) = (D!no, st1)
                    by step <5>10
                       hypothesis H3
              <5>1 prove tau_rbac_acc (r1, st1) = (D!no, st1)
                   by step <5>11
                      hypothesis H8
              <5>2 prove (d1, st2) = (D!no, st1)
                   by step <5>1
                      hypothesis H1
                      (* property beq_symm, beq_trans *)
              <5>3 prove D!equal (d1, D!no)
                   by step <5>2
                      property left_substitution
              <5>f qed
                   by step <5>3
                      property D!yes_is_not_no
            <4>f qed
                 by step <4>1
          <3>f qed
               by step <3>1, <3>2
        <2>3 hypothesis H4: Rr!is_rel (r1),
             prove D!equal (d1, D!yes) ->
                   sem_req (r1, st2)
          <3>1 hypothesis H4b: D!equal (d1, D!yes),
               prove sem_req (r1, st2)
            <4>1 prove sem_req_get (r1, st2)
              <5>1 prove Rr!is_get (r1) ->
                         S_a!est_element (A!create (Rr!get_s (r1),
                                                    Rr!get_o (r1),
                                                    Rr!get_m (r1)),
                                          lambda (st2))
                <6>1 prove ~ Rr!is_get (r1)
                     by hypothesis H4
                        property Rr!get_is_not_rel
                <6>f qed
                     by step <6>1
              <5>f qed
                   by step <5>1
                      definition of sem_req_get
            <4>2 prove sem_req_rel (r1, st2)
              <5>1 prove Rr!is_rel (r1) ->
                         ~ S_a!est_element (A!create (Rr!get_s (r1),
                                                      Rr!get_o (r1),
                                                      Rr!get_m (r1)),
                                            lambda (st2))
                <6>1 prove ~ S_a!est_element (A!create (Rr!get_s (r1),
                                                        Rr!get_o (r1),
                                                        Rr!get_m (r1)),
                                              lambda (st2))
                  <7>1 prove equal (st2, del (st1, A!create (Rr!get_s (r1),
                                                             Rr!get_o (r1),
                                                             Rr!get_m (r1))))
                    <8>1 prove (~ Rr!is_get (r1)) ->
                               tau_rbac_acc (r1, st1) =
                               (D!yes, del (st1, A!create (Rr!get_s (r1),
                                                           Rr!get_o (r1),
                                                           Rr!get_m (r1))))
                         by (* property beq_refl *)
                            definition of tau_rbac_acc
                    <8>2 prove tau_rbac_acc (r1, st1) =
                               (D!yes, del(st1, A!create (Rr!get_s (r1),
                                                          Rr!get_o (r1),
                                                          Rr!get_m (r1))))
                         by step <8>1
                            hypothesis H4
                            property Rr!get_is_not_rel
                    <8>3 prove (d1, st2) =
                               (D!yes, del (st1, A!create (Rr!get_s (r1),
                                                           Rr!get_o (r1),
                                                           Rr!get_m (r1))))
                         by step <8>2
                            hypothesis H1
                            (* property beq_symm, beq_trans *)
                    <8>f qed
                         by step <8>3
                            property right_substitution
                  <7>f qed
                       by step <7>1
                          property del_mem, equal_symmetric
                <6>f qed
                     by step <6>1
                        hypothesis H4
              <5>f qed
                   by step <5>1
                      definition of sem_req_rel
            <4>f qed
                 by step <4>1, <4>2
                    definition of sem_req
          <3>f qed
               by step <3>1
        <2>f qed
             by step <2>2, <2>3
                property Rr!get_or_rel
      <1>f conclude
 ;

  theorem tau_rbac_acc_r_correct_bis :
    all st1 st2 : Self, all r1 : Rr, all d1 : D,
      tau_rbac_acc (r1, st1) = (d1, st2) ->
        D!equal (d1, D!no) ->
          equal (st1, st2)
    proof =
      <1>1 assume st1 st2 : Self, r1 : Rr, d1 : D,
           hypothesis H1: tau_rbac_acc (r1, st1) = (d1, st2),
           prove D!equal (d1, D!no) ->
                 equal (st1, st2)
        <2>2 hypothesis H3: Rr!is_get (r1),
             prove D!equal (d1, D!no) ->
                   equal (st1, st2)
          <3>1 hypothesis H7: exists_role (st1,
          roles_s (st1, Rr!get_s (r1)),
          pa (st1,
              Rr!get_o (r1),
              Rr!get_m (r1))),
               prove D!equal (d1, D!no) ->
                     equal (st1, st2)
            <4>1 prove ~ D!equal (d1, D!no)
              <5>10 prove Rr!is_get (r1) ->
                          exists_role (st1,
                                       roles_s (st1, Rr!get_s (r1)),
                                       pa (st1,
                                           Rr!get_o (r1),
                                           Rr!get_m (r1))) ->
                          tau_rbac_acc (r1, st1) =
                          (D!yes, add (st1, A!create (Rr!get_s (r1),
                                                      Rr!get_o (r1),
                                                      Rr!get_m (r1))))
                    by (* property beq_refl *)
                       definition of tau_rbac_acc
              <5>11 prove exists_role (st1,
                                       roles_s (st1, Rr!get_s (r1)),
                                       pa (st1,
                                           Rr!get_o (r1),
                                           Rr!get_m (r1))) ->
                          tau_rbac_acc (r1, st1) =
                          (D!yes, add (st1, A!create (Rr!get_s (r1),
                                                      Rr!get_o (r1),
                                                      Rr!get_m (r1))))
                    by step <5>10
                       hypothesis H3
              <5>1 prove tau_rbac_acc (r1, st1) =
                         (D!yes, add (st1, A!create (Rr!get_s (r1),
                                                     Rr!get_o (r1),
                                                     Rr!get_m (r1))))
                   by step <5>11
                      hypothesis H7
              <5>2 prove (d1, st2) =
                         (D!yes, add (st1, A!create (Rr!get_s (r1),
                                                     Rr!get_o (r1),
                                                     Rr!get_m (r1))))
                   by step <5>1
                      hypothesis H1
                      (* property beq_symm, beq_trans *)
              <5>3 prove D!equal (d1, D!yes)
                   by step <5>2
                      property left_substitution
              <5>f qed
                   by step <5>3
                      property D!yes_is_not_no
            <4>f qed
                 by step <4>1
          <3>2 hypothesis H8: ~ exists_role (st1,
            roles_s (st1,
             Rr!get_s(r1)),
            pa (st1,
        Rr!get_o (r1),
        Rr!get_m (r1))),
               prove D!equal (d1, D!no) ->
                     equal (st1, st2)
            <4>1 hypothesis H2: D!equal (d1, D!no),
                 prove equal (st1, st2)
              <5>1 prove Rr!is_get (r1) ->
                         (~ exists_role (st1,
                                         roles_s (st1, Rr!get_s (r1)),
                                         pa (st1,
                                            Rr!get_o (r1),
                                            Rr!get_m (r1)))) ->
                         tau_rbac_acc (r1, st1) = (D!no, st1)
                   by (* property beq_refl *)
                      definition of tau_rbac_acc
              <5>2 prove (~ exists_role (st1,
                                         roles_s (st1, Rr!get_s (r1)),
                                         pa (st1,
                                             Rr!get_o (r1),
                                             Rr!get_m (r1)))) ->
                         tau_rbac_acc (r1, st1) = (D!no, st1)
                   by step <5>1
                      hypothesis H3
              <5>3 prove tau_rbac_acc (r1, st1) = (D!no, st1)
                   by step <5>2
                      hypothesis H8
              <5>4 prove (d1, st2) = (D!no, st1)
                   by step <5>3
                      hypothesis H1
                      (* property beq_symm, beq_trans *)
              <5>f qed
                   by step <5>4
                      property right_substitution, equal_symmetric
            <4>f qed
                 by step <4>1
          <3>f qed
               by step <3>1, <3>2
        <2>3 hypothesis H4: Rr!is_rel (r1),
             prove D!equal (d1, D!no) ->
                   equal (st1, st2)
          <3>1 prove ~ D!equal (d1, D!no)
            <4>10 prove (~ Rr!is_get (r1)) ->
                        tau_rbac_acc (r1, st1) =
                        (D!yes, del (st1, A!create (Rr!get_s (r1),
                                                    Rr!get_o (r1),
                                                    Rr!get_m (r1))))
                  by (* property beq_refl *)
                     definition of tau_rbac_acc
            <4>1 prove tau_rbac_acc (r1, st1) =
                       (D!yes, del (st1, A!create (Rr!get_s (r1),
                                                   Rr!get_o (r1),
                                                   Rr!get_m (r1))))
                 by step <4>10
                    hypothesis H4
                    property Rr!get_is_not_rel
            <4>2 prove (d1, st2) =
                       (D!yes, del(st1, A!create (Rr!get_s (r1),
                                                  Rr!get_o (r1),
                                                  Rr!get_m (r1))))
                 by step <4>1
                    hypothesis H1
                    (* property beq_symm, beq_trans *)
            <4>3 prove D!equal (d1, D!yes)
                 by step <4>2
                    property left_substitution
            <4>f qed
                 by step <4>3
                    property D!yes_is_not_no
          <3>f qed
               by step <3>1
        <2>f qed
             by step <2>2, <2>3
                property Rr!get_or_rel
      <1>f conclude
 ;

  theorem tau_rbac_adm_secure :
    all st1 st2 : Self, all r1 : Rr, all d1 : D,
      tau_rbac_adm (r1, st1) = (d1, st2) ->
        omega (st1) ->
          omega (st2)
    proof =
      <1>1 assume st1 st2 : Self, r1 : Rr, d1 : D,
           hypothesis H1: tau_rbac_adm (r1, st1) = (d1, st2),
                      H2: omega (st1),
           prove omega (st2)
        <2>1 hypothesis H3: Rr!is_add_ua (r1),
             prove omega (st2)
          <3>1 prove roles_er (st2)
            <4>2 assume s1 : S, ro1 : Ro,
                 hypothesis H31: roles_s (st2, s1, ro1),
                 prove er (st2, s1, ro1)
              <5>1 prove er(st1, s1, ro1)
                <6>1 (* assume s1 : S, ro1 : Ro, *)
                     prove roles_s (st1, s1, ro1) ->
                           er (st1, s1, ro1)
                     by hypothesis H2
                        definition of omega, roles_er
                <6>2 prove roles_s (st1, s1, ro1)
                  <7>1 prove equal(st2,
                                   add_ua (st1, Rr!get_u (r1), Rr!get_r (r1)))
                       by hypothesis H3, H1
                          property (* beq_symm, *) right_substitution
                          definition of tau_rbac_adm
                  <7>f qed
                       by step <7>1
                          hypothesis H31
                          property add_ua_roles_s_2
                <6>f qed
                     by step <6>1, <6>2
              <5>2 assume ro2 : Ro,
                   prove ua (st1, user (st1, s1), ro2) ->
                         ua (st2, user (st2, s1), ro2)
                <6>1 prove equal (st2,
                                  add_ua (st1, Rr!get_u (r1), Rr!get_r (r1)))
                     by hypothesis H3, H1
                        property (* beq_symm, *) right_substitution
                        definition of tau_rbac_adm
                <6>f qed
                     by step <6>1
                        property add_ua_ua
              <5>f qed
                   by step <5>1, <5>2
                      definition of er
            <4>f qed
                 by step <4>2
                    definition of roles_er
          <3>2 prove perm_ep (st2)
            <4>1 assume s1 : S, o1 : O, m1 : M,
                 hypothesis H32:
                   S_a!est_element (A!create (s1, o1, m1), lambda (st2)),
                 prove ep (st2, s1, o1, m1)
              <5>1 prove ep (st1, s1, o1, m1)
                <6>1 (* assume s1 : S, o1 : O, m1 : M, *)
                     prove S_a!est_element (A!create (s1, o1, m1),
                                            lambda (st1)) ->
                           ep (st1, s1, o1, m1)
                     by hypothesis H2
                        definition of omega, perm_ep
                <6>2 prove S_a!est_element (A!create (s1, o1, m1),
                                            lambda (st1))
                  <7>1 prove S_a!equal (lambda(st2), lambda(st1))
                    <8>1 prove equal (st2,
                                      add_ua (st1,
                                              Rr!get_u (r1),
                                              Rr!get_r (r1)))
                         by hypothesis H3, H1
                            property (* beq_symm, *) right_substitution
                            definition of tau_rbac_adm
                    <8>f qed
                         by step <8>1
                            property add_ua_access, S_a!equal_symmetric
                  <7>f qed
                       by step <7>1
                          hypothesis H32
                          property S_a!equal_prop
                <6>f qed
                     by step <6>1, <6>2
              <5>2 assume ro1 : Ro,
                   prove roles_s (st1, s1, ro1) ->
                         roles_s (st2, s1, ro1)
                <6>1 prove equal (st2,
                                  add_ua (st1, Rr!get_u (r1), Rr!get_r (r1)))
                         by hypothesis H3, H1
                            property (* beq_symm, *) right_substitution
                            definition of tau_rbac_adm
                <6>f qed
                     by step <6>1
                        property add_ua_roles_s_1
              <5>3 assume ro2 : Ro,
                   prove pa (st1, o1, m1, ro2) ->
                         pa (st2, o1, m1, ro2)
                <6>1 prove equal (st2,
                                  add_ua (st1, Rr!get_u (r1), Rr!get_r (r1)))
                     by hypothesis H3, H1
                        property (* beq_symm, *) right_substitution
                        definition of tau_rbac_adm
                <6>f qed
                     by step <6>1
                        property add_ua_pa
              <5>f qed
                   by step <5>1, <5>2, <5>3
                      definition of ep
            <4>f qed
                 by step <4>1
                    definition of perm_ep
          <3>f qed
               by step <3>1, <3>2
                  definition of omega
        <2>2 hypothesis H4: Rr!is_rm_ua (r1),
             prove omega (st2)
          <3>1 hypothesis H41: S_a!for_all (lambda (st1),
           iter_ua (st1,
            Rr!get_u (r1),
                                                            Rr!get_r (r1))),
               prove omega (st2)
            <4>1 prove roles_er (st2)
              <5>1 assume s1 : S, ro1 : Ro,
                   hypothesis H44: roles_s (st2, s1, ro1),
                   prove er (st2, s1, ro1)
                <6>1 prove er (st1, s1, ro1)
                  <7>1 (* assume s1 : S, ro1 : Ro, *)
                       prove roles_s (st1, s1, ro1) ->
                             er (st1, s1, ro1)
                       by hypothesis H2
                          definition of omega, roles_er
                  <7>2 prove roles_s (st1, s1, ro1)
                    <8>1 prove equal(st2,
                                     rm_ua (st1, Rr!get_u (r1), Rr!get_r (r1)))
                         by hypothesis H4, H1, H41
                            property (* beq_symm, *)
                                     Rr!add_ua_then_not_rm_ua,
                                     right_substitution
                            definition of tau_rbac_adm
                    <8>f qed
                         by step <8>1
                         hypothesis H44
                         property rm_ua_roles_s_2
                  <7>f qed
                       by step <7>1, <7>2
               <6>2 assume ro2 : Ro,
                    prove ua (st2, user (st2, s1), ro2)
                 <7>1 prove S_a!for_all (lambda (st2), iter_ua (st2,
                                                               Rr!get_u (r1),
                                                               Rr!get_r (r1)))
                   <8>1 prove equal (st2,
                                     rm_ua (st1, Rr!get_u (r1), Rr!get_r (r1)))
                        by hypothesis H4, H1, H41
                           property (* beq_symm, *)
                                    Rr!add_ua_then_not_rm_ua,
                                    right_substitution
                           definition of tau_rbac_adm
                   <8>f qed
                        by step <8>1
                           hypothesis H41
                           property for_all_spec_ua_1
                 <7>f qed
                      by step <7>1
                         property for_all_spec_ua_2
                <6>f qed
                     by step <6>1, <6>2
                        definition of er
              <5>f qed
                   by step <5>1
                      definition of roles_er
            <4>2 prove perm_ep (st2)
              <5>1 assume s1 : S, o1 : O, m1 : M,
                   hypothesis H43:
                     S_a!est_element (
                       A!create (s1, o1, m1), lambda (st2)
                     ),
                   prove ep (st2, s1, o1, m1)
                <6>1 prove ep(st1, s1, o1, m1)
                  <7>1 (* assume s1 : S, o1 : O, m1 : M, *)
                       prove S_a!est_element (A!create (s1, o1, m1),
                                              lambda (st1)) ->
                             ep (st1, s1, o1, m1)
                       by hypothesis H2
                          definition of omega, perm_ep
                  <7>2 prove S_a!est_element (A!create (s1, o1, m1),
                                              lambda (st1))
                    <8>1 prove S_a!equal (lambda (st2), lambda(st1))
                      <9>1 prove equal (st2,
                                        rm_ua (st1,
                                               Rr!get_u (r1),
                                               Rr!get_r (r1)))
                           by hypothesis H4, H1, H41
                              property (* beq_symm, *)
                                       Rr!add_ua_then_not_rm_ua,
                                       right_substitution
                              definition of tau_rbac_adm
                      <9>f qed
                           by step <9>1
                              property rm_ua_access, S_a!equal_symmetric
                    <8>f qed
                         by step <8>1
                            hypothesis H43
                            property S_a!equal_prop
                  <7>f qed
                       by step <7>1, <7>2
                <6>2 assume ro1 : Ro,
                     prove roles_s (st1, s1, ro1) ->
                           roles_s (st2, s1, ro1)
                  <7>1 prove equal (st2, rm_ua(st1,
                                               Rr!get_u (r1),
                                               Rr!get_r (r1)))
                       by hypothesis H4, H1, H41
                          property (* beq_symm, *)
                                   Rr!add_ua_then_not_rm_ua,
                                   right_substitution
                          definition of tau_rbac_adm
                  <7>f qed
                       by step <7>1
                          property rm_ua_roles_s_1
                <6>3 assume ro2 : Ro,
                     prove pa (st1, o1, m1, ro2) ->
                           pa (st2, o1, m1, ro2)
                  <7>1 prove equal (st2, rm_ua (st1,
                                                Rr!get_u (r1),
                                                Rr!get_r (r1)))
                       by hypothesis H4, H1, H41
                           property (* beq_symm, *)
                                    Rr!add_ua_then_not_rm_ua,
                                    right_substitution
                           definition of tau_rbac_adm
                  <7>f qed
                       by step <7>1
                          property rm_ua_pa
                <6>f qed
                     by step <6>1, <6>2, <6>3
                        definition of ep
              <5>f qed
                   by step <5>1
                      definition of perm_ep
            <4>f qed
                 by step <4>1, <4>2
                    definition of omega
          <3>2 hypothesis H42: ~ (S_a!for_all
            (lambda (st1),
             iter_ua (st1,
              Rr!get_u (r1),
              Rr!get_r (r1)))),
               prove omega (st2)
            <4>1 prove equal (st1 , st2)
              <5>1 prove (~ Rr!is_add_ua (r1)) ->
                         Rr!is_rm_ua (r1) ->
                         (~ (S_a!for_all (lambda(st1),
                                         iter_ua(st1,
                                                 Rr!get_u (r1),
                                                 Rr!get_r (r1))))) ->
                         tau_rbac_adm (r1, st1) = (D!no, st1)
                   by (* property beq_refl *)
                      definition of tau_rbac_adm
              <5>2 prove Rr!is_rm_ua (r1) ->
                         (~ (S_a!for_all (lambda (st1),
                                         iter_ua(st1,
                                                 Rr!get_u (r1),
                                                 Rr!get_r (r1))))) ->
                         tau_rbac_adm (r1, st1) = (D!no, st1)
                   by step <5>1
                      property Rr!add_ua_then_not_rm_ua
              <5>3 prove (~ (S_a!for_all (lambda(st1),
                                         iter_ua(st1,
                                                 Rr!get_u (r1),
                                                 Rr!get_r (r1))))) ->
                         tau_rbac_adm (r1, st1) = (D!no, st1)
                   by step <5>2
                      hypothesis H4
              <5>4 prove tau_rbac_adm (r1, st1) = (D!no, st1)
                   by step <5>3
                      hypothesis H42
              <5>5 prove (d1, st2) = (D!no, st1)
                   by step <5>4
                      hypothesis H1
                      (* property beq_symm, beq_trans *)
              <5>f qed
                   by step <5>5
                      property right_substitution, equal_symmetric
            <4>f qed
                 by step <4>1
                    hypothesis H2
                    property secure_state
          <3>f qed
               by step <3>1, <3>2
        <2>3 hypothesis H5: Rr!is_add_pa (r1),
             prove omega (st2)
          <3>1 prove roles_er (st2)
            <4>2 assume s1 : S, ro1 : Ro,
                 hypothesis H51: roles_s (st2, s1, ro1),
                 prove er (st2, s1, ro1)
              <5>1 prove er(st1, s1, ro1)
                <6>1 (* assume s1 : S, ro1 : Ro, *)
                     prove roles_s (st1, s1, ro1) ->
                           er (st1, s1, ro1)
                     by hypothesis H2
                        definition of omega, roles_er
                <6>2 prove roles_s (st1, s1, ro1)
                  <7>1 prove equal (st2, add_pa (st1,
                                                 Rr!get_o (r1),
                                                 Rr!get_m (r1),
                                                 Rr!get_r (r1)))
                       by hypothesis H5, H1
                          property (* beq_symm, *)
                                   Rr!add_pa_then_not_ua,
                                   right_substitution
                          definition of tau_rbac_adm
                  <7>f qed
                       by step <7>1
                          hypothesis H51
                          property add_pa_roles_s_2
                <6>f qed
                     by step <6>1, <6>2
              <5>2 assume ro2 : Ro,
                   prove ua (st1, user (st1, s1), ro2) ->
                         ua (st2, user (st2, s1), ro2)
                <6>1 prove equal (st2, add_pa (st1,
                                               Rr!get_o (r1),
                                               Rr!get_m (r1),
                                               Rr!get_r (r1)))
                     by hypothesis H5, H1
                        property (* beq_symm, *)
                                 Rr!add_pa_then_not_ua,
                                 right_substitution
                        definition of tau_rbac_adm
                <6>f qed
                     by step <6>1
                        property add_pa_ua
              <5>f qed
                   by step <5>1, <5>2
                      definition of er
            <4>f qed
                 by step <4>2
                    definition of roles_er
          <3>2 prove perm_ep (st2)
            <4>1 assume s1 : S, o1 : O, m1 : M,
                 hypothesis H52:
                   S_a!est_element (A!create (s1, o1, m1), lambda (st2)),
                 prove ep (st2, s1, o1, m1)
              <5>1 prove ep (st1, s1, o1, m1)
                <6>1 (* assume s1 : S, o1 : O, m1 : M, *)
                     prove S_a!est_element (A!create (s1, o1, m1),
                                            lambda(st1)) ->
                           ep (st1, s1, o1, m1)
                     by hypothesis H2
                        definition of omega, perm_ep
                <6>2 prove S_a!est_element (A!create (s1, o1, m1),
                                            lambda (st1))
                  <7>1 prove S_a!equal (lambda(st2), lambda (st1))
                    <8>1 prove equal (st2, add_pa (st1,
                                                   Rr!get_o (r1),
                                                   Rr!get_m (r1),
                                                   Rr!get_r (r1)))
                         by hypothesis H5, H1
                            property (* beq_symm, *)
                                     Rr!add_pa_then_not_ua,
                                     right_substitution
                            definition of tau_rbac_adm
                    <8>f qed
                         by step <8>1
                            property add_pa_access, S_a!equal_symmetric
                  <7>f qed
                       by step <7>1
                          hypothesis H52
                          property S_a!equal_prop
                <6>f qed
                     by step <6>1, <6>2
              <5>2 assume ro1 : Ro,
                   prove roles_s (st1, s1, ro1) ->
                         roles_s (st2, s1, ro1)
                <6>1 prove equal (st2, add_pa (st1,
                                               Rr!get_o (r1),
                                               Rr!get_m (r1),
                                               Rr!get_r (r1)))
                     by hypothesis H5, H1
                        property (* beq_symm, *)
                                 Rr!add_pa_then_not_ua,
                                 right_substitution
                        definition of tau_rbac_adm
                <6>f qed
                     by step <6>1
                        property add_pa_roles_s_1
              <5>3 assume ro2 : Ro,
                   prove pa (st1, o1, m1, ro2) ->
                         pa (st2, o1, m1, ro2)
                <6>1 prove equal (st2, add_pa (st1,
                                               Rr!get_o (r1),
                                               Rr!get_m (r1),
                                               Rr!get_r (r1)))
                     by hypothesis H5, H1
                        property (* beq_symm, *)
                                 Rr!add_pa_then_not_ua,
                                 right_substitution
                        definition of tau_rbac_adm
                <6>f qed
                     by step <6>1
                        property add_pa_pa
              <5>f qed
                   by step <5>1, <5>2, <5>3
                      definition of ep
            <4>f qed
                 by step <4>1
                    definition of perm_ep
          <3>f qed
               by step <3>1, <3>2
                  definition of omega
        <2>4 hypothesis H6: Rr!is_rm_pa (r1),
             prove omega (st2)
          <3>1 hypothesis H61: S_a!for_all (lambda (st1),
           iter_pa (st1,
            Rr!get_o (r1),
                                                            Rr!get_m (r1),
                                                            Rr!get_r (r1))),
               prove omega (st2)
            <4>1 prove roles_er (st2)
              <5>1 assume s1 : S, ro1 : Ro,
                   hypothesis H62: roles_s (st2, s1, ro1),
                   prove er (st2, s1, ro1)
                <6>1 prove er (st1, s1, ro1)
                  <7>1 (* assume s1 : S, ro1 : Ro, *)
                       prove roles_s (st1, s1, ro1) ->
                             er (st1, s1, ro1)
                       by hypothesis H2
                          definition of omega, roles_er
                  <7>2 prove roles_s (st1, s1, ro1)
                    <8>1 prove equal (st2, rm_pa (st1,
                                                  Rr!get_o (r1),
                                                  Rr!get_m (r1),
                                                  Rr!get_r (r1)))
                         by hypothesis H6, H1, H61
                            property (* beq_symm, *)
                                     Rr!rm_pa_then_not_add_pa_ua,
                                     right_substitution
                            definition of tau_rbac_adm
                    <8>f qed
                         by step <8>1
                            hypothesis H62
                            property rm_pa_roles_s_2
                  <7>f qed
                       by step <7>1, <7>2
                <6>2 assume ro2 : Ro,
                     prove ua (st1, user (st1, s1), ro2) ->
                           ua (st2, user (st2, s1), ro2)
                  <7>1 prove equal (st2, rm_pa (st1,
                                                Rr!get_o (r1),
                                                Rr!get_m (r1),
                                                Rr!get_r (r1)))
                         by hypothesis H6, H1, H61
                            property (* beq_symm, *)
                                     Rr!rm_pa_then_not_add_pa_ua,
                                     right_substitution
                            definition of tau_rbac_adm
                  <7>f qed
                       by step <7>1
                          property rm_pa_ua
                <6>f qed
                     by step <6>1, <6>2
                        definition of er
              <5>f qed
                   by step <5>1
                      definition of roles_er
            <4>2 prove perm_ep (st2)
              <5>1 assume s1 : S, o1 : O, m1 : M,
                   hypothesis H63:
                     S_a!est_element (A!create (s1, o1, m1), lambda (st2)),
                   prove ep (st2, s1, o1, m1)
                <6>1 prove exists_role(st2,
                                       roles_s (st2, s1),
                                       pa (st2, o1, m1))
                  <7>1 prove equal (st2, rm_pa (st1,
                                                Rr!get_o (r1),
                                                Rr!get_m (r1),
                                                Rr!get_r (r1)))
                       by hypothesis H6, H1, H61
                          property (* beq_symm, *)
                                   Rr!rm_pa_then_not_add_pa_ua,
                                   right_substitution
                          definition of tau_rbac_adm
                  <7>2 prove S_a!for_all (lambda (st1), iter_pa (st1,
                                                                Rr!get_o (r1),
                                                                Rr!get_m (r1),
                                                                Rr!get_r (r1)))
                       by hypothesis H61
                  <7>3 prove S_a!est_element (A!create (s1, o1, m1),
                                              lambda (st1))
                       by step <7>1
                          hypothesis H63
                          property rm_pa_access,
                                   S_a!equal_prop,
                                   S_a!equal_symmetric
                  <7>4 prove exists_role (rm_pa (st1,
                                                 Rr!get_o (r1),
                                                 Rr!get_m (r1),
                                                 Rr!get_r (r1)),
                                          roles_s (rm_pa (st1,
                                                          Rr!get_o (r1),
                                                          Rr!get_m (r1),
                                                          Rr!get_r (r1)),
                                                   s1),
                                          pa (rm_pa (st1,
                                                     Rr!get_o (r1),
                                                     Rr!get_m (r1),
                                                     Rr!get_r (r1)),
                                              o1,
                                              m1))
                       by step <7>2, <7>3
                          property iter_pa_spec
                  <7>f qed
                       by step <7>1, <7>4
                          property equal_exists_role, equal_symmetric
                <6>f qed
                     by step <6>1
                        property exists_role_ep
              <5>f qed
                   by step <5>1
                      definition of perm_ep
            <4>f qed
                 by step <4>1, <4>2
                    definition of omega
          <3>2 hypothesis H62: ~ (S_a!for_all
            (lambda (st1),
             iter_pa (st1,
              Rr!get_o (r1),
              Rr!get_m (r1),
              Rr!get_r (r1)))),
               prove omega (st2)
            <4>1 prove equal (st1 , st2)
              <5>1 prove (~ Rr!is_add_ua (r1)) ->
                         (~ Rr!is_rm_ua (r1)) ->
                         (~ Rr!is_add_pa (r1)) ->
                         Rr!is_rm_pa (r1) ->
                         (~ (S_a!for_all (lambda (st1),
                                         iter_pa (st1,
                                                  Rr!get_o (r1),
                                                  Rr!get_m (r1),
                                                  Rr!get_r (r1))))) ->
                         tau_rbac_adm (r1, st1) = (D!no, st1)
                    by (* property beq_refl *)
                       definition of tau_rbac_adm
              <5>2 prove Rr!is_rm_pa (r1) ->
                         (~ (S_a!for_all (lambda (st1),
                                         iter_pa (st1,
                                                  Rr!get_o (r1),
                                                  Rr!get_m (r1),
                                                  Rr!get_r (r1))))) ->
                         tau_rbac_adm (r1, st1) = (D!no, st1)
                   by step <5>1
                      hypothesis H6
                      property Rr!rm_pa_then_not_add_pa_ua
              <5>3 prove (~ (S_a!for_all (lambda (st1),
                                         iter_pa (st1,
                                                  Rr!get_o (r1),
                                                  Rr!get_m (r1),
                                                  Rr!get_r (r1))))) ->
                         tau_rbac_adm (r1, st1) = (D!no, st1)
                   by step <5>2
                      hypothesis H6
              <5>4 prove tau_rbac_adm (r1, st1) = (D!no, st1)
                   by step <5>3
                      hypothesis H62
              <5>5 prove (d1, st2) = (D!no, st1)
                   by step <5>4
                      hypothesis H1
                      (* property beq_symm, beq_trans *)
              <5>f qed
                   by step <5>5
                      property right_substitution, equal_symmetric
            <4>f qed
                 by step <4>1
                    hypothesis H2
                    property secure_state
          <3>f qed
               by step <3>1, <3>2
        <2>5 hypothesis H7: (~ Rr!is_add_ua (r1)) /\
                                   (~ Rr!is_rm_ua (r1)) /\
                                   (~ Rr!is_add_pa (r1)) /\
                                   (~ Rr!is_rm_pa (r1)),
             prove omega (st2)
          <3>1 prove equal (st1, st2)
            <4>1 prove ((~ Rr!is_add_ua (r1)) /\
                        (~ Rr!is_rm_ua (r1)) /\
                        (~ Rr!is_add_pa (r1)) /\
                        (~ Rr!is_rm_pa (r1))) ->
                       tau_rbac_adm (r1, st1) = (D!no, st1)
                 by (* property beq_refl *)
                    definition of tau_rbac_adm
            <4>2 prove tau_rbac_adm (r1, st1) = (D!no, st1)
                 by step <4>1
                    hypothesis H7
            <4>3 prove (d1, st2) = (D!no, st1)
                 by step <4>2
                    hypothesis H1
                    (* property beq_trans, beq_symm *)
            <4>f qed
                 by step <4>3
                    property right_substitution, equal_symmetric
          <3>f qed
               by step <3>1
                  hypothesis H2
                  property secure_state
        <2>f qed
             by step <2>1, <2>2, <2>3, <2>4, <2>5
      <1>f conclude
 ;

  theorem tau_rbac_secure :
    all st1 st2 : Self, all r1 : Rr, all d1 : D,
      tau_rbac (r1, st1) = (d1, st2) ->
        omega (st1) ->
          omega(st2)
    proof = by property tau_rbac_acc_secure, tau_rbac_adm_secure
              definition of tau_rbac;

end;;

(** HRU *)

(** Definition of a pair *)
species Pair (X is Setoid, Y is Setoid) =

  inherit Setoid;

  (** Allows to create a pair *)
  signature create : X -> Y -> Self;

  (** Returns the first element of the given pair *)
  signature first : Self -> X;

  (** Returns the second element of the given pair *)
  signature second : Self -> Y;

end;;

(** Definition of the HRU security predicate *)
species Policy_hru (Rh is Rho,
                    S is Subjects, O is Objects, M is Access_mode,
                    A is Access (S, O, M), S_a is Set_of (A)) =

  inherit Policy (Rh, S, O, M, A, S_a);

  (** Returns true if the given access is authorized, false otherwise *)
  signature fd : A -> bool;

  (**
     If two accesses a1 and a2 are equal and if a1 is authorized
     then a2 is authorized
   *)
  property fd_access :
    all a1 a2 : A,
      A!equal (a1, a2) ->
        fd (a1) ->
          fd (a2);
  (**
     The HRU security predicate : if an access belongs to the current
     accesses of a state then it is authorized
   *)
  logical let omega (st : Self) =
     all s1 : S, all o1 : O, all m1 : M,
       S_a!est_element (A!create (s1, o1, m1), lambda (st)) ->
         fd (A!create (s1, o1, m1));

end;;

(** Definition of the HRU transition function (reference monitor) *)
species Model_hru (Rh is Rho,
                   S is Subjects, O is Objects, M is Access_mode,
                   A is Access (S, O, M), S_a is Set_of (A),
                   R is Requests_gal (S, O, M),
                   D is Decisions) =

  inherit
    Policy_hru (Rh, S, O, M, A, S_a),
    Semantics_requests_gal (Rh, S, O, M, A, S_a, R),
    Models (Rh, S, O, M, A, S_a, R, D);

  (** HRU transition function *)
  let tau_hru (r1 : R, st : Self) =
     if R!is_get (r1) then
       if fd (A!create (R!get_s (r1), R!get_o (r1), R!get_m (r1)))
       then (D!yes, add (st,
                         A!create (R!get_s (r1), R!get_o (r1), R!get_m (r1))))
       else (D!no, st)
     else  (* R!is_rel (r1) *)
         (D!yes, del (st,
                      A!create (R!get_s (r1), R!get_o (r1), R!get_m(r1))));

  theorem tau_hru_secure :
    all st1 st2 : Self, all r1 : R, all d1 : D,
      tau_hru (r1, st1) = (d1, st2) ->
        omega (st1) ->
          omega (st2)
    proof =
      <1>1 assume st1 st2 : Self, r1 : R, d1 : D,
           hypothesis H1: tau_hru (r1, st1) = (d1, st2),
                      H2: omega (st1),
           prove omega (st2)
        <2>2 hypothesis H3: R!is_get (r1),
             prove omega (st2)
          <3>2 hypothesis H31: fd (A!create (R!get_s (r1),
            R!get_o (r1),
            R!get_m (r1))),
               prove omega (st2)
            <4>1 assume s2 : S, o2 : O, m2 : M,
                 prove S_a!est_element (A!create (s2, o2, m2),
                                        lambda (st2)) ->
                       fd (A!create (s2, o2, m2))
              <5>1 prove S_a!equal (lambda (st2),
                                    S_a!union
                                        (lambda (st1),
                                         S_a!singleton
                                             (A!create (R!get_s (r1),
                                                        R!get_o (r1),
                                                        R!get_m (r1)))))
                <6>1 prove equal (st2, add (st1, A!create (R!get_s (r1),
                                                           R!get_o (r1),
                                                           R!get_m (r1))))
                  <7>1 prove R!is_get (r1) ->
                             fd (A!create (R!get_s (r1),
                                           R!get_o (r1),
                                           R!get_m (r1))) ->
                             tau_hru (r1, st1) =
                             (D!yes, add (st1, A!create (R!get_s (r1),
                                                         R!get_o (r1),
                                                         R!get_m (r1))))
                       by (* property beq_refl *)
                          definition of tau_hru
                  <7>2 prove fd (A!create (R!get_s (r1),
                                           R!get_o (r1),
                                            R!get_m (r1))) ->
                             tau_hru (r1, st1) =
                             (D!yes, add (st1, A!create (R!get_s (r1),
                                                          R!get_o (r1),
                                                          R!get_m (r1))))
                       by step <7>1
                          hypothesis H3
                  <7>3 prove tau_hru (r1, st1) =
                             (D!yes, add(st1, A!create (R!get_s (r1),
                                                        R!get_o (r1),
                                                        R!get_m (r1))))
                       by step <7>2
                          hypothesis H31
                  <7>4 prove (d1, st2) =
                             (D!yes, add (st1, A!create (R!get_s (r1),
                                                         R!get_o (r1),
                                                         R!get_m (r1))))
                       by step <7>3
                          hypothesis H1
                          (* property beq_trans, beq_symm *)
                  <7>f qed
                       by step <7>4
                          property right_substitution
                <6>f qed
                     by step <6>1
                        property add_prop, equal_symmetric
              <5>2 prove S_a!est_element (A!create (s2, o2, m2),
                                          lambda (st1)) ->
                         fd (A!create (s2, o2, m2))
                   by hypothesis H2
                      definition of omega
              <5>3 prove S_a!est_element
                             (A!create (s2, o2, m2),
                              S_a!singleton(A!create (R!get_s (r1),
                                                      R!get_o (r1),
                                                      R!get_m(r1)))) ->
                         fd (A!create (s2, o2, m2))
                   by hypothesis H31
                      property S_a!singleton_prop, fd_access, A!equal_symmetric
              <5>4 prove S_a!est_element (A!create (s2, o2, m2),
                                          lambda (st2)) ->
                         S_a!est_element (A!create (s2, o2, m2),
                                          S_a!union
                                              (lambda (st1),
                                               S_a!singleton
                                                   (A!create (R!get_s (r1),
                                                              R!get_o (r1),
                                                              R!get_m (r1)))))
                   by step <5>1
                      property S_a!equal_prop
              <5>5 prove S_a!est_element
                             (A!create (s2, o2, m2),
                                S_a!union
                                    (lambda (st1),
                                     S_a!singleton
                                         (A!create (R!get_s (r1),
                                                    R!get_o (r1),
                                                    R!get_m (r1))))) ->
                         (S_a!est_element (A!create (s2, o2, m2),
                                           lambda (st1))
                          \/
                          S_a!est_element (A!create (s2, o2, m2),
                                           S_a!singleton
                                               (A!create (R!get_s (r1),
                                                          R!get_o (r1),
                                                          R!get_m (r1)))))
                   by property S_a!union_spec
              <5>f qed
                   by step <5>1, <5>2, <5>3, <5>4, <5>5
            <4>f qed
                 by step <4>1
                    definition of omega
          <3>3 hypothesis H32: ~ fd (A!create (R!get_s (r1),
              R!get_o (r1),
              R!get_m (r1))),
               prove omega (st2)
            <4>1 prove equal (st1, st2)
              <5>1 prove R!is_get (r1) ->
                         (~ fd (A!create (R!get_s (r1),
                                          R!get_o (r1),
                                          R!get_m (r1)))) ->
                         tau_hru (r1, st1) = (D!no, st1)
                   by (* property beq_refl *)
                      definition of tau_hru
              <5>2 prove (~ fd (A!create (R!get_s (r1),
                                          R!get_o (r1),
                                          R!get_m (r1)))) ->
                         tau_hru (r1, st1) = (D!no, st1)
                   by step <5>1
                      hypothesis H3
              <5>3 prove tau_hru (r1, st1) = (D!no, st1)
                   by step <5>2
                      hypothesis H32
              <5>4 prove (d1, st2) = (D!no, st1)
                   by step <5>3
                      hypothesis H1
                      (* property beq_trans, beq_symm *)
              <5>f qed
                   by step <5>4
                      property right_substitution, equal_symmetric
            <4>f qed
                 by step <4>1
                    hypothesis H2
                    property secure_state
          <3>f qed
               by step <3>2, <3>3
        <2>3 hypothesis H4: R!is_rel (r1),
             prove omega (st2)
          <3>6 assume s2 : S, o2 : O, m2 : M,
               prove S_a!est_element (A!create(s2, o2, m2),
                                      lambda (st2)) ->
                     fd (A!create (s2, o2, m2))
            <4>1 prove S_a!sous_ensemble (lambda (st2), lambda (st1))
              <5>1 prove equal(st2, del (st1,
                                         A!create(R!get_s (r1),
                                                  R!get_o (r1),
                                                  R!get_m (r1))))
                   by hypothesis H1, H4
                      property (* beq_symm, *)
                               R!get_is_not_rel, right_substitution
                      definition of tau_hru
              <5>2 assume acc : A,
                   prove S_a!est_element
                             (acc,
                              lambda (del(st1,
                                          A!create(R!get_s (r1),
                                                   R!get_o (r1),
                                                   R!get_m (r1))))) ->
                         S_a!est_element (acc, lambda (st1))
                   by property del_prop
              <5>3 assume acc : A,
                   prove S_a!est_element (acc, lambda (st2)) ->
                         S_a!est_element (acc, lambda (st1))
                   by step <5>1, <5>2
                      property S_a!equal_prop, lambda_prop
              <5>f qed
                   by step <5>3
                      property S_a!sous_ensemble_spec
            <4>2 prove S_a!est_element (A!create (s2, o2, m2),
                                        lambda (st1)) ->
                       fd (A!create (s2, o2, m2))
                 by hypothesis H2
                    definition of omega
            <4>f qed
                  by step <4>1, <4>2
                     property S_a!sous_ensemble_spec
           <3>f qed
                by step <3>6
                   definition of omega
         <2>f qed
              by step <2>2, <2>3
                 property R!get_or_rel
       <1>f conclude
 ;

  theorem tau_hru_correct :
    all st1 st2 : Self, all r1 : R, all d1 : D,
      tau_hru (r1, st1) = (d1, st2) ->
        D!equal (d1, D!yes) ->
          sem_req (r1, st2)
    proof =
      <1>1 assume st1 st2 : Self, r1 : R, d1 : D,
           hypothesis H1: tau_hru (r1, st1) = (d1, st2),
           prove D!equal (d1, D!yes) ->
                 sem_req (r1, st2)
        <2>2 hypothesis H3: R!is_get (r1),
             prove D!equal (d1, D!yes) ->
                   sem_req (r1, st2)
          <3>2 hypothesis H31: fd (A!create (R!get_s (r1),
            R!get_o (r1),
            R!get_m (r1))),
               prove D!equal (d1, D!yes) ->
                     sem_req (r1, st2)
            <4>1 hypothesis H2: D!equal (d1, D!yes),
                 prove sem_req (r1, st2)
              <5>1 prove sem_req_get (r1, st2)
                <6>1 prove R!is_get (r1) ->
                           S_a!est_element (A!create (R!get_s (r1),
                                                      R!get_o (r1),
                                                      R!get_m (r1)),
                                            lambda (st2))
                  <7>1 prove S_a!est_element (A!create (R!get_s (r1),
                                                        R!get_o (r1),
                                                        R!get_m (r1)),
                                              lambda (st2))
                    <8>1 prove equal (st2,
                                      add(st1, A!create(R!get_s (r1),
                                                        R!get_o (r1),
                                                        R!get_m (r1))))
                      <9>10 prove R!is_get (r1) ->
                                  fd (A!create (R!get_s (r1),
                                                R!get_o (r1),
                                                R!get_m (r1))) ->
                                  tau_hru (r1, st1) =
                                  (D!yes, add (st1, A!create (R!get_s (r1),
                                                              R!get_o (r1),
                                                              R!get_m (r1))))
                            by (* property beq_refl *)
                               definition of tau_hru
                       <9>11 prove fd (A!create (R!get_s (r1),
                                                 R!get_o (r1),
                                                 R!get_m (r1))) ->
                                   tau_hru (r1, st1) =
                                   (D!yes, add(st1, A!create (R!get_s (r1),
                                                              R!get_o (r1),
                                                              R!get_m (r1))))
                             by step <9>10
                                hypothesis H3
                       <9>1 prove tau_hru (r1, st1) =
                                  (D!yes, add(st1, A!create (R!get_s (r1),
                                                             R!get_o (r1),
                                                             R!get_m (r1))))
                            by step <9>11
                               hypothesis H31
                       <9>2 prove (d1, st2) =
                                  (D!yes, add(st1, A!create (R!get_s (r1),
                                                             R!get_o (r1),
                                                             R!get_m (r1))))
                            by step <9>1
                               hypothesis H1
                               (* property beq_symm, beq_trans *)
                       <9>f qed
                            by step <9>2
                               property right_substitution
                     <8>f qed
                          by step <8>1
                             property add_mem, equal_symmetric
                   <7>f qed
                        by step <7>1
                           hypothesis H3
                 <6>f qed
                      by step <6>1
                         definition of sem_req_get
               <5>2 prove sem_req_rel (r1, st2)
                 <6>1 prove R!is_rel (r1) ->
                            ~ S_a!est_element (A!create (R!get_s (r1),
                                                         R!get_o (r1),
                                                         R!get_m (r1)),
                                               lambda (st2))
                   <7>1 prove ~ R!is_rel (r1)
                        by hypothesis H3
                           property R!get_is_not_rel
                   <7>f qed
                        by step <7>1
                 <6>f qed
                      by step <6>1
                         definition of sem_req_rel
               <5>f qed
                    by step <5>1, <5>2
                       definition of sem_req
             <4>f qed
                  by step <4>1
           <3>3 hypothesis H32: ~ fd (A!create (R!get_s (r1),
               R!get_o (r1),
               R!get_m (r1))),
                prove D!equal (d1, D!yes) ->
                      sem_req (r1, st2)
             <4>1 prove ~ D!equal (d1, D!yes)
               <5>10 prove R!is_get (r1) ->
                           (~ fd (A!create (R!get_s (r1),
                                            R!get_o (r1),
                                            R!get_m (r1)))) ->
                           tau_hru (r1, st1) = (D!no, st1)
                     by (* property beq_refl *)
                        definition of tau_hru
               <5>11 prove (~ fd (A!create (R!get_s (r1),
                                            R!get_o (r1),
                                            R!get_m (r1)))) ->
                           tau_hru (r1, st1) = (D!no, st1)
                     by step <5>10
                        hypothesis H3
               <5>1 prove tau_hru (r1, st1) = (D!no, st1)
                    by step <5>11
                       hypothesis H32
               <5>2 prove (d1, st2) = (D!no, st1)
                    by step <5>1
                       hypothesis H1
                       (* property beq_trans, beq_symm *)
               <5>3 prove D!equal (d1, D!no)
                    by step <5>2
                       property left_substitution
               <5>f qed
                    by step <5>3
                       property D!yes_is_not_no
             <4>f qed
                  by step <4>1
           <3>f qed
                by step <3>2, <3>3
         <2>3 hypothesis H4: R!is_rel (r1),
              prove D!equal (d1, D!yes) ->
                    sem_req (r1, st2)
           <3>1 hypothesis H2bis: D!equal (d1, D!yes),
                prove sem_req (r1, st2)
             <4>1 prove sem_req_get (r1, st2)
               <5>1 prove R!is_get (r1) ->
                          S_a!est_element (A!create (R!get_s (r1),
                                                     R!get_o (r1),
                                                     R!get_m (r1)),
                                           lambda (st2))
                 <6>1 prove ~ R!is_get (r1)
                      by hypothesis H4
                         property R!get_is_not_rel
                 <6>f qed
                      by step <6>1
               <5>f qed
                    by step <5>1
                       definition of sem_req_get
             <4>2 prove sem_req_rel (r1, st2)
               <5>1 prove R!is_rel (r1) ->
                          ~ S_a!est_element (A!create (R!get_s (r1),
                                                       R!get_o (r1),
                                                       R!get_m (r1)),
                                             lambda (st2))
                 <6>1 prove ~ S_a!est_element (A!create (R!get_s (r1),
                                                         R!get_o (r1),
                                                         R!get_m (r1)),
                                               lambda (st2))
                   <7>1 prove equal (st2,
                                     del (st1, A!create(R!get_s (r1),
                                                        R!get_o (r1),
                                                        R!get_m (r1))))
                     <8>1 prove (~ R!is_get (r1)) ->
                                tau_hru (r1, st1) =
                                (D!yes, del (st1, A!create (R!get_s (r1),
                                                            R!get_o (r1),
                                                            R!get_m (r1))))
                          by (* property beq_refl *)
                             definition of tau_hru
                     <8>2 prove tau_hru (r1, st1) =
                               (D!yes, del (st1, A!create(R!get_s (r1),
                                                          R!get_o (r1),
                                                          R!get_m (r1))))
                          by step <8>1
                             hypothesis H4
                             property R!get_is_not_rel
                     <8>3 prove (d1, st2) =
                                (D!yes, del (st1, A!create (R!get_s (r1),
                                                            R!get_o (r1),
                                                            R!get_m (r1))))
                          by step <8>2
                             hypothesis H1
                             (* property beq_trans, beq_symm *)
                     <8>f qed
                          by step <8>3
                             property right_substitution
                   <7>f qed
                        by step <7>1
                           property del_mem, equal_symmetric
                 <6>f qed
                      by step <6>1
                         hypothesis H4
               <5>f qed
                    by step <5>1
                       definition of sem_req_rel
             <4>f qed
                  by step <4>1, <4>2
                     definition of sem_req
           <3>f qed
                 by step <3>1
         <2>f qed
              by step <2>2, <2>3
                 property R!get_or_rel
       <1>f conclude
 ;

  theorem tau_hru_correct_bis :
    all st1 st2 : Self, all r1 : R, all d1 : D,
      tau_hru (r1, st1) = (d1, st2) ->
        D!equal (d1, D!no) ->
          equal (st1, st2)
    proof =
      <1>1 assume st1 st2 : Self, r1 : R, d1 : D,
           hypothesis H1: tau_hru (r1, st1) = (d1, st2),
           prove D!equal (d1, D!no) ->
                 equal (st1, st2)
        <2>2 hypothesis H3: R!is_get (r1),
             prove D!equal (d1, D!no) ->
                   equal (st1, st2)
          <3>2 hypothesis H31: fd (A!create (R!get_s (r1),
            R!get_o (r1),
            R!get_m (r1))),
               prove D!equal (d1, D!no) ->
                     equal (st1, st2)
            <4>1 prove ~ D!equal (d1, D!no)
              <5>10 prove R!is_get (r1) ->
                          fd (A!create (R!get_s (r1),
                                        R!get_o (r1),
                                        R!get_m (r1))) ->
                          tau_hru (r1, st1) =
                          (D!yes, add (st1, A!create (R!get_s (r1),
                                                      R!get_o (r1),
                                                      R!get_m (r1))))
                    by (* property beq_refl *)
                       definition of tau_hru
              <5>11 prove fd (A!create (R!get_s (r1),
                                        R!get_o (r1),
                                        R!get_m (r1))) ->
                          tau_hru (r1, st1) =
                          (D!yes, add (st1, A!create (R!get_s (r1),
                                                      R!get_o (r1),
                                                      R!get_m (r1))))
                    by step <5>10
                       hypothesis H3
              <5>1 prove tau_hru (r1, st1) =
                         (D!yes, add (st1, A!create (R!get_s (r1),
                                                     R!get_o (r1),
                                                     R!get_m (r1))))
                   by step <5>11
                      hypothesis H31
              <5>2 prove (d1, st2) =
                         (D!yes, add (st1, A!create (R!get_s (r1),
                                                     R!get_o (r1),
                                                     R!get_m (r1))))
                   by step <5>1
                      hypothesis H1
                      (* property beq_trans, beq_symm *)
              <5>3 prove D!equal (d1, D!yes)
                   by step <5>2
                      property left_substitution
              <5>f qed
                   by step <5>3
                      property D!yes_is_not_no
            <4>f qed
                 by step <4>1
          <3>3 hypothesis H32: ~ fd (A!create (R!get_s (r1),
              R!get_o (r1),
              R!get_m (r1))),
               prove D!equal (d1, D!no) ->
                     equal (st1, st2)
            <4>1 hypothesis H2: D!equal (d1, D!no),
                 prove equal (st1, st2)
              <5>1 prove R!is_get (r1) ->
                         (~ fd (A!create (R!get_s (r1),
                                          R!get_o (r1),
                                          R!get_m (r1)))) ->
                         tau_hru (r1, st1) = (D!no, st1)
                   by (* property beq_refl *)
                      definition of tau_hru
              <5>2 prove (~ fd (A!create (R!get_s (r1),
                                          R!get_o (r1),
                                          R!get_m (r1)))) ->
                         tau_hru (r1, st1) = (D!no, st1)
                   by step <5>1
                      hypothesis H3
              <5>3 prove tau_hru (r1, st1) = (D!no, st1)
                   by step <5>2
                      hypothesis H32
              <5>4 prove (d1, st2) = (D!no, st1)
                   by step <5>3
                      hypothesis H1
                      (* property beq_symm, beq_trans *)
              <5>f qed
                   by step <5>4
                      property right_substitution, equal_symmetric
            <4>f qed
                 by step <4>1
          <3>f qed
               by step <3>2, <3>3
        <2>3 hypothesis H4: R!is_rel (r1),
             prove D!equal (d1, D!no) ->
                   equal (st1, st2)
          <3>1 prove ~ D!equal (d1, D!no)
            <4>10 prove (~ R!is_get (r1)) ->
                        tau_hru (r1, st1) =
                        (D!yes, del (st1, A!create (R!get_s (r1),
                                                    R!get_o (r1),
                                                    R!get_m (r1))))
                  by (* property beq_refl *)
                     definition of tau_hru
            <4>1 prove tau_hru (r1, st1) =
                       (D!yes, del (st1, A!create (R!get_s (r1),
                                                   R!get_o (r1),
                                                   R!get_m (r1))))
                 by step <4>10
                    hypothesis H4
                    property R!get_is_not_rel
            <4>2 prove (d1, st2) =
                       (D!yes, del (st1, A!create (R!get_s (r1),
                                                   R!get_o (r1),
                                                   R!get_m (r1))))
                 by step <4>1
                    hypothesis H1
                    (* property beq_trans, beq_symm *)
            <4>3 prove D!equal (d1, D!yes)
                 by step <4>2
                    property left_substitution
            <4>f qed
                 by step <4>3
                    property D!yes_is_not_no
          <3>f qed
               by step <3>1
        <2>f qed
             by step <2>2, <2>3
                property R!get_or_rel
      <1>f conclude
 ;

end;;

(** Access Control List (ACL) *)

(** An ACL state contains security information given by the function acl *)
species States_acl (Rh is Rho,
                    S is Subjects, O is Objects, M is Access_mode,
                    A is Access (S, O, M), S_a is Set_of (A),
                    C is Pair (S, M), S_s_m is Set_of (C)) =

  inherit States (Rh, S, O, M, A, S_a);

  (** Incorrect *)
  signature acl : O -> S_s_m;

end;;

(** The ACL is the same as the HRU policy *)
species Policy_acl (Rh is Rho,
                    S is Subjects, O is Objects, M is Access_mode,
                    A is Access (S, O, M), S_a is Set_of (A),
                    C is Pair (S, M), S_s_m is Set_of (C)) =

  inherit
    Policy_hru (Rh, S, O, M, A, S_a),
    States_acl (Rh, S, O, M, A, S_a, C, S_s_m);

  (** Definition of the function fd *)
  let fd (ac) =
     S_s_m!est_element (C!create (A!get_s (ac), A!get_m (ac)),
                        acl (A!get_o (ac)));

end;;

(** The ACL transition function is the same as the HRU transition function *)
species Model_acl (Rh is Rho,
                   S is Subjects, O is Objects, M is Access_mode,
                   A is Access (S, O, M), S_a is Set_of (A),
                   R is Requests_gal (S, O, M),
                   D is Decisions,
                   C is Pair (S, M), S_s_m is Set_of(C)) =

  inherit
    Policy_acl (Rh, S, O, M, A, S_a, C, S_s_m),
    Model_hru (Rh, S, O, M, A, S_a, R, D);

end
;;

(** Capabilities *)

(**
   A Capabilities state contains security information given by the function
   capabilities
 *)
species States_capabilities (Rh is Rho,
                             S is Subjects, O is Objects, M is Access_mode,
                             A is Access (S, O, M), S_a is Set_of (A),
                             C is Pair (O, M), S_o_m is Set_of (C)) =

  inherit States (Rh, S, O, M, A, S_a);

  (** Returns the set of permissions associated with the given subject *)
  signature capabilities :  S -> S_o_m;

end;;

(** The Capabilities policy is the same as the HRU policy *)
species Policy_capabilities (Rh is Rho,
                             S is Subjects, O is Objects, M is Access_mode,
                             A is Access (S, O, M), S_a is Set_of (A),
                             C is Pair (O, M), S_o_m is Set_of (C)) =

  inherit
    Policy_hru (Rh, S, O, M, A, S_a),
    States_capabilities (Rh, S, O, M, A, S_a, C, S_o_m);

  (** Definition of the function fd *)
  let fd (ac) =
     S_o_m!est_element (C!create (A!get_o (ac), A!get_m (ac)),
                        capabilities (A!get_s (ac)));

end
;;

(**
   The Capabilities transition function is the same as the HRU transition
   function
 *)
species Model_capabilities (Rh is Rho,
                            S is Subjects, O is Objects, M is Access_mode,
                            A is Access (S, O, M), S_a is Set_of (A),
                            R is Requests_gal (S, O, M),
                            D is Decisions,
                            C is Pair (O, M),
                            S_o_m is Set_of (C)) =

  inherit
    Policy_capabilities (Rh, S, O, M, A, S_a, C, S_o_m),
    Model_hru (Rh, S, O, M, A, S_a, R, D);

end
;;

(** Unix *)

(** The species representing the groups of the Unix model *)
species Groups =

  inherit Setoid;

end;;

(** The security parameter of the Unix model is composed of groups *)
species Rho_unix (G is Groups) =

  inherit Rho;

end;;

(**
   A Unix state contains security information given by :
   - A set AG &sube; Groups
   - A set SU &sube; Subjects
   - A function f_p : Objects &rarr; Subjects
   - A function f_g : Objects &rarr; Groups
   - A function f_s : Subjects &rarr; &weierp;(Groups)
   - A function f_d_p : Objects &rarr; &weierp;(Access_mode)
   - A function f_d_g : Objects &rarr; &weierp;(Access_mode)
   - A function f_d_o : Objects &rarr; &weierp;(Access_mode)
 *)
species States_unix (G is Groups, Rh is Rho_unix (G),
                     S is Subjects, O is Objects, M is Access_mode,
                     A is Access (S, O, M), S_a is Set_of (A),
                     S_m is Set_of (M), S_g is Set_of (G)) =

  inherit States (Rh, S, O, M, A, S_a);

  (**
     Returns true if the given group belongs to the set of active groups (AG),
     false otherwise
   *)
  signature ag : Self -> G -> bool;

  (**
     Returns true if the given subject belongs to the set of super-users (SU),
     false otherwise
   *)
  signature su : Self -> S -> bool;

  (** Returns the owner of the given object *)
  signature f_p : Self -> O -> S;

  (** Returns the group associated with the given object *)
  signature f_g : Self -> O -> G;

  (** Returns the set of groups to which belongs the given subject *)
  signature f_s : Self -> S -> S_g;

  (** Returns the owner's rights of the given object *)
  signature f_d_p : Self -> O -> S_m;

  (** Returns the group's rights of the given object *)
  signature f_d_g : Self -> O -> S_m;

  (** Returns the others' rights of the given object *)
  signature f_d_o : Self -> O -> S_m;

  (** Add a group to the given state's active groups *)
  signature add_ag : Self -> G -> Self;

  (** Remove a group from the given state's active groups *)
  signature rm_ag : Self -> G -> Self;

  (** Add a subject to the given state's super-users *)
  signature add_su : Self -> S -> Self;

  (** Remove a subject from the given state's super-users *)
  signature rm_su : Self -> S -> Self;

  (** Set the given subject as the owner of the given object *)
  signature chown : Self -> O -> S -> Self;

  (** Set the given group as the group to which belongs the given object *)
  signature chgrp : Self -> O -> G -> Self;

  (**
     Add the given group to the set of groups to which belongs the given
     subject
   *)
  signature add_g_s : Self -> S -> G -> Self;

  (**
     Remove the given group from the set of groups to which belongs the given
     subject
   *)
  signature rm_g_s : Self -> S -> G -> Self;

  (** Add the given access mode to the owner's rights of the given object *)
  signature add_d_p : Self -> O -> M -> Self;

  (**
     Remove the given access mode from the owner's rights of the given object
   *)
  signature rm_d_p : Self -> O -> M -> Self;

  (** Add the given access mode to the group's rights of the given object *)
  signature add_d_g : Self -> O -> M -> Self;

  (**
     Remove the given access mode from the group's rights of the given object
   *)
  signature rm_d_g : Self -> O -> M -> Self;

  (** Add the given access mode to the others' rights of the given object *)
  signature add_d_o : Self -> O -> M -> Self;

  (**
     Remove the given access mode from the others' rights of the given object
   *)
  signature rm_d_o : Self -> O -> M -> Self;

end;;

(** Definition of the Unix security predicate *)
species Policy_unix (G is Groups, Rh is Rho_unix (G),
                     S is Subjects, O is Objects, M is Access_mode,
                     A is Access (S, O, M), S_a is Set_of (A),
                     S_m is Set_of (M), S_g is Set_of (G)) =

  inherit
    States_unix (G, Rh, S, O, M, A, S_a, S_m, S_g),
    Policy (Rh, S, O, M, A, S_a);

  (** f_p(op) = sp &and; mp &isin; f_d_p(op) *)
  logical let owner_access (st : Self) =
     all sp : S, all op : O, all mp : M,
       S!equal (f_p (st, op), sp) /\
       S_m!est_element (mp, f_d_p (st, op));

  (** f_p(op) &ne; sp &and; f_g(op) &isin; f_s(sp) &and; mp &isin; f_d_g(op) *)
  logical let group_access (st : Self) =
     all sp : S, all op : O, all mp : M,
     (~ S!equal (f_p (st, op), sp)) /\
     S_g!est_element (f_g (st, op), f_s (st, sp)) /\
     S_m!est_element (mp, f_d_g (st, op));

  (** f_p(op) &ne; sp &and; f_g(op) &notin; f_s(sp) &and; mp &isin; f_d_o(op) *)
  logical let others_access (st : Self) =
     all sp : S, all op : O, all mp : M,
     (~ S!equal (f_p (st, op), sp)) /\
     (~ S_g!est_element (f_g (st, op), f_s (st, sp))) /\
     S_m!est_element (mp, f_d_o (st, op));

  (**
     If an access (sp,op,mp) belongs to the current accesses of a state
     then sp can access op thanks to the owner's rights (owner_access) or
     thanks to the group's rights (group_access) or
     thanks to the others' rights (others_access) or
     because sp is a super-user
   *)
  logical let omega (st : Self) =
     all sp : S, all op : O, all mp : M,
       S_a!est_element (A!create (sp, op, mp), lambda (st)) ->
         (owner_access (st) \/
          group_access (st) \/
          others_access (st) \/
          su (st, sp));

end;;

(** The species representing the rights of the Unix model *)
species Rights =

  inherit Setoid;

  (** The right "owner" *)
  signature d_p : Self;

  (** The right "group" *)
  signature d_g : Self;

  (** The right "others" *)
  signature d_o : Self;

end;;

(**
   The administrative requests of the Unix model :
   - &lang; +active,s,g &rang; : the subject s asks to activate the group g
   - &lang; -inactive,s,g &rang; : the subject s asks to deactivate the group g
   - &lang; +right,s,o,a,z &rang; : the subject s asks to add the access mode
     a to the z's right of the object o
   - &lang; -right,s,o,a,z &rang; : the subject s asks to remove the access
     mode a from the z's right of the object o
   - &lang; +chown,s1,o,s2 &rang; : the subject s1 asks to give the ownership
     over the object o to the subject s2
   - &lang; +chgrp,s,o,g &rang; : the subject s asks to change the goup of the
     object o to the group g
   - &lang; +group,s1,s2,g &rang; : the subject s1 asks to add the group g to
     subject s2's groups
   - &lang; -group,s1,s2,g &rang; : the subject s1 asks to remove the group g
     from subject s2's groups
 *)
species Requests_adm_unix (S is Subjects, O is Objects, M is Access_mode,
                           G is Groups, Z is Rights) =

  inherit Requests;

  (** Returns the group involved in the given administrative request *)
  signature get_g : Self -> G;

  (** Returns the right involved in the given administrative request *)
  signature get_z : Self -> Z;

  (**
     Returns the second subject involved in the given administrative request
   *)
  signature get_s2 : Self -> S;

  (**
     Returns true if the given administrative request is a "+active" request,
     false otherwise
   *)
  signature is_active : Self -> bool;

  (**
     Returns true if the given administrative request is a "-inactive"
     request, false otherwise
   *)
  signature is_inactive : Self -> bool;

  (**
     Returns true if the given administrative request is a "+right" request,
     false otherwise
   *)
  signature is_add_right : Self -> bool;

  (**
     Returns true if the given administrative request is a "-right" request,
     false otherwise
   *)
  signature is_rm_right : Self -> bool;

  (**
     Returns true if the right involved in the given administrative request
     is the right "owner", false otherwise
   *)
  signature is_d_p : Self -> bool;

  (**
     Returns true if the right involved in the given administrative request
     is the right "group", false otherwise
   *)
  signature is_d_g : Self -> bool;

  (**
     Returns true if the right involved in the given administrative request
     is the right "others", false otherwise
   *)
  signature is_d_o : Self -> bool;

  (**
     Returns true if the given administrative request is a "+chown" request,
     false otherwise
   *)
  signature is_chown : Self -> bool;

  (**
     Returns true if the given administrative request is a "+chgrp" request,
     false otherwise
   *)
  signature is_chgrp : Self -> bool;

  (**
     Returns true if the given administrative request is a "+group" request,
     false otherwise
   *)
  signature is_add_group : Self -> bool;

  (**
     Returns true if the given administrative request is a "-group" request,
     false otherwise
   *)
  signature is_rm_group : Self -> bool;

end;;

(**
   The requests of the Unix model are the general requests and
   the Unix administrative requests
 *)
species Requests_unix (S is Subjects, O is Objects, M is Access_mode,
                       G is Groups, Z is Rights) =

  inherit
    Requests_gal (S, O, M),
    Requests_adm_unix (S, O, M, G, Z);

end
;;

(** Definition of the Unix transition function (reference monitor) *)
species Models_unix (G is Groups, Rh is Rho_unix (G),
                     S is Subjects, O is Objects, M is Access_mode,
                     A is Access (S, O, M), S_a is Set_of (A),
                     S_m is Set_of (M), S_g is Set_of (G),
                     Z is Rights,
                     R is Requests_unix (S, O, M, G, Z),
                     D is Decisions) =

  inherit
    Policy_unix (G, Rh, S, O, M, A, S_a, S_m, S_g),
    Semantics_requests_gal (Rh, S, O, M, A, S_a, R),
    Models (Rh, S, O, M, A, S_a, R, D);

  (** Unix transition function on accesses *)
  let tau_unix_acc (r1 : R, st : Self) =
     let sp = R!get_s (r1) in
     let op = R!get_o (r1) in
     let mp = R!get_m (r1) in
     if R!is_get (r1) then
       if (S!equal (f_p (st, op), sp) &&
           S_m!est_element (mp, f_d_p (st, op)))
          ||
          (~~ (S!equal (f_p (st, op), sp)) &&
           S_g!est_element (f_g (st, op), f_s (st, sp)) &&
           S_m!est_element (mp, f_d_g (st, op)))
          ||
          (~~ (S!equal (f_p (st, op), sp)) &&
           ~~ (S_g!est_element (f_g (st, op), f_s (st, sp))) &&
           S_m!est_element (mp, f_d_o (st, op)))
          ||
          su (st, sp)
       then (D!yes, add (st, A!create (sp, op, mp)))
       else (D!no, st)
     else (D!yes, del (st, A!create (sp, op, mp)));

  (**
     Returns true if the given access ac satisfies the conditions needed to
     apply the request "-inactive", false otherwise
   *)
  let predicate_inactive (st, ga, ac) =
     let sp = A!get_s (ac) in
     let od = A!get_o (ac) in
     let md = A!get_m (ac) in
     ~~ (~~ (S!equal (sp, f_p (st, od))) &&
            S_g!est_element (f_g (st, od), f_s (st, sp)) &&
            ~~ (S_m!est_element (md, f_d_o (st, od))) &&
            G!equal (f_g (st, od), ga) &&
            ~~ (su (st, sp)));

  (**
     Returns true if the given access ac satisfies the conditions needed to
     apply the request "+right" with the right "owner", false otherwise
   *)
  let predicate_right_d_p (st, sa, oa, ma, ac) =
     let sp = A!get_s (ac) in
     let od = A!get_o (ac) in
     let md = A!get_m (ac) in
     ~~ (A!equal (A!create (sp, od, md), A!create (sa, oa, ma)) &&
         ~~ (su (st, sp)));

  (**
     Returns true if the given access ac satisfies the conditions needed to
     apply the request "+right" with the right "group", false otherwise
   *)
  let predicate_right_d_g (st, oa, ma, ac) =
     let sp = A!get_s (ac) in
     let od = A!get_o (ac) in
     let md = A!get_m (ac) in
     ~~ (O!equal (od, oa) &&
            M!equal (md, ma) &&
            S_g!est_element (f_g (st, od), f_s (st, sp)) &&
            S_m!est_element (md, f_d_g (st, od)) &&
            ~~ (su (st, sp)));

  (**
     Returns true if the given access ac satisfies the conditions needed to
     apply the request "+right" with the right "others", false otherwise
   *)
  let predicate_right_d_o (st, oa, ma, ac) =
     let sp = A!get_s (ac) in
     let od = A!get_o (ac) in
     let md = A!get_m (ac) in
     ~~ (O!equal (od, oa) &&
            M!equal (md, ma) &&
            ~~ (S_g!est_element (f_g (st, od), f_s (st, sp))) &&
            ~~ (S!equal (sp, f_p(st, od))) &&
            ~~ (su (st, sp)));

  (**
     Returns true if the given access ac satisfies the conditions needed to
     apply the request "+chown", false otherwise
   *)
  let predicate_chown (st, oa, s2a, ac) =
     let sp = A!get_s (ac) in
     let od = A!get_o (ac) in
     let md = A!get_m (ac) in
     ~~ (O!equal (od, oa)
            &&
            (((S!equal (f_p (st, oa), sp) &&
               S_m!est_element (md, f_d_p (st, oa)))
              &&
              ((~~ (S_m!est_element (md, f_d_g (st, oa))) &&
        ~~ (S_g!est_element (f_g (st, oa), f_s (st, sp))))
              ||
              ~~ (S_m!est_element (md, f_d_o (st, oa)))))
            ||
             (S!equal (sp, s2a) &&
              ~~ (S_m!est_element (md, f_d_p (st, oa)))))
            &&
            ~~ (su (st, sp))
            &&
            ~~ (su (st, s2a)));

  (**
     Returns true if the given access ac satisfies the conditions needed to
     apply the request "+chgrp", false otherwise
   *)
  let predicate_chgrp (st, oa, ga, ac) =
     let sp = A!get_s (ac) in
     let od = A!get_o (ac) in
     let md = A!get_m (ac) in
     ~~ (O!equal (oa, od)
           &&
            ((~~ (S!equal (sp, f_p (st, oa))) &&
              S_g!est_element (f_g (st, od), f_s (st, sp)) &&
              ~~ (S_g!est_element (ga, f_s (st, sp))) &&
              ~~ (S_m!est_element (md, f_d_o (st, od))))
            ||
             (~~ (S!equal (sp, f_p (st, oa))) &&
              ~~ (S_g!est_element (f_g (st, oa), f_s (st, sp))) &&
              S_g!est_element (ga, f_s (st, sp)) &&
              ~~ (S_m!est_element (md, f_d_g (st, od)))))
           &&
           ~~ (su (st, sp)));

  (**
     Returns true if the given access ac satisfies the conditions needed to
     apply the request "+group", false otherwise
   *)
  let predicate_pls_grp (st, ga, s2a, ac) =
     let sp = A!get_s (ac) in
     let od = A!get_o (ac) in
     let md = A!get_m (ac) in
     ~~ (S!equal (sp, s2a) &&
            ~~ (S!equal (s2a, f_p(st, od))) &&
            G!equal (f_g (st, od), ga) &&
            ~~ (S_g!est_element (f_g (st, od), f_s (st, s2a))) &&
            ~~ (S_m!est_element (md, f_d_g (st, od))) &&
            ~~ (su (st, sp)));

  (**
     Returns true if the given access ac satisfies the conditions needed to
     apply the request "-group", false otherwise
   *)
  let predicate_mns_grp (st, ga, s2a, ac) =
     let sp = A!get_s (ac) in
     let od = A!get_o (ac) in
     let md = A!get_m (ac) in
     ~~ (S!equal (sp, s2a) &&
            S_m!est_element (md, f_d_g (st, od)) &&
            G!equal (f_g (st, od), ga) &&
            ~~ (S_m!est_element (md, f_d_o (st, od))) &&
            ~~ (su (st, sp)));

  (** Unix administrative transition function *)
  let tau_unix_adm (r1 : R, st : Self) =
     if R!is_active (r1) then
       (* <+active,s,g> *)
       let sp = R!get_s (r1) in
       let sg = R!get_g (r1) in
       if su (st, sp)
       then (D!yes, add_ag (st, sg))
       else (D!no, st)
     else if R!is_inactive (r1) then
       (* <-active,s,g> *)
       let sp = R!get_s (r1) in
       let sg = R!get_g (r1) in
       if su (st, sp) &&
          ag (st, sg) &&
          S_a!for_all (lambda (st), predicate_inactive (st, sg))
       then (D!yes, rm_ag (st, sg))
       else (D!no, st)
     else if R!is_add_right (r1) then
       let ss = R!get_s (r1) in
       let so = R!get_o (r1) in
       let sm = R!get_m (r1) in
       (* same condition for all the requests <+right,...> *)
       if S!equal (ss, f_p (st, so)) || su (st, ss) then
         if R!is_d_p (r1) then
           (* <+right,s,o,a,DP> *)
           (D!yes, add_d_p (st, so, sm))
         else if R!is_d_g (r1) then
           (* <+right,s,o,a,DG> *)
           (D!yes, add_d_g (st, so, sm))
         else
           (* <+right,s,o,a,DO> *)
           (D!yes, add_d_o (st, so, sm))
       else (D!no, st)
     else  if R!is_rm_right (r1) then
       let ss = R!get_s (r1) in
       let so = R!get_o (r1) in
       let sm = R!get_m (r1) in
       if R!is_d_p (r1) then
         (* <-right,s,o,a,DP> *)
         if (S!equal (ss, f_p (st, so)) || su (st, ss)) &&
            S_a!for_all (lambda (st), predicate_right_d_p (st, ss, so, sm))
         then (D!yes, rm_d_p (st, so, sm))
         else (D!no, st)
       else if R!is_d_g (r1) then
         (* <-right,s,o,a,DG> *)
         if (S!equal (ss, f_p (st, so)) || su (st, ss)) &&
            S_a!for_all (lambda (st), predicate_right_d_g (st, so, sm))
         then (D!yes, rm_d_g (st, so, sm))
         else (D!no, st)
       else if (S!equal (ss, f_p (st, so)) || su (st, ss)) &&
               S_a!for_all (lambda (st), predicate_right_d_o (st, so, sm))
            (* <-right,s,o,a,DO> *)
       then (D!yes, rm_d_o (st, so, sm))
       else (D!no, st)
     else if R!is_chown (r1) then
       (* <+chown,s1,o,s2> *)
       let ss = R!get_s (r1) in
       let so = R!get_o (r1) in
       let ss2 = R!get_s2 (r1) in
       if su (st, ss) &&
          S_a!for_all (lambda (st), predicate_chown (st, so, ss2))
       then (D!yes, chown (st, so, ss2))
       else (D!no, st)
     else if R!is_chgrp (r1) then
       (* <+chgrp,s,o,g> *)
       let ss = R!get_s (r1) in
       let so = R!get_o (r1) in
       let sg = R!get_g (r1) in
       if su (st, ss) &&
          S_a!for_all (lambda (st), predicate_chgrp (st, so, sg))
       then (D!yes, chgrp (st, so, sg))
       else (D!no, st)
     else if R!is_add_group (r1) then
       let ss = R!get_s (r1) in
       let ss2 = R!get_s2 (r1) in
       let sg = R!get_g (r1) in
       (* <+group,s1,s2,g> *)
       if su (st, ss) &&
          S_a!for_all (lambda (st), predicate_pls_grp (st, sg, ss2))
       then (D!yes, add_g_s (st, ss2, sg))
       else (D!no, st)
     else if R!is_rm_group (r1) then
       let ss = R!get_s (r1) in
       let ss2 = R!get_s2 (r1) in
       let sg = R!get_g (r1) in
       (* <-group,s1,s2,g> *)
       if su (st, ss) &&
          S_a!for_all (lambda (st), predicate_mns_grp (st, sg, ss2)) &&
          S_g!est_element (sg, f_s (st, ss2))
       then (D!yes, rm_g_s (st, ss2, sg))
       else (D!no, st)
     else (D!no, st);

  (** Unix transition function *)
  let tau_unix (r1 : R, st : Self) =
     if R!is_get (r1) || R!is_rel (r1)
     then tau_unix_acc (r1, st)
     else tau_unix_adm (r1, st);

end;;

(** Tickets *)

(**
   The species representing the unforgeable capabilities (tickets) of the
   Tickets model
 *)
species Tickets =

 inherit Setoid;

end;;

(** The security parameter of the Tickets model is composed of tickets *)
species Rho_ticket (C is Tickets) =

  inherit Rho;

end;;

(**
   A Tickets state contains security information given by :
   - A set UC &sube; Tickets
   - A function T : Objects &rarr; Access_mode &rarr; &weierp;(Tickets)
   - A function W : Subjects &rarr; &weierp;(Tickets)
   - A function Owner : Objects &rarr; Subjects
 *)
species States_ticket (C is Tickets, Rh is Rho_ticket (C),
                       S is Subjects, O is Objects, M is Access_mode,
                       A is Access (S, O, M), S_a is Set_of (A)) =

  inherit States (Rh, S, O, M, A, S_a);

  (**
     Returns true if the given ticket belongs to the set of used tickets (UC),
     false otherwise
   *)
  signature uc : Self -> C -> bool;

  (**
     Returns true if the given ticket is associated with the given object and
     access mode according to the function T, false otherwise
   *)
  signature t : Self -> O -> M -> C -> bool;

  (**
     Returns true if the given ticket is associated with the given subject
     according to the function W, false otherwise
   *)
  signature w : Self -> S -> C -> bool;

  (**
     Returns true if the given subject is the owner of the given object,
     false otherwise
   *)
  signature owner : Self -> O -> S -> bool;

  (**
     Returns true if a ticket satisfying three predicates is found,
     false otherwise
   *)
  signature exists_ticket :
            Self -> (C -> bool) -> (C -> bool) -> (C -> bool) -> bool;

  (**
     Updates the given state's security information concerning the given ticket
   *)
  signature map_ticket : Self -> C -> Self;

  (** Add the given ticket to the set of used tickets *)
  signature add_uc : Self -> C -> Self;

  (** Remove the given ticket from the set of used tickets *)
  signature rm_uc : Self -> C -> Self;

  (**
     Add the given ticket to the set returned by the given state's T function
     when applied to the given object and access mode
   *)
  signature add_t : Self -> O -> M -> C -> Self;

  (**
     Remove the given ticket from the set returned by the given state's T
     function when applied to the given object and access mode
   *)
  signature rm_t : Self -> O -> M -> C -> Self;

  (**
     Add the given ticket to the set returned by the given state's W function
     when applied to the given subject
   *)
  signature add_w : Self -> S -> C -> Self;

  (**
     Remove the given ticket from the set returned by the given state's W
     function when applied to the given subject
   *)
  signature rm_w : Self -> S -> C -> Self;

end;;

(** Definition of the Tickets security predicate *)
species Policy_ticket (C is Tickets, Rh is Rho_ticket (C),
                       S is Subjects, O is Objects, M is Access_mode,
                       A is Access (S, O, M), S_a is Set_of (A)) =

  inherit
    States_ticket (C, Rh, S, O, M, A, S_a),
    Policy (Rh, S, O, M, A, S_a);

  (**
     If an access (sp,op,mo) belongs to the current accesses of a state
     then there exists a ticket ct such that ct belongs to W(sp) and T(op,mo)
   *)
  logical let omega (st : Self) =
     all sp : S, all op : O, all mo : M,
       ex ct : C,
         S_a!est_element (A!create (sp, op, mo), lambda (st)) ->
           (w (st, sp, ct) /\ t (st, op, mo, ct));

end;;

(**
   The administrative requests of the Tickets model :
   - &lang; +generate,s,c,o,a &rang; : the subject s asks to generate a
     ticket c corresponding to the permission (o,a)
   - &lang; +pass,s1,c,s2 &rang; : the subject s1 asks to give the ticket c
     to the subject s2
   - &lang; -remove,c,o,a, &rang; : the request allowing to ask to remove the
     ticket c corresponding to the permission (o,a)
 *)
species Requests_adm_ticket (S is Subjects, O is Objects, M is Access_mode,
                             C is Tickets) =

  inherit Requests;

  (** Returns the ticket involved in the given administrative request *)
  signature get_c : Self -> C;

  (**
     Returns the second subject involved in the given administrative request
   *)
  signature get_s2 : Self -> S;

  (**
     Returns true if the given administrative request is a "+generate"
     request, false otherwise
   *)
  signature is_generate : Self -> bool;

  (**
     Returns true if the given administrative request is a "+pass" request,
     false otherwise
   *)
  signature is_pass : Self -> bool;

  (**
     Returns true if the given administrative request is a "-remove" request,
     false otherwise
   *)
  signature is_remove : Self -> bool;

end;;

(**
   The requests of the Tickets model are the general requests and
   the Tickets administrative requests
 *)
species Requests_ticket (S is Subjects, O is Objects, M is Access_mode,
                         C is Tickets) =

  inherit
    Requests_gal (S, O, M),
    Requests_adm_ticket (S, O, M, C);

end;;

(** Definition of the Tickets transition function (reference monitor) *)
species Models_ticket (C is Tickets, Rh is Rho_ticket (C),
                       S is Subjects, O is Objects, M is Access_mode,
                       A is Access (S, O, M), S_a is Set_of (A),
                       R is Requests_ticket (S, O, M, C),
                       D is Decisions) =

  inherit
    Policy_ticket (C, Rh, S, O, M, A, S_a),
    Semantics_requests_gal (Rh, S, O, M, A, S_a, R),
    Models (Rh, S, O, M, A, S_a, R, D);

  (** Tickets transition function on accesses *)
  let tau_ticket_acc (r1 : R, st1 : Self) =
     let s1 = R!get_s (r1) in
     let o1 = R!get_o (r1) in
     let m1 = R!get_m (r1) in
     if R!is_get (r1) then
       if exists_ticket (st1, uc (st1), w (st1, s1), t (st1, o1, m1))
       then (D!yes, add (st1, A!create (s1, o1, m1)))
       else (D!no, st1)
     else (D!yes, del (st1, A!create (s1, o1, m1)));

  (**
     Returns true if the given access ap satisfies the conditions needed to
     apply the request "-remove", false otherwise
   *)
  let iter_ticket (st1, c1, o1, m1, ap) =
     let sp = A!get_s (ap) in
     let op = A!get_o (ap) in
     let mp = A!get_m (ap) in
     let stp = rm_uc (rm_w (rm_t (st1, o1, m1, c1), sp, c1), c1) in
     exists_ticket (stp, uc (stp), w (stp, sp), t (stp, op, mp));

  (** Tickets administrative transition function *)
  let tau_ticket_adm (r1 : R, st1 : Self) =
     if R!is_generate (r1) then
       let s1 = R!get_s (r1) in
       let c1 = R!get_c (r1) in
       let o1 = R!get_o (r1) in
       let m1 = R!get_m (r1) in
       if ~~ (uc (st1, c1)) && owner (st1, o1, s1)
       then (D!yes, add_uc (add_w (add_t (st1, o1, m1, c1), s1, c1), c1))
       else (D!no, st1)
     else if R!is_remove (r1) then
       let c1 = R!get_c (r1) in
       let o1 = R!get_o (r1) in
       let m1 = R!get_m (r1) in
       if S_a!for_all (lambda (st1), iter_ticket (st1, c1, o1, m1))
       then (D!yes, map_ticket (rm_uc (rm_t (st1, o1, m1, c1), c1), c1))
       else (D!no, st1)
     else if R!is_pass (r1) then
       let s1 = R!get_s (r1) in
       let c1 = R!get_c (r1) in
       let s2 = R!get_s2 (r1) in
       if w (st1, s1, c1)
       then (D!yes, add_w (st1, s2, c1))
       else (D!no, st1)
     else (D!no, st1);

  (** Tickets transition function *)
  let tau_ticket (r1 : R, st1 : Self) =
     if R!is_get (r1) || R!is_rel (r1)
     then tau_ticket_acc (r1, st1)
     else tau_ticket_adm (r1, st1);

end;;
