(***********************************************************************)
(*                                                                     *)
(*                        FoCaLiZe compiler                            *)
(*                                                                     *)
(*            François Pessaux                                         *)
(*            Pierre Weis                                              *)
(*            Damien Doligez                                           *)
(*                                                                     *)
(*                               LIP6  -  INRIA Rocquencourt           *)
(*                                                                     *)
(*  Copyright 2007 LIP6 and INRIA                                      *)
(*  Distributed only by permission.                                    *)
(*                                                                     *)
(***********************************************************************)

(* $Id: hru.fcl,v 1.26 2012-02-29 18:01:39 pessaux Exp $ *)

(**
   @title Implementation of the HRU model
   @author Florian Brecht, Andrea-Diane Kadja
 *)

open "basics";;
open "sets";;
open "orders";;
open "ensembles_finis";;
open "access_control";;

(** HRU implementation *)

species S_set_of (A is Setoid) =

  inherit Set_of (A), Liste (A);

  let create (l : list (A)) : Self = l;

  let support (l : Self) : list (A) = l;

  let head (l : Self) : A =
     match l with
     | [] -> A!element
     | h :: _underscore -> h;

  let tail (l : Self) : Self =
     match l with
     | [] -> vide
     | _underscore:: t -> t;

  let rec for_all (l, p) =
     match l with
     | [] -> true
     | h :: t -> p (h) && for_all (t, p)
  termination proof = structural l ;

  let print (l) =
     let rec aux (ls) =
        match ls with
        | [] -> "]"
        | h :: t ->
            match t with
            | [] -> A!print (h) ^ "]"
            | _underscore -> A!print (h) ^ ",\n                     " ^ aux (t)
     termination proof = structural ls
     in "[" ^ aux (l);

  proof of equal_prop = assumed (* Because todo *);

  proof of singleton_prop = assumed (* Because todo *);

end
;;

species S_setoid =

  inherit Setoid;

  representation = int * string;

  let create (n : int, s : string) : Self = (n, s);

  let equal (s1, s2) =  fst (s1) = fst (s2);

  let element = (0, "element");

  let print (s) = snd (s);

  proof of equal_reflexive =
    by definition of equal;

  proof of equal_symmetric =
    by definition of equal;

  proof of equal_transitive =
    by definition of equal;

end
;;

species S_subjects =

  inherit Subjects, S_setoid;

  let therese : Self = (1, "Therese");

  let mathieu : Self = (2, "Mathieu");

  let charles : Self = (3, "Charles");

end
;;

species S_objects =

  inherit Objects, S_setoid;

  let ssurf : Self = (1, "ssurf");

  let focal_pas_a_pas : Self = (2, "focal_pas_a_pas");

  let photos_de_vacances : Self = (3, "photos_de_vacances");

end
;;

species S_access_mode =

  inherit Access_mode, S_setoid;

  let read = (1, "read");

  let write = (2, "write");

end
;;

species S_access (S_sub is S_subjects,
                  S_obj is S_objects,
                  S_acc_mod is S_access_mode) =

  inherit Access (S_sub, S_obj, S_acc_mod);

  representation = S_sub * (S_obj * S_acc_mod);

  let create (s, o, m) = (s, (o, m));

  let get_s (a) = fst (a);

  let get_o (a) = fst (snd (a));

  let get_m (a) = snd (snd (a));

  let equal (a1, a2) =
     S_sub!equal (get_s (a1), get_s (a2)) &&
     S_obj!equal (get_o (a1), get_o (a2)) &&
     S_acc_mod!equal (get_m (a1), get_m (a2));

  let element = create (S_sub!element, S_obj!element, S_acc_mod!element);

  let print(a) =
     "(" ^ S_sub!print (get_s (a)) ^
     "," ^ S_obj!print (get_o (a)) ^
     "," ^ S_acc_mod!print (get_m (a)) ^
     ")";

  proof of equal_reflexive =
    by property S_sub!equal_reflexive,
                S_obj!equal_reflexive,
                S_acc_mod!equal_reflexive
       definition of equal;

  proof of equal_symmetric =
    by property S_sub!equal_symmetric,
                S_obj!equal_symmetric,
                S_acc_mod!equal_symmetric
       definition of equal;

  proof of equal_transitive =
    by property S_sub!equal_transitive,
                S_obj!equal_transitive,
                S_acc_mod!equal_transitive
       definition of equal;

  proof of access_equal = assumed (* Because todo *);

end
;;

species S_decisions =

  inherit Decisions, S_setoid;

  let yes = (1, "yes");

  let no = (2, "no");

  proof of yes_is_not_no = assumed (* Because todo *);

end
;;

species S_get_release =

  inherit S_setoid;

  let get : Self = (1, "+");

  let rel : Self = (2, "-");

end
;;

species S_requests_gal (S is S_subjects,
                        O is S_objects,
                        M is S_access_mode,
                        Sgr is S_get_release) =

  inherit Requests_gal (S, O, M);

  representation = (Sgr * (S * (O * M)));

  let create (g : Sgr, sa : S, oa : O, ma : M) : Self =
     (g, (sa, (oa, ma)));

  let get_gr (rg : Self) : Sgr = fst (rg);

  let get_s (rg) = fst (snd (rg));

  let get_o (rg) = fst (snd (snd (rg)));

  let get_m (rg) = snd (snd (snd (rg)));

  let is_get (rg) = Sgr!equal (Sgr!get, get_gr (rg));

  let is_rel (rg) = Sgr!equal (Sgr!rel, get_gr (rg));

  let equal (rg1, rg2) =
     Sgr!equal (get_gr (rg1), get_gr (rg2)) &&
     S!equal (get_s (rg1), get_s (rg2)) &&
     O!equal (get_o (rg1), get_o (rg2)) &&
     M!equal (get_m (rg1), get_m (rg2));

  let element = create (Sgr!get, S!element, O!element, M!element);

  let print (rg) =
     "<" ^ Sgr!print (get_gr (rg)) ^
     "," ^ S!print (get_s (rg)) ^
     "," ^ O!print (get_o (rg)) ^
     "," ^ M!print (get_m( rg)) ^
     ">";

  proof of equal_reflexive =
    by property S!equal_reflexive,
                O!equal_reflexive,
                M!equal_reflexive,
                Sgr!equal_reflexive
       definition of equal;

  proof of equal_symmetric =
    by property S!equal_symmetric,
                O!equal_symmetric,
                M!equal_symmetric,
                Sgr!equal_symmetric
       definition of equal;

  proof of equal_transitive =
    by property S!equal_transitive,
                O!equal_transitive,
                M!equal_transitive,
                Sgr!equal_transitive
       definition of equal;

  proof of get_or_rel = assumed (* Because todo *);

  proof of get_is_not_rel = assumed (* Because todo *);

end
;;

species S_rho =

  inherit Rho, S_setoid;

end
;;

species S_couple (A is Setoid, B is Setoid) =

  inherit Pair (A, B);

  representation = A * B;

  let create (s1, s2) = (s1, s2);

  let first (c) = fst (c);

  let second(c) = snd (c);

  let equal (c1, c2) =
     A!equal (first (c1), first (c2)) &&
     B!equal (second (c1), second (c2));

  let element = (A!element, B!element);

  let print (c : Self) : string =
     "( " ^ A!print(first (c)) ^ " , " ^ B!print(second (c)) ^ " )";

  proof of equal_reflexive = by property A!equal_reflexive,
                                         B!equal_reflexive
                                definition of equal;

  proof of equal_symmetric = by property A!equal_symmetric,
                                         B!equal_symmetric
                                definition of equal;

  proof of equal_transitive = by property A!equal_transitive,
                                          B!equal_transitive
                                 definition of equal;

end
;;

collection C_subjects =

  implement S_subjects;

end
;;

collection C_objects =

  implement S_objects;

end
;;

collection C_access_mode =

  implement S_access_mode;

end
;;

collection C_access =

  implement S_access (C_subjects, C_objects, C_access_mode);

end
;;

collection C_set_of_access =

  implement S_set_of(C_access);

end
;;

collection C_decisions =

  implement S_decisions;

end
;;

collection C_get_release =

  implement S_get_release;

end
;;

collection C_requests_gal =

  implement
    S_requests_gal
      (C_subjects,
       C_objects,
       C_access_mode,
       C_get_release);

end
;;

collection C_rho =

  implement S_rho;

end
;;

collection C_couple_s_m =

  implement S_couple (C_subjects, C_access_mode);

end
;;

collection C_couple_o_m =

  implement S_couple (C_objects, C_access_mode);

end
;;

collection C_set_of_s =

  implement S_set_of (C_subjects);

end
;;

collection C_set_of_o =

  implement S_set_of (C_objects);

end
;;

collection C_set_of_couple_s_m =

  implement S_set_of (C_couple_s_m);

end
;;

collection C_set_of_couple_o_m =

  implement S_set_of (C_couple_o_m);

end
;;

collection C_couple_o_s_s_m =

  implement S_couple (C_objects, C_set_of_couple_s_m);

end
;;

collection C_set_of_c_o_s_s_m =

  implement S_set_of (C_couple_o_s_s_m);

end
;;

collection C_states =

  implement S_couple (C_set_of_access, C_set_of_c_o_s_s_m);

end
;;

print_string ("Les sujets:\n");;

print_string (C_subjects!print (C_subjects!therese) ^ ", " ^
              C_subjects!print (C_subjects!mathieu) ^ ", " ^
              C_subjects!print (C_subjects!charles) ^ "\n")
;;

print_string ("Les objets:\n");;

print_string (C_objects!print (C_objects!ssurf) ^ ", " ^
              C_objects!print (C_objects!focal_pas_a_pas) ^ ", " ^
              C_objects!print (C_objects!photos_de_vacances) ^ "\n")
;;

print_string ("Les modes d'acces:\n");;

print_string (C_access_mode!print (C_access_mode!read) ^ ", " ^
              C_access_mode!print (C_access_mode!write) ^ "\n")
;;

print_string ("\n");;

print_string ("Acces autorises:\n");;

print_string (C_access!print (C_access!create (C_subjects!mathieu,
                                               C_objects!ssurf,
                                               C_access_mode!write)) ^ "\n")
;;

print_string (C_access!print (C_access!create (C_subjects!mathieu,
                                               C_objects!ssurf,
                                               C_access_mode!read)) ^ "\n")
;;

print_string (C_access!print (C_access!create (C_subjects!therese,
                                               C_objects!ssurf,
                                               C_access_mode!write)) ^ "\n")
;;

print_string (C_access!print (C_access!create (C_subjects!therese,
                                               C_objects!ssurf,
                                               C_access_mode!read)) ^ "\n")
;;

print_string (C_access!print (C_access!create (C_subjects!charles,
                                               C_objects!ssurf,
                                               C_access_mode!read)) ^ "\n")
;;

print_string (C_access!print (C_access!create (C_subjects!mathieu,
                                               C_objects!photos_de_vacances,
                                               C_access_mode!write)) ^ "\n")
;;

print_string ("\n");;

(** ACL implementation *)

species S_model_acl (Rh is Rho,
                     S is S_subjects, O is S_objects, M is S_access_mode,
                     A is Access (S, O, M), S_a is S_set_of (A),
                     Sgr is S_get_release,
                     R is S_requests_gal (S, O, M, Sgr),
                     D is S_decisions, C is S_couple (S, M),
                     S_s_m is S_set_of (C),
                     C_o_s_s_m is S_couple (O, S_s_m),
                     S_c_o_s_s_m is S_set_of (C_o_s_s_m),
                     Co is S_couple (S_a, S_c_o_s_s_m)) =

  inherit Model_acl (Rh, S, O, M, A, S_a, R, D, C, S_s_m);

  representation = S_a * (A -> bool);

  let create (s_ac : S_a) : Self = (s_ac, fd);

  let lambda (st) = fst (st);

  let upsilon (st : Self) = snd (st);

  let add (st, ac) =
     (S_a!union (lambda (st), S_a!singleton (ac)), upsilon (st));

  let del (st, ac) =
     (S_a!diff (lambda (st), S_a!singleton (ac)), upsilon (st));

  let liste_acl =
     S_c_o_s_s_m!create
     ([ C_o_s_s_m!create (O!ssurf,
                          S_s_m!create ([ C!create (S!mathieu, M!write);
                                          C!create (S!mathieu, M!read);
                                          C!create (S!therese, M!write);
                                          C!create (S!therese, M!read);
                                          C!create (S!charles, M!read) ]));
        C_o_s_s_m!create
        (O!photos_de_vacances,
         S_s_m!create ([ C!create (S!mathieu, M!write) ])) ]);

(*   let acl (ob) = *)
(*      let rec aux_acl (l : S_c_o_s_s_m) : S_s_m = *)
(*         if S_c_o_s_s_m!equal (l, S_c_o_s_s_m!vide) *)
(*         then S_s_m!vide *)
(*         else if O!equal (ob, C_o_s_s_m!first (S_c_o_s_s_m!head (l))) *)
(*         then C_o_s_s_m!second (S_c_o_s_s_m!head (l)) *)
(*         else aux_acl (S_c_o_s_s_m!tail (l)) *)
(*      in aux_acl (liste_acl); *)

  let rec aux_acl (l : S_c_o_s_s_m, ob) : S_s_m =
     if S_c_o_s_s_m!equal (l, S_c_o_s_s_m!vide)
     then S_s_m!vide
     else if O!equal (ob, C_o_s_s_m!first (S_c_o_s_s_m!head (l)))
     then C_o_s_s_m!second (S_c_o_s_s_m!head (l))
     else aux_acl (S_c_o_s_s_m!tail (l), ob);

  let acl (ob) =
     aux_acl (liste_acl, ob);

  let equal (m1, m2) =
     S_a!equal (lambda (m1), lambda (m2));

  let element = (S_a!vide, (function _a -> false));

  let print (st : Self) : string = S_a!print (lambda (st));

  proof of equal_reflexive =
    by property S_a!equal_reflexive
       definition of equal;

  proof of equal_symmetric =
    by property S_a!equal_symmetric
       definition of equal;

  proof of equal_transitive =
    by property S_a!equal_transitive
       definition of equal;

  proof of secure_state = assumed (* Because todo *);

  proof of right_substitution = assumed (* Because todo *);

  proof of left_substitution = assumed (* Because todo *);

  proof of del_mem = assumed (* Because todo *);

  proof of del_prop = assumed (* Because todo *);

  (*proof of del_prop_bis = assumed (* Because todo *);*)

  proof of add_mem = assumed (* Because todo *);

  proof of add_prop = assumed (* Because todo *);

  proof of lambda_prop = assumed (* Because todo *);

  proof of fd_access = assumed (* Because todo *);

end
;;

collection C_model_acl =

  implement
    S_model_acl
      (C_rho,
       C_subjects, C_objects, C_access_mode,
       C_access, C_set_of_access,
       C_get_release, C_requests_gal,
       C_decisions,
       C_couple_s_m, C_set_of_couple_s_m,
       C_couple_o_s_s_m,
       C_set_of_c_o_s_s_m, C_states);

end
;;


print_string ("Exemple implantation ACL\n");;

(* Creation of the empty initial state *)

let st1 = C_model_acl!create (C_set_of_access!vide);;

print_string ("Acces courants: " ^
              C_set_of_access!print (C_model_acl!lambda (st1)) ^ "\n")
;;

(* 1st request *)

let r1 = C_requests_gal!create (C_get_release!get,
                                C_subjects!mathieu,
                                C_objects!ssurf,
                                C_access_mode!write)
;;

print_string (C_requests_gal!print (r1) ^ "\n");;

let e1 = C_model_acl!tau_hru (r1, st1);;

let d1 = fst (e1);;

let st1b = snd (e1);;

print_string ("Reponse: " ^ C_decisions!print (d1) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_acl!lambda (st1b)) ^ "\n")
;;

(* 1st request bis *)

let r1b = C_requests_gal!create (C_get_release!get,
                                 C_subjects!charles,
                                 C_objects!ssurf,
                                 C_access_mode!read)
;;

print_string (C_requests_gal!print (r1b) ^ "\n");;

let e1b = C_model_acl!tau_hru (r1b, st1b);;

let d1b = fst (e1b);;

let st2 = snd (e1b);;

print_string ("Reponse: " ^ C_decisions!print (d1) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_acl!lambda (st2)) ^ "\n")
;;

(* 2nd request *)

let r2 = C_requests_gal!create (C_get_release!get,
                                C_subjects!mathieu,
                                C_objects!photos_de_vacances,
                                C_access_mode!read)
;;

print_string (C_requests_gal!print (r2) ^ "\n");;

let e2 = C_model_acl!tau_hru (r2, st2);;

let d2 = fst (e2);;

let st3 = snd (e2);;

print_string ("Reponse: " ^ C_decisions!print (d2) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_acl!lambda (st3)) ^ "\n")
;;

(* 3rd request *)

let r3 = C_requests_gal!create (C_get_release!rel,
                                C_subjects!therese,
                                C_objects!focal_pas_a_pas,
                                C_access_mode!read)
;;

print_string (C_requests_gal!print (r3) ^ "\n");;

let e3 = C_model_acl!tau_hru (r3, st3);;

let d3 = fst (e3);;

let st4 = snd (e3);;

print_string ("Reponse: " ^ C_decisions!print (d3) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_acl!lambda (st4)) ^ "\n")
;;

(* 4th request *)

let r4 = C_requests_gal!create (C_get_release!rel,
                                C_subjects!mathieu,
                                C_objects!ssurf,
                                C_access_mode!write)
;;

print_string (C_requests_gal!print (r4) ^ "\n");;

let e4 = C_model_acl!tau_hru (r4, st4);;

let d4 = fst (e4);;

let st5 = snd (e4);;

print_string ("Reponse: " ^ C_decisions!print (d4) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_acl!lambda (st5)) ^ "\n")
;;

print_string ("\n");;

(** Capabilities implementation *)

species S_model_capabilities (Rh is Rho, S is S_subjects, O is S_objects,
                              M is S_access_mode,
                              A is Access (S, O, M), S_a is S_set_of (A),
                              Sgr is S_get_release,
                              R is S_requests_gal (S, O, M, Sgr),
                              D is S_decisions,
                              C is S_couple (O, M), S_o_m is S_set_of (C)) =

  inherit Model_capabilities (Rh, S, O, M, A, S_a, R, D, C, S_o_m);

  representation = S_a * (A -> bool);

  let create (s_ac : S_a) : Self =  (s_ac, fd);

  let lambda (st) = fst (st);

  let upsilon (st : Self) = snd (st);

  let add (st, ac) =
     (S_a!union (lambda (st), S_a!singleton (ac)), upsilon (st));

  let del (st, ac) =
     (S_a!diff (lambda (st), S_a!singleton (ac)), upsilon (st));

  let cap (suj) : S_o_m =
     if S!equal (suj, S!mathieu)
     then S_o_m!create ([ C!create (O!ssurf, M!read);
                          C!create (O!ssurf, M!write);
                          C!create (O!photos_de_vacances, M!write) ])
     else if S!equal (suj, S!therese)
     then S_o_m!create ([ C!create (O!ssurf, M!read);
                          C!create (O!ssurf, M!write) ])
     else if S!equal (suj, S!charles)
     then S_o_m!create ([ C!create (O!ssurf, M!read) ])
     else S_o_m!vide;

  let capa (_sujet : S) : S_o_m = S_o_m!vide;

  let capabilities (sujet) = cap (sujet);

  let equal (m1, m2) = S_a!equal (lambda (m1), lambda (m2));

  let element = (S_a!vide, (function _a -> false));

  let print (c : Self) : string = S_a!print (lambda (c));

  proof of equal_reflexive =
    by property S_a!equal_reflexive
       definition of equal;

  proof of equal_symmetric =
    by property S_a!equal_symmetric
       definition of equal;

  proof of equal_transitive =
    by property S_a!equal_transitive
       definition of equal;

  proof of secure_state = assumed (* Because todo *);

  proof of right_substitution = assumed (* Because todo *);

  proof of left_substitution = assumed (* Because todo *);

  proof of del_mem = assumed (* Because todo *);

  proof of del_prop = assumed (* Because todo *);

  (*proof of del_prop_bis = assumed (* Because todo *);*)

  proof of add_mem = assumed (* Because todo *);

  proof of add_prop = assumed (* Because todo *);

  proof of lambda_prop = assumed (* Because todo *);

  proof of fd_access = assumed (* Because todo *);

end
;;

collection C_model_capabilities =

  implement
    S_model_capabilities
      (C_rho,
       C_subjects, C_objects, C_access_mode,
       C_access, C_set_of_access,
       C_get_release, C_requests_gal,
       C_decisions,
       C_couple_o_m, C_set_of_couple_o_m);

end
;;


print_string ("Exemple implantation CAPABILITIES\n");;

(* Creation of the empty initial state *)

let st1c = C_model_capabilities!create (C_set_of_access!vide);;

print_string ("Acces courants: " ^
              C_set_of_access!print (C_model_capabilities!lambda (st1c)) ^
              "\n")
;;

(* 1st request *)

let r1c = C_requests_gal!create (C_get_release!get,
                                 C_subjects!mathieu,
                                 C_objects!ssurf,
                                 C_access_mode!write)
;;

print_string (C_requests_gal!print (r1c) ^ "\n");;

let e1c = C_model_capabilities!tau_hru (r1c, st1c);;

let d1c = fst (e1c);;

let st1bc = snd (e1c);;

print_string ("Reponse: " ^ C_decisions!print (d1c) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_capabilities!lambda (st1bc)) ^
              "\n")
;;

(* 1st request bis *)

let r1bc = C_requests_gal!create (C_get_release!get,
                                  C_subjects!charles,
                                  C_objects!ssurf,
                                  C_access_mode!read)
;;

print_string (C_requests_gal!print (r1bc) ^ "\n");;

let e1bc = C_model_capabilities!tau_hru (r1bc, st1bc);;

let d1bc = fst (e1bc);;

let st2c = snd (e1bc);;

print_string ("Reponse: " ^ C_decisions!print (d1c) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_capabilities!lambda (st2c)) ^
              "\n")
;;

(* 2nd request *)

let r2c = C_requests_gal!create (C_get_release!get,
                                 C_subjects!mathieu,
                                 C_objects!photos_de_vacances,
                                 C_access_mode!read)
;;

print_string (C_requests_gal!print (r2c) ^ "\n");;

let e2c = C_model_capabilities!tau_hru (r2c, st2c);;

let d2c = fst (e2c);;

let st3c = snd (e2c);;

print_string ("Reponse: " ^ C_decisions!print (d2c) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_capabilities!lambda (st3c)) ^
              "\n")
;;

(* 3rd request *)

let r3c = C_requests_gal!create (C_get_release!rel,
                                 C_subjects!therese,
                                 C_objects!focal_pas_a_pas,
                                 C_access_mode!read)
;;

print_string (C_requests_gal!print (r3) ^ "\n");;

let e3c = C_model_capabilities!tau_hru (r3c, st3c);;

let d3c = fst (e3c);;

let st4c = snd (e3c);;

print_string ("Reponse: " ^ C_decisions!print (d3c) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_capabilities!lambda (st4c)) ^
              "\n")
;;

(* 4th request *)

let r4c = C_requests_gal!create (C_get_release!rel,
                                 C_subjects!mathieu,
                                 C_objects!ssurf,
                                 C_access_mode!write)
;;

print_string (C_requests_gal!print (r4c) ^ "\n");;

let e4c = C_model_capabilities!tau_hru (r4c, st4c);;

let d4c = fst (e4c);;

let st5c = snd (e4c);;

print_string ("Reponse: " ^ C_decisions!print (d4c) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_capabilities!lambda (st5c)) ^
              "\n")
;;
