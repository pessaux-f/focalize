(**
   @title Implementation of the HRU model
   @author Florian Brecht, Andrea-Diane Kadja
 *)

use "basics" ;;
open "basics" ;;
use "sets_orders" ;;
open "sets_orders" ;;
use "ensembles_finis" ;;
open "ensembles_finis" ;;
use "access_control" ;;
open "access_control" ;;

(** HRU implementation *)

species S_set_of (A is Setoid) inherits Set_of (A), Liste (A) =

  let create (l in list (A)) in Self = l ;

  let support (l in Self) in list (A) = l ;

  let head (l in Self) in A =
     match l with
     | [ ] -> A!element
     | h :: _ -> h ;

  let tail (l in Self) in Self =
     match l with
     | [ ] -> vide
     | _ :: t -> t ;

  let rec for_all (l, p) =
     match l with
     | [ ] -> true
     | h :: t -> and_b(p (h), for_all (t, p)) ;

  let print (l) =
     let rec aux (ls) =
        match ls with
        | [ ] -> "]"
        | h :: t ->
            match t with
            | [ ] -> A!print (h) ^ "]"
            | _ -> A!print (h) ^ ",\n                     " ^ aux (t)
     in "[" ^ aux (l) ;

  proof of equal_prop = assumed {* Because todo *} ;

  proof of singleton_prop = assumed {* Because todo *} ;

end ;;

species S_setoid inherits Setoid =

  representation = int * string ;

  let create (n in int, s in string) in Self = (n, s) ;

  let equal (s1, s2) =  fst (s1) = fst (s2) ;

  let element = (0, "element") ;

  let print (s) = snd (s) ;

  proof of equal_reflexive =
    by definition of equal ;

  proof of equal_symmetric =
    by definition of equal ;

  proof of equal_transitive =
    by definition of equal ;

end ;;

species S_subjects inherits Subjects, S_setoid =

  let therese in Self = (1, "Therese") ;

  let mathieu in Self = (2, "Mathieu") ;

  let charles in Self = (3, "Charles") ;

end ;;

species S_objects inherits Objects, S_setoid =

  let ssurf in Self = (1, "ssurf") ;

  let focal_pas_a_pas in Self = (2, "focal_pas_a_pas") ;

  let photos_de_vacances in Self = (3, "photos_de_vacances") ;

end ;;

species S_access_mode inherits Access_mode, S_setoid =

  let read = (1, "read") ;

  let write = (2, "write") ;

end ;;

species S_access (S_sub is S_subjects,
          S_obj is S_objects,
          S_acc_mod is S_access_mode)
  inherits Access (S_sub, S_obj, S_acc_mod) =

  representation = S_sub * (S_obj * S_acc_mod) ;

  let create (s, o, m) = (s, (o, m)) ;

  let get_s (a) = fst (a) ;

  let get_o (a) = fst (snd (a)) ;

  let get_m (a) = snd (snd (a)) ;

  let equal (a1, a2) =
     and_b (and_b (S_sub!equal (get_s (a1), get_s (a2)),
           S_obj!equal (get_o (a1), get_o (a2))),
            S_acc_mod!equal (get_m (a1), get_m (a2))) ;

  let element = create (S_sub!element, S_obj!element, S_acc_mod!element) ;

  let print(a) =
     "(" ^ S_sub!print (get_s (a)) ^
     "," ^ S_obj!print (get_o (a)) ^
     "," ^ S_acc_mod!print (get_m (a)) ^
     ")" ;

  proof of equal_reflexive =
    by property S_sub!equal_reflexive,
                S_obj!equal_reflexive,
                S_acc_mod!equal_reflexive
       definition of equal ;

  proof of equal_symmetric =
    by property S_sub!equal_symmetric,
                S_obj!equal_symmetric,
                S_acc_mod!equal_symmetric
       definition of equal ;

  proof of equal_transitive =
    by property S_sub!equal_transitive,
                S_obj!equal_transitive,
                S_acc_mod!equal_transitive
       definition of equal ;

  proof of access_equal = assumed {* Because todo *} ;

end ;;

species S_decisions inherits Decisions, S_setoid =

  let yes = (1, "yes") ;

  let no = (2, "no") ;

  proof of yes_is_not_no = assumed {* Because todo *} ;

end ;;

species S_get_release inherits S_setoid =

  let get in Self = (1, "+") ;

  let rel in Self = (2, "-") ;

end ;;

species S_requests_gal (S is S_subjects,
        O is S_objects,
        M is S_access_mode,
        Sgr is S_get_release)
  inherits Requests_gal (S, O, M) =

  representation = Sgr * (S * (O * M)) ;

  let create (g in Sgr, sa in S, oa in O, ma in M) in Self =
     (g, (sa, (oa, ma)));

  let get_gr (rg in Self) in Sgr = fst (rg) ;

  let get_s (rg) = fst (snd (rg)) ;

  let get_o (rg) = fst (snd (snd (rg))) ;

  let get_m (rg) = snd (snd (snd (rg))) ;

  let is_get (rg) = Sgr!equal (Sgr!get, get_gr (rg)) ;

  let is_rel (rg) = Sgr!equal (Sgr!rel, get_gr (rg)) ;

  let equal (rg1, rg2) =
     and_b (and_b (Sgr!equal (get_gr (rg1), get_gr (rg2)),
           and_b(S!equal (get_s (rg1), get_s (rg2)),
         O!equal (get_o (rg1), get_o (rg2)))),
            M!equal (get_m (rg1), get_m (rg2))) ;

  let element = create (Sgr!get, S!element, O!element, M!element) ;

  let print (rg) =
     "<" ^ Sgr!print (get_gr (rg)) ^
     "," ^ S!print (get_s (rg)) ^
     "," ^ O!print (get_o (rg)) ^
     "," ^ M!print (get_m( rg)) ^
     ">" ;

  proof of equal_reflexive =
    by property S!equal_reflexive,
                O!equal_reflexive,
                M!equal_reflexive,
                Sgr!equal_reflexive
       definition of equal ;

  proof of equal_symmetric =
    by property S!equal_symmetric,
                O!equal_symmetric,
                M!equal_symmetric,
                Sgr!equal_symmetric
       definition of equal ;

  proof of equal_transitive =
    by property S!equal_transitive,
                O!equal_transitive,
                M!equal_transitive,
                Sgr!equal_transitive
       definition of equal ;

  proof of get_or_rel = assumed {* Because todo *} ;

  proof of get_is_not_rel = assumed {* Because todo *} ;

end ;;

species S_rho inherits Rho, S_setoid = end ;;

species S_couple (A is Setoid, B is Setoid) inherits Pair (A, B) =

  representation = A * B ;

  let create (s1, s2) = (s1, s2) ;

  let first (c) = basics#fst (c) ;

  let second(c) = snd (c) ;

  let equal (c1, c2) =
     and_b (A!equal (fst (c1), fst (c2)),
            B!equal (second (c1), second (c2))) ;

  let element = (A!element, B!element) ;

  let print (c in Self) in string =
     "( " ^ A!print(fst (c)) ^ " , " ^ B!print(second (c)) ^ " )" ;

  proof of equal_reflexive = by property A!equal_reflexive,
                                         B!equal_reflexive
                                definition of equal ;

  proof of equal_symmetric = by property A!equal_symmetric,
                                         B!equal_symmetric
                                definition of equal ;

  proof of equal_transitive = by property A!equal_transitive,
                                          B!equal_transitive
                                 definition of equal ;

end ;;

collection C_subjects implements S_subjects ;;

collection C_objects implements S_objects ;;

collection C_access_mode implements S_access_mode ;;

collection C_access
  implements S_access (C_subjects, C_objects, C_access_mode) ;;

collection C_set_of_access implements S_set_of(C_access) ;;

collection C_decisions implements S_decisions ;;

collection C_get_release implements S_get_release ;;

collection C_requests_gal
  implements S_requests_gal (C_subjects,
             C_objects,
             C_access_mode,
             C_get_release) ;;

collection C_rho implements S_rho ;;

collection C_couple_s_m implements S_couple (C_subjects, C_access_mode) ;;

collection C_couple_o_m implements S_couple (C_objects, C_access_mode) ;;

collection C_set_of_s implements S_set_of (C_subjects) ;;

collection C_set_of_o implements S_set_of (C_objects) ;;

collection C_set_of_couple_s_m implements S_set_of (C_couple_s_m) ;;

collection C_set_of_couple_o_m implements S_set_of (C_couple_o_m) ;;

collection C_couple_o_s_s_m
  implements S_couple (C_objects, C_set_of_couple_s_m) ;;

collection C_set_of_c_o_s_s_m implements S_set_of (C_couple_o_s_s_m) ;;

collection C_states
  implements S_couple (C_set_of_access, C_set_of_c_o_s_s_m) ;;

print_string ("Les sujets:\n") ;;

print_string (C_subjects!print (C_subjects!therese) ^ ", " ^
              C_subjects!print (C_subjects!mathieu) ^ ", " ^
              C_subjects!print (C_subjects!charles) ^ "\n") ;;

print_string ("Les objets:\n") ;;

print_string (C_objects!print (C_objects!ssurf) ^ ", " ^
              C_objects!print (C_objects!focal_pas_a_pas) ^ ", " ^
              C_objects!print (C_objects!photos_de_vacances) ^ "\n") ;;

print_string ("Les modes d'acces:\n") ;;

print_string (C_access_mode!print (C_access_mode!read) ^ ", " ^
              C_access_mode!print (C_access_mode!write) ^ "\n") ;;

print_string ("\n") ;;

print_string ("Acces autorises:\n") ;;

print_string (C_access!print (C_access!create (C_subjects!mathieu,
               C_objects!ssurf,
               C_access_mode!write)) ^ "\n") ;;

print_string (C_access!print (C_access!create (C_subjects!mathieu,
               C_objects!ssurf,
               C_access_mode!read)) ^ "\n") ;;

print_string (C_access!print (C_access!create (C_subjects!therese,
               C_objects!ssurf,
               C_access_mode!write)) ^ "\n") ;;

print_string (C_access!print (C_access!create (C_subjects!therese,
               C_objects!ssurf,
               C_access_mode!read)) ^ "\n") ;;

print_string (C_access!print (C_access!create (C_subjects!charles,
               C_objects!ssurf,
               C_access_mode!read)) ^ "\n") ;;

print_string (C_access!print (C_access!create (C_subjects!mathieu,
               C_objects!photos_de_vacances,
               C_access_mode!write)) ^ "\n") ;;

print_string ("\n") ;;

(** ACL implementation *)

species S_model_acl (Rh is Rho,
                     S is S_subjects, O is S_objects, M is S_access_mode,
                     A is Access (S, O, M), S_a is S_set_of (A),
                     Sgr is S_get_release,
                     R is S_requests_gal (S, O, M, Sgr),
                     D is S_decisions, C is S_couple (S, M),
                     S_s_m is S_set_of (C),
                     C_o_s_s_m is S_couple (O, S_s_m),
                     S_c_o_s_s_m is S_set_of (C_o_s_s_m),
                     Co is S_couple (S_a, S_c_o_s_s_m))
  inherits Model_acl (Rh, S, O, M, A, S_a, R, D, C, S_s_m) =

  representation = S_a * (A -> bool) ;

  let create (s_ac in S_a) in Self = (s_ac, fd) ;

  let lambda (st) = fst (st) ;

  let upsilon (st in Self) = snd (st) ;

  let add (st, ac) = 
     (S_a!union (lambda (st), S_a!singleton (ac)), upsilon (st)) ;

  let del (st, ac) = 
     (S_a!diff (lambda (st), S_a!singleton (ac)), upsilon (st)) ;

  let liste_acl =
     S_c_o_s_s_m!create
     ([ C_o_s_s_m!create (O!ssurf,
                          S_s_m!create ([ C!create (S!mathieu, M!write);
                                          C!create (S!mathieu, M!read);
                                          C!create (S!therese, M!write);
                                          C!create (S!therese, M!read);
                                          C!create (S!charles, M!read) ]));
        C_o_s_s_m!create 
        (O!photos_de_vacances,
         S_s_m!create ([ C!create (S!mathieu, M!write) ])) ]) ;

  let acl (ob) =
     let rec aux_acl (l in S_c_o_s_s_m) in S_s_m =
        if S_c_o_s_s_m!equal (l, S_c_o_s_s_m!vide)
        then S_s_m!vide
        else if O!equal (ob, C_o_s_s_m!first (S_c_o_s_s_m!head (l)))
        then C_o_s_s_m!second (S_c_o_s_s_m!head (l))
        else aux_acl (S_c_o_s_s_m!tail (l))
     in aux_acl (liste_acl) ;

  let equal (m1, m2) =
     S_a!equal (lambda (m1), lambda (m2)) ;

  let element = (S_a!vide, (function _a -> false)) ;

  let print (st in Self) in string = S_a!print (lambda (st)) ;

  proof of equal_reflexive =
    by property S_a!equal_reflexive
       definition of equal ;

  proof of equal_symmetric =
    by property S_a!equal_symmetric
       definition of equal ;

  proof of equal_transitive =
    by property S_a!equal_transitive
       definition of equal ;

  proof of secure_state = assumed {* Because todo *} ;

  proof of right_substitution = assumed {* Because todo *} ;

  proof of left_substitution = assumed {* Because todo *} ;

  proof of del_mem = assumed {* Because todo *} ;

  proof of del_prop = assumed {* Because todo *} ;

  (*proof of del_prop_bis = assumed {* Because todo *} ;*)

  proof of add_mem = assumed {* Because todo *} ;

  proof of add_prop = assumed {* Because todo *} ;

  proof of lambda_prop = assumed {* Because todo *} ;

  proof of fd_access = assumed {* Because todo *} ;

end ;;

collection C_model_acl
  implements S_model_acl (C_rho,
          C_subjects, C_objects, C_access_mode,
          C_access, C_set_of_access,
          C_get_release, C_requests_gal,
          C_decisions,
          C_couple_s_m, C_set_of_couple_s_m,
          C_couple_o_s_s_m,
          C_set_of_c_o_s_s_m, C_states) ;;


print_string ("Exemple implantation ACL\n") ;;

(* Creation of the empty initial state *)

let st1 = C_model_acl!create (C_set_of_access!vide) ;;

print_string ("Acces courants: " ^
              C_set_of_access!print (C_model_acl!lambda (st1)) ^ "\n") ;;

(* 1st request *)

let r1 = C_requests_gal!create (C_get_release!get,
        C_subjects!mathieu,
        C_objects!ssurf,
        C_access_mode!write) ;;

print_string (C_requests_gal!print (r1) ^ "\n") ;;

let e1 = C_model_acl!tau_hru (r1, st1) ;;

let d1 = fst (e1) ;;

let st1b = snd (e1) ;;

print_string ("Reponse: " ^ C_decisions!print (d1) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_acl!lambda (st1b)) ^ "\n") ;;

(* 1st request bis *)

let r1b = C_requests_gal!create (C_get_release!get,
         C_subjects!charles,
         C_objects!ssurf,
         C_access_mode!read) ;;

print_string (C_requests_gal!print (r1b) ^ "\n") ;;

let e1b = C_model_acl!tau_hru (r1b, st1b) ;;

let d1b = fst (e1b) ;;

let st2 = snd (e1b) ;;

print_string ("Reponse: " ^ C_decisions!print (d1) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_acl!lambda (st2)) ^ "\n") ;;

(* 2nd request *)

let r2 = C_requests_gal!create (C_get_release!get,
        C_subjects!mathieu,
        C_objects!photos_de_vacances,
        C_access_mode!read) ;;

print_string (C_requests_gal!print (r2) ^ "\n") ;;

let e2 = C_model_acl!tau_hru (r2, st2) ;;

let d2 = fst (e2) ;;

let st3 = snd (e2) ;;

print_string ("Reponse: " ^ C_decisions!print (d2) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_acl!lambda (st3)) ^ "\n") ;;

(* 3rd request *)

let r3 = C_requests_gal!create (C_get_release!rel,
        C_subjects!therese,
        C_objects!focal_pas_a_pas,
        C_access_mode!read) ;;

print_string (C_requests_gal!print (r3) ^ "\n") ;;

let e3 = C_model_acl!tau_hru (r3, st3) ;;

let d3 = fst (e3) ;;

let st4 = snd (e3) ;;

print_string ("Reponse: " ^ C_decisions!print (d3) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_acl!lambda (st4)) ^ "\n") ;;

(* 4th request *)

let r4 = C_requests_gal!create (C_get_release!rel,
        C_subjects!mathieu,
        C_objects!ssurf,
        C_access_mode!write) ;;

print_string (C_requests_gal!print (r4) ^ "\n") ;;

let e4 = C_model_acl!tau_hru (r4, st4) ;;

let d4 = fst (e4) ;;

let st5 = snd (e4) ;;

print_string ("Reponse: " ^ C_decisions!print (d4) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_acl!lambda (st5)) ^ "\n") ;;

print_string ("\n") ;;

(** Capabilities implementation *)

species S_model_capabilities (Rh is Rho, S is S_subjects, O is S_objects,
              M is S_access_mode,
              A is Access (S, O, M), S_a is S_set_of (A),
              Sgr is S_get_release,
              R is S_requests_gal (S, O, M, Sgr),
              D is S_decisions,
              C is S_couple (O, M), S_o_m is S_set_of (C))
  inherits Model_capabilities (Rh, S, O, M, A, S_a, R, D, C, S_o_m) =

  representation = S_a * (A -> bool) ;

  let create (s_ac in S_a) in Self =  (s_ac, fd) ;

  let lambda (st) = fst (st) ;

  let upsilon (st in Self) = snd (st) ;

  let add (st, ac) = (S_a!union (lambda (st), S_a!singleton (ac)),
              upsilon (st)) ;

  let del (st, ac) = (S_a!diff (lambda (st), S_a!singleton (ac)),
              upsilon (st)) ;

  let cap (suj) in S_o_m =
     if S!equal (suj, S!mathieu)
     then S_o_m!create ([ C!create (O!ssurf, M!read);
                          C!create (O!ssurf, M!write);
                          C!create (O!photos_de_vacances, M!write) ])
     else if S!equal (suj, S!therese)
     then S_o_m!create ([ C!create (O!ssurf, M!read);
                          C!create (O!ssurf, M!write) ])
     else if S!equal (suj, S!charles)
     then S_o_m!create ([ C!create (O!ssurf, M!read) ])
     else S_o_m!vide ;

  let capa (_sujet in S) in S_o_m = S_o_m!vide ;

  let capabilities (sujet) = cap (sujet) ;

  let equal (m1, m2) = S_a!equal (lambda (m1), lambda (m2)) ;

  let element = (S_a!vide, (function _a -> false)) ;

  let print (c in Self) in string = S_a!print (lambda (c)) ;

  proof of equal_reflexive =
    by property S_a!equal_reflexive
       definition of equal ;

  proof of equal_symmetric =
    by property S_a!equal_symmetric
       definition of equal ;

  proof of equal_transitive =
    by property S_a!equal_transitive
       definition of equal ;

  proof of secure_state = assumed {* Because todo *} ;

  proof of right_substitution = assumed {* Because todo *} ;

  proof of left_substitution = assumed {* Because todo *} ;

  proof of del_mem = assumed {* Because todo *} ;

  proof of del_prop = assumed {* Because todo *} ;

  (*proof of del_prop_bis = assumed {* Because todo *} ;*)

  proof of add_mem = assumed {* Because todo *} ;

  proof of add_prop = assumed {* Because todo *} ;

  proof of lambda_prop = assumed {* Because todo *} ;

  proof of fd_access = assumed {* Because todo *} ;

end ;;

collection C_model_capabilities
  implements S_model_capabilities(C_rho,
          C_subjects, C_objects, C_access_mode,
          C_access, C_set_of_access,
          C_get_release, C_requests_gal,
          C_decisions,
          C_couple_o_m, C_set_of_couple_o_m) ;;


print_string ("Exemple implantation CAPABILITIES\n") ;;

(* Creation of the empty initial state *)

let st1c = C_model_capabilities!create (C_set_of_access!vide) ;;

print_string ("Acces courants: " ^
              C_set_of_access!print (C_model_capabilities!lambda (st1c)) ^
              "\n") ;;

(* 1st request *)

let r1c = C_requests_gal!create (C_get_release!get,
         C_subjects!mathieu,
         C_objects!ssurf,
         C_access_mode!write) ;;

print_string (C_requests_gal!print (r1c) ^ "\n") ;;

let e1c = C_model_capabilities!tau_hru (r1c, st1c) ;;

let d1c = fst (e1c) ;;

let st1bc = snd (e1c) ;;

print_string ("Reponse: " ^ C_decisions!print (d1c) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_capabilities!lambda (st1bc)) ^
              "\n") ;;

(* 1st request bis *)

let r1bc = C_requests_gal!create (C_get_release!get,
          C_subjects!charles,
          C_objects!ssurf,
          C_access_mode!read) ;;

print_string (C_requests_gal!print (r1bc) ^ "\n") ;;

let e1bc = C_model_capabilities!tau_hru (r1bc, st1bc) ;;

let d1bc = fst (e1bc) ;;

let st2c = snd (e1bc) ;;

print_string ("Reponse: " ^ C_decisions!print (d1c) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_capabilities!lambda (st2c)) ^
              "\n") ;;

(* 2nd request *)

let r2c = C_requests_gal!create (C_get_release!get,
         C_subjects!mathieu,
         C_objects!photos_de_vacances,
         C_access_mode!read) ;;

print_string (C_requests_gal!print (r2c) ^ "\n") ;;

let e2c = C_model_capabilities!tau_hru (r2c, st2c) ;;

let d2c = fst (e2c) ;;

let st3c = snd (e2c) ;;

print_string ("Reponse: " ^ C_decisions!print (d2c) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_capabilities!lambda (st3c)) ^
              "\n") ;;

(* 3rd request *)

let r3c = C_requests_gal!create (C_get_release!rel,
         C_subjects!therese,
         C_objects!focal_pas_a_pas,
         C_access_mode!read) ;;

print_string (C_requests_gal!print (r3) ^ "\n") ;;

let e3c = C_model_capabilities!tau_hru (r3c, st3c) ;;

let d3c = fst (e3c) ;;

let st4c = snd (e3c) ;;

print_string ("Reponse: " ^ C_decisions!print (d3c) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_capabilities!lambda (st4c)) ^
              "\n") ;;

(* 4th request *)

let r4c = C_requests_gal!create (C_get_release!rel,
                                 C_subjects!mathieu,
				 C_objects!ssurf,
				 C_access_mode!write) ;;

print_string (C_requests_gal!print (r4c) ^ "\n") ;;

let e4c = C_model_capabilities!tau_hru (r4c, st4c) ;;

let d4c = fst (e4c) ;;

let st5c = snd (e4c) ;;

print_string ("Reponse: " ^ C_decisions!print (d4c) ^
              "\nAcces courants: " ^
              C_set_of_access!print (C_model_capabilities!lambda (st5c)) ^
              "\n") ;;
